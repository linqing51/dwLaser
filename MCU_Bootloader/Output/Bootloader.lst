C51 COMPILER V9.59.0.0   BOOTLOADER                                                        12/07/2018 17:56:50 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE BOOTLOADER
OBJECT MODULE PLACED IN .\Output\Bootloader.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Bootloader\Bootloader.c LARGE OMF2 OPTIMIZE(8,SPEED) BROWSE INCDIR(.\Lib
                    -;.\LibFlash;.\FlashEprom;.\Bootloader;.\Driver) DEFINE(C8051F340) VARBANKING(1) DEBUG PRINT(.\Output\Bootloader.lst) PRE
                    -PRINT(.\Output\Bootloader.i) OBJECT(.\Output\Bootloader.obj)

line level    source

   1          #include "appConfig.h"
   2          /*****************************************************************************/
   3          #define CMD_STX                                                         0x81
   4          #define CMD_END                                                         0x91
   5          #define CMD_SET_HW_VER                                          0x30
   6          #define CMD_GET_HW_VER                                          0x31
   7          #define CMD_RESET_MCU                                           0x32
   8          #define CMD_GET_BOOTLOADER_VER                          0x33
   9          #define CMD_GET_OTA1_VER                                        0x34
  10          #define CMD_GET_OTA2_VER                                        0x35
  11          #define CMD_SET_BOOTLOADER_VER                          0x33
  12          #define CMD_SET_OTA1_VER                                        0x34
  13          #define CMD_SET_OTA2_VER                                        0x35
  14          #define CMD_GET_BOOT_CRC                                        0x36
  15          #define CMD_GET_OTA1_CRC                                        0x36
  16          #define CMD_GET_OTA2_CRC                                        0x36
  17          #define CMD_ERASE_FLASH_PAGE
  18          #define CMD_WRITE_FLASH_BYTES
  19          #define CMD_READ_FLASH_BYTES
  20          #define CMD_GOTO_OTA1
  21          #define CMD_GOTO_OTA2
  22          #define CMD_GET_HW_VER_TX_SZ                            3
  23          #define CMD_GET_HW_VER_RX_SZ                            6
  24          #define CMD_SET_HW_VER_TX_SZ                            7
  25          #define CMD_SET_HW_VER_RX_SZ                            3
  26          #define CMD_RESPOND_OK                                          0xFF
  27          #define CMD_RESPOND_FAIL                                        0x00
  28          /*****************************************************************************/
  29          #define FW_BOOT_ADR_START                               0x0000//引导程序起始
  30          #define FW_BOOT_ADR_END                                 0x0FFF//引导程序结束
  31          #define FW_OTA1_ADR_START                               0x1000//应用程序1起始地址
  32          #define FW_OTA1_ADR_END                                 0x8000
  33          #define FW_OTA2_ADR_START                               0x8000//应用程序2起始地址
  34          #define FW_OTA2_ADR_END                                 0xF000
  35          #define BOOT_LOADER                                             0x5555
  36          #define BOOT_OTA1                                               0xA5A5
  37          #define BOOT_OTA2                                               0x5A5A
  38          /*****************************************************************************/
  39          #define CMD_RX_BUFFER_SIZE                              2048
  40          #define CMD_TX_BUFFER_SIZE                              1024
  41          /*****************************************************************************/
  42          #define EPROM_BOOT_CRC                          0
  43          #define EPROM_OTA1_CRC                          4
  44          #define EPROM_OTA2_CRC                          8
  45          #define EPROM_BOOT_VER                          12
  46          #define EPROM_OTA1_VER                          13
  47          #define EPROM_OTA2_VER                          14
  48          #define EPROM_HW_VER                            15
  49          #define EPROM_OTA1_START                        16
  50          #define EPROM_OTA1_END                          20
  51          #define EPROM_OTA2_START                        24
  52          #define EPROM_OTA2_END                          28
  53          #define EPROM_BOOT_ORDER                        32
C51 COMPILER V9.59.0.0   BOOTLOADER                                                        12/07/2018 17:56:50 PAGE 2   

  54          
  55          
  56          /*****************************************************************************/
  57          void (*BOOT_Program)();//引导程序指针
  58          void (*OTA1_Program)();//应用程序1指针
  59          void (*OTA2_Program)();//应用程序2指针
  60          void bootSequence(void);
  61          uint32_t bootFlashCrc(void);
  62          uint32_t ota1FlashCrc(void);
  63          uint32_t ota2FlashCrc(void);
  64          uint8_t CmdRxBuf[CMD_RX_BUFFER_SIZE];
  65          uint8_t CmdTxBuf[CMD_TX_BUFFER_SIZE];
  66          uint8_t FlashEprom[EE_SIZE];//FLASH EPROM模拟
  67          /*****************************************************************************/
  68          static void uint32ToAscii(uint32_t *dat, uint8_t *pstr){//将32位有符号数转换为8个ASCII字符
  69   1              data uint8_t temp;      
  70   1              temp = *dat & 0xF;//0x0000000A
  71   1              if(temp <= 0x09){
  72   2                      *(pstr + 0) = (temp + 0x30);
  73   2          }
  74   1          else{
  75   2                       *(pstr + 0) = (temp + 0x37);
  76   2          }
  77   1              
  78   1              temp = (*dat >> 4) & 0xF;//0x000000A0
  79   1              if(temp <= 0x09){
  80   2                      *(pstr + 1) = (temp + 0x30);
  81   2          }
  82   1          else{
  83   2                       *(pstr + 1) = (temp + 0x37);
  84   2          }
  85   1              
  86   1              temp = (*dat >> 8) & 0xF;//0x00000A00
  87   1              if(temp <= 0x09){
  88   2                      *(pstr + 2) = (temp + 0x30);
  89   2          }
  90   1          else{
  91   2                       *(pstr + 2) = (temp + 0x37);
  92   2          }
  93   1              
  94   1              temp = (*dat >> 12) & 0xF;//0x0000A000
  95   1              if(temp <= 0x09){
  96   2                      *pstr = (temp + 0x30);
  97   2          }
  98   1          else{
  99   2                      *pstr = (temp + 0x37);
 100   2          }
 101   1              
 102   1              temp = (*dat >> 16) & 0xF;//0x000A0000
 103   1              if(temp <= 0x09){
 104   2                      *(pstr + 4) = (temp + 0x30);
 105   2          }
 106   1          else{
 107   2                       *(pstr + 4) = (temp + 0x37);
 108   2          }
 109   1      
 110   1              temp = (*dat >> 20) & 0xF;//0x00A00000
 111   1              if(temp <= 0x09){
 112   2                      *(pstr + 5) = (temp + 0x30);
 113   2          }
 114   1          else{
 115   2                       *(pstr + 5) = (temp + 0x37);
C51 COMPILER V9.59.0.0   BOOTLOADER                                                        12/07/2018 17:56:50 PAGE 3   

 116   2          }
 117   1              
 118   1              temp = (*dat >> 24) & 0xF;//0x0A000000
 119   1              if(temp <= 0x09){
 120   2                      *(pstr + 6) = (temp + 0x30);
 121   2          }
 122   1          else{
 123   2                       *(pstr + 6) = (temp + 0x37);
 124   2          }
 125   1              
 126   1              temp = (*dat >> 28) & 0xF;//0x00A00000
 127   1              if(temp <= 0x09){
 128   2                      *(pstr + 7) = (temp + 0x30);
 129   2          }
 130   1          else{
 131   2                       *(pstr + 7) = (temp + 0x37);
 132   2          }
 133   1      }
 134          static uint32_t asciiToUint32(uint8_t *pstr){//将8个BCD组合成一个32进制数
 135   1              data uint8_t temp[8];
 136   1              data uint32_t hex;
 137   1              //取出0x0000000A
 138   1              if(*pstr >= 'A' && *pstr <='F'){//A-F
 139   2                      temp[0] = *pstr - 0x37; 
 140   2              }
 141   1              else if(*pstr >= '0' && *pstr <='9'){
 142   2                      temp[0] = *pstr - 0x30; 
 143   2              }
 144   1              //取出0x000000A0
 145   1              if(*(pstr + 1) >= 'A' && *(pstr + 1) <='F'){//A-F
 146   2                      temp[1] = *(pstr + 1) - 0x37; 
 147   2              }
 148   1              else if(*(pstr + 1) >= '0' && *(pstr + 1) <='9'){
 149   2                      temp[1] = *(pstr + 1) - 0x30;   
 150   2              }
 151   1              //取出0x00000A00
 152   1              if(*pstr >= 'A' && *pstr <='F'){//A-F
 153   2                      temp[2] = *pstr - 0x37; 
 154   2              }
 155   1              else if(*pstr >= '0' && *pstr <='9'){
 156   2                      temp[2] = *pstr - 0x30; 
 157   2              }
 158   1              //取出0x0000A000
 159   1              if(*(pstr + 1) >= 'A' && *(pstr + 1) <='F'){//A-F
 160   2                      temp[3] = *(pstr + 1) - 0x37; 
 161   2              }
 162   1              else if(*(pstr + 1) >= '0' && *(pstr + 1) <='9'){
 163   2                      temp[3] = *(pstr + 1) - 0x30;   
 164   2              }
 165   1              
 166   1              //取出0x0000A000
 167   1              if(*pstr >= 'A' && *pstr <='F'){//A-F
 168   2                      temp[4] = *pstr - 0x37; 
 169   2              }
 170   1              else if(*pstr >= '0' && *pstr <='9'){
 171   2                      temp[4] = *pstr - 0x30; 
 172   2              }
 173   1              //取出0x00000A00
 174   1              if(*(pstr + 1) >= 'A' && *(pstr + 1) <='F'){//A-F
 175   2                      temp[5] = *(pstr + 1) - 0x37; 
 176   2              }
 177   1              else if(*(pstr + 1) >= '0' && *(pstr + 1) <='9'){
C51 COMPILER V9.59.0.0   BOOTLOADER                                                        12/07/2018 17:56:50 PAGE 4   

 178   2                      temp[5] = *(pstr + 1) - 0x30;   
 179   2              }
 180   1              //取出0x000000A0
 181   1              if(*pstr >= 'A' && *pstr <='F'){//A-F
 182   2                      temp[6] = *pstr - 0x37; 
 183   2              }
 184   1              else if(*pstr >= '0' && *pstr <='9'){
 185   2                      temp[6] = *pstr - 0x30; 
 186   2              }
 187   1              //取出0x0000000A
 188   1              if(*(pstr + 1) >= 'A' && *(pstr + 1) <='F'){//A-F
 189   2                      temp[7] = *(pstr + 1) - 0x37; 
 190   2              }
 191   1              else if(*(pstr + 1) >= '0' && *(pstr + 1) <='9'){
 192   2                      temp[7] = *(pstr + 1) - 0x30;   
 193   2              }
 194   1              hex = 0;
 195   1              hex |= (temp[0] & 0x0000000F);
 196   1              hex |= (((temp[1] & 0x0F) << 4) & 0x000000F0);
 197   1              hex |= (((temp[2] & 0x0F) << 8) & 0x00000F00);
 198   1              hex |= (((temp[3] & 0x0F) << 12) & 0x0000F000);
 199   1              hex |= (((temp[4] & 0x0F) << 16) & 0x000F0000);
 200   1              hex |= (((temp[5] & 0x0F) << 20) & 0x00F00000);
 201   1              hex |= (((temp[6] & 0x0F) << 24) & 0x00F00000);
 202   1              hex |= (((temp[7] & 0x0F) << 28) & 0x00F00000);
 203   1              return hex;
 204   1      }
 205          static void uint16ToAscii(uint16_t *dat, uint8_t *pstr){//将16位有符号数转换为4个ASCII字符
 206   1              data uint8_t temp;
 207   1              temp = *dat & 0x000F;//0x000A
 208   1              if(temp <= 0x09){
 209   2                      *(pstr + 0) = (temp + 0x30);
 210   2          }
 211   1          else{
 212   2                       *(pstr + 0) = (temp + 0x37);
 213   2          }
 214   1              temp = (*dat >> 4) & 0x000F;//0x00A0
 215   1              if(temp <= 0x09){
 216   2                      *(pstr + 1) = (temp + 0x30);
 217   2          }
 218   1          else{
 219   2                       *(pstr + 1) = (temp + 0x37);
 220   2          }
 221   1              temp = (*dat >> 8) & 0x000F;//0x0A00
 222   1              if(temp <= 0x09){
 223   2                      *(pstr + 2) = (temp + 0x30);
 224   2          }
 225   1          else{
 226   2                       *(pstr + 2) = (temp + 0x37);
 227   2          }
 228   1              temp = (*dat >> 12) & 0x000F;//0xA000
 229   1              if(temp <= 0x09){
 230   2                      *(pstr + 3) = (temp + 0x30);
 231   2          }
 232   1          else{
 233   2                      *(pstr + 3) = (temp + 0x37);
 234   2          }
 235   1      }
 236          static void uint8ToAscii(uint8_t *dat, uint8_t *pstr){//将16进制数转换成两个ASCII字符
 237   1              data uint8_t temp;
 238   1              temp = (*dat & 0x0f);
 239   1              if(temp <= 0x09){
C51 COMPILER V9.59.0.0   BOOTLOADER                                                        12/07/2018 17:56:50 PAGE 5   

 240   2                      *(pstr + 1) = (temp + 0x30);
 241   2          }
 242   1          else{
 243   2                       *(pstr + 1) = (temp + 0x37);
 244   2          }
 245   1              temp = ((*dat & 0xf0) >> 4);
 246   1              if(temp <= 0x09){
 247   2                      *pstr = (temp + 0x30);
 248   2              }
 249   1              else{
 250   2                      *pstr = (temp + 0x37);
 251   2              }
 252   1      }
 253          static uint8_t asciiToUint8(uint8_t *pstr){//将两个int8_t 组合成一个16进制数
 254   1              data uint8_t temp[2];
 255   1              data uint8_t hex;
 256   1              if(*pstr >= 'A' && *pstr <='F'){//A-F
 257   2                      temp[1] = *pstr - 0x37; 
 258   2              }
 259   1              else if(*pstr >= '0' && *pstr <='9'){
 260   2                      temp[1] = *pstr - 0x30; 
 261   2              }
 262   1              if(*(pstr + 1) >= 'A' && *(pstr + 1) <='F'){//A-F
 263   2                      temp[0] = *(pstr + 1) - 0x37; 
 264   2              }
 265   1              else if(*(pstr + 1) >= '0' && *(pstr + 1) <='9'){
 266   2                      temp[0] = *(pstr + 1) - 0x30;   
 267   2              }
 268   1              hex = 0;
 269   1              hex |= temp[0] & 0xF;
 270   1              hex |= (temp[1] & 0x0F << 4) & 0xF0;
 271   1              return hex;
 272   1      }
 273          
 274          static uint16_t asciiToUint16(uint8_t *pstr){
 275   1              data uint8_t temp[4];
 276   1              data uint16_t hex;
 277   1              //取出0xA000
 278   1              if(*pstr >= 'A' && *pstr <='F'){//A-F
 279   2                      temp[3] = *pstr - 0x37; 
 280   2              }
 281   1              else if(*pstr >= '0' && *pstr <='9'){
 282   2                      temp[3] = *pstr - 0x30; 
 283   2              }
 284   1              //取出0x0A00
 285   1              if(*(pstr + 1) >= 'A' && *(pstr + 1) <='F'){//A-F
 286   2                      temp[2] = *(pstr + 1) - 0x37; 
 287   2              }
 288   1              else if(*(pstr + 1) >= '0' && *(pstr + 1) <='9'){
 289   2                      temp[2] = *(pstr + 1) - 0x30;   
 290   2              }
 291   1              //取出0x00A0
 292   1              if(*pstr >= 'A' && *pstr <='F'){//A-F
 293   2                      temp[1] = *pstr - 0x37; 
 294   2              }
 295   1              else if(*pstr >= '0' && *pstr <='9'){
 296   2                      temp[1] = *pstr - 0x30; 
 297   2              }
 298   1              //取出0x000A
 299   1              if(*(pstr + 1) >= 'A' && *(pstr + 1) <='F'){//A-F
 300   2                      temp[0] = *(pstr + 1) - 0x37; 
 301   2              }
C51 COMPILER V9.59.0.0   BOOTLOADER                                                        12/07/2018 17:56:50 PAGE 6   

 302   1              else if(*(pstr + 1) >= '0' && *(pstr + 1) <='9'){
 303   2                      temp[0] = *(pstr + 1) - 0x30;   
 304   2              }
 305   1              hex = 0;
 306   1              hex |= temp[0] & 0x000F;
 307   1              hex |= ((temp[1] & 0x0F) << 4) & 0x00F0;
 308   1              hex |= ((temp[2] & 0x0F) << 8) & 0x0F00;
 309   1              hex |= ((temp[3] & 0x0F) << 12) & 0xF000;
 310   1              return hex;
 311   1      }
 312          static uint8_t LRC(uint8_t *buf, int32_t len){//计算LRC LRC方法是将消息中的8Bit的字节连续累加，丢弃了进位
 313   1              int i;
 314   1              uint8_t lrc = 0;        /*lrc字节初始化*/
 315   1              for( i = 0; i < len; i++ ){
 316   2                      lrc = lrc + buf[i];
 317   2              }
 318   1              return lrc;
 319   1      }
 320          void uart0Send(uint8_t *buf, uint16_t count){//串口0查询发送
 321   1              uint8_t *ptr = buf;
 322   1              do{
 323   2                  SBUF0 = *ptr++;
 324   2                      while(TI0 == 0);
 325   2                      TI0 = 0;
 326   2              }while(--count);
 327   1      }
 328          void uart0Receive(uint8_t *buf, uint16_t count){//串口0查询接收
 329   1              uint8_t * ptr = buf;
 330   1              do{
 331   2                      if(RI0 == 1)
 332   2                      {
 333   3                              *ptr++ = SBUF0;
 334   3                              RI0 = 0;
 335   3                              count--;
 336   3                      }
 337   2              }while(count);
 338   1      }
 339          void CmdSetHwVer(void){//设置硬件版本
 340   1              FlashEprom[EPROM_HW_VER] = asciiToUint8(CmdRxBuf + 2);
 341   1              if(EEPROM_WriteBlock(EPROM_HW_VER, FlashEprom, 1) != EE_NO_ERROR){//从FLASH中读取OTA MD5值
 342   2                      CmdTxBuf[0] = CMD_STX;
 343   2                      CmdTxBuf[1] = CMD_SET_HW_VER;
 344   2                      CmdTxBuf[2] = CMD_RESPOND_FAIL;
 345   2                      CmdTxBuf[3] = CMD_END;  
 346   2              }
 347   1              else{
 348   2                      CmdTxBuf[0] = CMD_STX;
 349   2                      CmdTxBuf[1] = CMD_SET_HW_VER;
 350   2                      CmdTxBuf[2] = CMD_RESPOND_OK;
 351   2                      CmdTxBuf[3] = CMD_END;
 352   2              }
 353   1              uart0Send(CmdTxBuf, 4);
 354   1      }
 355          void CmdGetHwVer(void){//获取硬件版本
 356   1              CmdTxBuf[0] = CMD_STX;
 357   1              CmdTxBuf[1] = CMD_SET_HW_VER;
 358   1              CmdTxBuf[2] = FlashEprom[EPROM_HW_VER];
 359   1              CmdTxBuf[3] = CMD_END;
 360   1              uart0Send(CmdTxBuf, 4);
 361   1      }
 362          void CmdResetMcu(void){//强制复位
 363   1              RSTSRC |= (1 << 4);
C51 COMPILER V9.59.0.0   BOOTLOADER                                                        12/07/2018 17:56:50 PAGE 7   

 364   1      }
 365          void CmdGetBootLoaderVer(void){//获取BOOTLOADER版本
 366   1              CmdTxBuf[0] = CMD_STX;
 367   1              CmdTxBuf[1] = CMD_GET_BOOTLOADER_VER;
 368   1              CmdTxBuf[2] = FlashEprom[EPROM_BOOT_VER];
 369   1              CmdTxBuf[3] = CMD_END;  
 370   1              uart0Send(CmdTxBuf, 4);
 371   1      }
 372          void CmdSetBootLoaderVer(void){//设置Bootloader版本号
 373   1              FlashEprom[EPROM_BOOT_VER] = asciiToUint8(CmdRxBuf + 2);
 374   1              if(EEPROM_WriteBlock(EPROM_HW_VER, FlashEprom, 1) != EE_NO_ERROR){//从FLASH中读取OTA MD5值
 375   2                      CmdTxBuf[0] = CMD_STX;
 376   2                      CmdTxBuf[1] = EPROM_BOOT_VER;
 377   2                      CmdTxBuf[2] = CMD_RESPOND_FAIL;
 378   2                      CmdTxBuf[3] = CMD_END;  
 379   2              }
 380   1              else{
 381   2                      CmdTxBuf[0] = CMD_STX;
 382   2                      CmdTxBuf[1] = EPROM_BOOT_VER;
 383   2                      CmdTxBuf[2] = CMD_RESPOND_OK;
 384   2                      CmdTxBuf[3] = CMD_END;
 385   2              }
 386   1              uart0Send(CmdTxBuf, 4);
 387   1      }
 388          
 389          void CmdGetOTA1Ver(void){//获取OTA1版本号
 390   1              CmdTxBuf[0] = CMD_STX;
 391   1              CmdTxBuf[1] = CMD_GET_OTA1_VER;
 392   1              CmdTxBuf[2] = FlashEprom[EPROM_OTA1_VER];
 393   1              CmdTxBuf[3] = CMD_END;  
 394   1              uart0Send(CmdTxBuf, 4);
 395   1      }
 396          void CmdSetOTA1Ver(void){//设置OTA1版本号
 397   1              FlashEprom[EPROM_OTA1_VER] = asciiToUint8(CmdRxBuf + 2);
 398   1              if(EEPROM_WriteBlock(EPROM_OTA1_VER, FlashEprom, 1) != EE_NO_ERROR){//从FLASH中读取OTA MD5值
 399   2                      CmdTxBuf[0] = CMD_STX;
 400   2                      CmdTxBuf[1] = CMD_SET_OTA1_VER;
 401   2                      CmdTxBuf[2] = CMD_RESPOND_FAIL;
 402   2                      CmdTxBuf[3] = CMD_END;  
 403   2              }
 404   1              else{
 405   2                      CmdTxBuf[0] = CMD_STX;
 406   2                      CmdTxBuf[1] = CMD_SET_OTA1_VER;
 407   2                      CmdTxBuf[2] = CMD_RESPOND_OK;
 408   2                      CmdTxBuf[3] = CMD_END;
 409   2              }
 410   1              uart0Send(CmdTxBuf, 4);
 411   1      }
 412          void CmdGetOTA2Ver(void){//获取OTA2版本号
 413   1              CmdTxBuf[0] = CMD_STX;
 414   1              CmdTxBuf[1] = CMD_GET_OTA2_VER;
 415   1              CmdTxBuf[2] = FlashEprom[EPROM_OTA2_VER];
 416   1              CmdTxBuf[3] = CMD_END;  
 417   1              uart0Send(CmdTxBuf, 4);
 418   1      }
 419          void CmdGetBootCrc(void){//获取BOOT CRC
 420   1              CmdTxBuf[0] = CMD_STX;
 421   1              CmdTxBuf[1] = CMD_GET_BOOT_CRC;
 422   1              CmdTxBuf[2] = FlashEprom[EPROM_BOOT_CRC];
 423   1              CmdTxBuf[3] = CMD_END;  
 424   1              uart0Send(CmdTxBuf, 4);
 425   1      }
C51 COMPILER V9.59.0.0   BOOTLOADER                                                        12/07/2018 17:56:50 PAGE 8   

 426          void CmdGetOTA1Crc(void){//获取OTA1 CRC
 427   1              CmdTxBuf[0] = CMD_STX;
 428   1              CmdTxBuf[1] = CMD_GET_OTA1_CRC;
 429   1              CmdTxBuf[2] = FlashEprom[EPROM_OTA1_CRC];
 430   1              CmdTxBuf[3] = CMD_END;  
 431   1              uart0Send(CmdTxBuf, 4);
 432   1      }
 433          void CmdGetOTA2Crc(void){//获取OTA2 CRC
 434   1              CmdTxBuf[0] = CMD_STX;
 435   1              CmdTxBuf[1] = CMD_GET_OTA2_CRC;
 436   1              CmdTxBuf[2] = FlashEprom[EPROM_OTA2_CRC];
 437   1              CmdTxBuf[3] = CMD_END;  
 438   1              uart0Send(CmdTxBuf, 4);
 439   1      }
 440          void CmdEraseFlashPage(void){//查出FLASH指定页
 441   1              uint8_t page;
 442   1              page = asciiToUint8(CmdRxBuf + 2);
 443   1              //限制page范围
 444   1              EE_FLASH_WriteErase (page, 0, 0x13);
 445   1      }
 446          CMD_ERASE_FLASH_PAGE
 447          void cmdPoll(void){
 448   1              uint16_t i;
 449   1              uint8_t *ptr, *ptw;
 450   1              while(1){
 451   2                      ptr = CmdRxBuf;
 452   2                      uart0Receive(ptr, 1);
 453   2                      if(*ptr == CMD_STX){
 454   3                              ptr ++;
 455   3                              do{
 456   4                                      uart0Receive(ptr, 1);
 457   4                                      if(*ptr == CMD_END){
 458   5                                              switch(CmdRxBuf[1])
 459   5                                              {
 460   6                                                      case CMD_SET_HW_VER:
 461   6                                                              CmdSetHwVer();
 462   6                                                              break;
 463   6                                                      case CMD_GET_HW_VER:
 464   6                                                              break;
 465   6                                                      case CMD_RESET_MCU:
 466   6                                                              break;
 467   6                                                      case CMD_GET_BOOTLOADER_VER:
 468   6                                                              break;
 469   6                                                      case CMD_GET_OTA1_VER:
 470   6                                                              break;
 471   6                                                      case CMD_GET_OTA2_VER:
 472   6                                                              break;
 473   6                                                      case CMD_GET_OTA1_CRC:
 474   6                                                              break;
 475   6                                                      default:break;
 476   6                                              }
 477   5                                              break;
 478   5                                      }
 479   4                                      else if(ptr >= (CmdRxBuf + CMD_RX_BUFFER_SIZE)){
 480   5                                              break;
 481   5                                      }
 482   4                              }while(1);
 483   3                      }
 484   2              }
 485   1      }
*** WARNING C280 IN LINE 448 OF Bootloader\Bootloader.c: 'i': unreferenced local variable
*** WARNING C280 IN LINE 449 OF Bootloader\Bootloader.c: 'ptw': unreferenced local variable
C51 COMPILER V9.59.0.0   BOOTLOADER                                                        12/07/2018 17:56:50 PAGE 9   

 486          //-----------------------------------------------------------------------------
 487          // receive_code
 488          //-----------------------------------------------------------------------------
 489          // This routine receives the new firmware through the UART in HEX record 
 490          // format.
 491          //
 492          // Hex Record Format:
 493          //
 494          // +--------+--------+------+-------+--------+------(n bytes)------+----------+
 495          // | RECORD | RECLEN |    OFFSET    | RECORD |                     | CHECKSUM |
 496          // |  MARK  |  (n)   |   (2 BYTES)  |  TYPE  |        DATA         |          |
 497          // |  ':'   |        |              |        |                     |          |
 498          // +--------+--------+------+-------+--------+------(n bytes)------+----------+
 499          //
 500          //
 501          //void receive_code(void)
 502          //{
 503          //   char xdata* data pwrite;               // pointer used for writing FLASH
 504          //   char code* data pread;                 // pointer used for reading FLASH
 505          //   unsigned char len;                     // holds the HEX record length field
 506          //   unsigned char record_type;             // holds the HEX record type field
 507          //   unsigned int offset;                   // holds the HEX record offset field
 508          //                                          // this is the starting address of
 509          //                                          // the code image contained in the 
 510          //                                          // record
 511          
 512          //   char checksum;                         // holds the HEX record checksum field
 513          //   char flash_checksum;                   // holds the checksum calculated after
 514          //                                          // the FLASH has been programmed
 515          //   bit EA_state;                          // temporary holder used to restore 
 516          //                                          // interrupts to their previous state
 517          
 518          //   char c;                                // temporary char
 519          //   int i;                                 // temporary int
 520          
 521          //   // make sure FLASH has been erased
 522          //   if(!code_erased){
 523          //      printf("\n*** At least one FLASH page must be erased prior");
 524          //      printf(" to this operation.\n");
 525          //      return;
 526          //   } else {
 527          
 528          //      printf("\nReady to receive...\n");
 529          //   }
 530          
 531          //   // wait for the user send HEX file
 532          
 533          //   do{
 534          //      
 535          //      while( c = _getkey() != ':' );      // ignore all characters until 
 536          //                                          // reaching the record mark field
 537          //      
 538          //      // get the record length
 539          //      len = hex2char();
 540          //      
 541          //      // get the starting address (offset field in HEX record)
 542          //      offset = hex2char();                // get the MSB
 543          //      offset <<= 8;                       
 544          //      offset |= hex2char();               // get the LSB
 545          
 546          //      // get the record type
 547          //      record_type = hex2char();
C51 COMPILER V9.59.0.0   BOOTLOADER                                                        12/07/2018 17:56:50 PAGE 10  

 548          //      if( record_type != 0 && record_type != 1 ){
 549          //         printf("\n*** Cannot decode HEX file.\n"); 
 550          //         return;
 551          //      }      
 552          
 553          //      EA_state = EA;                      // save the interrupt enable bit state
 554          //      
 555          //      EA = 0;                             // disable interrupts (precautionary)   
 556          //      FLSCL |= 0x01;                      // enable FLASH write/erase
 557          //      PSCTL  = 0x01;                      // MOVX writes FLASH
 558          
 559          //      pwrite = (char xdata*) offset;      // initialize the write pointer
 560          //      
 561          //      
 562          //      code_erased = FALSE;                // clear the code_erased flag      
 563          //           
 564          //      // write the record into flash
 565          //      for( i = 0; i < len; i++){
 566          //         
 567          //         // check for valid pointer
 568          //         if(pwrite < 0x1000){ 
 569          //            *pwrite = hex2char();         // write one byte to FLASH
 570          //            pwrite++;                     // increment FLASH write pointer
 571          //         } else {
 572          //            printf("\n\nExceeded Code Space.\n");  // print error message
 573          //         }
 574          //      }
 575          //      
 576          //      PSCTL = 0x00;                       // MOVX writes target XRAM
 577          //      FLSCL &= ~0x01;                     // disable FLASH write/erase
 578          //      EA = EA_state;                      // restore interrupts to previous state
 579          //            
 580          //      // verify the checksum
 581          //      pread =  (char code*) offset;       // initialize the read pointer
 582          //      checksum = hex2char();              // get the HEX record checksum field
 583          //      flash_checksum = 0;                 // set the flash_checksum to zero
 584          
 585          //      // add the data field stored in FLASH to the checksum
 586          //      for( i = 0; i < len; i++)
 587          //      {
 588          //         flash_checksum += *pread++;
 589          //      } 
 590          //      
 591          //      // add the remaining fields
 592          //      flash_checksum += len;
 593          //      flash_checksum += (char) (offset >> 8);
 594          //      flash_checksum += (char) (offset & 0x00FF);
 595          //      flash_checksum += record_type;
 596          //      flash_checksum += checksum;
 597          //      
 598          //      // verify the checksum (the flash_checksum should equal zero)     
 599          //      if(flash_checksum != 0){
 600          //         printf("*** Checksum failed, try again");
 601          //         return;
 602          //      }
 603          
 604          //   } while(record_type != 1); 
 605          //   
 606          //   f_valid = TRUE;                        // indicate that download is valid 
 607          //   
 608          //   printf("\n** Firmware Update Complete. **\n");
 609          //}
C51 COMPILER V9.59.0.0   BOOTLOADER                                                        12/07/2018 17:56:50 PAGE 11  

 610          
 611          void bootSequence(void)
 612          {//启动顺序选择
 613   1              data uint32_t ota1Crc32, ota2Crc32;
 614   1              if(FlashEprom[20] == BOOT_OTA1){//启动顺序选择BOOT_OTA1
 615   2                      ota1Crc32 = ota1FlashCrc();
 616   2                      if(ota1Crc32 == FlashEprom[EPROM_OTA1_CRC])
 617   2                      {
 618   3                              OTA1_Program = (void code *)(FW_OTA1_ADR_START & 0x1FFFF);//获取OTA1起始地址
 619   3                              OTA1_Program();//执行应用程序
 620   3                      }
 621   2              }
 622   1              else if(FlashEprom[20] == BOOT_OTA2){//启动顺序选择BOOT_OTA2
 623   2                      if(ota2Crc32 == FlashEprom[EPROM_OTA2_CRC]){
 624   3                              OTA2_Program = (void code *)(FW_OTA2_ADR_START & 0x1FFFF);//获取OTA2起始地址
 625   3                              OTA2_Program();//执行应用程序
 626   3                      }       
 627   2              }
 628   1              else if(FlashEprom[20] == BOOT_LOADER){
 629   2              }
 630   1      }
 631          uint32_t bootFlashCrc(void)
 632          {//BOOT CRC32校验       
 633   1              data uint32_t crc = 0, i;
 634   1              data uint8_t temp;
 635   1              
 636   1              crc32Clear();//CRC32清除
 637   1              for(i = FW_BOOT_ADR_START;i < FW_BOOT_ADR_END;i ++)
 638   1              {//计算BOOT CRC32
 639   2                      FLASH_Read(&temp, i, 1);
 640   2                      crc = crc32CalculateAdd(temp);
 641   2              }
 642   1              return crc;
 643   1      }
 644          uint32_t ota1FlashCrc(void)
 645          {//OTA1 CRC32校验
 646   1              data uint32_t crc = 0 ,i;
 647   1              data uint8_t temp;
 648   1              crc32Clear();//CRC32清除
 649   1              for(i = FW_OTA1_ADR_START;i < FW_OTA1_ADR_END;i ++)
 650   1              {//计算OTA1 CRC32
 651   2                      FLASH_Read(&temp, i, 1);
 652   2                      crc = crc32CalculateAdd(temp);
 653   2              }
 654   1              return crc;
 655   1      }
 656          uint32_t ota2FlashCrc(void)
 657          {//OTA2 CRC32校验
 658   1              data uint32_t crc = 0, i;
 659   1              data uint8_t temp;
 660   1              for(i = FW_OTA2_ADR_START;i < FW_OTA2_ADR_END;i ++)
 661   1              {//计算OTA2 CRC32
 662   2                      FLASH_Read(&temp, i, 1);
 663   2                      crc = crc32CalculateAdd(temp);
 664   2              }
 665   1              return crc;
 666   1      }
 667          
 668          void main (void) 
 669          {
 670   1              data uint32_t bootCrc32, ota1Crc32, ota2Crc32;
 671   1              data uint8_t temp, ctemp;
C51 COMPILER V9.59.0.0   BOOTLOADER                                                        12/07/2018 17:56:50 PAGE 12  

 672   1              data uint32_t i, rxCounter;
 673   1              
 674   1              cmdPoll();
 675   1              
 676   1      
 677   1              
 678   1      //      SFRPAGE_SWITCH()
 679   1      //      ENABLE_VDDMON()
 680   1      //      DISABLE_WDT()
 681   1      //      SFRPAGE_RESTORE()                       
 682   1      //      //等待串口发送固件更新指令
 683   1      //      
 684   1      //      if(EEPROM_ReadBlock(0, FlashEprom, EE_SIZE) != EE_NO_ERROR){//从FLASH中读取OTA MD5值
 685   1      //              while(1);// Error reading EEPROM
 686   1      //      }       
 687   1              
 688   1      
 689   1      
 690   1         while (1){
 691   2            //1秒内等待串口发出更新码
 692   2                //FLASH_Clear(CONFIG_APP_START_ADR, (CONFIG_APP_END_ADR - CONFIG_APP_START_ADR));
 693   2                 //检测到更新码
 694   2                //擦除FLASH
 695   2                //执行固件更新
 696   2                //执行应用程序
 697   2            
 698   2       
 699   2         }
 700   1      
 701   1      }
*** WARNING C280 IN LINE 670 OF Bootloader\Bootloader.c: 'bootCrc32': unreferenced local variable
*** WARNING C280 IN LINE 670 OF Bootloader\Bootloader.c: 'ota1Crc32': unreferenced local variable
*** WARNING C280 IN LINE 670 OF Bootloader\Bootloader.c: 'ota2Crc32': unreferenced local variable
*** WARNING C280 IN LINE 671 OF Bootloader\Bootloader.c: 'temp': unreferenced local variable
*** WARNING C280 IN LINE 671 OF Bootloader\Bootloader.c: 'ctemp': unreferenced local variable
*** WARNING C280 IN LINE 672 OF Bootloader\Bootloader.c: 'i': unreferenced local variable
*** WARNING C280 IN LINE 672 OF Bootloader\Bootloader.c: 'rxCounter': unreferenced local variable


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3152    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   3337      51
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      81
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  9 WARNING(S),  0 ERROR(S)
