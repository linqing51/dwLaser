C51 COMPILER V9.59.0.0   BOOTLOADER                                                        12/06/2018 16:57:09 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE BOOTLOADER
OBJECT MODULE PLACED IN .\Output\Bootloader.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Bootloader\Bootloader.c LARGE OMF2 OPTIMIZE(8,SPEED) BROWSE INCDIR(.\Lib
                    -;.\LibFlash;.\FlashEprom;.\Bootloader;.\Driver) DEFINE(C8051F340) VARBANKING(1) DEBUG PRINT(.\Output\Bootloader.lst) PRE
                    -PRINT(.\Output\Bootloader.i) OBJECT(.\Output\Bootloader.obj)

line level    source

   1          #include "appConfig.h"
   2          /*****************************************************************************/
   3          #define FW_BOOT_ADR_START                               0x0000//引导程序起始
   4          #define FW_BOOT_ADR_END                                 0x0FFF//引导程序结束
   5          #define FW_OTA1_ADR_START                               0x1000//应用程序1起始地址
   6          #define FW_OTA1_ADR_END                                 0x8000
   7          #define FW_OTA2_ADR_START                               0x8000//应用程序2起始地址
   8          #define FW_OTA2_ADR_END                                 0xF000
   9          #define BOOT_OTA1                                               0xA5A5
  10          #define BOOT_OTA2                                               0x5A5A
  11          #define CMD_STX                                                 '$'//起始码
  12          //#define CMD_FUN0//功能码
  13          //#define CMD_FUN1
  14          #define CMD_END                                                 '#'//结束码
  15          #define CMD_RX_BUFFER_SIZE                      128
  16          #define CMD_TX_BUFFER_SIZE                      128
  17          
  18                  //FLASH EEPROM 32BYTE
  19                  //BOOT_CRC 4B | BOOT_VER 4B
  20                  //OTA1_CRC 4B | OTA1_VER 4B 
  21                  //OTA2_CRC 4B | OTA2_VER 4B 
  22                  //HW_VER   4B | NULL     4B     
  23                  //SN_H     4B | SN_L     4B
  24                  //NULL     4B | SEL_BOOT 4B
  25          /*****************************************************************************/
  26          void (*BOOT_Program)();//引导程序指针
  27          void (*OTA1_Program)();//应用程序1指针
  28          void (*OTA2_Program)();//应用程序2指针
  29          uint8_t CMD_RX_BUF[CMD_RX_BUFFER_SIZE];
  30          uint8_t CMD_TX_BUF[CMD_TX_BUFFER_SIZE];
  31          uint8_t FlashEprom[EE_SIZE];//FLASH EPROM模拟
  32          /*****************************************************************************/
  33          
  34          
  35          void main (void) 
  36          {
  37   1              data uint32_t bootCrc32, ota1Crc32, ota2Crc32;
  38   1              data uint8_t temp, ctemp;
  39   1              data uint32_t i, rxCounter;
  40   1              ctemp = getkey();
  41   1              do{
  42   2                      rxCounter ++;
  43   2              }while(ctemp != CMD_STX);
  44   1              CMD_RX_BUF[i] = ctemp;
  45   1              
  46   1      //      while ((ctemp = _getkey ()) != CMD_STX){
  47   1      //              CMD_RX_BUF[0] = ctemp;
  48   1      //      }
  49   1              
  50   1              SFRPAGE_SWITCH()
  51   1              ENABLE_VDDMON()
  52   1              DISABLE_WDT()
  53   1              SFRPAGE_RESTORE()                       
C51 COMPILER V9.59.0.0   BOOTLOADER                                                        12/06/2018 16:57:09 PAGE 2   

  54   1              //等待串口发送固件更新指令
  55   1              if(EEPROM_ReadBlock(0, FlashEprom, EE_SIZE) != EE_NO_ERROR){//从FLASH中读取OTA MD5值
  56   2                      while(1);// Error reading EEPROM
  57   2              }
  58   1              crc32Clear();//CRC32清除
  59   1              for(i = FW_BOOT_ADR_START;i < FW_BOOT_ADR_END;i ++)
  60   1              {//计算BOOT CRC32
  61   2                      FLASH_Read(&temp, i, 1);
  62   2                      bootCrc32 = crc32CalculateAdd(temp);
  63   2              }
  64   1              
  65   1              for(i = FW_OTA1_ADR_START;i < FW_OTA1_ADR_END;i ++)
  66   1              {//计算OTA1 CRC32
  67   2                      FLASH_Read(&temp, i, 1);
  68   2                      ota1Crc32 = crc32CalculateAdd(temp);
  69   2              }
  70   1              for(i = FW_OTA2_ADR_START;i < FW_OTA2_ADR_END;i ++)
  71   1              {//计算OTA2 CRC32
  72   2                      FLASH_Read(&temp, i, 1);
  73   2                      ota2Crc32 = crc32CalculateAdd(temp);
  74   2              }
  75   1              //      //读取FEPROM中APP_HW MD5校正值
  76   1              if(FlashEprom[20] == BOOT_OTA1)
  77   1              {
  78   2                      if(bootCrc32 == FlashEprom[0] && ota1Crc32 == FlashEprom[8]     )
  79   2                      {
  80   3                              OTA1_Program = (void code *) FW_OTA1_ADR_START;//获取OTA1起始地址
  81   3                              OTA1_Program();//执行应用程序
  82   3                      }
  83   2              }
  84   1              if(FlashEprom[20] == BOOT_OTA2)
  85   1              {
  86   2                      if(bootCrc32 == FlashEprom[0] && ota2Crc32 == FlashEprom[16]    )
  87   2                      {
  88   3                              OTA2_Program = (void code *) FW_OTA2_ADR_START;//获取OTA2起始地址
  89   3                              OTA2_Program();//执行应用程序
  90   3                      }       
  91   2              }
  92   1              
  93   1              //SFRPAGE_SWITCH()
  94   1      //      ENABLE_VDDMON()
  95   1      //      DISABLE_WDT()
  96   1      //      SFRPAGE_RESTORE()                       
  97   1      //      if(EEPROM_ReadBlock(0, FLASH_EPROM, EE_SIZE) != EE_NO_ERROR){//从FLASH中读取OTA MD5值
  98   1      //              while(1);// Error reading EEPROM
  99   1      //      }
 100   1      //      if(FLASH_EPROM[(EE_SIZE - 1)] == BOOT_OTA1)
 101   1      //      {
 102   1      //              
 103   1      //      }
 104   1      //      else if(FLASH_EPROM[(EE_SIZE - 1)] == BOOT_OTA2)
 105   1      //      {
 106   1      //      }
 107   1              
 108   1      //   // Write RAM buffer to EEPROM.
 109   1      //   if (EEPROM_WriteBlock (0, wBuffer, EE_SIZE) != EE_NO_ERROR)
 110   1      //   {
 111   1      //      while(1);      // Error writing EEPROM
 112   1      //   }
 113   1      
 114   1      //   // Read EEPROM contents back into RAM 
 115   1      //   if (EEPROM_ReadBlock(0, rBuffer, EE_SIZE) != EE_NO_ERROR)
C51 COMPILER V9.59.0.0   BOOTLOADER                                                        12/06/2018 16:57:09 PAGE 3   

 116   1      //   {
 117   1      //      while(1);      // Error reading EEPROM
 118   1      //   }
 119   1         while (1){
 120   2            //1秒内等待串口发出更新码
 121   2                //FLASH_Clear(CONFIG_APP_START_ADR, (CONFIG_APP_END_ADR - CONFIG_APP_START_ADR));
 122   2                 //检测到更新码
 123   2                //擦除FLASH
 124   2                //执行固件更新
 125   2                //执行应用程序
 126   2            
 127   2       
 128   2         }
 129   1      
 130   1      }
 131          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    496    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    329    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      22
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
