C51 COMPILER V9.59.0.0   BOOTLOADER                                                        12/09/2018 22:48:18 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE BOOTLOADER
OBJECT MODULE PLACED IN .\Output\Bootloader.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Bootloader\Bootloader.c COMPACT OMF2 OPTIMIZE(8,SPEED) BROWSE INCDIR(.\L
                    -ib;.\LibFlash;.\FlashEprom;.\Bootloader;.\Driver) DEFINE(C8051F340) VARBANKING(1) DEBUG PRINT(.\Output\Bootloader.lst) P
                    -REPRINT(.\Output\Bootloader.i) OBJECT(.\Output\Bootloader.obj)

line level    source

   1          #include "appConfig.h"
   2          /*****************************************************************************/
   3          #define CONFIG_DEBUG                                            1
   4          #define CMD_STX                                                         0x24//$
   5          #define CMD_END                                                         0x25//%
   6          #define CMD_SET_HW_VER                                          0x31//1
   7          #define CMD_GET_HW_VER                                          0x32//2
   8          #define CMD_RESET_MCU                                           0x33//3
   9          #define CMD_GET_BOOTLOADER_VER                          0x34//4
  10          #define CMD_GET_OTA1_VER                                        0x35//5
  11          #define CMD_GET_OTA2_VER                                        0x36//6
  12          #define CMD_SET_BOOTLOADER_VER                          0x37//7
  13          #define CMD_SET_OTA1_VER                                        0x38//8
  14          #define CMD_SET_OTA2_VER                                        0x39//9
  15          #define CMD_GET_BOOT_CRC                                        0x41//A
  16          #define CMD_GET_OTA1_CRC                                        0x42//B
  17          #define CMD_GET_OTA2_CRC                                        0x43//C
  18          #define CMD_WRITE_FLASH_PAGE                            0x44//D 写入FLASH PAGE
  19          #define CMD_READ_FLASH_PAGE                                     0x45//E 读取FLASH PAGE
  20          #define CMD_CLEAR_FLASH_PAGE                            0x46//F 清除FLASH PAGE
  21          #define CMD_GOTO_OTA1                                           0x47//G
  22          #define CMD_GOTO_OTA2                                           0x48//H
  23          #define CMD_GET_HW_VER_TX_SZ                            3
  24          #define CMD_GET_HW_VER_RX_SZ                            6
  25          #define CMD_SET_HW_VER_TX_SZ                            7
  26          #define CMD_SET_HW_VER_RX_SZ                            3
  27          #define CMD_RESPOND_OK                                          0x31
  28          #define CMD_RESPOND_FAIL                                        0x30
  29          /*****************************************************************************/
  30          #define BOOT_SELECT_OTA                                         0x5A
  31          #define BOOT_SELECT_LOADER                                      0xA5
  32          #define BOOT_SELECT_TIMEOUT                                     1000000UL
  33          #define BOOT_SELECT_CHECKSUM                            0x8A//BOOTLOADER选择校验码
  34          /*****************************************************************************/
  35          #define FW_SECTORS_SIZE                                         512//FLASH扇区
  36          #define FW_BOOT_ADR_START                                       0x0000//引导程序起始
  37          #define FW_BOOT_ADR_END                                         0x1FFF//引导程序结束
  38          #define FW_OTA1_ADR_START                                       0x2000//应用程序1起始地址
  39          #define FW_OTA1_ADR_END                                         0x7FFF
  40          #define FW_OTA2_ADR_START                                       0x8000//应用程序2起始地址
  41          #define FW_OTA2_ADR_END                                         0xEFFF
  42          /*****************************************************************************/
  43          #define SELECT_BOOT_LOADER                                      0x5555
  44          #define SELECT_BOOT_OTA1                        0xA5A5
  45          #define SELECT_BOOT_OTA2                                        0x5A5A
  46          /*****************************************************************************/
  47          #define CMD_RX_BUFFER_SIZE                                      2048
  48          #define CMD_TX_BUFFER_SIZE                                      64
  49          /*****************************************************************************/
  50          #define EPROM_BOOT_CRC                                          0
  51          #define EPROM_OTA1_CRC                                          4
  52          #define EPROM_OTA2_CRC                                          8
  53          #define EPROM_BOOT_VER                                          12
C51 COMPILER V9.59.0.0   BOOTLOADER                                                        12/09/2018 22:48:18 PAGE 2   

  54          #define EPROM_OTA1_VER                                          13
  55          #define EPROM_OTA2_VER                                          14
  56          #define EPROM_HW_VER                                            15
  57          #define EPROM_OTA1_START                                        16
  58          #define EPROM_OTA1_END                                          20
  59          #define EPROM_OTA2_START                                        24
  60          #define EPROM_OTA2_END                                          28
  61          #define EPROM_BOOT_ORDER                                        32
  62          /*****************************************************************************/
  63          void (*BOOT_Program)();//引导程序指针
  64          void (*OTA1_Program)();//应用程序1指针
  65          void (*OTA2_Program)();//应用程序2指针
  66          void bootSequence(void);
  67          uint32_t bootFlashCrc(void);
  68          uint32_t ota1FlashCrc(void);
  69          uint32_t ota2FlashCrc(void);
  70          xdata uint8_t CmdRxBuf[CMD_RX_BUFFER_SIZE];
  71          xdata uint8_t CmdTxBuf[CMD_TX_BUFFER_SIZE];
  72          xdata uint8_t FlashEprom[EE_SIZE];//FLASH EPROM模拟
  73          /*****************************************************************************/
  74          static void uint32ToAscii(uint32_t *dat, uint8_t *pstr){//将32位有符号数转换为8个ASCII字符
  75   1              data uint8_t temp;      
  76   1              temp = *dat & 0xF;//0x0000000A
  77   1              if(temp <= 0x09){
  78   2                      *(pstr + 0) = (temp + 0x30);
  79   2          }
  80   1          else{
  81   2                       *(pstr + 0) = (temp + 0x37);
  82   2          }
  83   1              
  84   1              temp = (*dat >> 4) & 0xF;//0x000000A0
  85   1              if(temp <= 0x09){
  86   2                      *(pstr + 1) = (temp + 0x30);
  87   2          }
  88   1          else{
  89   2                       *(pstr + 1) = (temp + 0x37);
  90   2          }
  91   1              
  92   1              temp = (*dat >> 8) & 0xF;//0x00000A00
  93   1              if(temp <= 0x09){
  94   2                      *(pstr + 2) = (temp + 0x30);
  95   2          }
  96   1          else{
  97   2                       *(pstr + 2) = (temp + 0x37);
  98   2          }
  99   1              
 100   1              temp = (*dat >> 12) & 0xF;//0x0000A000
 101   1              if(temp <= 0x09){
 102   2                      *pstr = (temp + 0x30);
 103   2          }
 104   1          else{
 105   2                      *pstr = (temp + 0x37);
 106   2          }
 107   1              
 108   1              temp = (*dat >> 16) & 0xF;//0x000A0000
 109   1              if(temp <= 0x09){
 110   2                      *(pstr + 4) = (temp + 0x30);
 111   2          }
 112   1          else{
 113   2                       *(pstr + 4) = (temp + 0x37);
 114   2          }
 115   1      
C51 COMPILER V9.59.0.0   BOOTLOADER                                                        12/09/2018 22:48:18 PAGE 3   

 116   1              temp = (*dat >> 20) & 0xF;//0x00A00000
 117   1              if(temp <= 0x09){
 118   2                      *(pstr + 5) = (temp + 0x30);
 119   2          }
 120   1          else{
 121   2                       *(pstr + 5) = (temp + 0x37);
 122   2          }
 123   1              
 124   1              temp = (*dat >> 24) & 0xF;//0x0A000000
 125   1              if(temp <= 0x09){
 126   2                      *(pstr + 6) = (temp + 0x30);
 127   2          }
 128   1          else{
 129   2                       *(pstr + 6) = (temp + 0x37);
 130   2          }
 131   1              
 132   1              temp = (*dat >> 28) & 0xF;//0x00A00000
 133   1              if(temp <= 0x09){
 134   2                      *(pstr + 7) = (temp + 0x30);
 135   2          }
 136   1          else{
 137   2                       *(pstr + 7) = (temp + 0x37);
 138   2          }
 139   1      }
 140          static uint32_t asciiToUint32(uint8_t *pstr){//将8个BCD组合成一个32进制数
 141   1              data uint8_t temp[8];
 142   1              data uint32_t hex;
 143   1              //取出0x0000000A
 144   1              if(*pstr >= 'A' && *pstr <='F'){//A-F
 145   2                      temp[0] = *pstr - 0x37; 
 146   2              }
 147   1              else if(*pstr >= '0' && *pstr <='9'){
 148   2                      temp[0] = *pstr - 0x30; 
 149   2              }
 150   1              //取出0x000000A0
 151   1              if(*(pstr + 1) >= 'A' && *(pstr + 1) <='F'){//A-F
 152   2                      temp[1] = *(pstr + 1) - 0x37; 
 153   2              }
 154   1              else if(*(pstr + 1) >= '0' && *(pstr + 1) <='9'){
 155   2                      temp[1] = *(pstr + 1) - 0x30;   
 156   2              }
 157   1              //取出0x00000A00
 158   1              if(*pstr >= 'A' && *pstr <='F'){//A-F
 159   2                      temp[2] = *pstr - 0x37; 
 160   2              }
 161   1              else if(*pstr >= '0' && *pstr <='9'){
 162   2                      temp[2] = *pstr - 0x30; 
 163   2              }
 164   1              //取出0x0000A000
 165   1              if(*(pstr + 1) >= 'A' && *(pstr + 1) <='F'){//A-F
 166   2                      temp[3] = *(pstr + 1) - 0x37; 
 167   2              }
 168   1              else if(*(pstr + 1) >= '0' && *(pstr + 1) <='9'){
 169   2                      temp[3] = *(pstr + 1) - 0x30;   
 170   2              }
 171   1              
 172   1              //取出0x0000A000
 173   1              if(*pstr >= 'A' && *pstr <='F'){//A-F
 174   2                      temp[4] = *pstr - 0x37; 
 175   2              }
 176   1              else if(*pstr >= '0' && *pstr <='9'){
 177   2                      temp[4] = *pstr - 0x30; 
C51 COMPILER V9.59.0.0   BOOTLOADER                                                        12/09/2018 22:48:18 PAGE 4   

 178   2              }
 179   1              //取出0x00000A00
 180   1              if(*(pstr + 1) >= 'A' && *(pstr + 1) <='F'){//A-F
 181   2                      temp[5] = *(pstr + 1) - 0x37; 
 182   2              }
 183   1              else if(*(pstr + 1) >= '0' && *(pstr + 1) <='9'){
 184   2                      temp[5] = *(pstr + 1) - 0x30;   
 185   2              }
 186   1              //取出0x000000A0
 187   1              if(*pstr >= 'A' && *pstr <='F'){//A-F
 188   2                      temp[6] = *pstr - 0x37; 
 189   2              }
 190   1              else if(*pstr >= '0' && *pstr <='9'){
 191   2                      temp[6] = *pstr - 0x30; 
 192   2              }
 193   1              //取出0x0000000A
 194   1              if(*(pstr + 1) >= 'A' && *(pstr + 1) <='F'){//A-F
 195   2                      temp[7] = *(pstr + 1) - 0x37; 
 196   2              }
 197   1              else if(*(pstr + 1) >= '0' && *(pstr + 1) <='9'){
 198   2                      temp[7] = *(pstr + 1) - 0x30;   
 199   2              }
 200   1              hex = 0;
 201   1              hex |= (temp[0] & 0x0000000F);
 202   1              hex |= (((temp[1] & 0x0F) << 4) & 0x000000F0);
 203   1              hex |= (((temp[2] & 0x0F) << 8) & 0x00000F00);
 204   1              hex |= (((temp[3] & 0x0F) << 12) & 0x0000F000);
 205   1              hex |= (((temp[4] & 0x0F) << 16) & 0x000F0000);
 206   1              hex |= (((temp[5] & 0x0F) << 20) & 0x00F00000);
 207   1              hex |= (((temp[6] & 0x0F) << 24) & 0x00F00000);
 208   1              hex |= (((temp[7] & 0x0F) << 28) & 0x00F00000);
 209   1              return hex;
 210   1      }
 211          static void uint16ToAscii(uint16_t *dat, uint8_t *pstr){//将16位有符号数转换为4个ASCII字符
 212   1              data uint8_t temp;
 213   1              temp = *dat & 0x000F;//0x000A
 214   1              if(temp <= 0x09){
 215   2                      *(pstr + 0) = (temp + 0x30);
 216   2          }
 217   1          else{
 218   2                       *(pstr + 0) = (temp + 0x37);
 219   2          }
 220   1              temp = (*dat >> 4) & 0x000F;//0x00A0
 221   1              if(temp <= 0x09){
 222   2                      *(pstr + 1) = (temp + 0x30);
 223   2          }
 224   1          else{
 225   2                       *(pstr + 1) = (temp + 0x37);
 226   2          }
 227   1              temp = (*dat >> 8) & 0x000F;//0x0A00
 228   1              if(temp <= 0x09){
 229   2                      *(pstr + 2) = (temp + 0x30);
 230   2          }
 231   1          else{
 232   2                       *(pstr + 2) = (temp + 0x37);
 233   2          }
 234   1              temp = (*dat >> 12) & 0x000F;//0xA000
 235   1              if(temp <= 0x09){
 236   2                      *(pstr + 3) = (temp + 0x30);
 237   2          }
 238   1          else{
 239   2                      *(pstr + 3) = (temp + 0x37);
C51 COMPILER V9.59.0.0   BOOTLOADER                                                        12/09/2018 22:48:18 PAGE 5   

 240   2          }
 241   1      }
 242          static void uint8ToAscii(uint8_t *dat, uint8_t *pstr){//将16进制数转换成两个ASCII字符
 243   1              data uint8_t temp;
 244   1              temp = (*dat & 0x0f);
 245   1              if(temp <= 0x09){
 246   2                      *(pstr + 1) = (temp + 0x30);
 247   2          }
 248   1          else{
 249   2                       *(pstr + 1) = (temp + 0x37);
 250   2          }
 251   1              temp = ((*dat & 0xf0) >> 4);
 252   1              if(temp <= 0x09){
 253   2                      *pstr = (temp + 0x30);
 254   2              }
 255   1              else{
 256   2                      *pstr = (temp + 0x37);
 257   2              }
 258   1      }
 259          static uint8_t asciiToUint8(uint8_t *pstr){//将两个int8_t 组合成一个16进制数
 260   1              data uint8_t temp[2];
 261   1              data uint8_t hex;
 262   1              if(*pstr >= 'A' && *pstr <='F'){//A-F
 263   2                      temp[0] = *pstr - 0x37; 
 264   2              }
 265   1              else if(*pstr >= '0' && *pstr <='9'){
 266   2                      temp[0] = *pstr - 0x30; 
 267   2              }
 268   1              if(*(pstr + 1) >= 'A' && *(pstr + 1) <='F'){//A-F
 269   2                      temp[1] = *(pstr + 1) - 0x37; 
 270   2              }
 271   1              else if(*(pstr + 1) >= '0' && *(pstr + 1) <='9'){
 272   2                      temp[1] = *(pstr + 1) - 0x30;   
 273   2              }
 274   1              hex = 0;
 275   1              hex |= temp[1] & 0xF;
 276   1              hex |= ((temp[0] << 4) & 0xF0);
 277   1              return hex;
 278   1      }
 279          
 280          static uint16_t asciiToUint16(uint8_t *pstr){
 281   1              data uint8_t temp[4];
 282   1              data uint16_t hex;
 283   1              //取出0xA000
 284   1              if(*pstr >= 'A' && *pstr <='F'){//A-F
 285   2                      temp[3] = *pstr - 0x37; 
 286   2              }
 287   1              else if(*pstr >= '0' && *pstr <='9'){
 288   2                      temp[3] = *pstr - 0x30; 
 289   2              }
 290   1              //取出0x0A00
 291   1              if(*(pstr + 1) >= 'A' && *(pstr + 1) <='F'){//A-F
 292   2                      temp[2] = *(pstr + 1) - 0x37; 
 293   2              }
 294   1              else if(*(pstr + 1) >= '0' && *(pstr + 1) <='9'){
 295   2                      temp[2] = *(pstr + 1) - 0x30;   
 296   2              }
 297   1              //取出0x00A0
 298   1              if(*pstr >= 'A' && *pstr <='F'){//A-F
 299   2                      temp[1] = *pstr - 0x37; 
 300   2              }
 301   1              else if(*pstr >= '0' && *pstr <='9'){
C51 COMPILER V9.59.0.0   BOOTLOADER                                                        12/09/2018 22:48:18 PAGE 6   

 302   2                      temp[1] = *pstr - 0x30; 
 303   2              }
 304   1              //取出0x000A
 305   1              if(*(pstr + 1) >= 'A' && *(pstr + 1) <='F'){//A-F
 306   2                      temp[0] = *(pstr + 1) - 0x37; 
 307   2              }
 308   1              else if(*(pstr + 1) >= '0' && *(pstr + 1) <='9'){
 309   2                      temp[0] = *(pstr + 1) - 0x30;   
 310   2              }
 311   1              hex = 0;
 312   1              hex |= temp[0] & 0x000F;
 313   1              hex |= ((temp[1] & 0x0F) << 4) & 0x00F0;
 314   1              hex |= ((temp[2] & 0x0F) << 8) & 0x0F00;
 315   1              hex |= ((temp[3] & 0x0F) << 12) & 0xF000;
 316   1              return hex;
 317   1      }
 318          static uint8_t LRC(uint8_t *buf, int32_t len){//计算LRC LRC方法是将消息中的8Bit的字节连续累加，丢弃了进位
 319   1              int i;
 320   1              uint8_t lrc = 0;        /*lrc字节初始化*/
 321   1              for( i = 0; i < len; i++ ){
 322   2                      lrc = lrc + buf[i];
 323   2              }
 324   1              return lrc;
 325   1      }
 326          void uart0Send(uint8_t *buf, uint16_t count){//串口0查询发送
 327   1              uint8_t *ptr = buf;
 328   1              do{
 329   2                  SBUF0 = *ptr++;
 330   2                      while(TI0 == 0);
 331   2                      TI0 = 0;
 332   2              }while(--count);
 333   1      }
 334          void uart0Receive(uint8_t *buf, uint16_t count){//串口0查询接收
 335   1              uint8_t * ptr = buf;
 336   1              do{
 337   2                      if(RI0 == 1)
 338   2                      {
 339   3                              *ptr++ = SBUF0;
 340   3                              RI0 = 0;
 341   3                              count--;
 342   3                      }
 343   2              }while(count);
 344   1      }
 345          uint8_t uart0ReceiveBootOrder(void){//串口0查询接收带超时
 346   1              uint8_t temp;
 347   1              uint32_t timeOutCounter;
 348   1      #if CONFIG_DEBUG == 1
 349   1              sprintf(CmdTxBuf,"Bootloader->Debug:Input 'C' Into Loader Mode\n");
 350   1              printf(CmdTxBuf);
 351   1      #endif
 352   1              timeOutCounter = 0;
 353   1              do{
 354   2                      if(RI0 == 1){
 355   3                              temp = SBUF0;
 356   3                              RI0 = 0;
 357   3                              if(temp == 'c')
 358   3                              {
 359   4      #if CONFIG_DEBUG == 1
 360   4                                      printf("Bootloader->Debug:BOOT_SELECT_LOADER\n");
 361   4      #endif
 362   4                                      return BOOT_SELECT_LOADER;
 363   4                              }
C51 COMPILER V9.59.0.0   BOOTLOADER                                                        12/09/2018 22:48:18 PAGE 7   

 364   3                      }
 365   2                      timeOutCounter ++;
 366   2              }while(timeOutCounter <= BOOT_SELECT_TIMEOUT);
 367   1      #if CONFIG_DEBUG == 1
 368   1              printf("Bootloader->Debug:BOOT_SELECT_OTA\n");
 369   1      #endif
 370   1              return BOOT_SELECT_OTA;
 371   1      }
 372          void CmdSetHwVer(void){//设置硬件版本
 373   1              uint16_t itemp;
 374   1              FlashEprom[EPROM_HW_VER] = asciiToUint8(CmdRxBuf + 2);
 375   1      #if CONFIG_DEBUG == 1
 376   1              itemp = FlashEprom[EPROM_HW_VER];
 377   1              printf("Bootloader->Debug->CMD_SET_HW_VER:%2X\n", itemp);
 378   1      #endif
 379   1              if(EEPROM_WriteBlock(EPROM_HW_VER, FlashEprom, 1) != EE_NO_ERROR){//从FLASH中读取OTA MD5值
 380   2                      CmdTxBuf[0] = CMD_STX;
 381   2                      CmdTxBuf[1] = CMD_SET_HW_VER;
 382   2                      CmdTxBuf[2] = CMD_RESPOND_FAIL;
 383   2                      CmdTxBuf[3] = CMD_END;  
 384   2              }
 385   1              else{
 386   2                      CmdTxBuf[0] = CMD_STX;
 387   2                      CmdTxBuf[1] = CMD_SET_HW_VER;
 388   2                      CmdTxBuf[2] = CMD_RESPOND_OK;
 389   2                      CmdTxBuf[3] = CMD_END;
 390   2              }
 391   1              uart0Send(CmdTxBuf, 4);
 392   1      }
 393          void CmdGetHwVer(void){//获取硬件版本
 394   1              uint8_t ctemp[2];
 395   1              uint16_t itemp;
 396   1              uint8ToAscii((FlashEprom + EPROM_HW_VER), ctemp);
 397   1      #if CONFIG_DEBUG == 1
 398   1              itemp = FlashEprom[EPROM_HW_VER];
 399   1              printf("Bootloader->Debug->CMD_GET_HW_VER:%2X\n", itemp);
 400   1      #endif
 401   1              CmdTxBuf[0] = CMD_STX;
 402   1              CmdTxBuf[1] = CMD_GET_HW_VER;
 403   1              CmdTxBuf[2] = ctemp[0];
 404   1              CmdTxBuf[3] = ctemp[1];
 405   1              CmdTxBuf[4] = CMD_END;
 406   1              uart0Send(CmdTxBuf, 5);
 407   1      }
 408          void CmdResetMcu(void){//强制复位
 409   1              RSTSRC |= (1 << 4);
 410   1      }
 411          void CmdGetBootLoaderVer(void){//获取BOOTLOADER版本
 412   1              uint8_t ctemp[2];
 413   1              uint16_t itemp;
 414   1              uint8ToAscii((FlashEprom + EPROM_BOOT_VER), ctemp);
 415   1      #if CONFIG_DEBUG == 1
 416   1              itemp = FlashEprom[EPROM_BOOT_VER];
 417   1              printf("Bootloader->Debug->CMD_GET_BOOT_VER:%2X\n", itemp);
 418   1      #endif
 419   1              CmdTxBuf[0] = CMD_STX;
 420   1              CmdTxBuf[1] = CMD_GET_BOOTLOADER_VER;
 421   1              CmdTxBuf[2] = ctemp[0];
 422   1              CmdTxBuf[3] = ctemp[1];
 423   1              CmdTxBuf[4] = CMD_END;  
 424   1              uart0Send(CmdTxBuf, 5);
 425   1      }
C51 COMPILER V9.59.0.0   BOOTLOADER                                                        12/09/2018 22:48:18 PAGE 8   

 426          void CmdSetBootLoaderVer(void){//设置Bootloader版本号
 427   1              uint16_t itemp;
 428   1              FlashEprom[EPROM_BOOT_VER] = asciiToUint8(CmdRxBuf + 2);
 429   1      #if CONFIG_DEBUG == 1
 430   1              itemp = FlashEprom[EPROM_BOOT_VER];
 431   1              printf("Bootloader->Debug->CMD_SET_BOOT_VER:%2X\n", itemp);
 432   1      #endif
 433   1              if(EEPROM_WriteBlock(EPROM_HW_VER, FlashEprom, 1) != EE_NO_ERROR){//从FLASH中读取OTA MD5值
 434   2                      CmdTxBuf[0] = CMD_STX;
 435   2                      CmdTxBuf[1] = CMD_SET_BOOTLOADER_VER;
 436   2                      CmdTxBuf[2] = CMD_RESPOND_FAIL;
 437   2                      CmdTxBuf[3] = CMD_END;  
 438   2              }
 439   1              else{
 440   2                      CmdTxBuf[0] = CMD_STX;
 441   2                      CmdTxBuf[1] = CMD_SET_BOOTLOADER_VER;
 442   2                      CmdTxBuf[2] = CMD_RESPOND_OK;
 443   2                      CmdTxBuf[3] = CMD_END;
 444   2              }
 445   1              uart0Send(CmdTxBuf, 4);
 446   1      }
 447          void CmdGetOTA1Ver(void){//获取OTA1版本号
 448   1              uint8_t ctemp[2];
 449   1              uint16_t itemp;
 450   1              uint8ToAscii((FlashEprom + EPROM_OTA1_VER), ctemp);
 451   1      #if CONFIG_DEBUG == 1
 452   1              itemp = FlashEprom[EPROM_OTA1_VER];
 453   1              printf("Bootloader->Debug->CMD_GET_OTA1_VER:%2X\n", itemp);
 454   1      #endif
 455   1              CmdTxBuf[0] = CMD_STX;
 456   1              CmdTxBuf[1] = CMD_GET_OTA1_VER;
 457   1              CmdTxBuf[2] = ctemp[0];
 458   1              CmdTxBuf[3] = ctemp[1];
 459   1              CmdTxBuf[4] = CMD_END;  
 460   1              uart0Send(CmdTxBuf, 5);
 461   1      }
 462          void CmdSetOTA1Ver(void){//设置OTA1版本号
 463   1              uint16_t itemp;
 464   1              FlashEprom[EPROM_OTA1_VER] = asciiToUint8(CmdRxBuf + 2);
 465   1      #if CONFIG_DEBUG == 1
 466   1              itemp = FlashEprom[EPROM_OTA1_VER];
 467   1              printf("Bootloader->Debug->CMD_SET_OTA1_VER:%2X\n", itemp);
 468   1      #endif
 469   1              if(EEPROM_WriteBlock(EPROM_OTA1_VER, FlashEprom, 1) != EE_NO_ERROR){//从FLASH中读取OTA MD5值
 470   2                      CmdTxBuf[0] = CMD_STX;
 471   2                      CmdTxBuf[1] = CMD_SET_OTA1_VER;
 472   2                      CmdTxBuf[2] = CMD_RESPOND_FAIL;
 473   2                      CmdTxBuf[3] = CMD_END;  
 474   2              }
 475   1              else{
 476   2                      CmdTxBuf[0] = CMD_STX;
 477   2                      CmdTxBuf[1] = CMD_SET_OTA1_VER;
 478   2                      CmdTxBuf[2] = CMD_RESPOND_OK;
 479   2                      CmdTxBuf[3] = CMD_END;
 480   2              }
 481   1              uart0Send(CmdTxBuf, 4);
 482   1      }
 483          void CmdGetOTA2Ver(void){//获取OTA2版本号
 484   1              uint8_t ctemp[2];
 485   1              uint16_t itemp;
 486   1              uint8ToAscii((FlashEprom + EPROM_OTA2_VER), ctemp);
 487   1      #if CONFIG_DEBUG == 1
C51 COMPILER V9.59.0.0   BOOTLOADER                                                        12/09/2018 22:48:18 PAGE 9   

 488   1              itemp = FlashEprom[EPROM_OTA2_VER];
 489   1              printf("Bootloader->Debug->CMD_GET_OTA2_VER:%2X\n", itemp);
 490   1      #endif
 491   1              CmdTxBuf[0] = CMD_STX;
 492   1              CmdTxBuf[1] = CMD_GET_OTA2_VER;
 493   1              CmdTxBuf[2] = ctemp[0];
 494   1              CmdTxBuf[3] = ctemp[1];
 495   1              CmdTxBuf[4] = CMD_END;  
 496   1              uart0Send(CmdTxBuf, 5);
 497   1      }
 498          void CmdSetOTA2Ver(void){//设置OTA2版本号
 499   1              uint16_t itemp;
 500   1              FlashEprom[EPROM_OTA2_VER] = asciiToUint8(CmdRxBuf + 2);
 501   1      #if CONFIG_DEBUG == 1
 502   1              itemp = FlashEprom[EPROM_OTA2_VER];
 503   1              printf("Bootloader->Debug->CMD_SET_OTA2_VER:%2X\n", itemp);
 504   1      #endif
 505   1              if(EEPROM_WriteBlock(EPROM_OTA2_VER, FlashEprom, 1) != EE_NO_ERROR){//从FLASH中读取OTA MD5值
 506   2                      CmdTxBuf[0] = CMD_STX;
 507   2                      CmdTxBuf[1] = CMD_SET_OTA2_VER;
 508   2                      CmdTxBuf[2] = CMD_RESPOND_FAIL;
 509   2                      CmdTxBuf[3] = CMD_END;  
 510   2              }
 511   1              else{
 512   2                      CmdTxBuf[0] = CMD_STX;
 513   2                      CmdTxBuf[1] = CMD_SET_OTA2_VER;
 514   2                      CmdTxBuf[2] = CMD_RESPOND_OK;
 515   2                      CmdTxBuf[3] = CMD_END;
 516   2              }
 517   1              uart0Send(CmdTxBuf, 4);
 518   1      }
 519          void CmdGetBootCrc(void){//获取BOOT CRC
 520   1              uint8_t ctemp[2];
 521   1              uint16_t itemp;
 522   1              uint8ToAscii((FlashEprom + EPROM_BOOT_CRC), ctemp);
 523   1      #if CONFIG_DEBUG == 1
 524   1              itemp = FlashEprom[EPROM_BOOT_CRC];
 525   1              printf("Bootloader->Debug->CMD_GET_BOOT_CRC:%2X\n", itemp);
 526   1      #endif  
 527   1              CmdTxBuf[0] = CMD_STX;
 528   1              CmdTxBuf[1] = CMD_GET_BOOT_CRC;
 529   1              CmdTxBuf[2] = ctemp[0];
 530   1              CmdTxBuf[3] = ctemp[1];
 531   1              CmdTxBuf[4] = CMD_END;  
 532   1              uart0Send(CmdTxBuf, 5);
 533   1      }
 534          void CmdGetOTA1Crc(void){//获取OTA1 CRC
 535   1              uint8_t ctemp[2];
 536   1              uint16_t itemp;
 537   1              uint8ToAscii((FlashEprom + EPROM_OTA1_CRC), ctemp);
 538   1      #if CONFIG_DEBUG == 1
 539   1              itemp = FlashEprom[EPROM_OTA1_CRC];
 540   1              printf("Bootloader->Debug->CMD_GET_OTA1_CRC:%2X\n", itemp);
 541   1      #endif
 542   1              CmdTxBuf[0] = CMD_STX;
 543   1              CmdTxBuf[1] = CMD_GET_OTA1_CRC;
 544   1              CmdTxBuf[2] = ctemp[0];
 545   1              CmdTxBuf[3] = ctemp[1];
 546   1              CmdTxBuf[4] = CMD_END;  
 547   1              uart0Send(CmdTxBuf, 5);
 548   1      }
 549          void CmdGetOTA2Crc(void){//获取OTA2 CRC
C51 COMPILER V9.59.0.0   BOOTLOADER                                                        12/09/2018 22:48:18 PAGE 10  

 550   1              uint8_t ctemp[2];
 551   1              uint16_t itemp;
 552   1              uint8ToAscii((FlashEprom + EPROM_OTA2_CRC), ctemp);
 553   1      #if CONFIG_DEBUG == 1
 554   1              itemp = FlashEprom[EPROM_OTA2_CRC];
 555   1              printf("Bootloader->Debug->CMD_GET_OTA2_CRC:%2X\n", itemp);
 556   1      #endif
 557   1              CmdTxBuf[0] = CMD_STX;
 558   1              CmdTxBuf[1] = CMD_GET_OTA2_CRC;
 559   1              CmdTxBuf[2] = ctemp[0];
 560   1              CmdTxBuf[3] = ctemp[1];
 561   1              CmdTxBuf[4] = CMD_END;  
 562   1              uart0Send(CmdTxBuf, 5);
 563   1      }
 564          void CmdEraseFlashPage(void){//擦除FLASH指定页
 565   1              uint8_t page, temp;
 566   1              uint32_t
 567   1              page = asciiToUint8(CmdRxBuf + 2);
*** ERROR C231 IN LINE 567 OF Bootloader\Bootloader.c: 'page': redefinition
 568   1              if((page > (FW_OTA1_ADR_START / FW_SECTORS_SIZE)) && (page < (FW_OTA2_ADR_END / FW_SECTORS_SIZE))){
 569   2      #if CONFIG_DEBUG == 1
 570   2                      printf("Bootloader->Debug->CMD_ERASE_FLASH_PAGE:0x%2XH\n", temp);       
 571   2      #endif
 572   2                      EE_FLASH_WriteErase (page, 0, 0x13);
 573   2              }
 574   1              else{
 575   2      #if CONFIG_DEBUG == 1
 576   2              printf("Bootloader->Debug->CMD_ERASE_FLASH_PAGE:0x%2XH Fail\n", temp);  
 577   2      #endif
 578   2              }
 579   1      }
 580          
 581          
 582          void CmdWriteFlashBytes(void){//写入FLASH
 583   1              
 584   1      }
 585          void CmdReadFlashBytes(void){//读取FLASH
 586   1              
 587   1      }
 588          
 589          void loaderCmdPoll(void){//串口命令轮询
 590   1              uint8_t *ptr, *ptw;
 591   1              uart0Send("C", 1);
 592   1              while(1){
 593   2                      ptr = CmdRxBuf;
 594   2                      uart0Receive(ptr, 1);
 595   2                      if(*ptr == CMD_STX){
 596   3                              ptr ++;
 597   3                              do{
 598   4                                      uart0Receive(ptr, 1);
 599   4                                      if(*ptr == CMD_END)
 600   4                                      {
 601   5                                              switch(CmdRxBuf[1])
 602   5                                              {
 603   6                                                      case CMD_SET_HW_VER://1
 604   6                                                      {
 605   7                                                              CmdSetHwVer();
 606   7                                                              break;
 607   7                                                      }
 608   6                                                      case CMD_GET_HW_VER://2
 609   6                                                      {
 610   7                                                              CmdGetHwVer();
C51 COMPILER V9.59.0.0   BOOTLOADER                                                        12/09/2018 22:48:18 PAGE 11  

 611   7                                                              break;
 612   7                                                      }
 613   6                                                      case CMD_RESET_MCU://3
 614   6                                                      {
 615   7                                                              CmdResetMcu();
 616   7                                                              break;
 617   7                                                      }
 618   6                                                      case CMD_GET_BOOTLOADER_VER://4
 619   6                                                      {
 620   7                                                              CmdGetBootLoaderVer();
 621   7                                                              break;
 622   7                                                      }
 623   6                                                      case CMD_GET_OTA1_VER://5
 624   6                                                      {
 625   7                                                              CmdGetOTA1Ver();
 626   7                                                              break;
 627   7                                                      }
 628   6                                                      case CMD_GET_OTA2_VER://6
 629   6                                                      {
 630   7                                                              CmdGetOTA2Ver();
 631   7                                                              break;
 632   7                                                      }
 633   6                                                      case CMD_SET_BOOTLOADER_VER://7
 634   6                                                      {
 635   7                                                              CmdSetBootLoaderVer();
 636   7                                                              break;
 637   7                                                      }
 638   6                                                      case CMD_SET_OTA1_VER://8
 639   6                                                      {
 640   7                                                              CmdSetOTA1Ver();
 641   7                                                              break;
 642   7                                                      }
 643   6                                                      case CMD_SET_OTA2_VER://9
 644   6                                                      {
 645   7                                                              CmdSetOTA2Ver();
 646   7                                                              break;
 647   7                                                      }                                                       
 648   6                                                      case CMD_GET_OTA1_CRC://
 649   6                                                      {
 650   7                                                              CmdGetOTA1Crc();
 651   7                                                              break;
 652   7                                                      }
 653   6                                                      case CMD_GET_OTA2_CRC:
 654   6                                                      {
 655   7                                                              CmdGetOTA2Crc();
 656   7                                                              break;
 657   7                                                      }
 658   6                                                      case CMD_ERASE_FLASH_PAGE:
*** ERROR C202 IN LINE 658 OF Bootloader\Bootloader.c: 'CMD_ERASE_FLASH_PAGE': undefined identifier
 659   6                                                      {
 660   7                                                              CmdEraseFlashPage();
 661   7                                                              break;
 662   7                                                      }
 663   6                                                      case CMD_WRITE_FLASH_BYTES:
*** ERROR C202 IN LINE 663 OF Bootloader\Bootloader.c: 'CMD_WRITE_FLASH_BYTES': undefined identifier
 664   6                                                      {
 665   7                                                              break;
 666   7                                                      }
 667   6                                                      case CMD_READ_FLASH_BYTES:
*** ERROR C202 IN LINE 667 OF Bootloader\Bootloader.c: 'CMD_READ_FLASH_BYTES': undefined identifier
 668   6                                                      {
 669   7                                                              break;
C51 COMPILER V9.59.0.0   BOOTLOADER                                                        12/09/2018 22:48:18 PAGE 12  

 670   7                                                      }
 671   6                                                      case CMD_GOTO_OTA1:
 672   6                                                      {
 673   7                                                              break;
 674   7                                                      }
 675   6                                                      case CMD_GOTO_OTA2:
 676   6                                                      {
 677   7                                                              break;
 678   7                                                      }
 679   6                                                      default:break;
 680   6                                              }
 681   5                                              break;
 682   5                                      }
 683   4                                      else if(ptr >= (CmdRxBuf + CMD_RX_BUFFER_SIZE)){
 684   5                                              NOP();
 685   5                                              break;
 686   5                                      }
 687   4                                      ptr ++;
 688   4                              }while(1);
 689   3                      }
 690   2              }
 691   1      }
 692          
 693          void bootSequence(void){//启动顺序选择
 694   1              data uint32_t ota1Crc32, ota2Crc32;
 695   1              //开始计时器
 696   1              data uint8_t temp;
 697   1              temp = uart0ReceiveBootOrder();
 698   1              if(temp == BOOT_SELECT_OTA)
 699   1              {
 700   2                      if(FlashEprom[EPROM_BOOT_ORDER] == SELECT_BOOT_OTA1)
 701   2                      {//启动顺序选择BOOT_OTA1
 702   3                              ota1Crc32 = ota1FlashCrc();
 703   3                              if(ota1Crc32 == FlashEprom[EPROM_OTA1_CRC])
 704   3                              {
 705   4                                      OTA1_Program = (void code *)(FW_OTA1_ADR_START & 0x1FFFF);//获取OTA1起始地址
 706   4                                      OTA1_Program();//执行应用程序
 707   4                              }
 708   3                      }
 709   2                      else if(FlashEprom[EPROM_BOOT_ORDER] == SELECT_BOOT_OTA2)
 710   2                      {//启动顺序选择BOOT_OTA2
 711   3                              if(ota2Crc32 == FlashEprom[EPROM_OTA2_CRC])
 712   3                              {
 713   4                                      OTA2_Program = (void code *)(FW_OTA2_ADR_START & 0x1FFFF);//获取OTA2起始地址
 714   4                                      OTA2_Program();//执行应用程序
 715   4                              }       
 716   3                      }
 717   2                      else{
 718   3      #if CONFIG_DEBUG == 1
 719   3                              printf("Bootloader->Debug:OTA CRC32 Check Fail,Into Loader Mode\n");
 720   3      #endif
 721   3                              loaderCmdPoll();
 722   3                      }       
 723   2              }
 724   1              else if(temp == BOOT_SELECT_LOADER)
 725   1              {
 726   2                      while(1)
 727   2                      {
 728   3                              loaderCmdPoll();
 729   3                      }
 730   2              }       
 731   1      }
C51 COMPILER V9.59.0.0   BOOTLOADER                                                        12/09/2018 22:48:18 PAGE 13  

 732          uint32_t bootFlashCrc(void){//BOOT CRC32校验    
 733   1              data uint32_t crc = 0, i;
 734   1              data uint8_t temp;
 735   1              
 736   1              crc32Clear();//CRC32清除
 737   1              for(i = FW_BOOT_ADR_START;i < FW_BOOT_ADR_END;i ++)
 738   1              {//计算BOOT CRC32
 739   2                      FLASH_Read(&temp, i, 1);
 740   2                      crc = crc32CalculateAdd(temp);
 741   2              }
 742   1              return crc;
 743   1      }
 744          uint32_t ota1FlashCrc(void){//OTA1 CRC32校验
 745   1              data uint32_t crc = 0 ,i;
 746   1              data uint8_t temp;
 747   1              crc32Clear();//CRC32清除
 748   1              for(i = FW_OTA1_ADR_START;i < FW_OTA1_ADR_END;i ++)
 749   1              {//计算OTA1 CRC32
 750   2                      FLASH_Read(&temp, i, 1);
 751   2                      crc = crc32CalculateAdd(temp);
 752   2              }
 753   1              return crc;
 754   1      }
 755          uint32_t ota2FlashCrc(void){//OTA2 CRC32校验
 756   1              data uint32_t crc = 0, i;
 757   1              data uint8_t temp;
 758   1              for(i = FW_OTA2_ADR_START;i < FW_OTA2_ADR_END;i ++)
 759   1              {//计算OTA2 CRC32
 760   2                      FLASH_Read(&temp, i, 1);
 761   2                      crc = crc32CalculateAdd(temp);
 762   2              }
 763   1              return crc;
 764   1      }
 765          
 766          void main (void) 
 767          {
 768   1              Init_Device();
 769   1      #if CONFIG_DEBUG == 1
 770   1              printf("Bootloader->Debug:Hello C8051 Bootloader\n");
 771   1      #endif
 772   1              bootSequence();
 773   1              while(1);
 774   1      }

C51 COMPILATION COMPLETE.  0 WARNING(S),  4 ERROR(S)
