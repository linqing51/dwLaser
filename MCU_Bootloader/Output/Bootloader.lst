C51 COMPILER V9.59.0.0   BOOTLOADER                                                        12/11/2018 23:27:22 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE BOOTLOADER
OBJECT MODULE PLACED IN .\Output\Bootloader.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Bootloader\Bootloader.c COMPACT OMF2 OPTIMIZE(9,SPEED) REGFILE(.\Output\
                    -bootload.ORC) BROWSE INCDIR(.\Lib;.\LibFlash;.\FlashEprom;.\Bootloader;.\Driver) DEFINE(C8051F340) VARBANKING(1) DEBUG P
                    -RINT(.\Output\Bootloader.lst) PREPRINT(.\Output\Bootloader.i) OBJECT(.\Output\Bootloader.obj)

line level    source

   1          #include "appConfig.h"
   2          /*****************************************************************************/
   3          #define CONFIG_DEBUG                                            1
   4          #define CMD_STX                                                         0x24//$
   5          #define CMD_END                                                         0x25//%
   6          #define CMD_SET_HW_VER                                          0x31//1
   7          #define CMD_GET_HW_VER                                          0x32//2
   8          #define CMD_RESET_MCU                                           0x33//3
   9          #define CMD_GET_BOOTLOADER_VER                          0x34//4
  10          #define CMD_GET_OTA1_VER                                        0x35//5
  11          #define CMD_GET_OTA2_VER                                        0x36//6
  12          #define CMD_SET_BOOTLOADER_VER                          0x37//7
  13          #define CMD_SET_OTA1_VER                                        0x38//8
  14          #define CMD_SET_OTA2_VER                                        0x39//9
  15          #define CMD_GET_BOOT_CRC                                        0x41//A
  16          #define CMD_GET_OTA1_CRC                                        0x42//B
  17          #define CMD_GET_OTA2_CRC                                        0x43//C
  18          #define CMD_WRITE_FLASH_PAGE                            0x44//D 写入FLASH PAGE
  19          #define CMD_READ_FLASH_PAGE                                     0x45//E 读取FLASH PAGE
  20          #define CMD_CLEAR_FLASH_PAGE                            0x46//F 清除FLASH PAGE
  21          #define CMD_GOTO_OTA1                                           0x47//G
  22          #define CMD_GOTO_OTA2                                           0x48//H
  23          #define CMD_GET_HW_VER_TX_SZ                            3
  24          #define CMD_GET_HW_VER_RX_SZ                            6
  25          #define CMD_SET_HW_VER_TX_SZ                            7
  26          #define CMD_SET_HW_VER_RX_SZ                            3
  27          #define CMD_RESPOND_OK                                          0x31
  28          #define CMD_RESPOND_FAIL                                        0x30
  29          /*****************************************************************************/
  30          #define BOOT_SELECT_OTA                                         0x5A
  31          #define BOOT_SELECT_LOADER                                      0xA5
  32          #define BOOT_SELECT_TIMEOUT                                     1000000UL
  33          #define BOOT_SELECT_CHECKSUM                            0x8A//BOOTLOADER选择校验码
  34          /*****************************************************************************/
  35          #define FW_BOOT_ADR_START                                       0x0000//引导程序起始
  36          #define FW_BOOT_ADR_END                                         0x1FFF//引导程序结束
  37          #define FW_OTA1_ADR_START                                       0x2000//应用程序1起始地址
  38          #define FW_OTA1_ADR_END                                         0x7FFF
  39          #define FW_OTA2_ADR_START                                       0x8000//应用程序2起始地址
  40          #define FW_OTA2_ADR_END                                         0xEFFF
  41          /*****************************************************************************/
  42          #define SELECT_BOOT_LOADER                                      0x5555
  43          #define SELECT_BOOT_OTA1                        0xA5A5
  44          #define SELECT_BOOT_OTA2                                        0x5A5A
  45          /*****************************************************************************/
  46          #define CMD_RX_BUFFER_SIZE                                      1100
  47          #define CMD_TX_BUFFER_SIZE                                      1100
  48          /*****************************************************************************/
  49          #define EPROM_BOOT_CRC                                          0
  50          #define EPROM_OTA1_CRC                                          4
  51          #define EPROM_OTA2_CRC                                          8
  52          #define EPROM_BOOT_VER                                          12
  53          #define EPROM_OTA1_VER                                          13
C51 COMPILER V9.59.0.0   BOOTLOADER                                                        12/11/2018 23:27:22 PAGE 2   

  54          #define EPROM_OTA2_VER                                          14
  55          #define EPROM_HW_VER                                            15
  56          #define EPROM_OTA1_START                                        16
  57          #define EPROM_OTA1_END                                          20
  58          #define EPROM_OTA2_START                                        24
  59          #define EPROM_OTA2_END                                          28
  60          #define EPROM_BOOT_ORDER                                        32
  61          /*****************************************************************************/
  62          void (*BOOT_Program)();//引导程序指针
  63          void (*OTA1_Program)();//应用程序1指针
  64          void (*OTA2_Program)();//应用程序2指针
  65          void bootSequence(void);
  66          uint32_t bootFlashCrc(void);
  67          uint32_t ota1FlashCrc(void);
  68          uint32_t ota2FlashCrc(void);
  69          xdata uint8_t CmdRxBuf[CMD_RX_BUFFER_SIZE];
  70          xdata uint8_t CmdTxBuf[CMD_TX_BUFFER_SIZE];
  71          xdata uint8_t TempBuf[FL_PAGE_SIZE];//临时缓冲区
  72          xdata uint8_t FlashEprom[EE_SIZE];//FLASH EPROM模拟
  73          /*****************************************************************************/
  74          static void uint32ToAscii(uint32_t *dat, uint8_t *pstr){//将32位有符号数转换为8个ASCII字符
  75   1              data uint8_t temp;      
  76   1              temp = *dat & 0xF;//0x0000000A
  77   1              if(temp <= 0x09){
  78   2                      *(pstr + 0) = (temp + 0x30);
  79   2          }
  80   1          else{
  81   2                       *(pstr + 0) = (temp + 0x37);
  82   2          }
  83   1              
  84   1              temp = (*dat >> 4) & 0xF;//0x000000A0
  85   1              if(temp <= 0x09){
  86   2                      *(pstr + 1) = (temp + 0x30);
  87   2          }
  88   1          else{
  89   2                       *(pstr + 1) = (temp + 0x37);
  90   2          }
  91   1              
  92   1              temp = (*dat >> 8) & 0xF;//0x00000A00
  93   1              if(temp <= 0x09){
  94   2                      *(pstr + 2) = (temp + 0x30);
  95   2          }
  96   1          else{
  97   2                       *(pstr + 2) = (temp + 0x37);
  98   2          }
  99   1              
 100   1              temp = (*dat >> 12) & 0xF;//0x0000A000
 101   1              if(temp <= 0x09){
 102   2                      *pstr = (temp + 0x30);
 103   2          }
 104   1          else{
 105   2                      *pstr = (temp + 0x37);
 106   2          }
 107   1              
 108   1              temp = (*dat >> 16) & 0xF;//0x000A0000
 109   1              if(temp <= 0x09){
 110   2                      *(pstr + 4) = (temp + 0x30);
 111   2          }
 112   1          else{
 113   2                       *(pstr + 4) = (temp + 0x37);
 114   2          }
 115   1      
C51 COMPILER V9.59.0.0   BOOTLOADER                                                        12/11/2018 23:27:22 PAGE 3   

 116   1              temp = (*dat >> 20) & 0xF;//0x00A00000
 117   1              if(temp <= 0x09){
 118   2                      *(pstr + 5) = (temp + 0x30);
 119   2          }
 120   1          else{
 121   2                       *(pstr + 5) = (temp + 0x37);
 122   2          }
 123   1              
 124   1              temp = (*dat >> 24) & 0xF;//0x0A000000
 125   1              if(temp <= 0x09){
 126   2                      *(pstr + 6) = (temp + 0x30);
 127   2          }
 128   1          else{
 129   2                       *(pstr + 6) = (temp + 0x37);
 130   2          }
 131   1              
 132   1              temp = (*dat >> 28) & 0xF;//0x00A00000
 133   1              if(temp <= 0x09){
 134   2                      *(pstr + 7) = (temp + 0x30);
 135   2          }
 136   1          else{
 137   2                       *(pstr + 7) = (temp + 0x37);
 138   2          }
 139   1      }
 140          static uint32_t asciiToUint32(uint8_t *pstr){//将8个BCD组合成一个32进制数
 141   1              data uint8_t temp[8];
 142   1              data uint32_t hex;
 143   1              //取出0x0000000A
 144   1              if(*pstr >= 'A' && *pstr <='F'){//A-F
 145   2                      temp[0] = *pstr - 0x37; 
 146   2              }
 147   1              else if(*pstr >= '0' && *pstr <='9'){
 148   2                      temp[0] = *pstr - 0x30; 
 149   2              }
 150   1              //取出0x000000A0
 151   1              if(*(pstr + 1) >= 'A' && *(pstr + 1) <='F'){//A-F
 152   2                      temp[1] = *(pstr + 1) - 0x37; 
 153   2              }
 154   1              else if(*(pstr + 1) >= '0' && *(pstr + 1) <='9'){
 155   2                      temp[1] = *(pstr + 1) - 0x30;   
 156   2              }
 157   1              //取出0x00000A00
 158   1              if(*pstr >= 'A' && *pstr <='F'){//A-F
 159   2                      temp[2] = *pstr - 0x37; 
 160   2              }
 161   1              else if(*pstr >= '0' && *pstr <='9'){
 162   2                      temp[2] = *pstr - 0x30; 
 163   2              }
 164   1              //取出0x0000A000
 165   1              if(*(pstr + 1) >= 'A' && *(pstr + 1) <='F'){//A-F
 166   2                      temp[3] = *(pstr + 1) - 0x37; 
 167   2              }
 168   1              else if(*(pstr + 1) >= '0' && *(pstr + 1) <='9'){
 169   2                      temp[3] = *(pstr + 1) - 0x30;   
 170   2              }
 171   1              
 172   1              //取出0x0000A000
 173   1              if(*pstr >= 'A' && *pstr <='F'){//A-F
 174   2                      temp[4] = *pstr - 0x37; 
 175   2              }
 176   1              else if(*pstr >= '0' && *pstr <='9'){
 177   2                      temp[4] = *pstr - 0x30; 
C51 COMPILER V9.59.0.0   BOOTLOADER                                                        12/11/2018 23:27:22 PAGE 4   

 178   2              }
 179   1              //取出0x00000A00
 180   1              if(*(pstr + 1) >= 'A' && *(pstr + 1) <='F'){//A-F
 181   2                      temp[5] = *(pstr + 1) - 0x37; 
 182   2              }
 183   1              else if(*(pstr + 1) >= '0' && *(pstr + 1) <='9'){
 184   2                      temp[5] = *(pstr + 1) - 0x30;   
 185   2              }
 186   1              //取出0x000000A0
 187   1              if(*pstr >= 'A' && *pstr <='F'){//A-F
 188   2                      temp[6] = *pstr - 0x37; 
 189   2              }
 190   1              else if(*pstr >= '0' && *pstr <='9'){
 191   2                      temp[6] = *pstr - 0x30; 
 192   2              }
 193   1              //取出0x0000000A
 194   1              if(*(pstr + 1) >= 'A' && *(pstr + 1) <='F'){//A-F
 195   2                      temp[7] = *(pstr + 1) - 0x37; 
 196   2              }
 197   1              else if(*(pstr + 1) >= '0' && *(pstr + 1) <='9'){
 198   2                      temp[7] = *(pstr + 1) - 0x30;   
 199   2              }
 200   1              hex = 0;
 201   1              hex |= (temp[0] & 0x0000000F);
 202   1              hex |= (((temp[1] & 0x0F) << 4) & 0x000000F0);
 203   1              hex |= (((temp[2] & 0x0F) << 8) & 0x00000F00);
 204   1              hex |= (((temp[3] & 0x0F) << 12) & 0x0000F000);
 205   1              hex |= (((temp[4] & 0x0F) << 16) & 0x000F0000);
 206   1              hex |= (((temp[5] & 0x0F) << 20) & 0x00F00000);
 207   1              hex |= (((temp[6] & 0x0F) << 24) & 0x00F00000);
 208   1              hex |= (((temp[7] & 0x0F) << 28) & 0x00F00000);
 209   1              return hex;
 210   1      }
 211          static void uint16ToAscii(uint16_t *dat, uint8_t *pstr){//将16位有符号数转换为4个ASCII字符
 212   1              data uint8_t temp;
 213   1              temp = *dat & 0x000F;//0x000A
 214   1              if(temp <= 0x09){
 215   2                      *(pstr + 0) = (temp + 0x30);
 216   2          }
 217   1          else{
 218   2                       *(pstr + 0) = (temp + 0x37);
 219   2          }
 220   1              temp = (*dat >> 4) & 0x000F;//0x00A0
 221   1              if(temp <= 0x09){
 222   2                      *(pstr + 1) = (temp + 0x30);
 223   2          }
 224   1          else{
 225   2                       *(pstr + 1) = (temp + 0x37);
 226   2          }
 227   1              temp = (*dat >> 8) & 0x000F;//0x0A00
 228   1              if(temp <= 0x09){
 229   2                      *(pstr + 2) = (temp + 0x30);
 230   2          }
 231   1          else{
 232   2                       *(pstr + 2) = (temp + 0x37);
 233   2          }
 234   1              temp = (*dat >> 12) & 0x000F;//0xA000
 235   1              if(temp <= 0x09){
 236   2                      *(pstr + 3) = (temp + 0x30);
 237   2          }
 238   1          else{
 239   2                      *(pstr + 3) = (temp + 0x37);
C51 COMPILER V9.59.0.0   BOOTLOADER                                                        12/11/2018 23:27:22 PAGE 5   

 240   2          }
 241   1      }
 242          static void uint8ToAscii(uint8_t *dat, uint8_t *pstr){//将16进制数转换成两个ASCII字符
 243   1              data uint8_t temp;
 244   1              temp = (*dat & 0x0f);
 245   1              if(temp <= 0x09){
 246   2                      *(pstr + 1) = (temp + 0x30);
 247   2          }
 248   1          else{
 249   2                       *(pstr + 1) = (temp + 0x37);
 250   2          }
 251   1              temp = ((*dat & 0xf0) >> 4);
 252   1              if(temp <= 0x09){
 253   2                      *pstr = (temp + 0x30);
 254   2              }
 255   1              else{
 256   2                      *pstr = (temp + 0x37);
 257   2              }
 258   1      }
 259          static uint8_t asciiToUint8(uint8_t *pstr){//将两个int8_t 组合成一个16进制数
 260   1              data uint8_t temp[2];
 261   1              data uint8_t hex;
 262   1              if(*pstr >= 'A' && *pstr <='F'){//A-F
 263   2                      temp[0] = *pstr - 0x37; 
 264   2              }
 265   1              else if(*pstr >= '0' && *pstr <='9'){
 266   2                      temp[0] = *pstr - 0x30; 
 267   2              }
 268   1              if(*(pstr + 1) >= 'A' && *(pstr + 1) <='F'){//A-F
 269   2                      temp[1] = *(pstr + 1) - 0x37; 
 270   2              }
 271   1              else if(*(pstr + 1) >= '0' && *(pstr + 1) <='9'){
 272   2                      temp[1] = *(pstr + 1) - 0x30;   
 273   2              }
 274   1              hex = 0;
 275   1              hex |= temp[1] & 0xF;
 276   1              hex |= ((temp[0] << 4) & 0xF0);
 277   1              return hex;
 278   1      }
 279          
 280          static uint16_t asciiToUint16(uint8_t *pstr){
 281   1              data uint8_t temp[4];
 282   1              data uint16_t hex;
 283   1              //取出0xA000
 284   1              if(*pstr >= 'A' && *pstr <='F'){//A-F
 285   2                      temp[3] = *pstr - 0x37; 
 286   2              }
 287   1              else if(*pstr >= '0' && *pstr <='9'){
 288   2                      temp[3] = *pstr - 0x30; 
 289   2              }
 290   1              //取出0x0A00
 291   1              if(*(pstr + 1) >= 'A' && *(pstr + 1) <='F'){//A-F
 292   2                      temp[2] = *(pstr + 1) - 0x37; 
 293   2              }
 294   1              else if(*(pstr + 1) >= '0' && *(pstr + 1) <='9'){
 295   2                      temp[2] = *(pstr + 1) - 0x30;   
 296   2              }
 297   1              //取出0x00A0
 298   1              if(*pstr >= 'A' && *pstr <='F'){//A-F
 299   2                      temp[1] = *pstr - 0x37; 
 300   2              }
 301   1              else if(*pstr >= '0' && *pstr <='9'){
C51 COMPILER V9.59.0.0   BOOTLOADER                                                        12/11/2018 23:27:22 PAGE 6   

 302   2                      temp[1] = *pstr - 0x30; 
 303   2              }
 304   1              //取出0x000A
 305   1              if(*(pstr + 1) >= 'A' && *(pstr + 1) <='F'){//A-F
 306   2                      temp[0] = *(pstr + 1) - 0x37; 
 307   2              }
 308   1              else if(*(pstr + 1) >= '0' && *(pstr + 1) <='9'){
 309   2                      temp[0] = *(pstr + 1) - 0x30;   
 310   2              }
 311   1              hex = 0;
 312   1              hex |= temp[0] & 0x000F;
 313   1              hex |= ((temp[1] & 0x0F) << 4) & 0x00F0;
 314   1              hex |= ((temp[2] & 0x0F) << 8) & 0x0F00;
 315   1              hex |= ((temp[3] & 0x0F) << 12) & 0xF000;
 316   1              return hex;
 317   1      }
 318          static uint8_t LRC(uint8_t *buf, int32_t len){//计算LRC LRC方法是将消息中的8Bit的字节连续累加，丢弃了进位
 319   1              int i;
 320   1              uint8_t lrc = 0;        /*lrc字节初始化*/
 321   1              for( i = 0; i < len; i++ ){
 322   2                      lrc = lrc + buf[i];
 323   2              }
 324   1              return lrc;
 325   1      }
 326          void uart0Send(uint8_t *buf, uint16_t count){//串口0查询发送
 327   1              uint8_t *ptr = buf;
 328   1              do{
 329   2                  SBUF0 = *ptr++;
 330   2                      while(TI0 == 0);
 331   2                      TI0 = 0;
 332   2              }while(--count);
 333   1      }
 334          void uart0Receive(uint8_t *buf, uint16_t count){//串口0查询接收
 335   1              uint8_t * ptr = buf;
 336   1              do{
 337   2                      if(RI0 == 1)
 338   2                      {
 339   3                              *ptr++ = SBUF0;
 340   3                              RI0 = 0;
 341   3                              count--;
 342   3                      }
 343   2              }while(count);
 344   1      }
 345          uint8_t uart0ReceiveBootOrder(void){//串口0查询接收带超时
 346   1              uint8_t temp;
 347   1              uint32_t timeOutCounter;
 348   1      #if CONFIG_DEBUG == 1
 349   1              sprintf(CmdTxBuf,"Bootloader->Debug:Input 'C' Into Loader Mode\n");
 350   1              printf(CmdTxBuf);
 351   1      #endif
 352   1              timeOutCounter = 0;
 353   1              do{
 354   2                      if(RI0 == 1){
 355   3                              temp = SBUF0;
 356   3                              RI0 = 0;
 357   3                              if(temp == 'c')
 358   3                              {
 359   4      #if CONFIG_DEBUG == 1
 360   4                                      printf("Bootloader->Debug:BOOT_SELECT_LOADER\n");
 361   4      #endif
 362   4                                      return BOOT_SELECT_LOADER;
 363   4                              }
C51 COMPILER V9.59.0.0   BOOTLOADER                                                        12/11/2018 23:27:22 PAGE 7   

 364   3                      }
 365   2                      timeOutCounter ++;
 366   2              }while(timeOutCounter <= BOOT_SELECT_TIMEOUT);
 367   1      #if CONFIG_DEBUG == 1
 368   1              printf("Bootloader->Debug:BOOT_SELECT_OTA\n");
 369   1      #endif
 370   1              return BOOT_SELECT_OTA;
 371   1      }
 372          void CmdSetHwVer(void){//设置硬件版本
 373   1              uint16_t itemp;
 374   1              FlashEprom[EPROM_HW_VER] = asciiToUint8(CmdRxBuf + 2);
 375   1      #if CONFIG_DEBUG == 1
 376   1              itemp = FlashEprom[EPROM_HW_VER];
 377   1              printf("Bootloader->Debug->CMD_SET_HW_VER:%2X\n", itemp);
 378   1      #endif
 379   1              if(EEPROM_WriteBlock(EPROM_HW_VER, FlashEprom, 1) != EE_NO_ERROR){//从FLASH中读取OTA MD5值
 380   2                      CmdTxBuf[0] = CMD_STX;
 381   2                      CmdTxBuf[1] = CMD_SET_HW_VER;
 382   2                      CmdTxBuf[2] = CMD_RESPOND_FAIL;
 383   2                      CmdTxBuf[3] = CMD_END;  
 384   2              }
 385   1              else{
 386   2                      CmdTxBuf[0] = CMD_STX;
 387   2                      CmdTxBuf[1] = CMD_SET_HW_VER;
 388   2                      CmdTxBuf[2] = CMD_RESPOND_OK;
 389   2                      CmdTxBuf[3] = CMD_END;
 390   2              }
 391   1              uart0Send(CmdTxBuf, 4);
 392   1      }
 393          void CmdGetHwVer(void){//获取硬件版本
 394   1              uint8_t ctemp[2];
 395   1              uint16_t itemp;
 396   1              uint8ToAscii((FlashEprom + EPROM_HW_VER), ctemp);
 397   1              EEPROM_ReadBlock(EPROM_HW_VER, FlashEprom, 1);
 398   1      #if CONFIG_DEBUG == 1
 399   1              itemp = FlashEprom[EPROM_HW_VER];
 400   1              printf("Bootloader->Debug->CMD_GET_HW_VER:%2X\n", itemp);
 401   1      #endif
 402   1              CmdTxBuf[0] = CMD_STX;
 403   1              CmdTxBuf[1] = CMD_GET_HW_VER;
 404   1              CmdTxBuf[2] = ctemp[0];
 405   1              CmdTxBuf[3] = ctemp[1];
 406   1              CmdTxBuf[4] = CMD_END;
 407   1              uart0Send(CmdTxBuf, 5);
 408   1      }
 409          void CmdResetMcu(void){//强制复位
 410   1              RSTSRC |= (1 << 4);
 411   1      }
 412          void CmdGetBootLoaderVer(void){//获取BOOTLOADER版本
 413   1              uint8_t ctemp[2];
 414   1              uint16_t itemp;
 415   1              EEPROM_ReadBlock(EPROM_BOOT_VER, FlashEprom, 1);
 416   1              uint8ToAscii((FlashEprom + EPROM_BOOT_VER), ctemp);
 417   1      #if CONFIG_DEBUG == 1
 418   1              itemp = FlashEprom[EPROM_BOOT_VER];
 419   1              printf("Bootloader->Debug->CMD_GET_BOOT_VER:%2X\n", itemp);
 420   1      #endif
 421   1              CmdTxBuf[0] = CMD_STX;
 422   1              CmdTxBuf[1] = CMD_GET_BOOTLOADER_VER;
 423   1              CmdTxBuf[2] = ctemp[0];
 424   1              CmdTxBuf[3] = ctemp[1];
 425   1              CmdTxBuf[4] = CMD_END;  
C51 COMPILER V9.59.0.0   BOOTLOADER                                                        12/11/2018 23:27:22 PAGE 8   

 426   1              uart0Send(CmdTxBuf, 5);
 427   1      }
 428          void CmdSetBootLoaderVer(void){//设置Bootloader版本号
 429   1              uint16_t itemp;
 430   1              FlashEprom[EPROM_BOOT_VER] = asciiToUint8(CmdRxBuf + 2);
 431   1      #if CONFIG_DEBUG == 1
 432   1              itemp = FlashEprom[EPROM_BOOT_VER];
 433   1              printf("Bootloader->Debug->CMD_SET_BOOT_VER:%2X\n", itemp);
 434   1      #endif
 435   1              if(EEPROM_WriteBlock(EPROM_HW_VER, FlashEprom, 1) != EE_NO_ERROR){//从FLASH中读取OTA MD5值
 436   2                      CmdTxBuf[0] = CMD_STX;
 437   2                      CmdTxBuf[1] = CMD_SET_BOOTLOADER_VER;
 438   2                      CmdTxBuf[2] = CMD_RESPOND_FAIL;
 439   2                      CmdTxBuf[3] = CMD_END;  
 440   2              }
 441   1              else{
 442   2                      CmdTxBuf[0] = CMD_STX;
 443   2                      CmdTxBuf[1] = CMD_SET_BOOTLOADER_VER;
 444   2                      CmdTxBuf[2] = CMD_RESPOND_OK;
 445   2                      CmdTxBuf[3] = CMD_END;
 446   2              }
 447   1              uart0Send(CmdTxBuf, 4);
 448   1      }
 449          void CmdGetOTA1Ver(void){//获取OTA1版本号
 450   1              uint8_t ctemp[2];
 451   1              uint16_t itemp;
 452   1              EEPROM_ReadBlock(EPROM_OTA1_VER, FlashEprom, 1);
 453   1              uint8ToAscii((FlashEprom + EPROM_OTA1_VER), ctemp);
 454   1      #if CONFIG_DEBUG == 1
 455   1              itemp = FlashEprom[EPROM_OTA1_VER];
 456   1              printf("Bootloader->Debug->CMD_GET_OTA1_VER:%2X\n", itemp);
 457   1      #endif
 458   1              CmdTxBuf[0] = CMD_STX;
 459   1              CmdTxBuf[1] = CMD_GET_OTA1_VER;
 460   1              CmdTxBuf[2] = ctemp[0];
 461   1              CmdTxBuf[3] = ctemp[1];
 462   1              CmdTxBuf[4] = CMD_END;  
 463   1              uart0Send(CmdTxBuf, 5);
 464   1      }
 465          void CmdSetOTA1Ver(void){//设置OTA1版本号
 466   1              uint16_t itemp;
 467   1              FlashEprom[EPROM_OTA1_VER] = asciiToUint8(CmdRxBuf + 2);
 468   1      #if CONFIG_DEBUG == 1
 469   1              itemp = FlashEprom[EPROM_OTA1_VER];
 470   1              printf("Bootloader->Debug->CMD_SET_OTA1_VER:%2X\n", itemp);
 471   1      #endif
 472   1              if(EEPROM_WriteBlock(EPROM_OTA1_VER, FlashEprom, 1) != EE_NO_ERROR){//从FLASH中读取OTA MD5值
 473   2                      CmdTxBuf[0] = CMD_STX;
 474   2                      CmdTxBuf[1] = CMD_SET_OTA1_VER;
 475   2                      CmdTxBuf[2] = CMD_RESPOND_FAIL;
 476   2                      CmdTxBuf[3] = CMD_END;  
 477   2              }
 478   1              else{
 479   2                      CmdTxBuf[0] = CMD_STX;
 480   2                      CmdTxBuf[1] = CMD_SET_OTA1_VER;
 481   2                      CmdTxBuf[2] = CMD_RESPOND_OK;
 482   2                      CmdTxBuf[3] = CMD_END;
 483   2              }
 484   1              uart0Send(CmdTxBuf, 4);
 485   1      }
 486          void CmdGetOTA2Ver(void){//获取OTA2版本号
 487   1              uint8_t ctemp[2];
C51 COMPILER V9.59.0.0   BOOTLOADER                                                        12/11/2018 23:27:22 PAGE 9   

 488   1              uint16_t itemp;
 489   1              EEPROM_ReadBlock(EPROM_OTA2_VER, FlashEprom, 1);
 490   1              uint8ToAscii((FlashEprom + EPROM_OTA2_VER), ctemp);
 491   1      #if CONFIG_DEBUG == 1
 492   1              itemp = FlashEprom[EPROM_OTA2_VER];
 493   1              printf("Bootloader->Debug->CMD_GET_OTA2_VER:%2X\n", itemp);
 494   1      #endif
 495   1              CmdTxBuf[0] = CMD_STX;
 496   1              CmdTxBuf[1] = CMD_GET_OTA2_VER;
 497   1              CmdTxBuf[2] = ctemp[0];
 498   1              CmdTxBuf[3] = ctemp[1];
 499   1              CmdTxBuf[4] = CMD_END;  
 500   1              uart0Send(CmdTxBuf, 5);
 501   1      }
 502          void CmdSetOTA2Ver(void){//设置OTA2版本号
 503   1              uint16_t itemp;
 504   1              FlashEprom[EPROM_OTA2_VER] = asciiToUint8(CmdRxBuf + 2);
 505   1      #if CONFIG_DEBUG == 1
 506   1              itemp = FlashEprom[EPROM_OTA2_VER];
 507   1              printf("Bootloader->Debug->CMD_SET_OTA2_VER:%2X\n", itemp);
 508   1      #endif
 509   1              if(EEPROM_WriteBlock(EPROM_OTA2_VER, FlashEprom, 1) != EE_NO_ERROR){//从FLASH中读取OTA MD5值
 510   2                      CmdTxBuf[0] = CMD_STX;
 511   2                      CmdTxBuf[1] = CMD_SET_OTA2_VER;
 512   2                      CmdTxBuf[2] = CMD_RESPOND_FAIL;
 513   2                      CmdTxBuf[3] = CMD_END;  
 514   2              }
 515   1              else{
 516   2                      CmdTxBuf[0] = CMD_STX;
 517   2                      CmdTxBuf[1] = CMD_SET_OTA2_VER;
 518   2                      CmdTxBuf[2] = CMD_RESPOND_OK;
 519   2                      CmdTxBuf[3] = CMD_END;
 520   2              }
 521   1              uart0Send(CmdTxBuf, 4);
 522   1      }
 523          void CmdGetBootCrc(void){//获取BOOT CRC
 524   1              uint8_t ctemp[2];
 525   1              uint16_t itemp;
 526   1              EEPROM_ReadBlock(EPROM_BOOT_CRC, FlashEprom, 1);
 527   1              uint8ToAscii((FlashEprom + EPROM_BOOT_CRC), ctemp);
 528   1      #if CONFIG_DEBUG == 1
 529   1              itemp = FlashEprom[EPROM_BOOT_CRC];
 530   1              printf("Bootloader->Debug->CMD_GET_BOOT_CRC:%2X\n", itemp);
 531   1      #endif  
 532   1              CmdTxBuf[0] = CMD_STX;
 533   1              CmdTxBuf[1] = CMD_GET_BOOT_CRC;
 534   1              CmdTxBuf[2] = ctemp[0];
 535   1              CmdTxBuf[3] = ctemp[1];
 536   1              CmdTxBuf[4] = CMD_END;  
 537   1              uart0Send(CmdTxBuf, 5);
 538   1      }
 539          void CmdGetOTA1Crc(void){//获取OTA1 CRC
 540   1              uint8_t ctemp[2];
 541   1              uint16_t itemp;
 542   1              EEPROM_ReadBlock(EPROM_OTA1_CRC, FlashEprom, 1);
 543   1              uint8ToAscii((FlashEprom + EPROM_OTA1_CRC), ctemp);
 544   1      #if CONFIG_DEBUG == 1
 545   1              itemp = FlashEprom[EPROM_OTA1_CRC];
 546   1              printf("Bootloader->Debug->CMD_GET_OTA1_CRC:%2X\n", itemp);
 547   1      #endif
 548   1              CmdTxBuf[0] = CMD_STX;
 549   1              CmdTxBuf[1] = CMD_GET_OTA1_CRC;
C51 COMPILER V9.59.0.0   BOOTLOADER                                                        12/11/2018 23:27:22 PAGE 10  

 550   1              CmdTxBuf[2] = ctemp[0];
 551   1              CmdTxBuf[3] = ctemp[1];
 552   1              CmdTxBuf[4] = CMD_END;  
 553   1              uart0Send(CmdTxBuf, 5);
 554   1      }
 555          void CmdGetOTA2Crc(void){//获取OTA2 CRC
 556   1              uint8_t ctemp[2];
 557   1              uint16_t itemp;
 558   1              EEPROM_ReadBlock(EPROM_OTA2_CRC, FlashEprom, 1);
 559   1              uint8ToAscii((FlashEprom + EPROM_OTA2_CRC), ctemp);
 560   1      #if CONFIG_DEBUG == 1
 561   1              itemp = FlashEprom[EPROM_OTA2_CRC];
 562   1              printf("Bootloader->Debug->CMD_GET_OTA2_CRC:%2X\n", itemp);
 563   1      #endif
 564   1              CmdTxBuf[0] = CMD_STX;
 565   1              CmdTxBuf[1] = CMD_GET_OTA2_CRC;
 566   1              CmdTxBuf[2] = ctemp[0];
 567   1              CmdTxBuf[3] = ctemp[1];
 568   1              CmdTxBuf[4] = CMD_END;  
 569   1              uart0Send(CmdTxBuf, 5);
 570   1      }
 571          void CmdReadFlashPage(void){//读取FLASH指定页
 572   1              uint16_t i;
 573   1              uint32_t adr, crc;
 574   1              uint8_t temp, page;
 575   1              page = asciiToUint8(CmdRxBuf + 2);
 576   1              if(page > (FW_BOOT_ADR_END / FL_PAGE_SIZE) && (page < (FLASH_TEMP / FL_PAGE_SIZE)))
 577   1              {       
 578   2                      adr = (uint32_t)(page - 1) * FL_PAGE_SIZE;
 579   2                      crc32Clear();crc = 0;
 580   2                      CmdTxBuf[0] = CMD_STX;
 581   2                      CmdTxBuf[1] = CMD_READ_FLASH_PAGE;
 582   2                      uint8ToAscii(&page, (CmdTxBuf + 2));
 583   2                      for(i = 0;i < FL_PAGE_SIZE;i ++){
 584   3                              FLASH_Read (&temp, (adr + i), 1);//读取FLSAH
 585   3                              crc = crc32CalculateAdd(temp);
 586   3                              uint8ToAscii(&temp, (CmdTxBuf + 4 + (i * 2)));
 587   3                      }
 588   2                      uint32ToAscii(&crc, (CmdTxBuf + 4 + 1024));
 589   2                      CmdTxBuf[1032] = CMD_END;       
 590   2                      uart0Send(CmdTxBuf, 1033);
 591   2              }
 592   1              else{
 593   2                      CmdTxBuf[0] = CMD_STX;
 594   2                      CmdTxBuf[1] = CMD_READ_FLASH_PAGE;
 595   2                      uint8ToAscii(&page, (CmdTxBuf + 2));
 596   2                      CmdTxBuf[4] = CMD_RESPOND_FAIL;
 597   2                      CmdTxBuf[5] = CMD_END;  
 598   2                      uart0Send(CmdTxBuf, 6);
 599   2              }
 600   1      }
 601          void CmdClearFlashPage(void){//清除FLASH指定页
 602   1              uint32_t adr;
 603   1              uint8_t page;
 604   1              page = asciiToUint8(CmdRxBuf + 2);
 605   1              if(page > (FW_BOOT_ADR_END / FL_PAGE_SIZE) && (page < (FLASH_TEMP / FL_PAGE_SIZE))){    
 606   2                      adr = (uint32_t)(page - 1) * FL_PAGE_SIZE;
 607   2                      FLASH_Clear (adr, FL_PAGE_SIZE);
 608   2                      CmdTxBuf[0] = CMD_STX;
 609   2                      CmdTxBuf[1] = CMD_CLEAR_FLASH_PAGE;
 610   2                      uint8ToAscii(&page, (CmdTxBuf + 2));
 611   2                      CmdTxBuf[4] = CMD_RESPOND_OK;
C51 COMPILER V9.59.0.0   BOOTLOADER                                                        12/11/2018 23:27:22 PAGE 11  

 612   2                      CmdTxBuf[5] = CMD_END;  
 613   2                      uart0Send(CmdTxBuf, 6);
 614   2              }
 615   1              else{
 616   2                      CmdTxBuf[0] = CMD_STX;
 617   2                      CmdTxBuf[1] = CMD_CLEAR_FLASH_PAGE;
 618   2                      uint8ToAscii(&page, (CmdTxBuf + 2));
 619   2                      CmdTxBuf[4] = CMD_RESPOND_FAIL;
 620   2                      CmdTxBuf[5] = CMD_END;  
 621   2                      uart0Send(CmdTxBuf, 6);
 622   2              }
 623   1      }
 624          void CmdWriteFlashPage(void){//写入FLASH指定页
 625   1              uint32_t adr, crc0, crc1;
 626   1              uint8_t page, dat;
 627   1              uint16_t i;
 628   1              page = asciiToUint8(CmdRxBuf + 2);
 629   1              adr = page * FL_PAGE_SIZE;
 630   1              uint32ToAscii(&crc0, (CmdTxBuf + 4 + 1024));//接收到的CRC32值
 631   1              for(i = 0;i < FL_PAGE_SIZE;i ++){
 632   2                      *(TempBuf + i) = asciiToUint8(CmdRxBuf + 2 + (i * 2));
 633   2              }
 634   1              crc32Clear();
 635   1              crc1 = crc32Calculate(TempBuf, FL_PAGE_SIZE);
 636   1              if(page > (FW_BOOT_ADR_END / FL_PAGE_SIZE) && (page < (FLASH_TEMP / FL_PAGE_SIZE)) && crc0 == crc1){    
 637   2                      FLASH_Write(adr, TempBuf, FL_PAGE_SIZE);
 638   2                      CmdTxBuf[0] = CMD_STX;
 639   2                      CmdTxBuf[1] = CMD_WRITE_FLASH_PAGE;
 640   2                      uint8ToAscii(&page, (CmdTxBuf + 2));
 641   2                      CmdTxBuf[4] = CMD_RESPOND_OK;
 642   2                      CmdTxBuf[5] = CMD_END;  
 643   2                      uart0Send(CmdTxBuf, 6);
 644   2              }
 645   1              else{
 646   2                      CmdTxBuf[0] = CMD_STX;
 647   2                      CmdTxBuf[1] = CMD_WRITE_FLASH_PAGE;
 648   2                      uint8ToAscii(&page, (CmdTxBuf + 2));
 649   2                      CmdTxBuf[4] = CMD_RESPOND_FAIL;
 650   2                      CmdTxBuf[5] = CMD_END;  
 651   2                      uart0Send(CmdTxBuf, 6);
 652   2              }
 653   1      }
*** WARNING C280 IN LINE 626 OF Bootloader\Bootloader.c: 'dat': unreferenced local variable
 654          void loaderCmdPoll(void){//串口命令轮询
 655   1              uint8_t *ptr, *ptw;
 656   1              uart0Send("C", 1);
 657   1              while(1){
 658   2                      ptr = CmdRxBuf;
 659   2                      uart0Receive(ptr, 1);
 660   2                      if(*ptr == CMD_STX){
 661   3                              ptr ++;
 662   3                              do{
 663   4                                      uart0Receive(ptr, 1);
 664   4                                      if(*ptr == CMD_END)
 665   4                                      {
 666   5                                              switch(CmdRxBuf[1])
 667   5                                              {
 668   6                                                      case CMD_SET_HW_VER://1
 669   6                                                      {
 670   7                                                              CmdSetHwVer();
 671   7                                                              break;
 672   7                                                      }
C51 COMPILER V9.59.0.0   BOOTLOADER                                                        12/11/2018 23:27:22 PAGE 12  

 673   6                                                      case CMD_GET_HW_VER://2
 674   6                                                      {
 675   7                                                              CmdGetHwVer();
 676   7                                                              break;
 677   7                                                      }
 678   6                                                      case CMD_RESET_MCU://3
 679   6                                                      {
 680   7                                                              CmdResetMcu();
 681   7                                                              break;
 682   7                                                      }
 683   6                                                      case CMD_GET_BOOTLOADER_VER://4
 684   6                                                      {
 685   7                                                              CmdGetBootLoaderVer();
 686   7                                                              break;
 687   7                                                      }
 688   6                                                      case CMD_GET_OTA1_VER://5
 689   6                                                      {
 690   7                                                              CmdGetOTA1Ver();
 691   7                                                              break;
 692   7                                                      }
 693   6                                                      case CMD_GET_OTA2_VER://6
 694   6                                                      {
 695   7                                                              CmdGetOTA2Ver();
 696   7                                                              break;
 697   7                                                      }
 698   6                                                      case CMD_SET_BOOTLOADER_VER://7
 699   6                                                      {
 700   7                                                              CmdSetBootLoaderVer();
 701   7                                                              break;
 702   7                                                      }
 703   6                                                      case CMD_SET_OTA1_VER://8
 704   6                                                      {
 705   7                                                              CmdSetOTA1Ver();
 706   7                                                              break;
 707   7                                                      }
 708   6                                                      case CMD_SET_OTA2_VER://9
 709   6                                                      {
 710   7                                                              CmdSetOTA2Ver();
 711   7                                                              break;
 712   7                                                      }                                                       
 713   6                                                      case CMD_GET_OTA1_CRC://A
 714   6                                                      {
 715   7                                                              CmdGetOTA1Crc();
 716   7                                                              break;
 717   7                                                      }
 718   6                                                      case CMD_GET_OTA2_CRC://B
 719   6                                                      {
 720   7                                                              CmdGetOTA2Crc();
 721   7                                                              break;
 722   7                                                      }
 723   6                                                      case CMD_WRITE_FLASH_PAGE://C
 724   6                                                      {
 725   7                                                              CmdWriteFlashPage();
 726   7                                                              break;
 727   7                                                      }
 728   6                                                      case CMD_READ_FLASH_PAGE://D
 729   6                                                      {
 730   7                                                              CmdReadFlashPage();
 731   7                                                              break;
 732   7                                                      }
 733   6                                                      case CMD_CLEAR_FLASH_PAGE://E
 734   6                                                      {
C51 COMPILER V9.59.0.0   BOOTLOADER                                                        12/11/2018 23:27:22 PAGE 13  

 735   7                                                              CmdClearFlashPage();
 736   7                                                              break;
 737   7                                                      }
 738   6                                                      case CMD_GOTO_OTA1://F
 739   6                                                      {
 740   7                                                              OTA1_Program();
 741   7                                                              break;
 742   7                                                      }
 743   6                                                      case CMD_GOTO_OTA2://G
 744   6                                                      {
 745   7                                                              OTA2_Program();
 746   7                                                              break;
 747   7                                                      }
 748   6                                                      default:break;
 749   6                                              }
 750   5                                              break;
 751   5                                      }
 752   4                                      else if(ptr >= (CmdRxBuf + CMD_RX_BUFFER_SIZE)){
 753   5                                              NOP();
 754   5                                              break;
 755   5                                      }
 756   4                                      ptr ++;
 757   4                              }while(1);
 758   3                      }
 759   2              }
 760   1      }
*** WARNING C280 IN LINE 655 OF Bootloader\Bootloader.c: 'ptw': unreferenced local variable
 761          
 762          void bootSequence(void){//启动顺序选择
 763   1              data uint32_t ota1Crc32, ota2Crc32;
 764   1              //开始计时器
 765   1              data uint8_t temp;
 766   1              temp = uart0ReceiveBootOrder();
 767   1              if(temp == BOOT_SELECT_OTA)
 768   1              {
 769   2                      if(FlashEprom[EPROM_BOOT_ORDER] == SELECT_BOOT_OTA1)
 770   2                      {//启动顺序选择BOOT_OTA1
 771   3                              ota1Crc32 = ota1FlashCrc();
 772   3                              if(ota1Crc32 == FlashEprom[EPROM_OTA1_CRC])
 773   3                              {
 774   4                                      OTA1_Program = (void code *)(FW_OTA1_ADR_START & 0x1FFFF);//获取OTA1起始地址
 775   4                                      OTA1_Program();//执行应用程序
 776   4                              }
 777   3                      }
 778   2                      else if(FlashEprom[EPROM_BOOT_ORDER] == SELECT_BOOT_OTA2)
 779   2                      {//启动顺序选择BOOT_OTA2
 780   3                              if(ota2Crc32 == FlashEprom[EPROM_OTA2_CRC])
 781   3                              {
 782   4                                      OTA2_Program = (void code *)(FW_OTA2_ADR_START & 0x1FFFF);//获取OTA2起始地址
 783   4                                      OTA2_Program();//执行应用程序
 784   4                              }       
 785   3                      }
 786   2                      else{
 787   3      #if CONFIG_DEBUG == 1
 788   3                              printf("Bootloader->Debug:OTA CRC32 Check Fail,Into Loader Mode\n");
 789   3      #endif
 790   3                              loaderCmdPoll();
 791   3                      }       
 792   2              }
 793   1              else if(temp == BOOT_SELECT_LOADER)
 794   1              {
 795   2                      while(1)
C51 COMPILER V9.59.0.0   BOOTLOADER                                                        12/11/2018 23:27:22 PAGE 14  

 796   2                      {
 797   3                              loaderCmdPoll();
 798   3                      }
 799   2              }       
 800   1      }
 801          uint32_t bootFlashCrc(void){//BOOT CRC32校验    
 802   1              data uint32_t crc = 0, i;
 803   1              data uint8_t temp;
 804   1              
 805   1              crc32Clear();//CRC32清除
 806   1              for(i = FW_BOOT_ADR_START;i < FW_BOOT_ADR_END;i ++)
 807   1              {//计算BOOT CRC32
 808   2                      FLASH_Read(&temp, i, 1);
 809   2                      crc = crc32CalculateAdd(temp);
 810   2              }
 811   1              return crc;
 812   1      }
 813          uint32_t ota1FlashCrc(void){//OTA1 CRC32校验
 814   1              data uint32_t crc = 0 ,i;
 815   1              data uint8_t temp;
 816   1              crc32Clear();//CRC32清除
 817   1              for(i = FW_OTA1_ADR_START;i < FW_OTA1_ADR_END;i ++)
 818   1              {//计算OTA1 CRC32
 819   2                      FLASH_Read(&temp, i, 1);
 820   2                      crc = crc32CalculateAdd(temp);
 821   2              }
 822   1              return crc;
 823   1      }
 824          uint32_t ota2FlashCrc(void){//OTA2 CRC32校验
 825   1              data uint32_t crc = 0, i;
 826   1              data uint8_t temp;
 827   1              for(i = FW_OTA2_ADR_START;i < FW_OTA2_ADR_END;i ++)
 828   1              {//计算OTA2 CRC32
 829   2                      FLASH_Read(&temp, i, 1);
 830   2                      crc = crc32CalculateAdd(temp);
 831   2              }
 832   1              return crc;
 833   1      }
 834          
 835          void main (void) 
 836          {
 837   1              Init_Device();
 838   1      #if CONFIG_DEBUG == 1
 839   1              printf("Bootloader->Debug:Hello C8051 Bootloader\n");
 840   1      #endif
 841   1              bootSequence();
 842   1              while(1);
 843   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3784    ----
   CONSTANT SIZE    =    667    ----
   XDATA SIZE       =   2776    ----
   PDATA SIZE       =      9      94
   DATA SIZE        =   ----      60
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
C51 COMPILER V9.59.0.0   BOOTLOADER                                                        12/11/2018 23:27:22 PAGE 15  

END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  2 WARNING(S),  0 ERROR(S)
