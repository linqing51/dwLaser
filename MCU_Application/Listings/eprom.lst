C51 COMPILER V9.59.0.0   EPROM                                                             12/22/2018 00:39:03 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE EPROM
OBJECT MODULE PLACED IN .\Objects\eprom.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Driver\eprom.c COMPACT OPTIMIZE(8,SPEED) REGFILE(.\Objects\dwLaser_F020.
                    -ORC) BROWSE ORDER INCDIR(.\Lib;.\Driver;.\MainApp;.\Modbus) DEFINE(C8051F020) DEBUG OBJECTEXTEND PRINT(.\Listings\eprom.
                    -lst) PREPRINT(.\Listings\eprom.i) OBJECT(.\Objects\eprom.obj)

line level    source

   1          #include "eprom.h"
   2          /*****************************************************************************/
   3          
   4          /*****************************************************************************/
   5          void epromInit(void){//³õÊ¼»¯IIC½Ó¿Ú
   6   1              iic0Init();
   7   1      }
   8          
   9          uint8_t epromReadOneByte(uint16_t ReadAddr){//ÔÚAT24CXXÖ¸¶¨µØÖ·¶Á³öÒ»¸öÊý¾Ý
  10   1      //ReadAddr:¿ªÊ¼¶ÁÊýµÄµØÖ·  
  11   1      //·µ»ØÖµ  :¶Áµ½µÄÊý¾Ý                             
  12   1              uint8_t temp=0;                                                                                                                                                  
  13   1              iic0Start();  
  14   1      #if CONFIG_EPROM_SIZE > CONFIG_AT24C16_SIZE
  15   1      //¼æÈÝ24CxxÖÐÆäËûµÄ°æ±¾
  16   1              iic0SendByte(((CONFIG_EPROM_ADDRESS << 1) & 0xFE));//·¢ËÍÐ´ÃüÁî
  17   1              iic0WaitAck();
  18   1              iic0SendByte(ReadAddr >> 8);//·¢ËÍ¸ßµØÖ·                 
  19   1      #else 
                      iic0SendByte(((CONFIG_EPROM_ADDRESS << 1) & 0xFE) + ((ReadAddr / 256) << 1));//·¢ËÍÆ÷¼þµØÖ·0XA0,Ð´Êý¾Ý   
              #endif
  22   1              iic0WaitAck(); 
  23   1              iic0SendByte(ReadAddr % 256);   //·¢ËÍµÍµØÖ·
  24   1              iic0WaitAck();      
  25   1              iic0Start();               
  26   1              iic0SendByte(((CONFIG_EPROM_ADDRESS << 1) | 0x01));//½øÈë½ÓÊÕÄ£Ê½                          
  27   1              iic0WaitAck();   
  28   1              temp = iic0ReadByte(0);//¶ÁÒ»¸ö×Ö½Ú£¬·ÇÓ¦´ðÐÅºÅÐÅºÅ        
  29   1              iic0Stop();        //²úÉúÒ»¸öÍ£Ö¹Ìõ¼þ       
  30   1              return temp;
  31   1      }
  32          
  33          void epromWriteOneByte(uint16_t WriteAddr, uint8_t DataToWrite){//ÔÚAT24CXXÖ¸¶¨µØÖ·Ð´ÈëÒ»¸öÊý¾Ý
  34   1      //WriteAddr  :Ð´ÈëÊý¾ÝµÄÄ¿µÄµØÖ·    
  35   1      //DataToWrite:ÒªÐ´ÈëµÄÊý¾Ý                                                                                                                                                                               
  36   1              iic0Start();  
  37   1      #if CONFIG_EPROM_SIZE > CONFIG_AT24C16_SIZE
  38   1              iic0SendByte(((CONFIG_EPROM_ADDRESS << 1) & 0xFE));         //·¢ËÍÐ´ÃüÁî
  39   1              iic0WaitAck();
  40   1              iic0SendByte(WriteAddr >> 8);    //·¢ËÍ¸ßµØÖ·
  41   1      #else
                      iic0SendByte(((CONFIG_EPROM_ADDR << 1) & 0xFE) +( (WriteAddr / 256) << 1));   //·¢ËÍÆ÷¼þµØÖ·0XA0,Ð´Êý¾Ý 
              #endif 
  44   1              iic0WaitAck();     
  45   1              iic0SendByte(WriteAddr % 256);   //·¢ËÍµÍµØÖ·
  46   1              iic0WaitAck();                                                                                                     
  47   1              iic0SendByte(DataToWrite);     //·¢ËÍ×Ö½Ú                                                          
  48   1              iic0WaitAck();                             
  49   1              iic0Stop();//²úÉúÒ»¸öÍ£Ö¹Ìõ¼þ 
  50   1      #if CONFIG_EPROM_FRAM != 1
  51   1              delayMs(10);     
  52   1      #endif
  53   1      }
C51 COMPILER V9.59.0.0   EPROM                                                             12/22/2018 00:39:03 PAGE 2   

  54          
  55          void epromWriteLenByte(uint16_t WriteAddr, uint32_t DataToWrite, uint8_t Len){//ÔÚAT24CXXÀïÃæµÄÖ¸¶¨µØÖ·¿ªÊ
             -¼Ð´Èë³¤¶ÈÎªLenµÄÊý¾Ý
  56   1      //¸Ãº¯ÊýÓÃÓÚÐ´Èë16bit»òÕß32bitµÄÊý¾Ý.
  57   1      //WriteAddr  :¿ªÊ¼Ð´ÈëµÄµØÖ·  
  58   1      //DataToWrite:Êý¾ÝÊý×éÊ×µØÖ·
  59   1      //Len        :ÒªÐ´ÈëÊý¾ÝµÄ³¤¶È2,4       
  60   1              uint8_t t;
  61   1              for(t = 0;t < Len;t ++){
  62   2                      epromWriteOneByte(WriteAddr + t, (DataToWrite >> (8 * t)) & 0xff);
  63   2              }                                                                                                   
  64   1      }
  65          uint32_t epromReadLenByte(uint16_t ReadAddr, uint8_t Len){//ÔÚAT24CXXÀïÃæµÄÖ¸¶¨µØÖ·¿ªÊ¼¶Á³ö³¤¶ÈÎªLenµÄÊý¾Ý
  66   1      //¸Ãº¯ÊýÓÃÓÚ¶Á³ö16bit»òÕß32bitµÄÊý¾Ý.
  67   1      //ReadAddr   :¿ªÊ¼¶Á³öµÄµØÖ· 
  68   1      //·µ»ØÖµ     :Êý¾Ý
  69   1      //Len        :Òª¶Á³öÊý¾ÝµÄ³¤¶È2,4       
  70   1              uint8_t t;
  71   1              uint32_t temp=0;
  72   1              for(t = 0;t < Len;t ++){
  73   2                      temp <<= 8;
  74   2                      temp += epromReadOneByte(ReadAddr + Len - t - 1);                                          
  75   2              }
  76   1              return temp;                                                                                                
  77   1      }
  78               
  79          void epromRead(uint16_t ReadAddr,uint8_t *pBuffer,uint16_t NumToRead){//ÔÚAT24CXXÀïÃæµÄÖ¸¶¨µØÖ·¿ªÊ¼¶Á³öÖ¸¶
             -¨¸öÊýµÄÊý¾Ý
  80   1      //ReadAddr :¿ªÊ¼¶Á³öµÄµØÖ· ¶Ô24c02Îª0~255
  81   1      //pBuffer  :Êý¾ÝÊý×éÊ×µØÖ·
  82   1      //NumToRead:Òª¶Á³öÊý¾ÝµÄ¸öÊý
  83   1              while(NumToRead)
  84   1              {
  85   2                      *pBuffer++ = epromReadOneByte(ReadAddr ++);     
  86   2                      NumToRead --;
  87   2              }
  88   1      }  
  89          void epromWrite(uint16_t WriteAddr, uint8_t *pBuffer, uint16_t NumToWrite){//ÔÚAT24CXXÀïÃæµÄÖ¸¶¨µØÖ·¿ªÊ¼Ð´
             -ÈëÖ¸¶¨¸öÊýµÄÊý¾Ý
  90   1      //WriteAddr :¿ªÊ¼Ð´ÈëµÄµØÖ· ¶Ô24c02Îª0~255
  91   1      //pBuffer   :Êý¾ÝÊý×éÊ×µØÖ·
  92   1      //NumToWrite:ÒªÐ´ÈëÊý¾ÝµÄ¸öÊý
  93   1              while(NumToWrite --)
  94   1              {
  95   2                      epromWriteOneByte(WriteAddr, *pBuffer);
  96   2                      WriteAddr ++;
  97   2                      pBuffer ++;
  98   2              }
  99   1      }
 100          void epromTest(void){//EPROM ¶ÁÐ´×Ô²âÊÔ
 101   1              uint8_t temp;
 102   1              uint32_t i, j, crc32Src, crc32Dist;
 103   1              
 104   1              crc32Clear();
 105   1              for(i = 0;i < CONFIG_EPROM_SIZE;i ++){
 106   2                      temp = rand() % 255;
 107   2                      crc32Src = crc32CalculateAdd(temp);
 108   2                      epromWriteOneByte(i, temp);
 109   2              }
 110   1              crc32Clear();
 111   1              for(i = 0;i < CONFIG_EPROM_SIZE;i ++){
 112   2                      temp = epromReadOneByte(i);
C51 COMPILER V9.59.0.0   EPROM                                                             12/22/2018 00:39:03 PAGE 3   

 113   2                      crc32Dist = crc32CalculateAdd(temp);
 114   2              }
 115   1              if(crc32Src == crc32Dist)
 116   1                      printf("EPROM:Self Test Loop %d OK\n", j);
 117   1              else
 118   1                      printf("EPROM:Self Test Loop %d Fail\n", j);
 119   1      
 120   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    772    ----
   CONSTANT SIZE    =     58    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----      47
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
