C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE SPLC
OBJECT MODULE PLACED IN .\Objects\sPlc.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE MainApp\sPlc.c OPTIMIZE(9,SPEED) REGFILE(.\Objects\dwLaser_F020.ORC) BRO
                    -WSE ORDER INCDIR(.\Lib;.\Driver;.\MainApp;.\Modbus) DEFINE(C8051F020) DEBUG OBJECTEXTEND CODE LISTINCLUDE SYMBOLS PRINT(
                    -.\Listings\sPlc.lst) PREPRINT(.\Listings\sPlc.i) OBJECT(.\Objects\sPlc.obj)

line level    source

   1          #include "sPlc.h"
   1      =1  #ifndef __SPLC_H__
   2      =1  #define __SPLC_H__
   3      =1  /*****************************************************************************/
   4      =1  #include "appConfig.h"
   1      =2  #ifndef __APPCONFIG_H__
   2      =2  #define __APPCONFIG_H__
   3      =2  /*****************************************************************************/
   4      =2  #define CONFIG_SYSCLK                       (22118400L)
   5      =2  #ifdef C8051F020
   6      =2  #define SAR_CLK                                                 2000000L//ADC0时钟 <2.5MHz
   7      =2  #endif
   8      =2  #define CONFIG_DEBUG                        0//调试功能
   9      =2  #define CONFIG_USING_WDT                                        0//使能看门狗
  10      =2  #define CONFIG_USING_RESET                                      0//使能PLC复位MCU功能
  11      =2  #define CONFIG_LADDER_SECTORS_START                     64//指令起始地址
  12      =2  #define CONFIG_LADDER_SECTORS_END                       128//指令结束地址
  13      =2  #define CONFIG_LASERTIMER_OVERFLOW_US           1000L//定时器周期 1mS
  14      =2  #define CONFIG_VERSION                                          0x0001
  15      =2  #define CONFIG_CHECK_CODE                                       0x5A00
  16      =2  
  17      =2  /*****************************************************************************/
  18      =2  #define CONFIG_UART0_BAUDRATE                           57600//串口波特率
  19      =2  #define CONFIG_UART0_PARITY                                     NONE
  20      =2  #define CONFIG_UART0_STOPBIT                            1
  21      =2  #define CONFIG_UART0_DATABIT                            8
  22      =2  
  23      =2  #define CONFIG_UART1_BAUDRATE                           115200//串口波特率
  24      =2  #define CONFIG_UART1_PARITY                                     NONE
  25      =2  #define CONFIG_UART1_STOPBIT                            1
  26      =2  #define CONFIG_UART1_DATABIT                            8
  27      =2  /*****************************************************************************/
  28      =2  #define CONFIG_I2C0_FREQ                                        (100000L)               
  29      =2  #define CONFIG_I2C1_FREQ                                        (100000L)
  30      =2  #define CONFIG_I2C2_FREQ                                        (100000L)
  31      =2  #define CONFIG_I2C3_FREQ                                        (100000L)
  32      =2  #define CONFIG_I2C4_FREQ                                        (100000L)
  33      =2  /*****************************************************************************/
  34      =2  #define CONFIG_EPROM_SIZE                                       CONFIG_AT24C64_SIZE
  35      =2  #define CONFIG_AT24C02_SIZE                             256
  36      =2  #define CONFIG_AT24C04_SIZE                             512
  37      =2  #define CONFIG_AT24C08_SIZE                             1024
  38      =2  #define CONFIG_AT24C16_SIZE                             2048
  39      =2  #define CONFIG_AT24C32_SIZE                             4096
  40      =2  #define CONFIG_AT24C64_SIZE                                     8192
  41      =2  #define CONFIG_AT24C128_SIZE                            16384
  42      =2  #define CONFIG_AT24C256_SIZE                            32768
  43      =2  #define CONFIG_EPROM_ADDRESS                            0x50
  44      =2  #define CONFIG_EPROM_FRAM                                       0//铁电存储体无写入等待
  45      =2  #define CONFIG_EPROM_FREQ                                       1//
  46      =2  /*****************************************************************************/
  47      =2  #define CONFIG_USE_IPID                                         1//使能IPID温度控制
  48      =2  /*****************************************************************************/
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 2   

  49      =2  #define CONFIG_USE_HWVER_SHOW                           1//使能固件版本显示
  50      =2  #define CONFIG_USE_MPD1_SHOW                            1//使能MPD1测量显示
  51      =2  #define CONFIG_USE_MPD2_SHOW                            1//使能MPD2测量显示
  52      =2  #define CONFIG_USE_FBS1                                         1//使能FBS1检测
  53      =2  #define CONFIG_USE_FBS2                                         1//使能FBS2检测
  54      =2  #define CONFIG_USE_LASER_TEMP                           1//使能激光器温度显示
  55      =2  #define CONFIG_USE_RADIATOR_TEMP                        1//使能散热器温度显示
  56      =2  #define CONFIG_USE_ENVI_TEMP                            1//使能环境温度显示
  57      =2  #define CONFIG_USE_IPID_UPDATE                          1//使能IPID参数更新功能
  58      =2  #define CONFIG_USE_IPID_OUTSHOW                         1//使能IPID输出显示
  59      =2  /*****************************************************************************/
  60      =2  //SPLC设置
  61      =2  #define CONFIG_SPLC_IO_INPUT_NUM                        16//硬件输入点数
  62      =2  #define CONFIG_SPLC_IO_OUTPUT_NUM                       16//硬件输出点数
  63      =2  #define CONFIG_SOFTPLC_HWTIME                           1000L//1mS
  64      =2  #define CONFIG_INPUT_FILTER_TIME                        3//输入数字滤波扫描周期 1mS * N
  65      =2  #define CONFIG_IPID_RUN_CYCLE                           40//IPID运行周期 默认 40 * 100mS
  66      =2  #define CONFIG_IPID_PWM_CYCLE                           20//IPID输出周期 默认 20 * 100mS
  67      =2  /*****************************************************************************/
  68      =2  #define CONFIG_SPLC_USING_WDT                           0//看门狗启用
  69      =2  /*****************************************************************************/
  70      =2  #define CONFIG_SPLC_USING_IO_INPUT                      1//输入IO刷新启用
  71      =2  /*****************************************************************************/
  72      =2  #define CONFIG_SPLC_USING_IO_OUTPUT                     1//输出IO刷新启用
  73      =2  /*****************************************************************************/
  74      =2  #define CONFIG_SPLC_USING_EPROM                         0//EPROM掉电存储启用
  75      =2  /*****************************************************************************/
  76      =2  #define CONFIG_SPLC_USING_ADC                           0//使能ADC模块
  77      =2  #define CONFIG_SPLC_ADC_FILTER_TAP                      48//ADC位移滤波次数
  78      =2  #define CONFIG_SPLC_ADC_CHANNLE                         9//ADC通道数
  79      =2  #define CONFIG_SPLC_ADC_TEMP_SENSOR_GAIN    3330L// Temp Sensor Gain in (uV / degC)
  80      =2  #define CONFIG_SPLC_ADC_TEMP_SENSOR_OFFSET  856L// Temp Sensor Offset in mV
  81      =2  #define CONFIG_SPLC_ADC_INTERNAL_VREF           2200L// ADC Voltage Reference (mV)
  82      =2  #define CONFIG_SPLC_ADC_AMBIENT             25L// Ambient temp in deg C
  83      =2  /*****************************************************************************/
  84      =2  #define CONFIG_SPLC_USING_DAC                           1//是能DAC模块
  85      =2  /*****************************************************************************/
  86      =2  #define CONFIG_SPLC_USING_MB_RTU_SLAVE          1//是能MODBUS RTU从站
  87      =2  #define CONFIG_MB_RTU_SLAVE_TIMER                       1000L//1000uS
  88      =2  #define CONFIG_MB_RTU_SLAVE_ADDRESS                     0x01//从设备地址
  89      =2  #define CONFIG_MB_RTU_SLAVE_BUFFER_SIZE         256//发送接收缓冲区
  90      =2  #define CONFIG_MB_RTU_SLAVE_TIMEOUT                     100//接收通讯超时 10mS
  91      =2  #define CONFIG_MB_RTU_SLAVE_IO_DELAY            1//RX TX切换延时
  92      =2  /*****************************************************************************/
  93      =2  
  94      =2  /*****************************************************************************/
  95      =2  #define ID_ONLY_1_CHANNEL                                       4321
  96      =2  #define ID_ONLY_2_CHANNEL                                       8765
  97      =2  #define ID_BOTH_CHANNEL                                         9431
  98      =2  #define ID_LASER_MODE_CW                                        7631
  99      =2  #define ID_LASER_MODE_SP                                        8934
 100      =2  #define ID_LASER_MODE_MP                                        2453
 101      =2  #define ID_LASER_MODE_GP                                        3876
 102      =2  /*****************************************************************************/
 103      =2  #define FBS1_IN_PORT                                            3
 104      =2  #define FBS2_IN_PORT                                            2
 105      =2  #define COOLON_OUT_PORT                                         (1 * 8 + 3)
 106      =2  /*****************************************************************************/
 107      =2  //PID FUZZY 模糊PID配置
 108      =2  #define CONFIG_TECOUT_CYCLE                                     4000//PID输出转PWM周期
 109      =2  /*****************************************************************************/
 110      =2  /*****************************************************************************/
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 3   

 111      =2  #define DISABLE_MODBUS_SERIAL_INTERRUPT         ES0 = 0;
 112      =2  #define ENABLE_MODBUS_SERIAL_INTERRUPT          ES0 = 1;
 113      =2  #define DISABLE_INTERRUPT                                       EA = 0;
 114      =2  #define ENABLE_INTERRUPT                                        EA = 1;
 115      =2  /*****************************************************************************/
 116      =2  #include "stdint.h"
   1      =3  /**************************************************************************//**
   2      =3   * Copyright (c) 2015 by Silicon Laboratories Inc. All rights reserved.
   3      =3   *
   4      =3   * http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   5      =3   *****************************************************************************/
   6      =3  
   7      =3  #ifndef STDINT_H
   8      =3  #define STDINT_H
   9      =3  
  10      =3  #if defined __C51__
  11      =3  
  12      =3  typedef unsigned char uint8_t;
  13      =3  typedef unsigned short uint16_t;
  14      =3  typedef unsigned long uint32_t;
  15      =3  typedef uint32_t uint64_t[2];
  16      =3  
  17      =3  typedef signed char int8_t;
  18      =3  typedef short int16_t;
  19      =3  typedef long int32_t;
  20      =3  typedef int32_t int64_t[2];
  21      =3  typedef float fp32_t;
  22      =3  typedef double fp64_t;
  23      =3  
  24      =3  #elif defined __ICC8051__
           =3 
           =3 /* Fixed size types. These are all optional. */
           =3 #ifdef __INT8_T_TYPE__
           =3   typedef __INT8_T_TYPE__   int8_t;
           =3   typedef __UINT8_T_TYPE__ uint8_t;
           =3 #endif /* __INT8_T_TYPE__ */
           =3 
           =3 #ifdef __INT16_T_TYPE__
           =3   typedef __INT16_T_TYPE__   int16_t;
           =3   typedef __UINT16_T_TYPE__ uint16_t;
           =3 #endif /* __INT16_T_TYPE__ */
           =3 
           =3 #ifdef __INT32_T_TYPE__
           =3   typedef __INT32_T_TYPE__   int32_t;
           =3   typedef __UINT32_T_TYPE__ uint32_t;
           =3 #endif /* __INT32_T_TYPE__ */
           =3 
           =3 #ifdef __INT64_T_TYPE__
           =3   #pragma language=save
           =3   #pragma language=extended
           =3   typedef __INT64_T_TYPE__   int64_t;
           =3   typedef __UINT64_T_TYPE__ uint64_t;
           =3   #pragma language=restore
           =3 #endif /* __INT64_T_TYPE__ */
           =3 
           =3 #endif
  51      =3  
  52      =3  #endif
 117      =2  #include "stdbool.h"
   1      =3  /**************************************************************************//**
   2      =3   * Copyright (c) 2015 by Silicon Laboratories Inc. All rights reserved.
   3      =3   *
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 4   

   4      =3   * http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   5      =3   *****************************************************************************/
   6      =3  
   7      =3  #ifndef STDBOOL_H
   8      =3  #define STDBOOL_H
   9      =3  
  10      =3  #if defined __C51__
  11      =3  
  12      =3  typedef bit bool;
  13      =3  enum{
  14      =3    false = 0,
  15      =3    true = 1,
  16      =3  };
  17      =3  
  18      =3  #elif defined __ICC8051__
           =3 
           =3 #ifndef _SYSTEM_BUILD
           =3   #pragma system_include
           =3 #endif
           =3 
           =3 #ifndef __cplusplus
           =3 
           =3 #define bool _Bool
           =3 #define true 1
           =3 #define false 0
           =3 
           =3 #define __bool_true_false_are_defined 1
           =3 
           =3 #endif /* !__cplusplus */
           =3 
           =3 #else  // __SLS_IDE__ : Macros defined to remove syntax errors within Simplicity Studio
           =3 
           =3 typedef bit bool;
           =3 enum{
           =3   false = 0,
           =3   true = 1,
           =3 };
           =3 
           =3 #endif
  43      =3  
  44      =3  #endif //STDBOOL_H
  45      =3  
 118      =2  #include "endian.h"
   1      =3  /**************************************************************************//**
   2      =3   * Copyright (c) 2015 by Silicon Laboratories Inc. All rights reserved.
   3      =3   *
   4      =3   * http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   5      =3   *****************************************************************************/
   6      =3  
   7      =3  #ifndef __ENDIAN_H__
   8      =3  #define __ENDIAN_H__
   9      =3  
  10      =3  #define bswapu16(x) (((x) >> 8) | ((x) << 8))
  11      =3  #define bswapu32(x) (((x) >> 24) | (((x) & 0x00FF0000) >> 8) \
  12      =3                    | (((x) & 0x0000FF00) << 8) | ((x) << 24))
  13      =3  
  14      =3  #define bswap16(x) bswapu16((uint16_t)(x))
  15      =3  #define bswap32(x) bswapu32((uint32_t)(x))
  16      =3  
  17      =3  // Big Endian Compilers
  18      =3  #if ((defined __C51__) || (defined __RC51__) || (defined _CC51))
  19      =3  
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 5   

  20      =3  #define htobe16(x) (x)
  21      =3  #define htobe32(x) (x)
  22      =3  #define be16toh(x) (x)
  23      =3  #define be32toh(x) (x)
  24      =3  
  25      =3  #define htole16(x) bswap16(x)
  26      =3  #define htole32(x) bswap32(x)
  27      =3  #define le16toh(x) bswap16(x)
  28      =3  #define le32toh(x) bswap32(x)
  29      =3  
  30      =3  #elif ((defined SDCC) || (defined HI_TECH_C) || (defined __ICC8051__))
           =3 
           =3 #define htobe16(x) bswap16(x)
           =3 #define htobe32(x) bswap32(x)
           =3 #define be16toh(x) bswap16(x)
           =3 #define be32toh(x) bswap32(x)
           =3 
           =3 #define htole16(x) (x)
           =3 #define htole32(x) (x)
           =3 #define le16toh(x) (x)
           =3 #define le32toh(x) (x)
           =3 
           =3 #else
           =3 
           =3 #define htobe16(x) (x)
           =3 #define htobe32(x) (x)
           =3 #define be16toh(x) (x)
           =3 #define be32toh(x) (x)
           =3 
           =3 #define htole16(x) (x)
           =3 #define htole32(x) (x)
           =3 #define le16toh(x) (x)
           =3 #define le32toh(x) (x)
           =3 
           =3 #endif  // Compiler Definitions
  55      =3  
  56      =3  #endif  // __ENDIAN_H__
 119      =2  #include "si_toolchain.h"
   1      =3  /******************************************************************************
   2      =3   * Copyright (c) 2015 by Silicon Laboratories Inc. All rights reserved.
   3      =3   *
   4      =3   * http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   5      =3   *****************************************************************************/
   6      =3  
   7      =3  #ifndef __SI_TOOLCHAIN_H__
   8      =3  #define __SI_TOOLCHAIN_H__
   9      =3  
  10      =3  #include <stdint.h>
   1      =4  /**************************************************************************//**
   2      =4   * Copyright (c) 2015 by Silicon Laboratories Inc. All rights reserved.
   3      =4   *
   4      =4   * http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   5      =4   *****************************************************************************/
   6      =4  
   7      =4  #ifndef STDINT_H
           =4 #define STDINT_H
           =4 
           =4 #if defined __C51__
           =4 
           =4 typedef unsigned char uint8_t;
           =4 typedef unsigned short uint16_t;
           =4 typedef unsigned long uint32_t;
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 6   

           =4 typedef uint32_t uint64_t[2];
           =4 
           =4 typedef signed char int8_t;
           =4 typedef short int16_t;
           =4 typedef long int32_t;
           =4 typedef int32_t int64_t[2];
           =4 typedef float fp32_t;
           =4 typedef double fp64_t;
           =4 
           =4 #elif defined __ICC8051__
           =4 
           =4 /* Fixed size types. These are all optional. */
           =4 #ifdef __INT8_T_TYPE__
           =4   typedef __INT8_T_TYPE__   int8_t;
           =4   typedef __UINT8_T_TYPE__ uint8_t;
           =4 #endif /* __INT8_T_TYPE__ */
           =4 
           =4 #ifdef __INT16_T_TYPE__
           =4   typedef __INT16_T_TYPE__   int16_t;
           =4   typedef __UINT16_T_TYPE__ uint16_t;
           =4 #endif /* __INT16_T_TYPE__ */
           =4 
           =4 #ifdef __INT32_T_TYPE__
           =4   typedef __INT32_T_TYPE__   int32_t;
           =4   typedef __UINT32_T_TYPE__ uint32_t;
           =4 #endif /* __INT32_T_TYPE__ */
           =4 
           =4 #ifdef __INT64_T_TYPE__
           =4   #pragma language=save
           =4   #pragma language=extended
           =4   typedef __INT64_T_TYPE__   int64_t;
           =4   typedef __UINT64_T_TYPE__ uint64_t;
           =4   #pragma language=restore
           =4 #endif /* __INT64_T_TYPE__ */
           =4 
           =4 #endif
           =4 
           =4 #endif
  11      =3  #include <stdbool.h>
   1      =4  /**************************************************************************//**
   2      =4   * Copyright (c) 2015 by Silicon Laboratories Inc. All rights reserved.
   3      =4   *
   4      =4   * http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   5      =4   *****************************************************************************/
   6      =4  
   7      =4  #ifndef STDBOOL_H
           =4 #define STDBOOL_H
           =4 
           =4 #if defined __C51__
           =4 
           =4 typedef bit bool;
           =4 enum{
           =4   false = 0,
           =4   true = 1,
           =4 };
           =4 
           =4 #elif defined __ICC8051__
           =4 
           =4 #ifndef _SYSTEM_BUILD
           =4   #pragma system_include
           =4 #endif
           =4 
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 7   

           =4 #ifndef __cplusplus
           =4 
           =4 #define bool _Bool
           =4 #define true 1
           =4 #define false 0
           =4 
           =4 #define __bool_true_false_are_defined 1
           =4 
           =4 #endif /* !__cplusplus */
           =4 
           =4 #else  // __SLS_IDE__ : Macros defined to remove syntax errors within Simplicity Studio
           =4 
           =4 typedef bit bool;
           =4 enum{
           =4   false = 0,
           =4   true = 1,
           =4 };
           =4 
           =4 #endif
           =4 
           =4 #endif //STDBOOL_H
  45      =4  
  12      =3  
  13      =3  /**************************************************************************//**
  14      =3   *
  15      =3   * @addtogroup toolchain_group Toolchain Abstraction
  16      =3   *
  17      =3   * @brief Macros for toolchain abstraction.
  18      =3   *
  19      =3   * # Introduction #
  20      =3   *
  21      =3   * This header file contains macros that are used to provide an abstraction
  22      =3   * for toolchain use in source code.  The 8051 compiler requires C-language
  23      =3   * extensions in order to fully use features of the 8051 architecture.  All
  24      =3   * compilers for 8051 implement a set of extensions but use different names
  25      =3   * and ways of implementing those extensions.  This header file provides
  26      =3   * macros that are defined for each supported toolchain and can be used in
  27      =3   * the source code.  This allows the source code to use 8051 extensions and
  28      =3   * remain independent of which toolchain is used for compilation.
  29      =3   *
  30      =3   * ## Variable and Pointer Declarations ##
  31      =3   *
  32      =3   * It is often useful to specify the memory area (or segment) of a variable,
  33      =3   * pointer, or pointer target.  For example, you may wish to place all
  34      =3   * variables in XDATA by default, but for variables used in time-sensitive
  35      =3   * code you use DATA for efficient access.  In this case you declare the
  36      =3   * XDATA variable in the normal C way, but declare the variables to be located
  37      =3   * in the DATA segment using @ref SI_SEGMENT_VARIABLE.
  38      =3   *
  39      =3   * Pointers are more complicated because there are two memory spaces
  40      =3   * associated with a pointer, the pointer target, and the pointer variable
  41      =3   * itself.  When using default memory segment for the pointer location and
  42      =3   * target, then no special macro is needed.  But if you wish to specify the
  43      =3   * pointer variable location, or target memory segment, then you can use one
  44      =3   * of the following macros to do this in a toolchain-independent way.
  45      =3   *
  46      =3   * |Pointer segment|Target segment|Macro                                   |
  47      =3   * |---------------|--------------|----------------------------------------|
  48      =3   * |default        |generic       |None                                    |
  49      =3   * |default        |specific      |@ref SI_VARIABLE_SEGMENT_POINTER        |
  50      =3   * |specific       |generic       |@ref SI_SEGMENT_POINTER                 |
  51      =3   * |specific       |specific      |@ref SI_SEGMENT_VARIABLE_SEGMENT_POINTER|
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 8   

  52      =3   *
  53      =3   * ## Prior Toolchain Abstraction Header File ##
  54      =3   *
  55      =3   * This file supercedes an earlier header file named `compiler_defs.h`.  We
  56      =3   * are deprecating the use of compiler_defs.h, however it will remain for
  57      =3   * backwards compatibility.  This file was created to normalize macro names,
  58      =3   * remove unused macros, and to provide documentation.
  59      =3   *
  60      =3   * ## Supported Toolchains ##
  61      =3   *
  62      =3   * - Keil/ARM C51
  63      =3   *
  64      =3   * @{
  65      =3   *
  66      =3   *****************************************************************************/
  67      =3  
  68      =3  // Make sure there is a NULL defined if the toolchain does not provide it.
  69      =3  #ifndef NULL
  70      =3  #define NULL ((void *)0)
  71      =3  #endif
  72      =3  
  73      =3  // -------------------------------
  74      =3  // Keil/ARM C51
  75      =3  //
  76      =3  #if defined(__C51__)
  77      =3  
  78      =3  /// Used with pointers, declares a generic pointer.  Generic pointers
  79      =3  /// work with any memory space but are inefficient.
  80      =3  #define SI_SEG_GENERIC
  81      =3  
  82      =3  /// Declares a variable to be located in 8051 DATA space.
  83      =3  #define SI_SEG_DATA data
  84      =3  
  85      =3  /// Declares a variable to be located in 8051 IDATA space.
  86      =3  #define SI_SEG_IDATA idata
  87      =3  
  88      =3  /// Declares a variable to be located in 8051 XDATA space.
  89      =3  #define SI_SEG_XDATA xdata
  90      =3  
  91      =3  /// Declares a variable to be located in 8051 PDATA space.
  92      =3  #define SI_SEG_PDATA pdata
  93      =3  
  94      =3  /// Declares a variable to be located in 8051 BDATA (bit-addressable) space.
  95      =3  #define SI_SEG_BDATA bdata
  96      =3  
  97      =3  /// Declares a variable to be located in 8051 CODE space.
  98      =3  #define SI_SEG_CODE code
  99      =3  
 100      =3  /**************************************************************************//**
 101      =3   * Declares a bit variable in a bit-addressable memory space.
 102      =3   *
 103      =3   * @param name The name of the bit variable.
 104      =3   *****************************************************************************/
 105      =3  #define SI_BIT(name) bit name
 106      =3  
 107      =3  /**************************************************************************//**
 108      =3   * Declares a bit variable in a bit-addressable SFR or memory space.
 109      =3   *
 110      =3   * @param name The name of the bit variable.
 111      =3   * @param address The address of the byte containing the bit.
 112      =3   * @param bitnum The bit number (0-7) within the byte.
 113      =3   *
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 9   

 114      =3   * This cannot be used to make any arbitrary SFR or variable into
 115      =3   * a bit variable.  The underlying memory must support bit-addressability.
 116      =3   *****************************************************************************/
 117      =3  #define SI_SBIT(name, address, bitnum) sbit name = address^bitnum
 118      =3  
 119      =3  /**************************************************************************//**
 120      =3   * Declares an 8-bit special function register (SFR) variable.
 121      =3   *
 122      =3   * @param name The name of the SFR variable.
 123      =3   * @param address The address of the SFR.
 124      =3   *
 125      =3   * This creates a C variable (8-bit) that maps to a physical special function
 126      =3   * register of the 8051.  This cannot be used to make any arbitrary memory
 127      =3   * location into an SFR.  The _address_ must map to a real SFR in the memory
 128      =3   * map.
 129      =3   *****************************************************************************/
 130      =3  #define SI_SFR(name, address) sfr name = address
 131      =3  
 132      =3  /**************************************************************************//**
 133      =3   * Declares a 16-bit special function register (SFR) variable.
 134      =3   *
 135      =3   * @param name The name of the SFR variable.
 136      =3   * @param address The address of the 16-bit SFR.
 137      =3   *
 138      =3   * This creates a C variable (16-bit) that maps to a physical special function
 139      =3   * register of the 8051.  This cannot be used to make any arbitrary memory
 140      =3   * location into an SFR.  The _address_ must map to a real 16-bit SFR in the
 141      =3   * memory map.
 142      =3   *****************************************************************************/
 143      =3  #define SI_SFR16(name, address) sfr16 name = address
 144      =3  
 145      =3  #ifndef __SLS_IDE__
 146      =3  /**************************************************************************//**
 147      =3   * Define an interrupt handler function for an interrupt vector.
 148      =3   *
 149      =3   * @param name The name of the interrupt handler function.
 150      =3   * @param vector The interrupt vector number.
 151      =3   *
 152      =3   * This macro defines a function to be an interrupt handler.  The _vector_
 153      =3   * parameter is the 8051 interrupt vector number, not the address.  This
 154      =3   * will cause the compiler to treat the function as the interrupt handler
 155      =3   * and generate the appropriate prolog/epilog code.
 156      =3   *
 157      =3   * @note This macro is used to define the function implementation.  To declare
 158      =3   * the interrupt function prototype, use @ref SI_INTERRUPT_PROTO.
 159      =3   *****************************************************************************/
 160      =3  #define SI_INTERRUPT(name, vector) void name (void) interrupt vector
 161      =3  
 162      =3  /**************************************************************************//**
 163      =3   * Define an interrupt handler function using a specific register bank.
 164      =3   *
 165      =3   * @param name The name of the interrupt handler function.
 166      =3   * @param vector The interrupt vector number.
 167      =3   * @param regnum The register bank number (0-3).
 168      =3   *
 169      =3   * This macro defines a function to be an interrupt handler, using a specific
 170      =3   * register bank for the interrupt code.  The _vector_ parameter is the 8051
 171      =3   * interrupt vector number, not the address.  The _regnum_ parameter is the
 172      =3   * register bank number (0-3) that will be used as general purpose registers
 173      =3   * for the instructions in the compiled code.  Using dedicated register banks
 174      =3   * for interrupt handlers allows the prolog code to just switch banks instead
 175      =3   * of saving and restoring all the general purpose registers.  This can make
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 10  

 176      =3   * interrupt entry/exit faster but requires dedicating a register bank for
 177      =3   * the interrupt handler.
 178      =3   *
 179      =3   * @note This macro is used to define the function implementation.  To declare
 180      =3   * the interrupt function prototype, use @ref SI_INTERRUPT_PROTO_USING.
 181      =3   *****************************************************************************/
 182      =3  #define SI_INTERRUPT_USING(name, vector, regnum)                             \
 183      =3               void name (void) interrupt vector using regnum
 184      =3  
 185      =3  /**************************************************************************//**
 186      =3   * Declare an interrupt handler prototype for an interrupt vector.
 187      =3   *
 188      =3   * @param name The name of the interrupt handler function.
 189      =3   * @param vector The interrupt vector number.
 190      =3   *
 191      =3   * This macro declares a function prototype for an interrupt handler.  The
 192      =3   * _vector_ parameter is the 8051 interrupt vector number, not the address.
 193      =3   * Declaring the function prototype this way will cause the compiler to
 194      =3   * recognize that the function is an interrupt handler and not a normal C
 195      =3   * function.
 196      =3   *
 197      =3   * @note This macro is used to declare a prototype for the interrupt function.
 198      =3   * To define the interrupt function implementation, use @ref SI_INTERRUPT.
 199      =3   *****************************************************************************/
 200      =3  #define SI_INTERRUPT_PROTO(name, vector) void name (void)
 201      =3  
 202      =3  /**************************************************************************//**
 203      =3   * Declare an interrupt handler prototype using a specific register bank.
 204      =3   *
 205      =3   * @param name The name of the interrupt handler function.
 206      =3   * @param vector The interrupt vector number.
 207      =3   * @param regnum The register bank number (0-3).
 208      =3   *
 209      =3   * This macro declares a function prototype for an interrupt handler, for a
 210      =3   * function that uses a specific register bank for the interrupt code.  The
 211      =3   * _vector_ parameter is the 8051 interrupt vector number, not the address.
 212      =3   * The _regnum_ parameter is the register bank number (0-3) that will be used
 213      =3   * as general purpose registers in the function.  Declaring the function
 214      =3   * prototype this way will cause the compiler to recognize that the function
 215      =3   * is an interrupt handler and is not a normal C function.
 216      =3   *
 217      =3   * @note This macro is used to declare a prototype for the interrupt function.
 218      =3   * To define the interrupt function implementation,
 219      =3   * use @ref SI_INTERRUPT_USING.
 220      =3   *****************************************************************************/
 221      =3  #define SI_INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
 222      =3  
 223      =3  /**************************************************************************//**
 224      =3   * Define a function to be reentrant (store local variables on the stack).
 225      =3   *
 226      =3   * @param name The name of the function.
 227      =3   * @param return_type The data type of the function return value
 228      =3   * (void, int, etc).
 229      =3   * @param parameter One C function parameter (or "void") (type and name).
 230      =3   *
 231      =3   * This macro defines a function to be reentrant.
 232      =3   *
 233      =3   * You must specify the _return_type_ which is the type of the function.  It
 234      =3   * can be `void` or any other C type or typedef.  The _parameters_ argument
 235      =3   * is the list of function parameters.  It can be `void` or else it must be
 236      =3   * a parameter data type and name.  It can also be multiple parameters but
 237      =3   * they must be enclosed in parentheses and separated by commas.
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 11  

 238      =3   *
 239      =3   * __Example__
 240      =3   *
 241      =3   * ~~~~~~~~.c
 242      =3   * // The following is used to implement a function with the following
 243      =3   * // signature...
 244      =3   * uint16_t myFunction(uint8_t parm1, uint8_t parm2);
 245      =3   *
 246      =3   * SI_REENTRANT_FUNCTION(myFunction, uint16_t, (uint8_t parm1, uint8_t parm2))
 247      =3   * {
 248      =3   *   // Function implementation body
 249      =3   * }
 250      =3   * ~~~~~~~~
 251      =3   *
 252      =3   * @note This macro is used to define the function implementation.  To declare
 253      =3   * the function prototype, use @ref SI_REENTRANT_FUNCTION_PROTO.
 254      =3   *****************************************************************************/
 255      =3  #define SI_REENTRANT_FUNCTION(name, return_type, parameter) \
 256      =3    return_type name parameter reentrant
 257      =3  
 258      =3  /**************************************************************************//**
 259      =3   * Declare a function to be reentrant (store local variables on the stack).
 260      =3   *
 261      =3   * @param name The name of the function.
 262      =3   * @param return_type The data type of the function return value
 263      =3   * (void, int, etc).
 264      =3   * @param parameter One C function parameter (or "void") (type and name).
 265      =3   *
 266      =3   * This macro declares a function prototype for a C function that is reentrant.
 267      =3   * See the documentation for @ref SI_REENTRANT_FUNCTION for an explanation of
 268      =3   * the macro arguments.  This is an advanced feature.
 269      =3   *
 270      =3   * @note This macro is used to declare a prototype for the function.  To
 271      =3   * define the function implementation, use @ref SI_REENTRANT_FUNCTION.
 272      =3   *****************************************************************************/
 273      =3  #define SI_REENTRANT_FUNCTION_PROTO(name, return_type, parameter) \
 274      =3    return_type name parameter reentrant
 275      =3                 
 276      =3  /**************************************************************************//**
 277      =3   * Define a function to use a specific register bank.
 278      =3   *
 279      =3   * @param name The name of the function.
 280      =3   * @param return_value The data type of the function return value
 281      =3   * (void, int, etc).
 282      =3   * @param parameter One C function parameter (or "void") (type and name).
 283      =3   * @param regnum The register bank number (0-3).
 284      =3   *
 285      =3   * This macro defines a function that uses a specific register bank.  The
 286      =3   * _regnum_ parameter is the register bank number (0-3) that will be used as
 287      =3   * general purpose registers for the instructions in the compiled function
 288      =3   * code.  Using dedicated register banks for a function can reduce the amount
 289      =3   * of registers saving and restoring needed on entry and exit to the
 290      =3   * function.  However, this is an advanced feature and you should not use it
 291      =3   * unless you fully understand how and when to use register banking.
 292      =3   *
 293      =3   * You must specify the _return_value_ which is the type of the function.  It
 294      =3   * can be `void` or any other C type or typedef.  The _parameters_ argument
 295      =3   * is the list of function parameters.  It can be `void` or else it must be
 296      =3   * a parameter data type and name.  It can also be multiple parameters but
 297      =3   * they must be enclosed in parentheses and separated by commas.
 298      =3   *
 299      =3   * __Example__
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 12  

 300      =3   *
 301      =3   * ~~~~~~~~.c
 302      =3   * // The following is used to implement a function with the following
 303      =3   * // signature, and that uses register bank 3 ...
 304      =3   * uint16_t myFunction(uint8_t parm1, uint8_t parm2);
 305      =3   *
 306      =3   * SI_FUNCTION_USING(myFunction, uint16_t, (uint8_t parm1, uint8_t parm2), 3)
 307      =3   * {
 308      =3   *   // Function implementation body
 309      =3   * }
 310      =3   * ~~~~~~~~
 311      =3   *
 312      =3   * @note This macro is used to define the function implementation.  To declare
 313      =3   * the function prototype, use @ref SI_FUNCTION_PROTO_USING.
 314      =3   *****************************************************************************/
 315      =3  #define SI_FUNCTION_USING(name, return_value, parameter, regnum)              \
 316      =3               return_value name parameter using regnum
 317      =3  
 318      =3  /**************************************************************************//**
 319      =3   * Declare a function that uses a specific register bank.
 320      =3   *
 321      =3   * @param name The name of the function.
 322      =3   * @param return_value The data type of the function return value
 323      =3   * (void, int, etc).
 324      =3   * @param parameter One C function parameter (or "void") (type and name).
 325      =3   * @param regnum The register bank number (0-3).
 326      =3   *
 327      =3   * This macro declares a function prototype for a C function that uses a
 328      =3   * specific register its working registers.  See the documentation for
 329      =3   * @ref SI_FUNCTION_USING for an explanation of the macro arguments.  This is
 330      =3   * an advanced feature.
 331      =3   *
 332      =3   * @note This macro is used to declare a prototype for the function.  To
 333      =3   * define the function implementation, use @ref SI_FUNCTION_USING.
 334      =3   *****************************************************************************/
 335      =3  #define SI_FUNCTION_PROTO_USING(name, return_value, parameter, regnum)        \
 336      =3               return_value name parameter
 337      =3  
 338      =3  /**************************************************************************//**
 339      =3   * Declare a variable to be located in a specific memory segment.
 340      =3   *
 341      =3   * @param name The variable name.
 342      =3   * @param vartype The variable data type.* @param memseg The memory segment to use for the variable.
 343      =3   *
 344      =3   * This macro declares a variable to be located in a specific memory area
 345      =3   * (or segment) of the 8051 memory space.  It is only necessary to use this
 346      =3   * macro if you want to force the variable into a specific memory space instead
 347      =3   * of the default memory space used by the compiler.  The segment can be
 348      =3   * one of the following:
 349      =3   *
 350      =3   * - @ref SI_SEG_DATA
 351      =3   * - @ref SI_SEG_IDATA
 352      =3   * - @ref SI_SEG_BDATA
 353      =3   * - @ref SI_SEG_PDATA
 354      =3   * - @ref SI_SEG_XDATA
 355      =3   * - @ref SI_SEG_CODE
 356      =3   *
 357      =3   * __Example__
 358      =3   *
 359      =3   * ~~~~~~~~.c
 360      =3   * // The following macro can be used to create a variable located in
 361      =3   * // XDATA with the following signature:
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 13  

 362      =3   * uint8_t myVar;
 363      =3   *
 364      =3   * SI_SEGMENT_VARIABLE(myVar, uint8_t, SEG_XDATA);
 365      =3   * ~~~~~~~~
 366      =3   *****************************************************************************/
 367      =3  #define SI_SEGMENT_VARIABLE(name, vartype, memseg) vartype memseg name
 368      =3  
 369      =3  /**************************************************************************//**
 370      =3   * Declare a memory segment specific pointer variable.
 371      =3   *
 372      =3   * @param name The pointer variable name.
 373      =3   * @param vartype The pointer data type.
 374      =3   * @param targseg The target memory segment for the pointer.
 375      =3   *
 376      =3   * This macro declares a pointer that points at a specific memory area
 377      =3   * (or segment).  The memory segment of the pointer variable itself is not
 378      =3   * specified and the default is used.  The segment can be one of the following:
 379      =3   *
 380      =3   * - @ref SI_SEG_DATA
 381      =3   * - @ref SI_SEG_IDATA
 382      =3   * - @ref SI_SEG_BDATA
 383      =3   * - @ref SI_SEG_PDATA
 384      =3   * - @ref SI_SEG_XDATA
 385      =3   * - @ref SI_SEG_CODE
 386      =3   *
 387      =3   * __Example__
 388      =3   *
 389      =3   * ~~~~~~~~.c
 390      =3   * // The following macro can be used to create a pointer that points to
 391      =3   * // a location in XDATA with the following signature:
 392      =3   * uint8_t *pVar; // where pVar is pointing at XDATA
 393      =3   *
 394      =3   * SI_VARIABLE_SEGMENT_POINTER(pVar, uint8_t, SEG_XDATA);
 395      =3   * ~~~~~~~~
 396      =3   *****************************************************************************/
 397      =3  #define SI_VARIABLE_SEGMENT_POINTER(name, vartype, targseg)                  \
 398      =3               vartype targseg * name
 399      =3  
 400      =3  /**************************************************************************//**
 401      =3   * Declare a memory segment specific pointer variable, in a specific segment.
 402      =3   *
 403      =3   * @param name The pointer variable name.
 404      =3   * @param vartype The pointer data type.
 405      =3   * @param targseg The target memory segment for the pointer.
 406      =3   * @param memseg The memory segment to use for the pointer variable.
 407      =3   *
 408      =3   * This macro declares a pointer that points at a specific memory area
 409      =3   * (or segment).  The pointer variable itself is also located in a specified
 410      =3   * memory segment by _memseg_.  The arguments _targseg_ and _memseg_ can be
 411      =3   * one of the following:
 412      =3   *
 413      =3   * - @ref SI_SEG_DATA
 414      =3   * - @ref SI_SEG_IDATA
 415      =3   * - @ref SI_SEG_BDATA
 416      =3   * - @ref SI_SEG_PDATA
 417      =3   * - @ref SI_SEG_XDATA
 418      =3   * - @ref SI_SEG_CODE
 419      =3   *
 420      =3   * __Example__
 421      =3   *
 422      =3   * ~~~~~~~~.c
 423      =3   * // The following macro can be used to create a pointer that points to
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 14  

 424      =3   * // a location in XDATA while the pointer itself is located in DATA, with
 425      =3   * // the following signature:
 426      =3   * uint8_t *pVar; // where pVar is located in DATA and is pointing at XDATA
 427      =3   *
 428      =3   * SI_SEGMENT_VARIABLE_SEGMENT_POINTER(pVar, uint8_t, SEG_XDATA, SEG_DATA);
 429      =3   * ~~~~~~~~
 430      =3   *****************************************************************************/
 431      =3  #define SI_SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targseg, memseg)  \
 432      =3               vartype targseg * memseg name
 433      =3  
 434      =3  /**************************************************************************//**
 435      =3   * Declare a generic pointer variable that is located in a specific segment.
 436      =3   *
 437      =3   * @param name The pointer variable name.
 438      =3   * @param vartype The pointer data type.
 439      =3   * @param memseg The memory segment to use for the pointer variable.
 440      =3   *
 441      =3   * This macro declares a pointer that is a generic pointer.  This means it can
 442      =3   * point at any kind of memory location.  However the pointer variable itself
 443      =3   * is located in a specific memory segment by _memseg_, which can be one of
 444      =3   * the following:
 445      =3   *
 446      =3   * - @ref SI_SEG_DATA
 447      =3   * - @ref SI_SEG_IDATA
 448      =3   * - @ref SI_SEG_BDATA
 449      =3   * - @ref SI_SEG_PDATA
 450      =3   * - @ref SI_SEG_XDATA
 451      =3   * - @ref SI_SEG_CODE
 452      =3   *
 453      =3   * __Example__
 454      =3   *
 455      =3   * ~~~~~~~~.c
 456      =3   * // The following macro can be used to create a generic pointer that
 457      =3   * // is located in DATA and points at any memory type, with the
 458      =3   * // following signature:
 459      =3   * uint8_t *pVar; // where pVar is located in DATA and is a generic pointer
 460      =3   *
 461      =3   * SI_SEGMENT_POINTER(pVar, uint8_t, SEG_DATA);
 462      =3   * ~~~~~~~~
 463      =3   *****************************************************************************/
 464      =3  #define SI_SEGMENT_POINTER(name, vartype, memseg) vartype * memseg name
 465      =3  
 466      =3  /**************************************************************************//**
 467      =3   * Declare an uninitialized variable that is located at a specific address.
 468      =3   *
 469      =3   * @param name The variable name.
 470      =3   * @param vartype The variable data type.
 471      =3   * @param memseg The memory segment to use for the variable.
 472      =3   * @param address The memory address of the variable.
 473      =3   *
 474      =3   * This macro allows declaring a variable that can be placed at a specific
 475      =3   * location in memory.  This can only be used for variables that do not need
 476      =3   * initializers.  The _address_ is the memory address within the specified
 477      =3   * segment.  The memory segment, _memseg_, can be one of the following:
 478      =3   *
 479      =3   * - @ref SI_SEG_DATA
 480      =3   * - @ref SI_SEG_IDATA
 481      =3   * - @ref SI_SEG_BDATA
 482      =3   * - @ref SI_SEG_PDATA
 483      =3   * - @ref SI_SEG_XDATA
 484      =3   * - @ref SI_SEG_CODE
 485      =3   *
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 15  

 486      =3   * __Example__
 487      =3   *
 488      =3   * ~~~~~~~~.c
 489      =3   * // The following declares a variable located at 0x4000 in XDATA with
 490      =3   * // the following signature:
 491      =3   * uint8_t myMemVar;
 492      =3   *
 493      =3   * SI_LOCATED_VARIABLE_NO_INIT(myMemVar, uint8_t, SEG_DATA, 0x4000);
 494      =3   * ~~~~~~~~
 495      =3   *****************************************************************************/
 496      =3  #define SI_LOCATED_VARIABLE_NO_INIT(name, vartype, memseg, address)          \
 497      =3               vartype memseg name _at_ address
 498      =3  
 499      =3  
 500      =3  #else  // __SLS_IDE__ : Macros defined to remove syntax errors within Simplicity Studio
           =3 #define SI_INTERRUPT(name, vector) void name (void)
           =3 #define SI_INTERRUPT_USING(name, vector, regnum) void name (void)
           =3 #define SI_INTERRUPT_PROTO(name, vector) void name (void)
           =3 #define SI_INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
           =3 
           =3 #define SI_REENTRANT_FUNCTION(name, return_value, parameter, regnum) return_value name (parameter)
           =3 #define SI_REENTRANT_FUNCTION_PROTO(name, return_value, parameter, regnum) return_value name (parameter)
           =3 
           =3 #define SI_FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =3 #define SI_FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =3 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =3 
           =3 #define SI_SEGMENT_VARIABLE(name, vartype, locsegment) vartype name
           =3 #define SI_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype * name
           =3 #define SI_SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype * name
           =3 #define SI_SEGMENT_POINTER(name, vartype, locsegment) vartype * name
           =3 #define SI_LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) vartype name
           =3 #endif // __SLS_IDE__
 519      =3  
 520      =3  // The following are used for byte ordering when referring to individual
 521      =3  // bytes within a SI_UU32_t.  B0 is the least significant byte.
 522      =3  #define B0 3 ///< Least significant byte of a 4 byte word
 523      =3  #define B1 2 ///< Byte 1 of a 4-byte word, where byte 0 is LSB
 524      =3  #define B2 1 ///< Byte 2 of a 4-byte word, where byte 0 is LSB
 525      =3  #define B3 0 ///< Most significant byte of a 4-byte word
 526      =3  
 527      =3  #define LSB 1 ///< Index to least significant bit of a 2 byte word
 528      =3  #define MSB 0 ///< Index to most significant bit of a 2 byte word
 529      =3  
 530      =3  /// A union type to make it easier to access individual bytes of a 16-bit
 531      =3  /// word, and to use as signed or unsigned type.
 532      =3  typedef union SI_UU16
 533      =3  {
 534      =3    uint16_t u16;   ///< The two byte value as a 16-bit unsigned integer.
 535      =3    int16_t s16;    ///< The two byte value as a 16-bit signed integer.
 536      =3    uint8_t u8[2];  ///< The two byte value as two unsigned 8-bit integers.
 537      =3    int8_t s8[2];   ///< The two byte value as two signed 8-bit integers.
 538      =3  } SI_UU16_t;
 539      =3  
 540      =3  /// A union type to make it easier to access individual bytes within a
 541      =3  /// 32-bit word, or to access it as variations of 16-bit words, or to
 542      =3  /// use as signed or unsigned type.
 543      =3  typedef union SI_UU32
 544      =3  {
 545      =3    uint32_t u32;       ///< The 4-byte value as a 32-bit unsigned integer.
 546      =3    int32_t s32;        ///< The 4-byte value as a 32-bit signed integer.
 547      =3    SI_UU16_t uu16[2];  ///< The 4-byte value as a SI_UU16_t.
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 16  

 548      =3    uint16_t u16[2];    ///< The 4-byte value as two unsigned 16-bit integers.
 549      =3    int16_t s16[2];     ///< The 4-byte value as two signed 16-bit integers.
 550      =3    uint8_t u8[4];      ///< The 4-byte value as 4 unsigned 8-bit integers.
 551      =3    int8_t s8[4];       ///< The 4-byte value as 4 signed 8-bit integers.
 552      =3  } SI_UU32_t;
 553      =3  
 554      =3  // Generic pointer memory segment constants.
 555      =3  #define SI_GPTR                   ///< Generic pointer indeterminate type.
 556      =3  #define SI_GPTR_MTYPE_DATA  0x00  ///< Generic pointer for DATA segment.
 557      =3  #define SI_GPTR_MTYPE_IDATA 0x00  ///< Generic pointer for IDATA segment.
 558      =3  #define SI_GPTR_MTYPE_BDATA 0x00  ///< Generic pointer for BDATA segment.
 559      =3  #define SI_GPTR_MTYPE_PDATA 0xFE  ///< Generic pointer for PDATA segment.
 560      =3  #define SI_GPTR_MTYPE_XDATA 0x01  ///< Generic pointer for XDATA segment.
 561      =3  #define SI_GPTR_MTYPE_CODE  0xFF  ///< Generic pointer for CODE segment.
 562      =3  
 563      =3  /// Generic pointer structure containing the type and address.
 564      =3  typedef struct
 565      =3  {
 566      =3    uint8_t memtype;    ///< The type of memory of the generic pointer.
 567      =3    SI_UU16_t address;  ///< The address of the generic pointer.
 568      =3  } GPTR_t;
 569      =3  
 570      =3  /// A union type to allow access to the fields of a generic pointer.
 571      =3  /// A generic pointer has a field indicating the type of memory and an
 572      =3  /// address within the memory.
 573      =3  typedef union SI_GEN_PTR
 574      =3  {
 575      =3    uint8_t u8[3];    ///< 3-byte generic pointer as 3 unsigned 8-bit integers.
 576      =3    GPTR_t gptr;      ///< 3-byte generic pointer as pointer structure
 577      =3  } SI_GEN_PTR_t;
 578      =3  
 579      =3  // Declaration of Keil intrinisc
 580      =3  extern void _nop_(void);
 581      =3  /// Macro to insert a no-operation (NOP) instruction.
 582      =3  #define NOP() _nop_()
 583      =3  
 584      =3  // -------------------------------
 585      =3  // GCC for ARM Cortex-M
 586      =3  // Provides support for code that can be compiled for 8 or 32-bit
 587      =3  //
 588      =3  #elif defined (__GNUC__)
           =3 #if defined(__ARMEL__) && ((__ARMEL__ == 1) && ((__ARM_ARCH == 6) || (__ARM_ARCH == 7)))
           =3 
           =3 // these ignore any memory segment directives
           =3 #define SI_SEG_GENERIC
           =3 #define SI_SEG_DATA
           =3 #define SI_SEG_IDATA
           =3 #define SI_SEG_XDATA
           =3 #define SI_SEG_PDATA
           =3 #define SI_SEG_BDATA
           =3 #define SI_SEG_CODE
           =3 
           =3 // the following create a variable of the specified name but ignore the
           =3 // address and bit number.  If the using-code cares about the actual
           =3 // address or bit number, this probably will break it
           =3 #define SI_SBIT(name, address, bitnum) uint8_t name
           =3 #define SI_SFR(name, address) uint8_t name
           =3 #define SI_SFR16(name, address) uint16_t name
           =3 
           =3 // the following create function and variable names of the specified types
           =3 // but the 8051-specific aspects (like memory segment) are ignored
           =3 #define SI_INTERRUPT(name, vector) void name (void)
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 17  

           =3 #define SI_INTERRUPT_USING(name, vector, regnum) void name (void)
           =3 #define SI_INTERRUPT_PROTO(name, vector) void name (void)
           =3 #define SI_INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
           =3 #define SI_FUNCTION_USING(name, return_value, parameter, regnum)              \
           =3              return_value name (parameter)
           =3 #define SI_FUNCTION_PROTO_USING(name, return_value, parameter, regnum)        \
           =3              return_value name (parameter)
           =3 #define SI_SEGMENT_VARIABLE(name, vartype, memseg) vartype name
           =3 #define SI_VARIABLE_SEGMENT_POINTER(name, vartype, targseg)                  \
           =3              vartype * name
           =3 #define SI_SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targseg, memseg)  \
           =3              vartype * name
           =3 #define SI_SEGMENT_POINTER(name, vartype, memseg) vartype * name
           =3 #define SI_LOCATED_VARIABLE_NO_INIT(name, vartype, memseg, address)          \
           =3              vartype name
           =3 
           =3 #define B0 0
           =3 #define B1 1
           =3 #define B2 2
           =3 #define B3 3
           =3 #define LSB 0
           =3 #define MSB 1
           =3 typedef union SI_UU16
           =3 {
           =3   uint16_t u16;
           =3   int16_t s16;
           =3   uint8_t u8[2];
           =3   int8_t s8[2];
           =3 } SI_UU16_t;
           =3 
           =3 typedef union SI_UU32
           =3 {
           =3   uint32_t u32;
           =3   int32_t s32;
           =3   SI_UU16_t uu16[2];
           =3   uint16_t u16[2];
           =3   int16_t s16[2];
           =3   uint8_t u8[4];
           =3   int8_t s8[4];
           =3 } SI_UU32_t;
           =3 
           =3 // Generic pointer stuff is left out because if you are accessing
           =3 // generic pointer fields then it will need to be rewritten for 32-bit
           =3 
           =3 // __NOP should be declared in cmsis header core_cmInstr.h
           =3 extern void __NOP(void);
           =3 /// Macro to insert a no-operation (NOP) instruction.
           =3 #define NOP() __NOP()
           =3 
           =3 #else // ARM_ARCH 6 | 7
           =3 #error unsupported ARM arch
           =3 #endif
           =3 
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 // IAR 8051
           =3 // http://www.iar.com
           =3 #elif defined __ICC8051__
           =3 
           =3 #include <intrinsics.h>
           =3 
           =3 #define SI_BIT(name)              __no_init bool __bit name
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 18  

           =3 #define SI_SBIT(name, addr, bit)  __bit __no_init volatile bool name @ (addr+bit)
           =3 #define SI_SFR(name, addr)        __sfr __no_init volatile unsigned char name @ addr
           =3 #define SI_SFR16(name, addr)      __sfr __no_init volatile unsigned int  name @ addr
           =3 
           =3 #define SI_SEG_GENERIC __generic
           =3 #define SI_SEG_FAR  __xdata
           =3 #define SI_SEG_DATA __data
           =3 #define SI_SEG_NEAR __data
           =3 #define SI_SEG_IDATA __idata
           =3 #define SI_SEG_XDATA __xdata
           =3 #define SI_SEG_PDATA __pdata
           =3 #define SI_SEG_CODE  __code
           =3 #define SI_SEG_BDATA __bdata
           =3 
           =3 #define _PPTOSTR_(x) #x
           =3 #define _PPARAM_(address) _PPTOSTR_(vector=address * 8 + 3)
           =3 #define _PPARAM2_(regbank) _PPTOSTR_(register_bank=regbank)
           =3 #define SI_INTERRUPT(name, vector) _Pragma(_PPARAM_(vector)) __interrupt void name(void)
           =3 #define SI_INTERRUPT_PROTO(name, vector)  __interrupt void name(void)
           =3 #define SI_INTERRUPT_USING(name, vector, regnum) _Pragma(_PPARAM2_(regnum)) _Pragma(_PPARAM_(vector)) __in
             -terrupt void name(void)
           =3 #define SI_INTERRUPT_PROTO_USING(name, vector, regnum) __interrupt void name(void)
           =3 
           =3 #if (__DATA_MODEL__ == 0) /* TINY */ || \
           =3     (__DATA_MODEL__ == 1) /* SMALL */
           =3 #define SI_REENTRANT_FUNCTION(name, return_type, parameter) \
           =3   __idata_reentrant return_type name parameter
           =3 #define SI_REENTRANT_FUNCTION_PROTO(name, return_type, parameter) \
           =3   __idata_reentrant return_type name parameter
           =3 #elif (__DATA_MODEL__ == 2) /* LARGE */ || \
           =3       (__DATA_MODEL__ == 3) /* GENERIC */ || \
           =3       (__DATA_MODEL__ == 4) /* FAR */
           =3 #define SI_REENTRANT_FUNCTION(name, return_type, parameter) \
           =3   __xdata_reentrant return_type name parameter
           =3 #define SI_REENTRANT_FUNCTION_PROTO(name, return_type, parameter) \
           =3   __xdata_reentrant return_type name (parameter)
           =3 #else
           =3 #error "Illegal memory model setting."
           =3 #endif
           =3 
           =3 // Note: IAR does not support functions using different register banks. Register
           =3 //       banks can only be specified in interrupts. If a function is called from
           =3 //       inside an interrupt, it will use the same register bank as the interrupt.
           =3 #define SI_FUNCTION_USING(name, return_value, parameter, regnum)              \
           =3              return_value name parameter
           =3 #define SI_FUNCTION_PROTO_USING(name, return_value, parameter, regnum)        \
           =3              return_value name parameter
           =3 
           =3 #define SI_SEGMENT_VARIABLE(name, vartype, locsegment)  vartype locsegment name
           =3 #define SI_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment  * name
           =3 #define SI_SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * 
             -locsegment name
           =3                
           =3 #define SI_SEGMENT_POINTER(name, vartype, ptrseg) vartype __generic * ptrseg name
           =3 
           =3 #define SI_LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment __no_init vartype name @ add
             -r
           =3 
           =3 #define SI_LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) locsegment __no_init vartype name @ a
             -ddr
           =3 
           =3 // The following are used for byte ordering when referring to individual
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 19  

           =3 // bytes within a SI_UU32_t.  B0 is the least significant byte.
           =3 #define B0 0 ///< Least significant byte of a 4 byte word
           =3 #define B1 1 ///< Byte 1 of a 4-byte word, where byte 0 is LSB
           =3 #define B2 2 ///< Byte 2 of a 4-byte word, where byte 0 is LSB
           =3 #define B3 3 ///< Most significant byte of a 4-byte word
           =3 
           =3 #define LSB 0 ///< Index to least significant bit of a 2 byte word
           =3 #define MSB 1 ///< Index to most significant bit of a 2 byte word
           =3 
           =3 /// A union type to make it easier to access individual bytes of a 16-bit
           =3 /// word, and to use as signed or unsigned type.
           =3 typedef union SI_UU16
           =3 {
           =3   uint16_t u16;   ///< The two byte value as a 16-bit unsigned integer.
           =3   int16_t s16;    ///< The two byte value as a 16-bit signed integer.
           =3   uint8_t u8[2];  ///< The two byte value as two unsigned 8-bit integers.
           =3   int8_t s8[2];   ///< The two byte value as two signed 8-bit integers.
           =3 } SI_UU16_t;
           =3 
           =3 /// A union type to make it easier to access individual bytes within a
           =3 /// 32-bit word, or to access it as variations of 16-bit words, or to
           =3 /// use as signed or unsigned type.
           =3 typedef union SI_UU32
           =3 {
           =3   uint32_t u32;       ///< The 4-byte value as a 32-bit unsigned integer.
           =3   int32_t s32;        ///< The 4-byte value as a 32-bit signed integer.
           =3   SI_UU16_t uu16[2];  ///< The 4-byte value as a SI_UU16_t.
           =3   uint16_t u16[2];    ///< The 4-byte value as two unsigned 16-bit integers.
           =3   int16_t s16[2];     ///< The 4-byte value as two signed 16-bit integers.
           =3   uint8_t u8[4];      ///< The 4-byte value as 4 unsigned 8-bit integers.
           =3   int8_t s8[4];       ///< The 4-byte value as 4 signed 8-bit integers.
           =3 } SI_UU32_t;
           =3 
           =3 // Generic pointer memory segment constants.
           =3 #define SI_GPTR                   ///< Generic pointer indeterminate type.
           =3 #define SI_GPTR_MTYPE_DATA  0x01  ///< Generic pointer for DATA segment.
           =3 #define SI_GPTR_MTYPE_IDATA 0x01  ///< Generic pointer for IDATA segment.
           =3 #define SI_GPTR_MTYPE_BDATA 0x01  ///< Generic pointer for BDATA segment.
           =3 #define SI_GPTR_MTYPE_PDATA 0x00  ///< Generic pointer for PDATA segment.
           =3 #define SI_GPTR_MTYPE_XDATA 0x00  ///< Generic pointer for XDATA segment.
           =3 #define SI_GPTR_MTYPE_CODE  0x80  ///< Generic pointer for CODE segment.
           =3 
           =3 /// Generic pointer structure containing the type and address.
           =3 typedef struct
           =3 {
           =3   SI_UU16_t address;  ///< The address of the generic pointer.
           =3   uint8_t memtype;    ///< The type of memory of the generic pointer.  
           =3 } GPTR_t;
           =3 
           =3 /// A union type to allow access to the fields of a generic pointer.
           =3 /// A generic pointer has a field indicating the type of memory and an
           =3 /// address within the memory.
           =3 typedef union SI_GEN_PTR
           =3 {
           =3   uint8_t u8[3];    ///< 3-byte generic pointer as 3 unsigned 8-bit integers.
           =3   GPTR_t gptr;      ///< 3-byte generic pointer as pointer structure
           =3 } SI_GEN_PTR_t;
           =3 
           =3 /// Macro to insert a no-operation (NOP) instruction.
           =3 #define NOP() __no_operation()
           =3 
           =3 #else // unknown toolchain
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 20  

           =3 #error Unrecognized toolchain in si_toolchain.h
           =3 #endif
 794      =3  
 795      =3  /** @} */
 796      =3  
 797      =3  #endif
 120      =2  #include "compiler_defs.h"
   1      =3  //-----------------------------------------------------------------------------
   2      =3  // compiler_defs.h
   3      =3  //-----------------------------------------------------------------------------
   4      =3  // Portions of this file are copyright Maarten Brock
   5      =3  // http://sdcc.sourceforge.net
   6      =3  // Portions of this file are Copyright 2014 Silicon Laboratories, Inc.
   7      =3  // http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   8      =3  //
   9      =3  // GNU LGPL boilerplate:
  10      =3  /** This library is free software; you can redistribute it and/or
  11      =3    * modify it under the terms of the GNU Lesser General Public
  12      =3    * License as published by the Free Software Foundation; either
  13      =3    * version 2.1 of the License, or (at your option) any later version.
  14      =3    *
  15      =3    * This library is distributed in the hope that it will be useful,
  16      =3    * but WITHOUT ANY WARRANTY; without even the implied warranty of
  17      =3    * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
  18      =3    * Lesser General Public License for more details.
  19      =3    *
  20      =3    * You should have received a copy of the GNU Lesser General Public
  21      =3    * License along with this library; if not, write to the Free Software
  22      =3    * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  23      =3    *
  24      =3    * In other words, you are welcome to use, share and improve this program.
  25      =3    * You are forbidden to forbid anyone else to use, share and improve
  26      =3    * what you give them. Help stamp out software-hoarding!
  27      =3  **/
  28      =3  // Program Description:
  29      =3  //
  30      =3  // **Important Note**: This header file should be included before including
  31      =3  // a device-specific header file such as C8051F300_defs.h.
  32      =3  //
  33      =3  // Macro definitions to accomodate 8051 compiler differences in specifying
  34      =3  // special function registers and other 8051-specific features such as NOP
  35      =3  // generation, and locating variables in memory-specific segments.  The
  36      =3  // compilers are identified by their unique predefined macros. See also:
  37      =3  // http://predef.sourceforge.net/precomp.html
  38      =3  //
  39      =3  // SBIT and SFR define special bit and special function registers at the given
  40      =3  // address. SFR16 and SFR32 define sfr combinations at adjacent addresses in
  41      =3  // little-endian format. SFR16E and SFR32E define sfr combinations without
  42      =3  // prerequisite byte order or adjacency. None of these multi-byte sfr
  43      =3  // combinations will guarantee the order in which they are accessed when read
  44      =3  // or written.
  45      =3  //
  46      =3  // SFR16X and SFR32X for 16 bit and 32 bit xdata registers are not defined
  47      =3  // to avoid portability issues because of compiler endianness.
  48      =3  //
  49      =3  // Example:
  50      =3  // // my_mcu.c: main 'c' file for my mcu
  51      =3  // #include <compiler_defs.h>  // this file
  52      =3  // #include <C8051xxxx_defs.h> // SFR definitions for specific MCU target
  53      =3  //
  54      =3  // SBIT  (P0_1, 0x80, 1);      // Port 0 pin 1
  55      =3  // SFR   (P0, 0x80);           // Port 0
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 21  

  56      =3  // SFRX  (CPUCS, 0xE600);      // Cypress FX2 Control and Status register in
  57      =3  //                             // xdata memory at 0xE600
  58      =3  // SFR16 (TMR2, 0xCC);         // Timer 2, lsb at 0xCC, msb at 0xCD
  59      =3  // SFR16E(TMR0, 0x8C8A);       // Timer 0, lsb at 0x8A, msb at 0x8C
  60      =3  // SFR32 (MAC0ACC, 0x93);      // SiLabs C8051F120 32 bits MAC0 Accumulator,
  61      =3  //                             // lsb at 0x93, msb at 0x96
  62      =3  // SFR32E(SUMR, 0xE5E4E3E2);   // TI MSC1210 SUMR 32 bits Summation register,
  63      =3  //                             // lsb at 0xE2, msb at 0xE5
  64      =3  //
  65      =3  // Target:         C8051xxxx
  66      =3  // Tool chain:     Generic
  67      =3  // Command Line:   None
  68      =3  // 
  69      =3  // Release 2.7 - 25 JUN 2014 (JM)
  70      =3  //    -Added SI_GENERIC_PTR struct for accessing generic pointers
  71      =3  //    -Added SI_GPTR_MTYPE_XXXX definitions for determining the memory type
  72      =3  //     pointed at by a generic poitner
  73      =3  // Release 2.6 - 14 DEC 2012 (GO)
  74      =3  //        -Added define for deprecated SDCC keyword 'at'
  75      =3  // Release 2.5 - 12 SEP 2012 (TP)
  76      =3  //    -Added defines for deprecated SDCC keywords bit and code
  77      =3  // Release 2.4 - 27 AUG 2012 (TP)
  78      =3  //    -Added defines for deprecated SDCC keywords interrupt, _asm, and _endasm
  79      =3  // Release 2.3 - 27 MAY 2010 (DM)
  80      =3  //    -Removed 'LOCATED_VARIABLE' pragma from Keil because it is not supported
  81      =3  // Release 2.2 - 06 APR 2010 (ES)
  82      =3  //    -Removed 'PATHINCLUDE' pragma from Raisonance section
  83      =3  // Release 2.1 - 16 JUL 2009 (ES)
  84      =3  //    -Added SEGMENT_POINTER macro definitions for SDCC, Keil, and Raisonance
  85      =3  //    -Added LOCATED_VARIABLE_NO_INIT macro definitions for Raisonance
  86      =3  // Release 2.0 - 19 MAY 2009 (ES)
  87      =3  //    -Added LOCATED_VARIABLE_NO_INIT macro definitions for SDCC and Keil
  88      =3  // Release 1.9 - 23 OCT 2008 (ES)
  89      =3  //    -Updated Hi-Tech INTERRUPT and INTERRUPT_USING macro definitions
  90      =3  //    -Added SFR16 macro defintion for Hi-Tech
  91      =3  // Release 1.8 - 31 JUL 2008 (ES)
  92      =3  //    -Added INTERRUPT_USING and FUNCTION_USING macro's
  93      =3  //    -Added macro's for IAR
  94      =3  //    -Corrected Union definitions for Hi-Tech and added SFR16 macro defintion
  95      =3  // Release 1.7 - 11 SEP 2007 (BW)
  96      =3  //    -Added support for Raisonance EVAL 03.03.42 and Tasking Eval 7.2r1
  97      =3  // Release 1.6 - 27 AUG 2007 (BW)
  98      =3  //    -Updated copyright notice per agreement with Maartin Brock
  99      =3  //    -Added SDCC 2.7.0 "compiler.h" bug fixes
 100      =3  //    -Added memory segment defines (SEG_XDATA, for example)
 101      =3  // Release 1.5 - 24 AUG 2007 (BW)
 102      =3  //    -Added support for NOP () macro
 103      =3  //    -Added support for Hi-Tech ver 9.01
 104      =3  // Release 1.4 - 07 AUG 2007 (PKC)
 105      =3  //    -Removed FID and fixed formatting.
 106      =3  // Release 1.3 - 30 SEP 2007 (TP)
 107      =3  //    -Added INTERRUPT_PROTO_USING to properly support ISR context switching
 108      =3  //     under SDCC.
 109      =3  // Release 1.2 - (BW)
 110      =3  //    -Added support for U8,U16,U32,S8,S16,S32,UU16,UU32 data types
 111      =3  // Release 1.1 - (BW)
 112      =3  //    -Added support for INTERRUPT, INTERRUPT_USING, INTERRUPT_PROTO,
 113      =3  //     SEGMENT_VARIABLE, VARIABLE_SEGMENT_POINTER,
 114      =3  //     SEGMENT_VARIABLE_SEGMENT_POINTER, and LOCATED_VARIABLE
 115      =3  // Release 1.0 - 29 SEP 2006 (PKC)
 116      =3  //    -Initial revision
 117      =3  
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 22  

 118      =3  //-----------------------------------------------------------------------------
 119      =3  // Header File Preprocessor Directive
 120      =3  //-----------------------------------------------------------------------------
 121      =3  
 122      =3  #ifndef COMPILER_DEFS_H
 123      =3  #define COMPILER_DEFS_H
 124      =3  
 125      =3  #include "stdbool.h"
   1      =4  /**************************************************************************//**
   2      =4   * Copyright (c) 2015 by Silicon Laboratories Inc. All rights reserved.
   3      =4   *
   4      =4   * http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   5      =4   *****************************************************************************/
   6      =4  
   7      =4  #ifndef STDBOOL_H
           =4 #define STDBOOL_H
           =4 
           =4 #if defined __C51__
           =4 
           =4 typedef bit bool;
           =4 enum{
           =4   false = 0,
           =4   true = 1,
           =4 };
           =4 
           =4 #elif defined __ICC8051__
           =4 
           =4 #ifndef _SYSTEM_BUILD
           =4   #pragma system_include
           =4 #endif
           =4 
           =4 #ifndef __cplusplus
           =4 
           =4 #define bool _Bool
           =4 #define true 1
           =4 #define false 0
           =4 
           =4 #define __bool_true_false_are_defined 1
           =4 
           =4 #endif /* !__cplusplus */
           =4 
           =4 #else  // __SLS_IDE__ : Macros defined to remove syntax errors within Simplicity Studio
           =4 
           =4 typedef bit bool;
           =4 enum{
           =4   false = 0,
           =4   true = 1,
           =4 };
           =4 
           =4 #endif
           =4 
           =4 #endif //STDBOOL_H
  45      =4  
 126      =3  #include "stdint.h"
   1      =4  /**************************************************************************//**
   2      =4   * Copyright (c) 2015 by Silicon Laboratories Inc. All rights reserved.
   3      =4   *
   4      =4   * http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   5      =4   *****************************************************************************/
   6      =4  
   7      =4  #ifndef STDINT_H
           =4 #define STDINT_H
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 23  

           =4 
           =4 #if defined __C51__
           =4 
           =4 typedef unsigned char uint8_t;
           =4 typedef unsigned short uint16_t;
           =4 typedef unsigned long uint32_t;
           =4 typedef uint32_t uint64_t[2];
           =4 
           =4 typedef signed char int8_t;
           =4 typedef short int16_t;
           =4 typedef long int32_t;
           =4 typedef int32_t int64_t[2];
           =4 typedef float fp32_t;
           =4 typedef double fp64_t;
           =4 
           =4 #elif defined __ICC8051__
           =4 
           =4 /* Fixed size types. These are all optional. */
           =4 #ifdef __INT8_T_TYPE__
           =4   typedef __INT8_T_TYPE__   int8_t;
           =4   typedef __UINT8_T_TYPE__ uint8_t;
           =4 #endif /* __INT8_T_TYPE__ */
           =4 
           =4 #ifdef __INT16_T_TYPE__
           =4   typedef __INT16_T_TYPE__   int16_t;
           =4   typedef __UINT16_T_TYPE__ uint16_t;
           =4 #endif /* __INT16_T_TYPE__ */
           =4 
           =4 #ifdef __INT32_T_TYPE__
           =4   typedef __INT32_T_TYPE__   int32_t;
           =4   typedef __UINT32_T_TYPE__ uint32_t;
           =4 #endif /* __INT32_T_TYPE__ */
           =4 
           =4 #ifdef __INT64_T_TYPE__
           =4   #pragma language=save
           =4   #pragma language=extended
           =4   typedef __INT64_T_TYPE__   int64_t;
           =4   typedef __UINT64_T_TYPE__ uint64_t;
           =4   #pragma language=restore
           =4 #endif /* __INT64_T_TYPE__ */
           =4 
           =4 #endif
           =4 
           =4 #endif
 127      =3  
 128      =3  //-----------------------------------------------------------------------------
 129      =3  // Macro definitions
 130      =3  //-----------------------------------------------------------------------------
 131      =3  
 132      =3  //SDK Version
 133      =3  #define SDK_VERSION   2
 134      =3  
 135      =3  #ifndef NULL
           =3 #define NULL ((void*) 0)
           =3 #endif
 138      =3  
 139      =3  
 140      =3  // SDCC - Small Device C Compiler
 141      =3  // http://sdcc.sourceforge.net
 142      =3  
 143      =3  #if defined SDCC
           =3 
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 24  

           =3 #if (SDCC >= 300)
           =3 
           =3 #define interrupt __interrupt
           =3 #define _asm __asm
           =3 #define _endasm __endasm
           =3 #define bit __bit
           =3 #define code __code
           =3 #define at __at
           =3 
           =3 #endif
           =3 
           =3 # define SEG_GENERIC
           =3 # define SEG_FAR   __xdata
           =3 # define SEG_DATA  __data
           =3 # define SEG_NEAR  __data
           =3 # define SEG_IDATA __idata
           =3 # define SEG_XDATA __xdata
           =3 # define SEG_PDATA __pdata
           =3 # define SEG_CODE  __code
           =3 # define SEG_BDATA __bdata
           =3 
           =3 # define SBIT(name, addr, bit)  __sbit  __at(addr+bit)                  name
           =3 # define SFR(name, addr)        __sfr   __at(addr)                      name
           =3 # define SFRX(name, addr)       xdata volatile unsigned char __at(addr) name
           =3 # define SFR16(name, addr)      __sfr16 __at(((addr+1U)<<8) | addr)     name
           =3 # define SFR16E(name, fulladdr) __sfr16 __at(fulladdr)                  name
           =3 # define SFR32(name, addr)      __sfr32 __at(((addr+3UL)<<24) | ((addr+2UL)<<16) | ((addr+1UL)<<8) | addr)
             - name
           =3 # define SFR32E(name, fulladdr) __sfr32 __at(fulladdr)                  name
           =3 
           =3 # define INTERRUPT(name, vector) void name (void) interrupt (vector)
           =3 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt (vector) using (regnum)
           =3 # define INTERRUPT_PROTO(name, vector) void name (void) interrupt (vector)
           =3 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void) interrupt (vector) using (regnum)
           =3 
           =3 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using (regnum
             -)
           =3 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter) using (
             -regnum)
           =3 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =3 
           =3 # define SEGMENT_VARIABLE(name, vartype, locsegment) locsegment vartype name
           =3 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) targsegment vartype * name
           =3 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) targsegment vartype * lo
             -csegment name
           =3 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
           =3 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment at (addr) vartype name = init
           =3 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) locsegment at (addr) vartype name
           =3 
           =3 // used with UU16
           =3 # define LSB 0
           =3 # define MSB 1
           =3 
           =3 // used with UU32 (b0 is least-significant byte)
           =3 # define b0 0
           =3 # define b1 1
           =3 # define b2 2
           =3 # define b3 3
           =3 
           =3 typedef unsigned char U8;
           =3 typedef unsigned int U16;
           =3 typedef unsigned long U32;
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 25  

           =3 
           =3 typedef signed char S8;
           =3 typedef signed int S16;
           =3 typedef signed long S32;
           =3 
           =3 typedef union UU16
           =3 {
           =3    U16 U16;
           =3    S16 S16;
           =3    U8 U8[2];
           =3    S8 S8[2];
           =3 } UU16;
           =3 
           =3 typedef union UU32
           =3 {
           =3    U32 U32;
           =3    S32 S32;
           =3    UU16 UU16[2];
           =3    U16 U16[2];
           =3    S16 S16[2];
           =3    U8 U8[4];
           =3    S8 S8[4];
           =3 } UU32;
           =3 
           =3 // NOP () macro support
           =3 #define NOP() _asm NOP _endasm
           =3 
           =3 // generic pointer memory type specifiers
           =3 #define SI_GPTR
           =3 #define SI_GPTR_MTYPE_DATA       0x40
           =3 #define SI_GPTR_MTYPE_IDATA      0x40
           =3 #define SI_GPTR_MTYPE_BDATA      0x40
           =3 #define SI_GPTR_MTYPE_PDATA      0x60
           =3 #define SI_GPTR_MTYPE_XDATA      0x00
           =3 #define SI_GPTR_MTYPE_CODE       0x80
           =3 
           =3 // generic pointer access struct
           =3 typedef union SI_GENERIC_PTR
           =3 {
           =3     U8 U8[3];
           =3     struct
           =3     {
           =3         UU16 ADDR;
           =3         U8 MTYPE;
           =3     } GPTR;
           =3 } SI_GENERIC_PTR;
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 // Raisonance (must be placed before Keil C51)
           =3 // http://www.raisonance.com
           =3 
           =3 #elif defined __RC51__
           =3 
           =3 //#error Raisonance C51 detected.
           =3 
           =3 # define SEG_GENERIC generic     //SEG_GENERIC only applies to pointers in Raisonance, not variables.
           =3 # define SEG_FAR   xdata
           =3 # define SEG_DATA  data
           =3 # define SEG_NEAR  data
           =3 # define SEG_IDATA idata
           =3 # define SEG_XDATA xdata
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 26  

           =3 # define SEG_PDATA pdata
           =3 # define SEG_CODE  code
           =3 # define SEG_BDATA bdata
           =3 
           =3 # define SBIT(name, addr, bit)  at (addr+bit) sbit         name
           =3 # define SFR(name, addr)        sfr at addr                name
           =3 # define SFR16(name, addr)      sfr16 at addr              name
           =3 # define SFR16E(name, fulladdr) /* not supported */
           =3 # define SFR32(name, fulladdr)  /* not supported */
           =3 # define SFR32E(name, fulladdr) /* not supported */
           =3 
           =3 # define INTERRUPT(name, vector) void name (void) interrupt vector
           =3 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
           =3 # define INTERRUPT_PROTO(name, vector) void name (void)
           =3 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
           =3 
           =3 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using regnum
           =3 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =3 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =3 
           =3 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =3 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =3 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =3 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
           =3 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) at addr locsegment vartype name
           =3 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) at addr locsegment vartype name
           =3 
           =3 
           =3 // used with UU16
           =3 # define LSB 1
           =3 # define MSB 0
           =3 
           =3 // used with UU32 (b0 is least-significant byte)
           =3 # define b0 3
           =3 # define b1 2
           =3 # define b2 1
           =3 # define b3 0
           =3 
           =3 typedef unsigned char U8;
           =3 typedef unsigned int U16;
           =3 typedef unsigned long U32;
           =3 
           =3 typedef signed char S8;
           =3 typedef signed int S16;
           =3 typedef signed long S32;
           =3 
           =3 typedef union UU16
           =3 {
           =3    U16 U16;
           =3    S16 S16;
           =3    U8 U8[2];
           =3    S8 S8[2];
           =3 } UU16;
           =3 
           =3 typedef union UU32
           =3 {
           =3    U32 U32;
           =3    S32 S32;
           =3    UU16 UU16[2];
           =3    U16 U16[2];
           =3    S16 S16[2];
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 27  

           =3    U8 U8[4];
           =3    S8 S8[4];
           =3 } UU32;
           =3 
           =3 // NOP () macro support -- NOP is opcode 0x00
           =3 #define NOP() asm { 0x00 }
           =3 
           =3 // generic pointer memory type specifiers
           =3 #define SI_GPTR
           =3 #define SI_GPTR_MTYPE_DATA       0x04
           =3 #define SI_GPTR_MTYPE_IDATA      0x01
           =3 #define SI_GPTR_MTYPE_BDATA      0x04
           =3 #define SI_GPTR_MTYPE_PDATA      0x03
           =3 #define SI_GPTR_MTYPE_XDATA      0x02
           =3 #define SI_GPTR_MTYPE_CODE       0x05
           =3 
           =3 // generic pointer access struct
           =3 typedef union SI_GENERIC_PTR
           =3 {
           =3     U8 U8[3];
           =3     struct
           =3     {
           =3         U8 MTYPE;
           =3         UU16 ADDR;
           =3     } GPTR;
           =3 } SI_GENERIC_PTR;
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 
           =3 // Keil C51
           =3 // http://www.keil.com
           =3 
           =3 #elif defined __C51__
 360      =3  
 361      =3  //#error Keil C51 detected.
 362      =3  
 363      =3  # define SEG_GENERIC
 364      =3  # define SEG_FAR   xdata
 365      =3  # define SEG_DATA  data
 366      =3  # define SEG_NEAR  data
 367      =3  # define SEG_IDATA idata
 368      =3  # define SEG_XDATA xdata
 369      =3  # define SEG_PDATA pdata
 370      =3  # define SEG_CODE  code
 371      =3  # define SEG_BDATA bdata
 372      =3  
 373      =3  # define SBIT(name, addr, bit)  sbit  name = addr^bit
 374      =3  # define SFR(name, addr)        sfr   name = addr
 375      =3  # define SFR16(name, addr)      sfr16 name = addr
 376      =3  # define SFR16E(name, fulladdr) /* not supported */
 377      =3  # define SFR32(name, fulladdr)  /* not supported */
 378      =3  # define SFR32E(name, fulladdr) /* not supported */
 379      =3  
 380      =3  # ifndef __SLS_IDE__
 381      =3  
 382      =3  # define INTERRUPT(name, vector) void name (void) interrupt vector
 383      =3  # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
 384      =3  # define INTERRUPT_PROTO(name, vector) void name (void)
 385      =3  # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
 386      =3  
 387      =3  # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using regnum
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 28  

 388      =3  # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter)
 389      =3  // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
 390      =3  
 391      =3  # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
 392      =3  # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
 393      =3  # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
 394      =3  # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
 395      =3  # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) vartype locsegment name _at_ addr
 396      =3  
 397      =3  # else  // __SLS_IDE__
           =3 
           =3 # define INTERRUPT(name, vector) void name (void)
           =3 # define INTERRUPT_USING(name, vector, regnum) void name (void)
           =3 # define INTERRUPT_PROTO(name, vector) void name (void)
           =3 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
           =3 
           =3 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =3 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =3 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =3 
           =3 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype name
           =3 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype * name
           =3 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype * name
           =3 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * name
           =3 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) vartype name
           =3 
           =3 # endif // __SLS_IDE__
 415      =3  
 416      =3  // used with UU16
 417      =3  # define LSB 1
 418      =3  # define MSB 0
 419      =3  
 420      =3  // used with UU32 (b0 is least-significant byte)
 421      =3  # define b0 3
 422      =3  # define b1 2
 423      =3  # define b2 1
 424      =3  # define b3 0
 425      =3  
 426      =3  typedef unsigned char U8;
 427      =3  typedef unsigned int U16;
 428      =3  typedef unsigned long U32;
 429      =3  
 430      =3  typedef signed char S8;
 431      =3  typedef signed int S16;
 432      =3  typedef signed long S32;
 433      =3  
 434      =3  typedef union UU16
 435      =3  {
 436      =3     U16 U16;
 437      =3     S16 S16;
 438      =3     U8 U8[2];
 439      =3     S8 S8[2];
 440      =3  } UU16;
 441      =3  
 442      =3  typedef union UU32
 443      =3  {
 444      =3     U32 U32;
 445      =3     S32 S32;
 446      =3     UU16 UU16[2];
 447      =3     U16 U16[2];
 448      =3     S16 S16[2];
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 29  

 449      =3     U8 U8[4];
 450      =3     S8 S8[4];
 451      =3  } UU32;
 452      =3  
 453      =3  // NOP () macro support
 454      =3  extern void _nop_ (void);
 455      =3  #define NOP() _nop_()
 456      =3  
 457      =3  // generic pointer memory type specifiers
 458      =3  #define SI_GPTR
 459      =3  #define SI_GPTR_MTYPE_DATA      0x00
 460      =3  #define SI_GPTR_MTYPE_IDATA     0x00
 461      =3  #define SI_GPTR_MTYPE_BDATA     0x00
 462      =3  #define SI_GPTR_MTYPE_PDATA     0xFE
 463      =3  #define SI_GPTR_MTYPE_XDATA     0x01
 464      =3  #define SI_GPTR_MTYPE_CODE      0xFF
 465      =3  
 466      =3  // generic pointer access struct
 467      =3  typedef union SI_GENERIC_PTR
 468      =3  {
 469      =3      U8 U8[3];
 470      =3      struct
 471      =3      {
 472      =3          U8 MTYPE;
 473      =3          UU16 ADDR;
 474      =3      } GPTR;
 475      =3  } SI_GENERIC_PTR;
 476      =3  
 477      =3  //-----------------------------------------------------------------------------
 478      =3  
 479      =3  // Hi-Tech 8051
 480      =3  // http://www.htsoft.com
 481      =3  
 482      =3  #elif defined HI_TECH_C
           =3 
           =3 # define SEG_GENERIC
           =3 # define SEG_FAR   far
           =3 # define SEG_DATA  data
           =3 # define SEG_NEAR  near
           =3 # define SEG_IDATA idata
           =3 # define SEG_XDATA xdata
           =3 # define SEG_PDATA pdata
           =3 # define SEG_CODE  code
           =3 # define SEG_BDATA bdata
           =3 
           =3 
           =3 # define SBIT(name, addr, thebit) static volatile bit name @ (addr + thebit)
           =3 # define SFR(name, addr)          static volatile unsigned char name @ addr
           =3 # define SFR16(name, addr)        static volatile unsigned int name @ addr
           =3 # define SFR16E(name, fulladdr) /* not supported */
           =3 # define SFR32(name, fulladdr)  /* not supported */
           =3 # define SFR32E(name, fulladdr) /* not supported */
           =3 
           =3 # define INTERRUPT(name, vector)       void name (void) interrupt vector
           =3 # define INTERRUPT_PROTO(name, vector)
           =3 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
           =3 # define INTERRUPT_PROTO_USING(name, vector, regnum)
           =3 
           =3 # define FUNCTION_USING(name, return_value, parameter, regnum) /* not supported */
           =3 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) /* not supported */
           =3 // Note: Hi-Tech does not support functions using different register banks. Register
           =3 //       banks can only be specified in interrupts. If a function is called from
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 30  

           =3 //       inside an interrupt, it will use the same register bank as the interrupt.
           =3 
           =3 # define SEGMENT_VARIABLE(name, vartype, locsegment) locsegment vartype name
           =3 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) targsegment vartype * name
           =3 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) targsegment vartype * lo
             -csegment name
           =3 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment vartype name @ addr
           =3 
           =3 // used with UU16
           =3 # define LSB 0
           =3 # define MSB 1
           =3 
           =3 // used with UU32 (b0 is least-significant byte)
           =3 # define b0 0
           =3 # define b1 1
           =3 # define b2 2
           =3 # define b3 3
           =3 
           =3 typedef unsigned char U8;
           =3 typedef unsigned int U16;
           =3 typedef unsigned long U32;
           =3 
           =3 typedef signed char S8;
           =3 typedef signed int S16;
           =3 typedef signed long S32;
           =3 
           =3 typedef union UU16
           =3 {
           =3    U16 U16;
           =3    S16 S16;
           =3    U8 U8[2];
           =3    S8 S8[2];
           =3 } UU16;
           =3 
           =3 typedef union UU32
           =3 {
           =3    U32 U32;
           =3    S32 S32;
           =3    UU16 UU16[2];
           =3    U16 U16[2];
           =3    S16 S16[2];
           =3    U8 U8[4];
           =3    S8 S8[4];
           =3 } UU32;
           =3 
           =3 // NOP () macro support
           =3 #define NOP() asm(" nop ")
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 // Tasking / Altium
           =3 // http://www.altium.com/tasking
           =3 
           =3 
           =3 #elif defined _CC51
           =3 
           =3 # define SEG_GENERIC
           =3 # define SEG_FAR   _xdat
           =3 # define SEG_DATA  _data
           =3 # define SEG_NEAR  _data
           =3 # define SEG_IDATA _idat
           =3 # define SEG_XDATA _xdat
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 31  

           =3 # define SEG_PDATA _pdat
           =3 # define SEG_CODE  _rom
           =3 # define SEG_BDATA _bdat
           =3 
           =3 # define SBIT(name, addr, bit)  _sfrbit  name _at(addr+bit)
           =3 # define SFR(name, addr)        _sfrbyte name _at(addr)
           =3 # define SFRX(name, addr)       _xdat volatile unsigned char name _at(addr)
           =3 #if _CC51 > 71
           =3 # define SFR16(name, addr)      _sfrword _little name _at(addr)
           =3 #else
           =3 # define SFR16(name, addr)      /* not supported */
           =3 #endif
           =3 # define SFR16E(name, fulladdr) /* not supported */
           =3 # define SFR32(name, fulladdr)  /* not supported */
           =3 # define SFR32E(name, fulladdr) /* not supported */
           =3 
           =3 # define INTERRUPT(name, vector) _interrupt (vector) void name (void)
           =3 # define INTERRUPT_USING(name, vector, regnum) _interrupt (vector) _using(regnum) void name (void)
           =3 # define INTERRUPT_PROTO(name, vector) _interrupt (vector) void name (void)
           =3 # define INTERRUPT_PROTO_USING(name, vector, regnum) _interrupt (vector) _using(regnum) void name (void)
           =3 
           =3 // When calling FUNCTION_USING in Tasking, the function must be called from an interrupt or Main which
           =3 // is also using the same register bank. If not, the compiler will generate an error.
           =3 # define FUNCTION_USING(name, return_value, parameter, regnum) _using(regnum) return_value name (parameter
             -)
           =3 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) _using(regnum) return_value name (par
             -ameter)
           =3 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =3 
           =3 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =3 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =3 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =3 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) vartype locsegment name _at( addr )
           =3 
           =3 // used with UU16
           =3 # define LSB 1
           =3 # define MSB 0
           =3 
           =3 // used with UU32 (b0 is least-significant byte)
           =3 # define b0 3
           =3 # define b1 2
           =3 # define b2 1
           =3 # define b3 0
           =3 
           =3 typedef unsigned char U8;
           =3 typedef unsigned int U16;
           =3 typedef unsigned long U32;
           =3 
           =3 typedef signed char S8;
           =3 typedef signed int S16;
           =3 typedef signed long S32;
           =3 
           =3 typedef union UU16
           =3 {
           =3    U16 U16;
           =3    S16 S16;
           =3    U8 U8[2];
           =3    S8 S8[2];
           =3 } UU16;
           =3 
           =3 typedef union UU32
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 32  

           =3 {
           =3    U32 U32;
           =3    S32 S32;
           =3    UU16 UU16[2];
           =3    U16 U16[2];
           =3    S16 S16[2];
           =3    U8 U8[4];
           =3    S8 S8[4];
           =3 } UU32;
           =3 
           =3 // NOP () macro support
           =3 extern void _nop (void);
           =3 #define NOP() _nop()
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 
           =3 // IAR 8051
           =3 // http://www.iar.com
           =3 
           =3 #elif defined __ICC8051__
           =3 
           =3 #include <stdbool.h>
           =3 #include <intrinsics.h>
           =3 
           =3 # define SBIT(name, addr, bit)  __bit __no_init volatile bool name @ (addr+bit)
           =3 # define SFR(name, addr)        __sfr __no_init volatile unsigned char name @ addr
           =3 # define SFRX(name, addr)       __xdata __no_init volatile unsigned char name @ addr
           =3 # define SFR16(name, addr)      __sfr __no_init volatile unsigned int  name @ addr
           =3 # define SFR16E(name, fulladdr) /* not supported */
           =3 # define SFR32(name, fulladdr) /* not supported */
           =3 # define SFR32E(name, fulladdr) /* not supported */
           =3 
           =3 # define SEG_GENERIC __generic
           =3 # define SEG_FAR  __xdata
           =3 # define SEG_DATA __data
           =3 # define SEG_NEAR __data
           =3 # define SEG_IDATA __idata
           =3 # define SEG_XDATA __xdata
           =3 # define SEG_PDATA __pdata
           =3 # define SEG_CODE  __code
           =3 # define SEG_BDATA __bdata
           =3 
           =3 #define bit bool
           =3 
           =3 # define _PPTOSTR_(x) #x
           =3 # define _PPARAM_(address) _PPTOSTR_(vector=address * 8 + 3)
           =3 # define _PPARAM2_(regbank) _PPTOSTR_(register_bank=regbank)
           =3 # define INTERRUPT(name, vector) _Pragma(_PPARAM_(vector)) __interrupt void name(void)
           =3 # define INTERRUPT_PROTO(name, vector)  __interrupt void name(void)
           =3 # define INTERRUPT_USING(name, vector, regnum) _Pragma(_PPARAM2_(regnum)) _Pragma(_PPARAM_(vector)) __inte
             -rrupt void name(void)
           =3 # define INTERRUPT_PROTO_USING(name, vector, regnum) __interrupt void name(void)
           =3 
           =3 # define FUNCTION_USING(name, return_value, parameter, regnum) /* not supported */
           =3 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) /* not supported */
           =3 // Note: IAR does not support functions using different register banks. Register
           =3 //       banks can only be specified in interrupts. If a function is called from
           =3 //       inside an interrupt, it will use the same register bank as the interrupt.
           =3 
           =3 # define SEGMENT_VARIABLE(name, vartype, locsegment)  locsegment vartype name
           =3 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment  * name
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 33  

           =3 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =3 
           =3 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment __no_init vartype name @ addr
           =3 
           =3 // used with UU16
           =3 # define LSB 0
           =3 # define MSB 1
           =3 
           =3 // used with UU32 (b0 is least-significant byte)
           =3 # define b0 0
           =3 # define b1 1
           =3 # define b2 2
           =3 # define b3 3
           =3 
           =3 typedef unsigned char U8;
           =3 typedef unsigned int U16;
           =3 typedef unsigned long U32;
           =3 
           =3 typedef signed char S8;
           =3 typedef signed int S16;
           =3 typedef signed long S32;
           =3 
           =3 typedef union UU16
           =3 {
           =3    U16 U16;
           =3    S16 S16;
           =3    U8 U8[2];
           =3    S8 S8[2];
           =3 } UU16;
           =3 
           =3 typedef union UU32
           =3 {
           =3    U32 U32;
           =3    S32 S32;
           =3    UU16 UU16[2];
           =3    U16 U16[2];
           =3    S16 S16[2];
           =3    U8 U8[4];
           =3    S8 S8[4];
           =3 } UU32;
           =3 
           =3 
           =3 #define NOP() __no_operation();
           =3 
           =3 // generic pointer memory type specifiers
           =3 #define SI_GPTR
           =3 #define SI_GPTR_MTYPE_DATA       0x01
           =3 #define SI_GPTR_MTYPE_IDATA      0x01
           =3 #define SI_GPTR_MTYPE_BDATA      0x01
           =3 #define SI_GPTR_MTYPE_PDATA      0x00
           =3 #define SI_GPTR_MTYPE_XDATA      0x00
           =3 #define SI_GPTR_MTYPE_CODE       0x80
           =3 
           =3 // generic pointer access struct
           =3 typedef union SI_GENERIC_PTR
           =3 {
           =3     U8 U8[3];
           =3     struct
           =3     {
           =3         UU16 ADDR;
           =3         U8 MTYPE;
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 34  

           =3     } GPTR;
           =3 } SI_GENERIC_PTR;
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 // Crossware
           =3 // http://www.crossware.com
           =3 
           =3 #elif defined _XC51_VER
           =3 # define SBIT(name, addr, bit)  _sfrbit  name = (addr+bit)
           =3 # define SFR(name, addr)        _sfr     name = addr
           =3 # define SFR16(name, addr)      _sfrword name = addr
           =3 # define SFR16E(name, fulladdr) /* not supported */
           =3 # define SFR32(name, fulladdr)  /* not supported */
           =3 # define SFR32E(name, fulladdr) /* not supported */
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 // Wickenh盲user
           =3 // http://www.wickenhaeuser.de
           =3 
           =3 #elif defined __UC__
           =3 # define SBIT(name, addr, bit)  unsigned char bit  name @ (addr+bit)
           =3 # define SFR(name, addr)        near unsigned char name @ addr
           =3 # define SFR16(name, addr)      /* not supported */
           =3 # define SFR16E(name, fulladdr) /* not supported */
           =3 # define SFR32(name, fulladdr)  /* not supported */
           =3 # define SFR32E(name, fulladdr) /* not supported */
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 // Default
           =3 // Unknown compiler
           =3 
           =3 #else
           =3 # warning unrecognized compiler
           =3 # define SBIT(name, addr, bit)  volatile bool           name
           =3 # define SFR(name, addr)        volatile unsigned char  name
           =3 # define SFRX(name, addr)       volatile unsigned char  name
           =3 # define SFR16(name, addr)      volatile unsigned short name
           =3 # define SFR16E(name, fulladdr) volatile unsigned short name
           =3 # define SFR32(name, fulladdr)  volatile unsigned long  name
           =3 # define SFR32E(name, fulladdr) volatile unsigned long  name
           =3 
           =3 #endif
 798      =3  
 799      =3  //-----------------------------------------------------------------------------
 800      =3  // Header File PreProcessor Directive
 801      =3  //-----------------------------------------------------------------------------
 802      =3  
 803      =3  #endif                                 // #define COMPILER_DEFS_H
 804      =3  
 805      =3  //-----------------------------------------------------------------------------
 806      =3  // End Of File
 807      =3  //-----------------------------------------------------------------------------
 121      =2  #ifdef C8051F020
 122      =2  #include "C8051F020_defs.h"
   1      =3  //-----------------------------------------------------------------------------
   2      =3  // C8051F020_defs.h
   3      =3  //-----------------------------------------------------------------------------
   4      =3  // Copyright 2007, Silicon Laboratories, Inc.
   5      =3  // http://www.silabs.com
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 35  

   6      =3  //
   7      =3  // Program Description:
   8      =3  //
   9      =3  // Register/bit definitions for the C8051F02x family.
  10      =3  // **Important Note**: The compiler_defs.h header file should be included
  11      =3  // before including this header file.
  12      =3  //
  13      =3  // Target:         C8051F020, 'F021, 'F022, 'F023
  14      =3  // Tool chain:     Generic
  15      =3  // Command Line:   None
  16      =3  //
  17      =3  // Release 1.4 - 20 AUG 2012 (TP)
  18      =3  //    -Added #define for _XPAGE to provide support for SDCC memory paging
  19      =3  //     (pdata)
  20      =3  // Release 1.3 - 07 AUG 2007 (PKC)
  21      =3  //    -Removed #include <compiler_defs.h>. The C source file should include it.
  22      =3  // Release 1.2 - 09 JUL 2007 (PKC)
  23      =3  //    -Reformatted header file to enable portable SFR definitions
  24      =3  
  25      =3  //-----------------------------------------------------------------------------
  26      =3  // Header File Preprocessor Directive
  27      =3  //-----------------------------------------------------------------------------
  28      =3  
  29      =3  #ifndef C8051F020_DEFS_H
  30      =3  #define C8051F020_DEFS_H
  31      =3  
  32      =3  //-----------------------------------------------------------------------------
  33      =3  // Byte Registers
  34      =3  //-----------------------------------------------------------------------------
  35      =3  
  36      =3  SFR (P0, 0x80);                        // Port 0 Latch
  37      =3  SFR (SP, 0x81);                        // Stack Pointer
  38      =3  SFR (DPL, 0x82);                       // Data Pointer Low
  39      =3  SFR (DPH, 0x83);                       // Data Pointer High
  40      =3  SFR (P4, 0x84);                        // Port 4 Latch
  41      =3  SFR (P5, 0x85);                        // Port 5 Latch
  42      =3  SFR (P6, 0x86);                        // Port 6 Latch
  43      =3  SFR (PCON, 0x87);                      // Power Control
  44      =3  SFR (TCON, 0x88);                      // Timer/Counter Control
  45      =3  SFR (TMOD, 0x89);                      // Timer/Counter Mode
  46      =3  SFR (TL0, 0x8A);                       // Timer/Counter 0 Low
  47      =3  SFR (TL1, 0x8B);                       // Timer/Counter 1 Low
  48      =3  SFR (TH0, 0x8C);                       // Timer/Counter 0 High
  49      =3  SFR (TH1, 0x8D);                       // Timer/Counter 1 High
  50      =3  SFR (CKCON, 0x8E);                     // Clock Control
  51      =3  SFR (PSCTL, 0x8F);                     // Program Store R/W Control
  52      =3  SFR (P1, 0x90);                        // Port 1 Latch
  53      =3  SFR (TMR3CN, 0x91);                    // Timer/Counter 3 Control
  54      =3  SFR (TMR3RLL, 0x92);                   // Timer/Counter 3 Reload Low
  55      =3  SFR (TMR3RLH, 0x93);                   // Timer/Counter 3 Reload High
  56      =3  SFR (TMR3L, 0x94);                     // Timer/Counter 3 Low
  57      =3  SFR (TMR3H, 0x95);                     // Timer/Counter 3 High
  58      =3  SFR (P7, 0x96);                        // Port 7 Latch
  59      =3  SFR (SCON0, 0x98);                     // Serial Port UART0 Control
  60      =3  SFR (SBUF0, 0x99);                     // Serial Port UART0 Data Buffer
  61      =3  SFR (SPI0CFG, 0x9A);                   // SPI0 Configuration
  62      =3  SFR (SPI0DAT, 0x9B);                   // SPI0 Data
  63      =3  SFR (ADC1, 0x9C);                      // ADC1 Data
  64      =3  SFR (SPI0CKR, 0x9D);                   // SPI0 Clock Rate Control
  65      =3  SFR (CPT0CN, 0x9E);                    // Comparator 0 Control
  66      =3  SFR (CPT1CN, 0x9F);                    // Comparator 1 Control
  67      =3  SFR (P2, 0xA0);                        // Port 2 Latch
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 36  

  68      =3  SFR (EMI0TC, 0xA1);                    // EMIF Timing Control
  69      =3  SFR (EMI0CF, 0xA3);                    // EMIF Configuration
  70      =3  SFR (P0MDOUT, 0xA4);                   // Port 0 Output Mode Configuration
  71      =3  SFR (P1MDOUT, 0xA5);                   // Port 1 Output Mode Configuration
  72      =3  SFR (P2MDOUT, 0xA6);                   // Port 2 Output Mode Configuration
  73      =3  SFR (P3MDOUT, 0xA7);                   // Port 3 Output Mode Configuration
  74      =3  SFR (IE, 0xA8);                        // Interrupt Enable
  75      =3  SFR (SADDR0, 0xA9);                    // Serial Port UART0 Slave Address
  76      =3  SFR (ADC1CN, 0xAA);                    // ADC1 Control
  77      =3  SFR (ADC1CF, 0xAB);                    // ADC1 Analog Mux Configuration
  78      =3  SFR (AMX1SL, 0xAC);                    // ADC1 Analog Mux Channel Select
  79      =3  SFR (P3IF, 0xAD);                      // Port 3 External Interrupt Flags
  80      =3  SFR (SADEN1, 0xAE);                    // Serial Port UART1 Slave Address Mask
  81      =3  SFR (EMI0CN, 0xAF);                    // EMIF Control
  82      =3  SFR (P3, 0xB0);                        // Port 3 Latch
  83      =3  SFR (OSCXCN, 0xB1);                    // External Oscillator Control
  84      =3  SFR (OSCICN, 0xB2);                    // Internal Oscillator Control
  85      =3  SFR (P74OUT, 0xB5);                    // Ports 4 - 7 Output Mode
  86      =3  SFR (FLSCL, 0xB6);                     // Flash Memory Timing Prescaler
  87      =3  SFR (FLACL, 0xB7);                     // Flash Acess Limit
  88      =3  SFR (IP, 0xB8);                        // Interrupt Priority
  89      =3  SFR (SADEN0, 0xB9);                    // Serial Port UART0 Slave Address Mask
  90      =3  SFR (AMX0CF, 0xBA);                    // ADC0 Mux Configuration
  91      =3  SFR (AMX0SL, 0xBB);                    // ADC0 Mux Channel Selection
  92      =3  SFR (ADC0CF, 0xBC);                    // ADC0 Configuration
  93      =3  SFR (P1MDIN, 0xBD);                    // Port 1 Input Mode
  94      =3  SFR (ADC0L, 0xBE);                     // ADC0 Data Low
  95      =3  SFR (ADC0H, 0xBF);                     // ADC0 Data High
  96      =3  SFR (SMB0CN, 0xC0);                    // SMBus0 Control
  97      =3  SFR (SMB0STA, 0xC1);                   // SMBus0 Status
  98      =3  SFR (SMB0DAT, 0xC2);                   // SMBus0 Data
  99      =3  SFR (SMB0ADR, 0xC3);                   // SMBus0 Slave Address
 100      =3  SFR (ADC0GTL, 0xC4);                   // ADC0 Greater-Than Register Low
 101      =3  SFR (ADC0GTH, 0xC5);                   // ADC0 Greater-Than Register High
 102      =3  SFR (ADC0LTL, 0xC6);                   // ADC0 Less-Than Register Low
 103      =3  SFR (ADC0LTH, 0xC7);                   // ADC0 Less-Than Register High
 104      =3  SFR (T2CON, 0xC8);                     // Timer/Counter 2 Control
 105      =3  SFR (T4CON, 0xC9);                     // Timer/Counter 4 Control
 106      =3  SFR (RCAP2L, 0xCA);                    // Timer/Counter 2 Capture Low
 107      =3  SFR (RCAP2H, 0xCB);                    // Timer/Counter 2 Capture High
 108      =3  SFR (TL2, 0xCC);                       // Timer/Counter 2 Low
 109      =3  SFR (TH2, 0xCD);                       // Timer/Counter 2 High
 110      =3  SFR (SMB0CR, 0xCF);                    // SMBus0 Clock Rate
 111      =3  SFR (PSW, 0xD0);                       // Program Status Word
 112      =3  SFR (REF0CN, 0xD1);                    // Voltage Reference 0 Control
 113      =3  SFR (DAC0L, 0xD2);                     // DAC0 Register Low
 114      =3  SFR (DAC0H, 0xD3);                     // DAC0 Register High
 115      =3  SFR (DAC0CN, 0xD4);                    // DAC0 Control
 116      =3  SFR (DAC1L, 0xD5);                     // DAC1 Register Low
 117      =3  SFR (DAC1H, 0xD6);                     // DAC1 Register High
 118      =3  SFR (DAC1CN, 0xD7);                    // DAC1 Control
 119      =3  SFR (PCA0CN, 0xD8);                    // PCA0 Control
 120      =3  SFR (PCA0MD, 0xD9);                    // PCA0 Mode
 121      =3  SFR (PCA0CPM0, 0xDA);                  // PCA0 Module 0 Mode Register
 122      =3  SFR (PCA0CPM1, 0xDB);                  // PCA0 Module 1 Mode Register
 123      =3  SFR (PCA0CPM2, 0xDC);                  // PCA0 Module 2 Mode Register
 124      =3  SFR (PCA0CPM3, 0xDD);                  // PCA0 Module 3 Mode Register
 125      =3  SFR (PCA0CPM4, 0xDE);                  // PCA0 Module 4 Mode Register
 126      =3  SFR (ACC, 0xE0);                       // Accumulator
 127      =3  SFR (XBR0, 0xE1);                      // Port I/O Crossbar Control 0
 128      =3  SFR (XBR1, 0xE2);                      // Port I/O Crossbar Control 1
 129      =3  SFR (XBR2, 0xE3);                      // Port I/O Crossbar Control 2
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 37  

 130      =3  SFR (RCAP4L, 0xE4);                    // Timer 4 Capture Register Low
 131      =3  SFR (RCAP4H, 0xE5);                    // Timer 4 Capture Register High
 132      =3  SFR (EIE1, 0xE6);                      // External Interrupt Enable 1
 133      =3  SFR (EIE2, 0xE7);                      // External Interrupt Enable 2
 134      =3  SFR (ADC0CN, 0xE8);                    // ADC0 Control
 135      =3  SFR (PCA0L, 0xE9);                     // PCA0 Counter Low
 136      =3  SFR (PCA0CPL0, 0xEA);                  // PCA0 Capture 0 Low
 137      =3  SFR (PCA0CPL1, 0xEB);                  // PCA0 Capture 1 Low
 138      =3  SFR (PCA0CPL2, 0xEC);                  // PCA0 Capture 2 Low
 139      =3  SFR (PCA0CPL3, 0xED);                  // PCA0 Capture 3 Low
 140      =3  SFR (PCA0CPL4, 0xEE);                  // PCA0 Capture 4 Low
 141      =3  SFR (RSTSRC, 0xEF);                    // Reset Source Configuration/Status
 142      =3  SFR (B, 0xF0);                         // B Register
 143      =3  SFR (SCON1, 0xF1);                     // Serial Port UART1 Control
 144      =3  SFR (SBUF1, 0xF2);                     // Serail Port UART1 Data
 145      =3  SFR (SADDR1, 0xF3);                    // Serail Port UART1 Slave Address
 146      =3  SFR (TL4, 0xF4);                       // Timer/Counter 4 Low
 147      =3  SFR (TH4, 0xF5);                       // Timer/Counter 4 High
 148      =3  SFR (EIP1, 0xF6);                      // External Interrupt Priority 1
 149      =3  SFR (EIP2, 0xF7);                      // External Interrupt Priority 2
 150      =3  SFR (SPI0CN, 0xF8);                    // SPI0 Control
 151      =3  SFR (PCA0H, 0xF9);                     // PCA0 Counter High
 152      =3  SFR (PCA0CPH0, 0xFA);                  // PCA0 Capture 0 High
 153      =3  SFR (PCA0CPH1, 0xFB);                  // PCA0 Capture 1 High
 154      =3  SFR (PCA0CPH2, 0xFC);                  // PCA0 Capture 2 High
 155      =3  SFR (PCA0CPH3, 0xFD);                  // PCA0 Capture 3 High
 156      =3  SFR (PCA0CPH4, 0xFE);                  // PCA0 Capture 4 High
 157      =3  SFR (WDTCN, 0xFF);                     // Watchdog Timer Control
 158      =3  
 159      =3  //-----------------------------------------------------------------------------
 160      =3  // 16-bit Register Definitions (might not be supported by all compilers)
 161      =3  //-----------------------------------------------------------------------------
 162      =3  
 163      =3  SFR16 (DP, 0x82);                      // Data Pointer
 164      =3  SFR16 (TMR3RL, 0x92);                  // Timer3 Reload Value
 165      =3  SFR16 (TMR3, 0x94);                    // Timer3 Counter
 166      =3  SFR16 (ADC0, 0xBE);                    // ADC0 Data
 167      =3  SFR16 (ADC0GT, 0xC4);                  // ADC0 Greater Than Window
 168      =3  SFR16 (ADC0LT, 0xC6);                  // ADC0 Less Than Window
 169      =3  SFR16 (RCAP2, 0xCA);                   // Timer2 Capture/Reload
 170      =3  SFR16 (T2, 0xCC);                      // Timer2 Counter
 171      =3  SFR16 (TMR2RL, 0xCA);                  // Timer2 Capture/Reload
 172      =3  SFR16 (TMR2, 0xCC);                    // Timer2 Counter
 173      =3  SFR16 (RCAP4, 0xE4);                   // Timer4 Capture/Reload
 174      =3  SFR16 (T4, 0xF4);                      // Timer4 Counter
 175      =3  SFR16 (TMR4RL, 0xE4);                  // Timer4 Capture/Reload
 176      =3  SFR16 (TMR4, 0xF4);                    // Timer4 Counter
 177      =3  SFR16 (DAC0, 0xD2);                    // DAC0 Data
 178      =3  SFR16 (DAC1, 0xD5);                    // DAC1 Data
 179      =3  
 180      =3  //-----------------------------------------------------------------------------
 181      =3  // Address Definitions for bit-addressable SFRs
 182      =3  //-----------------------------------------------------------------------------
 183      =3  
 184      =3  #define SFR_P0       0x80
 185      =3  #define SFR_TCON     0x88
 186      =3  #define SFR_P1       0x90
 187      =3  #define SFR_SCON0    0x98
 188      =3  #define SFR_P2       0xA0
 189      =3  #define SFR_IE       0xA8
 190      =3  #define SFR_P3       0xB0
 191      =3  #define SFR_IP       0xB8
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 38  

 192      =3  #define SFR_SMB0CN   0xC0
 193      =3  #define SFR_T2CON    0xC8
 194      =3  #define SFR_PSW      0xD0
 195      =3  #define SFR_PCA0CN   0xD8
 196      =3  #define SFR_ACC      0xE0
 197      =3  #define SFR_ADC0CN   0xE8
 198      =3  #define SFR_B        0xF0
 199      =3  #define SFR_SPI0CN   0xF8
 200      =3  
 201      =3  //-----------------------------------------------------------------------------
 202      =3  // Bit Definitions
 203      =3  //-----------------------------------------------------------------------------
 204      =3  
 205      =3  // TCON 0x88
 206      =3  SBIT (TF1, SFR_TCON, 7);               // Timer 1 Overflow Flag
 207      =3  SBIT (TR1, SFR_TCON, 6);               // Timer 1 On/Off Control
 208      =3  SBIT (TF0, SFR_TCON, 5);               // Timer 0 Overflow Flag
 209      =3  SBIT (TR0, SFR_TCON, 4);               // Timer 0 On/Off Control
 210      =3  SBIT (IE1, SFR_TCON, 3);               // Ext. Interrupt 1 Edge Flag
 211      =3  SBIT (IT1, SFR_TCON, 2);               // Ext. Interrupt 1 Type
 212      =3  SBIT (IE0, SFR_TCON, 1);               // Ext. Interrupt 0 Edge Flag
 213      =3  SBIT (IT0, SFR_TCON, 0);               // Ext. Interrupt 0 Type
 214      =3  
 215      =3  // SCON0 0x98
 216      =3  SBIT (SM00, SFR_SCON0, 7);             // Serial Mode Control Bit 0
 217      =3  SBIT (SM10, SFR_SCON0, 6);             // Serial Mode Control Bit 1
 218      =3  SBIT (SM20, SFR_SCON0, 5);             // Multiprocessor Communication Enable
 219      =3  SBIT (REN0, SFR_SCON0, 4);             // Receive Enable
 220      =3  SBIT (TB80, SFR_SCON0, 3);             // Transmit Bit 8
 221      =3  SBIT (RB80, SFR_SCON0, 2);             // Receive Bit 8
 222      =3  SBIT (TI0, SFR_SCON0, 1);              // Transmit Interrupt Flag
 223      =3  SBIT (RI0, SFR_SCON0, 0);              // Receive Interrupt Flag
 224      =3  
 225      =3  // IE 0xA8
 226      =3  SBIT (EA, SFR_IE, 7);                  // Global Interrupt Enable
 227      =3  SBIT (IEGF0, SFR_IE, 6);               // General Purpose Flag 0
 228      =3  SBIT (ET2, SFR_IE, 5);                 // Timer 2 Interrupt Enable
 229      =3  SBIT (ES0, SFR_IE, 4);                 // Uart0 Interrupt Enable
 230      =3  SBIT (ET1, SFR_IE, 3);                 // Timer 1 Interrupt Enable
 231      =3  SBIT (EX1, SFR_IE, 2);                 // External Interrupt 1 Enable
 232      =3  SBIT (ET0, SFR_IE, 1);                 // Timer 0 Interrupt Enable
 233      =3  SBIT (EX0, SFR_IE, 0);                 // External Interrupt 0 Enable
 234      =3  
 235      =3  // IP 0xB8
 236      =3                                         // Bit7 UNUSED
 237      =3                                         // Bit6 UNUSED
 238      =3  SBIT (PT2, SFR_IP, 5);                 // Timer 2 Priority
 239      =3  SBIT (PS, SFR_IP, 4);                  // Serial Port Priority
 240      =3  SBIT (PT1, SFR_IP, 3);                 // Timer 1 Priority
 241      =3  SBIT (PX1, SFR_IP, 2);                 // External Interrupt 1 Priority
 242      =3  SBIT (PT0, SFR_IP, 1);                 // Timer 0 Priority
 243      =3  SBIT (PX0, SFR_IP, 0);                 // External Interrupt 0 Priority
 244      =3  
 245      =3  // SMB0CN 0xC0
 246      =3  SBIT (BUSY, SFR_SMB0CN, 7);            // SMBus 0 Busy
 247      =3  SBIT (ENSMB, SFR_SMB0CN, 6);           // SMBus 0 Enable
 248      =3  SBIT (STA, SFR_SMB0CN, 5);             // SMBus 0 Start Flag
 249      =3  SBIT (STO, SFR_SMB0CN, 4);             // SMBus 0 Stop Flag
 250      =3  SBIT (SI, SFR_SMB0CN, 3);              // SMBus 0 Interrupt Pending Flag
 251      =3  SBIT (AA, SFR_SMB0CN, 2);              // SMBus 0 Assert/Acknowledge Flag
 252      =3  SBIT (SMBFTE, SFR_SMB0CN, 1);          // SMBus 0 Free Timer Enable
 253      =3  SBIT (SMBTOE, SFR_SMB0CN, 0);          // SMBus 0 Timeout Enable
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 39  

 254      =3  
 255      =3  // T2CON 0xC8
 256      =3  SBIT (TF2, SFR_T2CON, 7);              // Timer 2 Overflow Flag
 257      =3  SBIT (EXF2, SFR_T2CON, 6);             // External Flag
 258      =3  SBIT (RCLK0, SFR_T2CON, 5);            // Uart0 Rx Clock Source
 259      =3  SBIT (TCLK0, SFR_T2CON, 4);            // Uart0 Tx Clock Source
 260      =3  SBIT (EXEN2, SFR_T2CON, 3);            // Timer 2 External Enable Flag
 261      =3  SBIT (TR2, SFR_T2CON, 2);              // Timer 2 On/Off Control
 262      =3  SBIT (CT2, SFR_T2CON, 1);              // Timer Or Counter Select
 263      =3  SBIT (CPRL2, SFR_T2CON, 0);            // Capture Or Reload Select
 264      =3  
 265      =3  //  PSW 0xD0
 266      =3  SBIT (CY, SFR_PSW, 7);                 // Carry Flag
 267      =3  SBIT (AC, SFR_PSW, 6);                 // Auxiliary Carry Flag
 268      =3  SBIT (F0, SFR_PSW, 5);                 // User Flag 0
 269      =3  SBIT (RS1, SFR_PSW, 4);                // Register Bank Select 1
 270      =3  SBIT (RS0, SFR_PSW, 3);                // Register Bank Select 0
 271      =3  SBIT (OV, SFR_PSW, 2);                 // Overflow Flag
 272      =3  SBIT (F1, SFR_PSW, 1);                 // User Flag 1
 273      =3  SBIT (P, SFR_PSW, 0);                  // Accumulator Parity Flag
 274      =3  
 275      =3  // PCA0CN 0xD8
 276      =3  SBIT (CF, SFR_PCA0CN, 7);              // PCA 0 Counter Overflow Flag
 277      =3  SBIT (CR, SFR_PCA0CN, 6);              // PCA 0 Counter Run Control Bit
 278      =3                                         // Bit5 UNUSED
 279      =3  SBIT (CCF4, SFR_PCA0CN, 4);            // PCA 0 Module 4 Interrupt Flag
 280      =3  SBIT (CCF3, SFR_PCA0CN, 3);            // PCA 0 Module 3 Interrupt Flag
 281      =3  SBIT (CCF2, SFR_PCA0CN, 2);            // PCA 0 Module 2 Interrupt Flag
 282      =3  SBIT (CCF1, SFR_PCA0CN, 1);            // PCA 0 Module 1 Interrupt Flag
 283      =3  SBIT (CCF0, SFR_PCA0CN, 0);            // PCA 0 Module 0 Interrupt Flag
 284      =3  
 285      =3  // ADC0CN 0xE8
 286      =3  SBIT (AD0EN, SFR_ADC0CN, 7);           // ADC 0 Enable
 287      =3  SBIT (AD0TM, SFR_ADC0CN, 6);           // ADC 0 Track Mode
 288      =3  SBIT (AD0INT, SFR_ADC0CN, 5);          // ADC 0 Converision Complete Interrupt Flag
 289      =3  SBIT (AD0BUSY, SFR_ADC0CN, 4);         // ADC 0 Busy Flag
 290      =3  SBIT (AD0CM1, SFR_ADC0CN, 3);          // ADC 0 Start Of Conversion Mode Bit 1
 291      =3  SBIT (AD0CM0, SFR_ADC0CN, 2);          // ADC 0 Start Of Conversion Mode Bit 0
 292      =3  SBIT (AD0WINT, SFR_ADC0CN, 1);         // ADC 0 Window Compare Interrupt Flag
 293      =3  SBIT (AD0LJST, SFR_ADC0CN, 0);         // ADC 0 Right Justify Data Bit
 294      =3  
 295      =3  // SPI0CN 0xF8
 296      =3  SBIT (SPIF, SFR_SPI0CN, 7);            // SPI 0 Interrupt Flag
 297      =3  SBIT (WCOL, SFR_SPI0CN, 6);            // SPI 0 Write Collision Flag
 298      =3  SBIT (MODF, SFR_SPI0CN, 5);            // SPI 0 Mode Fault Flag
 299      =3  SBIT (RXOVRN, SFR_SPI0CN, 4);          // SPI 0 Rx Overrun Flag
 300      =3  SBIT (TXBSY, SFR_SPI0CN, 3);           // SPI 0 Tx Busy Flag
 301      =3  SBIT (SLVSEL, SFR_SPI0CN, 2);          // SPI 0 Slave Select
 302      =3  SBIT (MSTEN, SFR_SPI0CN, 1);           // SPI 0 Master Enable
 303      =3  SBIT (SPIEN, SFR_SPI0CN, 0);           // SPI 0 SPI Enable
 304      =3  
 305      =3  //-----------------------------------------------------------------------------
 306      =3  // Interrupt Priorities
 307      =3  //-----------------------------------------------------------------------------
 308      =3  
 309      =3  #define INTERRUPT_INT0           0     // External Interrupt 0
 310      =3  #define INTERRUPT_TIMER0         1     // Timer0 Overflow
 311      =3  #define INTERRUPT_INT1           2     // External Interrupt 1
 312      =3  #define INTERRUPT_TIMER1         3     // Timer1 Overflow
 313      =3  #define INTERRUPT_UART0          4     // Serial Port UART0
 314      =3  #define INTERRUPT_TIMER2         5     // Timer2 Overflow
 315      =3  #define INTERRUPT_SPI0           6     // SPI0 Interface
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 40  

 316      =3  #define INTERRUPT_SMBUS0         7     // SMBus0 Interface
 317      =3  #define INTERRUPT_ADC0_WINDOW    8     // ADC0 Window Comparison
 318      =3  #define INTERRUPT_PCA0           9     // PCA0 Peripheral
 319      =3  #define INTERRUPT_COMPARATOR0F   10    // Comparator0 Falling Edge
 320      =3  #define INTERRUPT_COMPARATOR0R   11    // Comparator0 Rising Edge
 321      =3  #define INTERRUPT_COMPARATOR1F   12    // Comparator1 Falling Edge
 322      =3  #define INTERRUPT_COMPARATOR1R   13    // Comparator1 Rising Edge
 323      =3  #define INTERRUPT_TIMER3         14    // Timer3 Overflow
 324      =3  #define INTERRUPT_ADC0_EOC       15    // ADC0 End Of Conversion
 325      =3  #define INTERRUPT_TIMER4         16    // Timer4 Overflow
 326      =3  #define INTERRUPT_ADC1_EOC       17    // ADC1 End Of Conversion
 327      =3  #define INTERRUPT_INT6           18    // External Interrupt 6
 328      =3  #define INTERRUPT_INT7           19    // External Interrupt 7
 329      =3  #define INTERRUPT_UART1          20    // Serial Port UART1
 330      =3  #define INTERRUPT_XTAL_READY     21    // External Crystal Oscillator Ready
 331      =3  
 332      =3  //-----------------------------------------------------------------------------
 333      =3  // SDCC PDATA External Memory Paging Support
 334      =3  //-----------------------------------------------------------------------------
 335      =3  
 336      =3  #if defined SDCC
           =3 
           =3 SFR(_XPAGE, 0xAF); // Point to the EMI0CN register
           =3 
           =3 #endif
 341      =3  
 342      =3  //-----------------------------------------------------------------------------
 343      =3  // Header File PreProcessor Directive
 344      =3  //-----------------------------------------------------------------------------
 345      =3  
 346      =3  #endif                                 // #define C8051F020_DEFS_H
 347      =3  
 348      =3  //-----------------------------------------------------------------------------
 349      =3  // End Of File
 350      =3  //-----------------------------------------------------------------------------
 123      =2  #endif
 124      =2  #ifdef C8051F340
           =2 #include "C8051F340_defs.h"
           =2 #endif
 127      =2  /*****************************************************************************/
 128      =2  #include <stdio.h>
   1      =3  /*--------------------------------------------------------------------------
   2      =3  STDIO.H
   3      =3  
   4      =3  Prototypes for standard I/O functions.
   5      =3  Copyright (c) 1988-2002 Keil Elektronik GmbH and Keil Software, Inc.
   6      =3  All rights reserved.
   7      =3  --------------------------------------------------------------------------*/
   8      =3  
   9      =3  #ifndef __STDIO_H__
  10      =3  #define __STDIO_H__
  11      =3  
  12      =3  #ifndef EOF
  13      =3   #define EOF -1
  14      =3  #endif
  15      =3  
  16      =3  #ifndef NULL
           =3  #define NULL ((void *) 0)
           =3 #endif
  19      =3  
  20      =3  #ifndef _SIZE_T
  21      =3   #define _SIZE_T
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 41  

  22      =3   typedef unsigned int size_t;
  23      =3  #endif
  24      =3  
  25      =3  #pragma SAVE
  26      =3  #pragma REGPARMS
  27      =3  extern char _getkey (void);
  28      =3  extern char getchar (void);
  29      =3  extern char ungetchar (char);
  30      =3  extern char putchar (char);
  31      =3  extern int printf   (const char *, ...);
  32      =3  extern int sprintf  (char *, const char *, ...);
  33      =3  extern int vprintf  (const char *, char *);
  34      =3  extern int vsprintf (char *, const char *, char *);
  35      =3  extern char *gets (char *, int n);
  36      =3  extern int scanf (const char *, ...);
  37      =3  extern int sscanf (char *, const char *, ...);
  38      =3  extern int puts (const char *);
  39      =3  
  40      =3  #pragma RESTORE
  41      =3  
  42      =3  #endif
  43      =3  
 129      =2  #include <stdlib.h> 
   1      =3  /*--------------------------------------------------------------------------
   2      =3  STDLIB.H
   3      =3  
   4      =3  Standard functions.
   5      =3  Copyright (c) 1988-2008 Keil Elektronik GmbH and Keil Software, Inc.
   6      =3  Copyright (c) 2008-2016 ARM Germany GmbH
   7      =3  All rights reserved.
   8      =3  --------------------------------------------------------------------------*/
   9      =3  
  10      =3  #ifndef __STDLIB_H__
  11      =3  #define __STDLIB_H__
  12      =3  
  13      =3  #ifndef _SIZE_T
           =3  #define _SIZE_T
           =3  typedef unsigned int size_t;
           =3 #endif
  17      =3  
  18      =3  #ifndef NULL
           =3  #define NULL ((void *)0)
           =3 #endif
  21      =3  
  22      =3  #ifndef _WCHAR_T_DEFINED_
  23      =3  #define _WCHAR_T_DEFINED_
  24      =3  typedef char wchar_t;
  25      =3  #endif
  26      =3  
  27      =3  #if defined (__CX2__)
           =3 #ifndef _DIV_T_DEFINED
           =3 typedef struct _div_t {
           =3         int quot;
           =3         int rem;
           =3 } div_t;
           =3 typedef struct _ldiv_t {
           =3         long quot;
           =3         long rem;
           =3 } ldiv_t;
           =3 #define _DIV_T_DEFINED
           =3 #endif // _DIV_T_DEFINED
           =3 #endif // __CX2__
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 42  

  40      =3  
  41      =3  #ifndef RAND_MAX
  42      =3   #define RAND_MAX  32767u
  43      =3  #endif
  44      =3  
  45      =3  #if defined (__CX2__)
           =3 #pragma SAVE
           =3 #pragma FUNCTIONS(STATIC)
           =3 /* intrinsic functions are reentrant, but need static attribute */
           =3 extern int    abs  (int   val);
           =3 #pragma RESTORE
           =3 #endif // __CX2__
  52      =3  
  53      =3  #pragma SAVE
  54      =3  #pragma REGPARMS
  55      =3  
  56      =3  extern char   cabs (char  val);
  57      =3  #if !defined (__CX2__)
  58      =3  extern int    abs  (int   val);
  59      =3  #endif // __CX2__
  60      =3  extern long   labs (long  val);
  61      =3  
  62      =3  extern float  atof (const char *s1);
  63      =3  extern long   atol (const char *s1);
  64      =3  extern int    atoi (const char *s1);
  65      =3  extern int    rand (void);
  66      =3  extern void   srand (unsigned int seed);
  67      =3  
  68      =3  #ifdef _DIV_T_DEFINED
           =3 extern div_t  __div (int numer, int denom);
           =3 #define div(numer,denom)  __div((numer),(denom));
           =3 extern ldiv_t ldiv (long numer, long denom);
           =3 #endif // _DIV_T_DEFINED
  73      =3  
  74      =3  extern float         strtod  (const char *nptr, char **endptr);
  75      =3  extern long          strtol  (const char *nptr, char **endptr, unsigned char base);
  76      =3  extern unsigned long strtoul (const char *nptr, char **endptr, unsigned char base);
  77      =3  
  78      =3  #define _MALLOC_MEM_    xdata
  79      =3  
  80      =3  extern void init_mempool          (void _MALLOC_MEM_ *p, size_t size);
  81      =3  extern void _MALLOC_MEM_ *malloc  (size_t size);
  82      =3  extern void free                  (void _MALLOC_MEM_ *p);
  83      =3  extern void _MALLOC_MEM_ *realloc (void _MALLOC_MEM_ *p, size_t size);
  84      =3  extern void _MALLOC_MEM_ *calloc  (size_t nmemb, size_t size);
  85      =3  
  86      =3  #if defined (__CX2__)
           =3 extern void abort(void);
           =3 #endif // __CX2__
  89      =3  
  90      =3  #pragma RESTORE
  91      =3  
  92      =3  #endif // __STDLIB_H__
 130      =2  #include <string.h>
   1      =3  /*--------------------------------------------------------------------------
   2      =3  STRING.H
   3      =3  
   4      =3  String functions.
   5      =3  Copyright (c) 1988-2008 Keil Elektronik GmbH and Keil Software, Inc.
   6      =3  Copyright (c) 2008-2016 ARM Germany GmbH
   7      =3  All rights reserved.
   8      =3  --------------------------------------------------------------------------*/
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 43  

   9      =3  
  10      =3  #ifndef __STRING_H__
  11      =3  #define __STRING_H__
  12      =3  
  13      =3  #ifndef _SIZE_T
           =3  #define _SIZE_T
           =3  typedef unsigned int size_t;
           =3 #endif
  17      =3  
  18      =3  #ifndef NULL
           =3  #define NULL ((void *)0)
           =3 #endif
  21      =3  
  22      =3  #pragma SAVE
  23      =3  #pragma REGPARMS
  24      =3  extern char  *strcat  (char *s1, const char *s2);
  25      =3  extern char  *strncat (char *s1, const char *s2, size_t n);
  26      =3  
  27      =3  extern char   strcmp  (const char *s1, const char *s2);
  28      =3  extern char   strncmp (const char *s1, const char *s2, size_t n);
  29      =3  
  30      =3  extern char  *strcpy  (char *s1, const char *s2);
  31      =3  extern char  *strncpy (char *s1, const char *s2, size_t n);
  32      =3  
  33      =3  extern size_t strlen  (const char *);
  34      =3  
  35      =3  extern char  *strchr  (const char *s, char c);
  36      =3  extern int    strpos  (const char *s, char c);
  37      =3  extern char  *strrchr (const char *s, char c);
  38      =3  extern int    strrpos (const char *s, char c);
  39      =3  
  40      =3  extern size_t strspn  (const char *s, const char *set);
  41      =3  extern size_t strcspn (const char *s, const char *set);
  42      =3  extern char  *strpbrk (const char *s, const char *set);
  43      =3  extern char  *strrpbrk(const char *s, const char *set);
  44      =3  extern char  *strstr  (const char *s, const char *sub);
  45      =3  extern char  *strtok  (char *str, const char *set);
  46      =3  
  47      =3  extern char   memcmp  (const void *s1, const void *s2, size_t n);
  48      =3  extern void  *memcpy  (void *s1, const void *s2, size_t n);
  49      =3  extern void  *memchr  (const void *s, char val, size_t n);
  50      =3  extern void  *memccpy (void *s1, const void *s2, char val, size_t n);
  51      =3  extern void  *memmove (void *s1, const void *s2, size_t n);
  52      =3  extern void  *memset  (void *s, char val, size_t n);
  53      =3  #pragma RESTORE
  54      =3  
  55      =3  #endif
 131      =2  #include <INTRINS.H>
   1      =3  /*--------------------------------------------------------------------------
   2      =3  INTRINS.H
   3      =3  
   4      =3  Intrinsic functions for C51.
   5      =3  Copyright (c) 1988-2010 Keil Elektronik GmbH and ARM Germany GmbH
   6      =3  All rights reserved.
   7      =3  --------------------------------------------------------------------------*/
   8      =3  
   9      =3  #ifndef __INTRINS_H__
  10      =3  #define __INTRINS_H__
  11      =3  
  12      =3  #pragma SAVE
  13      =3  
  14      =3  #if defined (__CX2__)
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 44  

           =3 #pragma FUNCTIONS(STATIC)
           =3 /* intrinsic functions are reentrant, but need static attribute */
           =3 #endif
  18      =3  
  19      =3  extern void          _nop_     (void);
  20      =3  extern bit           _testbit_ (bit);
  21      =3  extern unsigned char _cror_    (unsigned char, unsigned char);
  22      =3  extern unsigned int  _iror_    (unsigned int,  unsigned char);
  23      =3  extern unsigned long _lror_    (unsigned long, unsigned char);
  24      =3  extern unsigned char _crol_    (unsigned char, unsigned char);
  25      =3  extern unsigned int  _irol_    (unsigned int,  unsigned char);
  26      =3  extern unsigned long _lrol_    (unsigned long, unsigned char);
  27      =3  extern unsigned char _chkfloat_(float);
  28      =3  #if defined (__CX2__)
           =3 extern int           abs       (int);
           =3 extern void          _illop_   (void);
           =3 #endif
  32      =3  #if !defined (__CX2__)
  33      =3  extern void          _push_    (unsigned char _sfr);
  34      =3  extern void          _pop_     (unsigned char _sfr);
  35      =3  #endif
  36      =3  
  37      =3  #pragma RESTORE
  38      =3  
  39      =3  #endif
  40      =3  
 132      =2  #include <ctype.h>
   1      =3  /*--------------------------------------------------------------------------
   2      =3  CTYPE.H
   3      =3  
   4      =3  Prototypes for character functions.
   5      =3  Copyright (c) 1988-2002 Keil Elektronik GmbH and Keil Software, Inc.
   6      =3  All rights reserved.
   7      =3  --------------------------------------------------------------------------*/
   8      =3  
   9      =3  #ifndef __CTYPE_H__
  10      =3  #define __CTYPE_H__
  11      =3  
  12      =3  #pragma SAVE
  13      =3  #pragma REGPARMS
  14      =3  extern bit isalpha (unsigned char);
  15      =3  extern bit isalnum (unsigned char);
  16      =3  extern bit iscntrl (unsigned char);
  17      =3  extern bit isdigit (unsigned char);
  18      =3  extern bit isgraph (unsigned char);
  19      =3  extern bit isprint (unsigned char);
  20      =3  extern bit ispunct (unsigned char);
  21      =3  extern bit islower (unsigned char);
  22      =3  extern bit isupper (unsigned char);
  23      =3  extern bit isspace (unsigned char);
  24      =3  extern bit isxdigit (unsigned char);
  25      =3  extern unsigned char tolower (unsigned char);
  26      =3  extern unsigned char toupper (unsigned char);
  27      =3  extern unsigned char toint (unsigned char);
  28      =3  
  29      =3  #define _tolower(c) ( (c)-'A'+'a' )
  30      =3  #define _toupper(c) ( (c)-'a'+'A' )
  31      =3  #define toascii(c)  ( (c) & 0x7F )
  32      =3  #pragma RESTORE
  33      =3  
  34      =3  #endif
 133      =2  #include <LIMITS.H>
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 45  

   1      =3  /*--------------------------------------------------------------------------
   2      =3  LIMITS.H
   3      =3  
   4      =3  ANSI standard include file.
   5      =3  Copyright (c) 1988-2008 Keil Elektronik GmbH and Keil Software, Inc.
   6      =3  Copyright (c) 2009 ARM Germany GmbH
   7      =3  All rights reserved.
   8      =3  --------------------------------------------------------------------------*/
   9      =3  
  10      =3  #ifndef __LIMITS_H__
  11      =3  #define __LIMITS_H__
  12      =3  
  13      =3  #define CHAR_BIT         8              /* Number of bits in any "char" */
  14      =3  #define CHAR_MAX         127            /* Max             "char" value */
  15      =3  #define CHAR_MIN       (-128)           /* Min             "char" value */
  16      =3  #define SCHAR_MAX        127            /* Max "signed"    "char" value */
  17      =3  #define SCHAR_MIN      (-128)           /* Min "signed"    "char" value */
  18      =3  #define UCHAR_MAX        255            /* Max "unsigned"  "char" value */
  19      =3  #define SHRT_MAX         32767          /* Max ("signed") "short" value */
  20      =3  #define SHRT_MIN       (-32767-1)       /* Min ("signed") "short" value */
  21      =3  #define USHRT_MAX        0xFFFF         /* Max "unsigned" "short" value */
  22      =3  #define INT_MAX          32767          /* Max ("signed")   "int" value */
  23      =3  #define INT_MIN        (-32767-1)       /* Min ("signed")   "int" value */
  24      =3  #define UINT_MAX         0xFFFF         /* Max "unsigned"   "int" value */
  25      =3  #define LONG_MAX         2147483647     /* Max ("signed")  "long" value */
  26      =3  #define LONG_MIN   (-2147483647L-1L)    /* Min ("signed")  "long" value */
  27      =3  #define ULONG_MAX        0xFFFFFFFF     /* Max "unsigned"  "long" value */
  28      =3  
  29      =3  #endif
 134      =2  #include <math.h>
   1      =3  /*--------------------------------------------------------------------------
   2      =3  MATH.H
   3      =3  
   4      =3  Prototypes for mathematic functions.
   5      =3  Copyright (c) 1988-2008 Keil Elektronik GmbH and Keil Software, Inc.
   6      =3  Copyright (c) 2008-2016 ARM Germany GmbH
   7      =3  All rights reserved.
   8      =3  --------------------------------------------------------------------------*/
   9      =3  
  10      =3  #ifndef __MATH_H__
  11      =3  #define __MATH_H__
  12      =3  
  13      =3  #if defined __CX2__ && (__CX2__ >= 558 || __CX2__ == 556 && __CX2_MINOR__ >= 207)
           =3 #ifndef HUGE_VAL
           =3 #define HUGE_VAL __inf__
           =3 #endif // HUGE_VAL
           =3 
           =3 #ifndef NAN
           =3 #define NAN __nan__
           =3 #endif // NAN
           =3 
           =3 #pragma SAVE
           =3 #pragma FUNCTIONS(STATIC)
           =3 /* intrinsic functions are reentrant, but need static attribute */
           =3 extern int    abs  (int   val);
           =3 #pragma RESTORE
           =3 #endif
  28      =3  
  29      =3  #pragma SAVE
  30      =3  #pragma REGPARMS
  31      =3  #if !defined (__CX2__)
  32      =3  extern char  cabs  (char  val);
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 46  

  33      =3  extern int    abs  (int   val);
  34      =3  extern long  labs  (long  val);
  35      =3  #endif
  36      =3  
  37      =3  extern float fabs  (float val);
  38      =3  extern float sqrt  (float val);
  39      =3  extern float exp   (float val);
  40      =3  extern float log   (float val);
  41      =3  extern float log10 (float val);
  42      =3  extern float sin   (float val);
  43      =3  extern float cos   (float val);
  44      =3  extern float tan   (float val);
  45      =3  extern float asin  (float val);
  46      =3  extern float acos  (float val);
  47      =3  extern float atan  (float val);
  48      =3  extern float sinh  (float val);
  49      =3  extern float cosh  (float val);
  50      =3  extern float tanh  (float val);
  51      =3  extern float atan2 (float y, float x);
  52      =3  
  53      =3  extern float ceil  (float val);
  54      =3  extern float floor (float val);
  55      =3  extern float modf  (float val, float *n);
  56      =3  extern float fmod  (float x, float y);
  57      =3  extern float pow   (float x, float y);
  58      =3  
  59      =3  #if defined (__CX2__)
           =3 extern float frexp (float val, int *exp);
           =3 extern float ldexp (float val, int exp);
           =3 #endif
  63      =3  
  64      =3  #pragma RESTORE
  65      =3  
  66      =3  #endif
 135      =2  #include "crc32.h"
   1      =3  #ifndef __CRC32_H__
   2      =3  #define __CRC32_H__
   3      =3  
   4      =3  //#ifdef __cplusplus
   5      =3  //extern "C" {
   6      =3  //#endif
   7      =3  /*****************************************************************************/
   8      =3  #include "AppConfig.h"
   1      =4  #ifndef __APPCONFIG_H__
           =4 #define __APPCONFIG_H__
           =4 /*****************************************************************************/
           =4 #define CONFIG_SYSCLK                       (22118400L)
           =4 #ifdef C8051F020
           =4 #define SAR_CLK                                                 2000000L//ADC0时钟 <2.5MHz
           =4 #endif
           =4 #define CONFIG_DEBUG                        0//调试功能
           =4 #define CONFIG_USING_WDT                                        0//使能看门狗
           =4 #define CONFIG_USING_RESET                                      0//使能PLC复位MCU功能
           =4 #define CONFIG_LADDER_SECTORS_START                     64//指令起始地址
           =4 #define CONFIG_LADDER_SECTORS_END                       128//指令结束地址
           =4 #define CONFIG_LASERTIMER_OVERFLOW_US           1000L//定时器周期 1mS
           =4 #define CONFIG_VERSION                                          0x0001
           =4 #define CONFIG_CHECK_CODE                                       0x5A00
           =4 
           =4 /*****************************************************************************/
           =4 #define CONFIG_UART0_BAUDRATE                           57600//串口波特率
           =4 #define CONFIG_UART0_PARITY                                     NONE
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 47  

           =4 #define CONFIG_UART0_STOPBIT                            1
           =4 #define CONFIG_UART0_DATABIT                            8
           =4 
           =4 #define CONFIG_UART1_BAUDRATE                           115200//串口波特率
           =4 #define CONFIG_UART1_PARITY                                     NONE
           =4 #define CONFIG_UART1_STOPBIT                            1
           =4 #define CONFIG_UART1_DATABIT                            8
           =4 /*****************************************************************************/
           =4 #define CONFIG_I2C0_FREQ                                        (100000L)               
           =4 #define CONFIG_I2C1_FREQ                                        (100000L)
           =4 #define CONFIG_I2C2_FREQ                                        (100000L)
           =4 #define CONFIG_I2C3_FREQ                                        (100000L)
           =4 #define CONFIG_I2C4_FREQ                                        (100000L)
           =4 /*****************************************************************************/
           =4 #define CONFIG_EPROM_SIZE                                       CONFIG_AT24C64_SIZE
           =4 #define CONFIG_AT24C02_SIZE                             256
           =4 #define CONFIG_AT24C04_SIZE                             512
           =4 #define CONFIG_AT24C08_SIZE                             1024
           =4 #define CONFIG_AT24C16_SIZE                             2048
           =4 #define CONFIG_AT24C32_SIZE                             4096
           =4 #define CONFIG_AT24C64_SIZE                                     8192
           =4 #define CONFIG_AT24C128_SIZE                            16384
           =4 #define CONFIG_AT24C256_SIZE                            32768
           =4 #define CONFIG_EPROM_ADDRESS                            0x50
           =4 #define CONFIG_EPROM_FRAM                                       0//铁电存储体无写入等待
           =4 #define CONFIG_EPROM_FREQ                                       1//
           =4 /*****************************************************************************/
           =4 #define CONFIG_USE_IPID                                         1//使能IPID温度控制
           =4 /*****************************************************************************/
           =4 #define CONFIG_USE_HWVER_SHOW                           1//使能固件版本显示
           =4 #define CONFIG_USE_MPD1_SHOW                            1//使能MPD1测量显示
           =4 #define CONFIG_USE_MPD2_SHOW                            1//使能MPD2测量显示
           =4 #define CONFIG_USE_FBS1                                         1//使能FBS1检测
           =4 #define CONFIG_USE_FBS2                                         1//使能FBS2检测
           =4 #define CONFIG_USE_LASER_TEMP                           1//使能激光器温度显示
           =4 #define CONFIG_USE_RADIATOR_TEMP                        1//使能散热器温度显示
           =4 #define CONFIG_USE_ENVI_TEMP                            1//使能环境温度显示
           =4 #define CONFIG_USE_IPID_UPDATE                          1//使能IPID参数更新功能
           =4 #define CONFIG_USE_IPID_OUTSHOW                         1//使能IPID输出显示
           =4 /*****************************************************************************/
           =4 //SPLC设置
           =4 #define CONFIG_SPLC_IO_INPUT_NUM                        16//硬件输入点数
           =4 #define CONFIG_SPLC_IO_OUTPUT_NUM                       16//硬件输出点数
           =4 #define CONFIG_SOFTPLC_HWTIME                           1000L//1mS
           =4 #define CONFIG_INPUT_FILTER_TIME                        3//输入数字滤波扫描周期 1mS * N
           =4 #define CONFIG_IPID_RUN_CYCLE                           40//IPID运行周期 默认 40 * 100mS
           =4 #define CONFIG_IPID_PWM_CYCLE                           20//IPID输出周期 默认 20 * 100mS
           =4 /*****************************************************************************/
           =4 #define CONFIG_SPLC_USING_WDT                           0//看门狗启用
           =4 /*****************************************************************************/
           =4 #define CONFIG_SPLC_USING_IO_INPUT                      1//输入IO刷新启用
           =4 /*****************************************************************************/
           =4 #define CONFIG_SPLC_USING_IO_OUTPUT                     1//输出IO刷新启用
           =4 /*****************************************************************************/
           =4 #define CONFIG_SPLC_USING_EPROM                         0//EPROM掉电存储启用
           =4 /*****************************************************************************/
           =4 #define CONFIG_SPLC_USING_ADC                           0//使能ADC模块
           =4 #define CONFIG_SPLC_ADC_FILTER_TAP                      48//ADC位移滤波次数
           =4 #define CONFIG_SPLC_ADC_CHANNLE                         9//ADC通道数
           =4 #define CONFIG_SPLC_ADC_TEMP_SENSOR_GAIN    3330L// Temp Sensor Gain in (uV / degC)
           =4 #define CONFIG_SPLC_ADC_TEMP_SENSOR_OFFSET  856L// Temp Sensor Offset in mV
           =4 #define CONFIG_SPLC_ADC_INTERNAL_VREF           2200L// ADC Voltage Reference (mV)
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 48  

           =4 #define CONFIG_SPLC_ADC_AMBIENT             25L// Ambient temp in deg C
           =4 /*****************************************************************************/
           =4 #define CONFIG_SPLC_USING_DAC                           1//是能DAC模块
           =4 /*****************************************************************************/
           =4 #define CONFIG_SPLC_USING_MB_RTU_SLAVE          1//是能MODBUS RTU从站
           =4 #define CONFIG_MB_RTU_SLAVE_TIMER                       1000L//1000uS
           =4 #define CONFIG_MB_RTU_SLAVE_ADDRESS                     0x01//从设备地址
           =4 #define CONFIG_MB_RTU_SLAVE_BUFFER_SIZE         256//发送接收缓冲区
           =4 #define CONFIG_MB_RTU_SLAVE_TIMEOUT                     100//接收通讯超时 10mS
           =4 #define CONFIG_MB_RTU_SLAVE_IO_DELAY            1//RX TX切换延时
           =4 /*****************************************************************************/
           =4 
           =4 /*****************************************************************************/
           =4 #define ID_ONLY_1_CHANNEL                                       4321
           =4 #define ID_ONLY_2_CHANNEL                                       8765
           =4 #define ID_BOTH_CHANNEL                                         9431
           =4 #define ID_LASER_MODE_CW                                        7631
           =4 #define ID_LASER_MODE_SP                                        8934
           =4 #define ID_LASER_MODE_MP                                        2453
           =4 #define ID_LASER_MODE_GP                                        3876
           =4 /*****************************************************************************/
           =4 #define FBS1_IN_PORT                                            3
           =4 #define FBS2_IN_PORT                                            2
           =4 #define COOLON_OUT_PORT                                         (1 * 8 + 3)
           =4 /*****************************************************************************/
           =4 //PID FUZZY 模糊PID配置
           =4 #define CONFIG_TECOUT_CYCLE                                     4000//PID输出转PWM周期
           =4 /*****************************************************************************/
           =4 /*****************************************************************************/
           =4 #define DISABLE_MODBUS_SERIAL_INTERRUPT         ES0 = 0;
           =4 #define ENABLE_MODBUS_SERIAL_INTERRUPT          ES0 = 1;
           =4 #define DISABLE_INTERRUPT                                       EA = 0;
           =4 #define ENABLE_INTERRUPT                                        EA = 1;
           =4 /*****************************************************************************/
           =4 #include "stdint.h"
           =4 #include "stdbool.h"
           =4 #include "endian.h"
           =4 #include "si_toolchain.h"
           =4 #include "compiler_defs.h"
           =4 #ifdef C8051F020
           =4 #include "C8051F020_defs.h"
           =4 #endif
           =4 #ifdef C8051F340
           =4 #include "C8051F340_defs.h"
           =4 #endif
           =4 /*****************************************************************************/
           =4 #include <stdio.h>
           =4 #include <stdlib.h> 
           =4 #include <string.h>
           =4 #include <INTRINS.H>
           =4 #include <ctype.h>
           =4 #include <LIMITS.H>
           =4 #include <math.h>
           =4 #include "crc32.h"
           =4 /*****************************************************************************/
           =4 #ifdef C8051F020
           =4 #include "InitDeviceF020.h"
           =4 #endif
           =4 #ifdef C8051F580
           =4 #include "InitDeviceF580.h"
           =4 #endif
           =4 
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 49  

           =4 #include "delay.h"
           =4 #include "i2c0.h"
           =4 //#include "i2c1.h"
           =4 //#include "i2c2.h"
           =4 //#include "i2c3.h"
           =4 //#include "i2c4.h"
           =4 //#include "i2c5.h"
           =4 //#include "i2c6.h"
           =4 #include "eprom.h"
           =4 //#include "mcp47x6.h"
           =4 //#include "inPca9554.h"
           =4 //#include "outPca9554.h"
           =4 /*****************************************************************************/
           =4 #include "Modbus.h"
           =4 #include "ModbusPort.h"
           =4 /*****************************************************************************/
           =4 #include "sPLC.h"
           =4 //#include "pidFuzzy.h"
           =4 /*****************************************************************************/
           =4 //#include "AppMath.h"
           =4 //#include "chipAdc.h"
           =4 //#include "ad5621.h"
           =4 //#include "chipBeem.h"
           =4 
           =4 /*****************************************************************************/
           =4 #endif
   9      =3  /*****************************************************************************/
  10      =3  uint32_t crc32Calculate(uint8_t *buf, uint32_t len);//CRC32 计算数组
  11      =3  uint32_t crc32CalculateAdd(uint8_t dat);//CRC32 计算连续字节
  12      =3  void crc32Clear(void);//清空旧CRC32结果
  13      =3  void crc32SetCrcOld(uint32_t old);
  14      =3  /*****************************************************************************/
  15      =3  //#ifdef __cplusplus
  16      =3  //}
  17      =3  //#endif
  18      =3  #endif
  19      =3  
  20      =3  
  21      =3  
 136      =2  /*****************************************************************************/
 137      =2  #ifdef C8051F020
 138      =2  #include "InitDeviceF020.h"
   1      =3  #ifndef __INITDEVICEF020_H__
   2      =3  #define __INITDEVICEF020_H__
   3      =3  /*****************************************************************************/
   4      =3  #include "compiler_defs.h"
   1      =4  //-----------------------------------------------------------------------------
   2      =4  // compiler_defs.h
   3      =4  //-----------------------------------------------------------------------------
   4      =4  // Portions of this file are copyright Maarten Brock
   5      =4  // http://sdcc.sourceforge.net
   6      =4  // Portions of this file are Copyright 2014 Silicon Laboratories, Inc.
   7      =4  // http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   8      =4  //
   9      =4  // GNU LGPL boilerplate:
  10      =4  /** This library is free software; you can redistribute it and/or
  11      =4    * modify it under the terms of the GNU Lesser General Public
  12      =4    * License as published by the Free Software Foundation; either
  13      =4    * version 2.1 of the License, or (at your option) any later version.
  14      =4    *
  15      =4    * This library is distributed in the hope that it will be useful,
  16      =4    * but WITHOUT ANY WARRANTY; without even the implied warranty of
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 50  

  17      =4    * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
  18      =4    * Lesser General Public License for more details.
  19      =4    *
  20      =4    * You should have received a copy of the GNU Lesser General Public
  21      =4    * License along with this library; if not, write to the Free Software
  22      =4    * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  23      =4    *
  24      =4    * In other words, you are welcome to use, share and improve this program.
  25      =4    * You are forbidden to forbid anyone else to use, share and improve
  26      =4    * what you give them. Help stamp out software-hoarding!
  27      =4  **/
  28      =4  // Program Description:
  29      =4  //
  30      =4  // **Important Note**: This header file should be included before including
  31      =4  // a device-specific header file such as C8051F300_defs.h.
  32      =4  //
  33      =4  // Macro definitions to accomodate 8051 compiler differences in specifying
  34      =4  // special function registers and other 8051-specific features such as NOP
  35      =4  // generation, and locating variables in memory-specific segments.  The
  36      =4  // compilers are identified by their unique predefined macros. See also:
  37      =4  // http://predef.sourceforge.net/precomp.html
  38      =4  //
  39      =4  // SBIT and SFR define special bit and special function registers at the given
  40      =4  // address. SFR16 and SFR32 define sfr combinations at adjacent addresses in
  41      =4  // little-endian format. SFR16E and SFR32E define sfr combinations without
  42      =4  // prerequisite byte order or adjacency. None of these multi-byte sfr
  43      =4  // combinations will guarantee the order in which they are accessed when read
  44      =4  // or written.
  45      =4  //
  46      =4  // SFR16X and SFR32X for 16 bit and 32 bit xdata registers are not defined
  47      =4  // to avoid portability issues because of compiler endianness.
  48      =4  //
  49      =4  // Example:
  50      =4  // // my_mcu.c: main 'c' file for my mcu
  51      =4  // #include <compiler_defs.h>  // this file
  52      =4  // #include <C8051xxxx_defs.h> // SFR definitions for specific MCU target
  53      =4  //
  54      =4  // SBIT  (P0_1, 0x80, 1);      // Port 0 pin 1
  55      =4  // SFR   (P0, 0x80);           // Port 0
  56      =4  // SFRX  (CPUCS, 0xE600);      // Cypress FX2 Control and Status register in
  57      =4  //                             // xdata memory at 0xE600
  58      =4  // SFR16 (TMR2, 0xCC);         // Timer 2, lsb at 0xCC, msb at 0xCD
  59      =4  // SFR16E(TMR0, 0x8C8A);       // Timer 0, lsb at 0x8A, msb at 0x8C
  60      =4  // SFR32 (MAC0ACC, 0x93);      // SiLabs C8051F120 32 bits MAC0 Accumulator,
  61      =4  //                             // lsb at 0x93, msb at 0x96
  62      =4  // SFR32E(SUMR, 0xE5E4E3E2);   // TI MSC1210 SUMR 32 bits Summation register,
  63      =4  //                             // lsb at 0xE2, msb at 0xE5
  64      =4  //
  65      =4  // Target:         C8051xxxx
  66      =4  // Tool chain:     Generic
  67      =4  // Command Line:   None
  68      =4  // 
  69      =4  // Release 2.7 - 25 JUN 2014 (JM)
  70      =4  //    -Added SI_GENERIC_PTR struct for accessing generic pointers
  71      =4  //    -Added SI_GPTR_MTYPE_XXXX definitions for determining the memory type
  72      =4  //     pointed at by a generic poitner
  73      =4  // Release 2.6 - 14 DEC 2012 (GO)
  74      =4  //        -Added define for deprecated SDCC keyword 'at'
  75      =4  // Release 2.5 - 12 SEP 2012 (TP)
  76      =4  //    -Added defines for deprecated SDCC keywords bit and code
  77      =4  // Release 2.4 - 27 AUG 2012 (TP)
  78      =4  //    -Added defines for deprecated SDCC keywords interrupt, _asm, and _endasm
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 51  

  79      =4  // Release 2.3 - 27 MAY 2010 (DM)
  80      =4  //    -Removed 'LOCATED_VARIABLE' pragma from Keil because it is not supported
  81      =4  // Release 2.2 - 06 APR 2010 (ES)
  82      =4  //    -Removed 'PATHINCLUDE' pragma from Raisonance section
  83      =4  // Release 2.1 - 16 JUL 2009 (ES)
  84      =4  //    -Added SEGMENT_POINTER macro definitions for SDCC, Keil, and Raisonance
  85      =4  //    -Added LOCATED_VARIABLE_NO_INIT macro definitions for Raisonance
  86      =4  // Release 2.0 - 19 MAY 2009 (ES)
  87      =4  //    -Added LOCATED_VARIABLE_NO_INIT macro definitions for SDCC and Keil
  88      =4  // Release 1.9 - 23 OCT 2008 (ES)
  89      =4  //    -Updated Hi-Tech INTERRUPT and INTERRUPT_USING macro definitions
  90      =4  //    -Added SFR16 macro defintion for Hi-Tech
  91      =4  // Release 1.8 - 31 JUL 2008 (ES)
  92      =4  //    -Added INTERRUPT_USING and FUNCTION_USING macro's
  93      =4  //    -Added macro's for IAR
  94      =4  //    -Corrected Union definitions for Hi-Tech and added SFR16 macro defintion
  95      =4  // Release 1.7 - 11 SEP 2007 (BW)
  96      =4  //    -Added support for Raisonance EVAL 03.03.42 and Tasking Eval 7.2r1
  97      =4  // Release 1.6 - 27 AUG 2007 (BW)
  98      =4  //    -Updated copyright notice per agreement with Maartin Brock
  99      =4  //    -Added SDCC 2.7.0 "compiler.h" bug fixes
 100      =4  //    -Added memory segment defines (SEG_XDATA, for example)
 101      =4  // Release 1.5 - 24 AUG 2007 (BW)
 102      =4  //    -Added support for NOP () macro
 103      =4  //    -Added support for Hi-Tech ver 9.01
 104      =4  // Release 1.4 - 07 AUG 2007 (PKC)
 105      =4  //    -Removed FID and fixed formatting.
 106      =4  // Release 1.3 - 30 SEP 2007 (TP)
 107      =4  //    -Added INTERRUPT_PROTO_USING to properly support ISR context switching
 108      =4  //     under SDCC.
 109      =4  // Release 1.2 - (BW)
 110      =4  //    -Added support for U8,U16,U32,S8,S16,S32,UU16,UU32 data types
 111      =4  // Release 1.1 - (BW)
 112      =4  //    -Added support for INTERRUPT, INTERRUPT_USING, INTERRUPT_PROTO,
 113      =4  //     SEGMENT_VARIABLE, VARIABLE_SEGMENT_POINTER,
 114      =4  //     SEGMENT_VARIABLE_SEGMENT_POINTER, and LOCATED_VARIABLE
 115      =4  // Release 1.0 - 29 SEP 2006 (PKC)
 116      =4  //    -Initial revision
 117      =4  
 118      =4  //-----------------------------------------------------------------------------
 119      =4  // Header File Preprocessor Directive
 120      =4  //-----------------------------------------------------------------------------
 121      =4  
 122      =4  #ifndef COMPILER_DEFS_H
           =4 #define COMPILER_DEFS_H
           =4 
           =4 #include "stdbool.h"
           =4 #include "stdint.h"
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 // Macro definitions
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 //SDK Version
           =4 #define SDK_VERSION   2
           =4 
           =4 #ifndef NULL
           =4 #define NULL ((void*) 0)
           =4 #endif
           =4 
           =4 
           =4 // SDCC - Small Device C Compiler
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 52  

           =4 // http://sdcc.sourceforge.net
           =4 
           =4 #if defined SDCC
           =4 
           =4 #if (SDCC >= 300)
           =4 
           =4 #define interrupt __interrupt
           =4 #define _asm __asm
           =4 #define _endasm __endasm
           =4 #define bit __bit
           =4 #define code __code
           =4 #define at __at
           =4 
           =4 #endif
           =4 
           =4 # define SEG_GENERIC
           =4 # define SEG_FAR   __xdata
           =4 # define SEG_DATA  __data
           =4 # define SEG_NEAR  __data
           =4 # define SEG_IDATA __idata
           =4 # define SEG_XDATA __xdata
           =4 # define SEG_PDATA __pdata
           =4 # define SEG_CODE  __code
           =4 # define SEG_BDATA __bdata
           =4 
           =4 # define SBIT(name, addr, bit)  __sbit  __at(addr+bit)                  name
           =4 # define SFR(name, addr)        __sfr   __at(addr)                      name
           =4 # define SFRX(name, addr)       xdata volatile unsigned char __at(addr) name
           =4 # define SFR16(name, addr)      __sfr16 __at(((addr+1U)<<8) | addr)     name
           =4 # define SFR16E(name, fulladdr) __sfr16 __at(fulladdr)                  name
           =4 # define SFR32(name, addr)      __sfr32 __at(((addr+3UL)<<24) | ((addr+2UL)<<16) | ((addr+1UL)<<8) | addr)
             - name
           =4 # define SFR32E(name, fulladdr) __sfr32 __at(fulladdr)                  name
           =4 
           =4 # define INTERRUPT(name, vector) void name (void) interrupt (vector)
           =4 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt (vector) using (regnum)
           =4 # define INTERRUPT_PROTO(name, vector) void name (void) interrupt (vector)
           =4 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void) interrupt (vector) using (regnum)
           =4 
           =4 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using (regnum
             -)
           =4 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter) using (
             -regnum)
           =4 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =4 
           =4 # define SEGMENT_VARIABLE(name, vartype, locsegment) locsegment vartype name
           =4 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) targsegment vartype * name
           =4 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) targsegment vartype * lo
             -csegment name
           =4 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
           =4 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment at (addr) vartype name = init
           =4 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) locsegment at (addr) vartype name
           =4 
           =4 // used with UU16
           =4 # define LSB 0
           =4 # define MSB 1
           =4 
           =4 // used with UU32 (b0 is least-significant byte)
           =4 # define b0 0
           =4 # define b1 1
           =4 # define b2 2
           =4 # define b3 3
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 53  

           =4 
           =4 typedef unsigned char U8;
           =4 typedef unsigned int U16;
           =4 typedef unsigned long U32;
           =4 
           =4 typedef signed char S8;
           =4 typedef signed int S16;
           =4 typedef signed long S32;
           =4 
           =4 typedef union UU16
           =4 {
           =4    U16 U16;
           =4    S16 S16;
           =4    U8 U8[2];
           =4    S8 S8[2];
           =4 } UU16;
           =4 
           =4 typedef union UU32
           =4 {
           =4    U32 U32;
           =4    S32 S32;
           =4    UU16 UU16[2];
           =4    U16 U16[2];
           =4    S16 S16[2];
           =4    U8 U8[4];
           =4    S8 S8[4];
           =4 } UU32;
           =4 
           =4 // NOP () macro support
           =4 #define NOP() _asm NOP _endasm
           =4 
           =4 // generic pointer memory type specifiers
           =4 #define SI_GPTR
           =4 #define SI_GPTR_MTYPE_DATA       0x40
           =4 #define SI_GPTR_MTYPE_IDATA      0x40
           =4 #define SI_GPTR_MTYPE_BDATA      0x40
           =4 #define SI_GPTR_MTYPE_PDATA      0x60
           =4 #define SI_GPTR_MTYPE_XDATA      0x00
           =4 #define SI_GPTR_MTYPE_CODE       0x80
           =4 
           =4 // generic pointer access struct
           =4 typedef union SI_GENERIC_PTR
           =4 {
           =4     U8 U8[3];
           =4     struct
           =4     {
           =4         UU16 ADDR;
           =4         U8 MTYPE;
           =4     } GPTR;
           =4 } SI_GENERIC_PTR;
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 // Raisonance (must be placed before Keil C51)
           =4 // http://www.raisonance.com
           =4 
           =4 #elif defined __RC51__
           =4 
           =4 //#error Raisonance C51 detected.
           =4 
           =4 # define SEG_GENERIC generic     //SEG_GENERIC only applies to pointers in Raisonance, not variables.
           =4 # define SEG_FAR   xdata
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 54  

           =4 # define SEG_DATA  data
           =4 # define SEG_NEAR  data
           =4 # define SEG_IDATA idata
           =4 # define SEG_XDATA xdata
           =4 # define SEG_PDATA pdata
           =4 # define SEG_CODE  code
           =4 # define SEG_BDATA bdata
           =4 
           =4 # define SBIT(name, addr, bit)  at (addr+bit) sbit         name
           =4 # define SFR(name, addr)        sfr at addr                name
           =4 # define SFR16(name, addr)      sfr16 at addr              name
           =4 # define SFR16E(name, fulladdr) /* not supported */
           =4 # define SFR32(name, fulladdr)  /* not supported */
           =4 # define SFR32E(name, fulladdr) /* not supported */
           =4 
           =4 # define INTERRUPT(name, vector) void name (void) interrupt vector
           =4 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
           =4 # define INTERRUPT_PROTO(name, vector) void name (void)
           =4 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
           =4 
           =4 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using regnum
           =4 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =4 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =4 
           =4 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =4 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =4 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =4 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
           =4 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) at addr locsegment vartype name
           =4 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) at addr locsegment vartype name
           =4 
           =4 
           =4 // used with UU16
           =4 # define LSB 1
           =4 # define MSB 0
           =4 
           =4 // used with UU32 (b0 is least-significant byte)
           =4 # define b0 3
           =4 # define b1 2
           =4 # define b2 1
           =4 # define b3 0
           =4 
           =4 typedef unsigned char U8;
           =4 typedef unsigned int U16;
           =4 typedef unsigned long U32;
           =4 
           =4 typedef signed char S8;
           =4 typedef signed int S16;
           =4 typedef signed long S32;
           =4 
           =4 typedef union UU16
           =4 {
           =4    U16 U16;
           =4    S16 S16;
           =4    U8 U8[2];
           =4    S8 S8[2];
           =4 } UU16;
           =4 
           =4 typedef union UU32
           =4 {
           =4    U32 U32;
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 55  

           =4    S32 S32;
           =4    UU16 UU16[2];
           =4    U16 U16[2];
           =4    S16 S16[2];
           =4    U8 U8[4];
           =4    S8 S8[4];
           =4 } UU32;
           =4 
           =4 // NOP () macro support -- NOP is opcode 0x00
           =4 #define NOP() asm { 0x00 }
           =4 
           =4 // generic pointer memory type specifiers
           =4 #define SI_GPTR
           =4 #define SI_GPTR_MTYPE_DATA       0x04
           =4 #define SI_GPTR_MTYPE_IDATA      0x01
           =4 #define SI_GPTR_MTYPE_BDATA      0x04
           =4 #define SI_GPTR_MTYPE_PDATA      0x03
           =4 #define SI_GPTR_MTYPE_XDATA      0x02
           =4 #define SI_GPTR_MTYPE_CODE       0x05
           =4 
           =4 // generic pointer access struct
           =4 typedef union SI_GENERIC_PTR
           =4 {
           =4     U8 U8[3];
           =4     struct
           =4     {
           =4         U8 MTYPE;
           =4         UU16 ADDR;
           =4     } GPTR;
           =4 } SI_GENERIC_PTR;
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 
           =4 // Keil C51
           =4 // http://www.keil.com
           =4 
           =4 #elif defined __C51__
           =4 
           =4 //#error Keil C51 detected.
           =4 
           =4 # define SEG_GENERIC
           =4 # define SEG_FAR   xdata
           =4 # define SEG_DATA  data
           =4 # define SEG_NEAR  data
           =4 # define SEG_IDATA idata
           =4 # define SEG_XDATA xdata
           =4 # define SEG_PDATA pdata
           =4 # define SEG_CODE  code
           =4 # define SEG_BDATA bdata
           =4 
           =4 # define SBIT(name, addr, bit)  sbit  name = addr^bit
           =4 # define SFR(name, addr)        sfr   name = addr
           =4 # define SFR16(name, addr)      sfr16 name = addr
           =4 # define SFR16E(name, fulladdr) /* not supported */
           =4 # define SFR32(name, fulladdr)  /* not supported */
           =4 # define SFR32E(name, fulladdr) /* not supported */
           =4 
           =4 # ifndef __SLS_IDE__
           =4 
           =4 # define INTERRUPT(name, vector) void name (void) interrupt vector
           =4 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 56  

           =4 # define INTERRUPT_PROTO(name, vector) void name (void)
           =4 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
           =4 
           =4 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using regnum
           =4 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =4 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =4 
           =4 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =4 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =4 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =4 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
           =4 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) vartype locsegment name _at_ addr
           =4 
           =4 # else  // __SLS_IDE__
           =4 
           =4 # define INTERRUPT(name, vector) void name (void)
           =4 # define INTERRUPT_USING(name, vector, regnum) void name (void)
           =4 # define INTERRUPT_PROTO(name, vector) void name (void)
           =4 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
           =4 
           =4 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =4 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =4 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =4 
           =4 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype name
           =4 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype * name
           =4 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype * name
           =4 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * name
           =4 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) vartype name
           =4 
           =4 # endif // __SLS_IDE__
           =4 
           =4 // used with UU16
           =4 # define LSB 1
           =4 # define MSB 0
           =4 
           =4 // used with UU32 (b0 is least-significant byte)
           =4 # define b0 3
           =4 # define b1 2
           =4 # define b2 1
           =4 # define b3 0
           =4 
           =4 typedef unsigned char U8;
           =4 typedef unsigned int U16;
           =4 typedef unsigned long U32;
           =4 
           =4 typedef signed char S8;
           =4 typedef signed int S16;
           =4 typedef signed long S32;
           =4 
           =4 typedef union UU16
           =4 {
           =4    U16 U16;
           =4    S16 S16;
           =4    U8 U8[2];
           =4    S8 S8[2];
           =4 } UU16;
           =4 
           =4 typedef union UU32
           =4 {
           =4    U32 U32;
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 57  

           =4    S32 S32;
           =4    UU16 UU16[2];
           =4    U16 U16[2];
           =4    S16 S16[2];
           =4    U8 U8[4];
           =4    S8 S8[4];
           =4 } UU32;
           =4 
           =4 // NOP () macro support
           =4 extern void _nop_ (void);
           =4 #define NOP() _nop_()
           =4 
           =4 // generic pointer memory type specifiers
           =4 #define SI_GPTR
           =4 #define SI_GPTR_MTYPE_DATA      0x00
           =4 #define SI_GPTR_MTYPE_IDATA     0x00
           =4 #define SI_GPTR_MTYPE_BDATA     0x00
           =4 #define SI_GPTR_MTYPE_PDATA     0xFE
           =4 #define SI_GPTR_MTYPE_XDATA     0x01
           =4 #define SI_GPTR_MTYPE_CODE      0xFF
           =4 
           =4 // generic pointer access struct
           =4 typedef union SI_GENERIC_PTR
           =4 {
           =4     U8 U8[3];
           =4     struct
           =4     {
           =4         U8 MTYPE;
           =4         UU16 ADDR;
           =4     } GPTR;
           =4 } SI_GENERIC_PTR;
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 // Hi-Tech 8051
           =4 // http://www.htsoft.com
           =4 
           =4 #elif defined HI_TECH_C
           =4 
           =4 # define SEG_GENERIC
           =4 # define SEG_FAR   far
           =4 # define SEG_DATA  data
           =4 # define SEG_NEAR  near
           =4 # define SEG_IDATA idata
           =4 # define SEG_XDATA xdata
           =4 # define SEG_PDATA pdata
           =4 # define SEG_CODE  code
           =4 # define SEG_BDATA bdata
           =4 
           =4 
           =4 # define SBIT(name, addr, thebit) static volatile bit name @ (addr + thebit)
           =4 # define SFR(name, addr)          static volatile unsigned char name @ addr
           =4 # define SFR16(name, addr)        static volatile unsigned int name @ addr
           =4 # define SFR16E(name, fulladdr) /* not supported */
           =4 # define SFR32(name, fulladdr)  /* not supported */
           =4 # define SFR32E(name, fulladdr) /* not supported */
           =4 
           =4 # define INTERRUPT(name, vector)       void name (void) interrupt vector
           =4 # define INTERRUPT_PROTO(name, vector)
           =4 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
           =4 # define INTERRUPT_PROTO_USING(name, vector, regnum)
           =4 
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 58  

           =4 # define FUNCTION_USING(name, return_value, parameter, regnum) /* not supported */
           =4 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) /* not supported */
           =4 // Note: Hi-Tech does not support functions using different register banks. Register
           =4 //       banks can only be specified in interrupts. If a function is called from
           =4 //       inside an interrupt, it will use the same register bank as the interrupt.
           =4 
           =4 # define SEGMENT_VARIABLE(name, vartype, locsegment) locsegment vartype name
           =4 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) targsegment vartype * name
           =4 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) targsegment vartype * lo
             -csegment name
           =4 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment vartype name @ addr
           =4 
           =4 // used with UU16
           =4 # define LSB 0
           =4 # define MSB 1
           =4 
           =4 // used with UU32 (b0 is least-significant byte)
           =4 # define b0 0
           =4 # define b1 1
           =4 # define b2 2
           =4 # define b3 3
           =4 
           =4 typedef unsigned char U8;
           =4 typedef unsigned int U16;
           =4 typedef unsigned long U32;
           =4 
           =4 typedef signed char S8;
           =4 typedef signed int S16;
           =4 typedef signed long S32;
           =4 
           =4 typedef union UU16
           =4 {
           =4    U16 U16;
           =4    S16 S16;
           =4    U8 U8[2];
           =4    S8 S8[2];
           =4 } UU16;
           =4 
           =4 typedef union UU32
           =4 {
           =4    U32 U32;
           =4    S32 S32;
           =4    UU16 UU16[2];
           =4    U16 U16[2];
           =4    S16 S16[2];
           =4    U8 U8[4];
           =4    S8 S8[4];
           =4 } UU32;
           =4 
           =4 // NOP () macro support
           =4 #define NOP() asm(" nop ")
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 // Tasking / Altium
           =4 // http://www.altium.com/tasking
           =4 
           =4 
           =4 #elif defined _CC51
           =4 
           =4 # define SEG_GENERIC
           =4 # define SEG_FAR   _xdat
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 59  

           =4 # define SEG_DATA  _data
           =4 # define SEG_NEAR  _data
           =4 # define SEG_IDATA _idat
           =4 # define SEG_XDATA _xdat
           =4 # define SEG_PDATA _pdat
           =4 # define SEG_CODE  _rom
           =4 # define SEG_BDATA _bdat
           =4 
           =4 # define SBIT(name, addr, bit)  _sfrbit  name _at(addr+bit)
           =4 # define SFR(name, addr)        _sfrbyte name _at(addr)
           =4 # define SFRX(name, addr)       _xdat volatile unsigned char name _at(addr)
           =4 #if _CC51 > 71
           =4 # define SFR16(name, addr)      _sfrword _little name _at(addr)
           =4 #else
           =4 # define SFR16(name, addr)      /* not supported */
           =4 #endif
           =4 # define SFR16E(name, fulladdr) /* not supported */
           =4 # define SFR32(name, fulladdr)  /* not supported */
           =4 # define SFR32E(name, fulladdr) /* not supported */
           =4 
           =4 # define INTERRUPT(name, vector) _interrupt (vector) void name (void)
           =4 # define INTERRUPT_USING(name, vector, regnum) _interrupt (vector) _using(regnum) void name (void)
           =4 # define INTERRUPT_PROTO(name, vector) _interrupt (vector) void name (void)
           =4 # define INTERRUPT_PROTO_USING(name, vector, regnum) _interrupt (vector) _using(regnum) void name (void)
           =4 
           =4 // When calling FUNCTION_USING in Tasking, the function must be called from an interrupt or Main which
           =4 // is also using the same register bank. If not, the compiler will generate an error.
           =4 # define FUNCTION_USING(name, return_value, parameter, regnum) _using(regnum) return_value name (parameter
             -)
           =4 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) _using(regnum) return_value name (par
             -ameter)
           =4 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =4 
           =4 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =4 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =4 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =4 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) vartype locsegment name _at( addr )
           =4 
           =4 // used with UU16
           =4 # define LSB 1
           =4 # define MSB 0
           =4 
           =4 // used with UU32 (b0 is least-significant byte)
           =4 # define b0 3
           =4 # define b1 2
           =4 # define b2 1
           =4 # define b3 0
           =4 
           =4 typedef unsigned char U8;
           =4 typedef unsigned int U16;
           =4 typedef unsigned long U32;
           =4 
           =4 typedef signed char S8;
           =4 typedef signed int S16;
           =4 typedef signed long S32;
           =4 
           =4 typedef union UU16
           =4 {
           =4    U16 U16;
           =4    S16 S16;
           =4    U8 U8[2];
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 60  

           =4    S8 S8[2];
           =4 } UU16;
           =4 
           =4 typedef union UU32
           =4 {
           =4    U32 U32;
           =4    S32 S32;
           =4    UU16 UU16[2];
           =4    U16 U16[2];
           =4    S16 S16[2];
           =4    U8 U8[4];
           =4    S8 S8[4];
           =4 } UU32;
           =4 
           =4 // NOP () macro support
           =4 extern void _nop (void);
           =4 #define NOP() _nop()
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 
           =4 // IAR 8051
           =4 // http://www.iar.com
           =4 
           =4 #elif defined __ICC8051__
           =4 
           =4 #include <stdbool.h>
           =4 #include <intrinsics.h>
           =4 
           =4 # define SBIT(name, addr, bit)  __bit __no_init volatile bool name @ (addr+bit)
           =4 # define SFR(name, addr)        __sfr __no_init volatile unsigned char name @ addr
           =4 # define SFRX(name, addr)       __xdata __no_init volatile unsigned char name @ addr
           =4 # define SFR16(name, addr)      __sfr __no_init volatile unsigned int  name @ addr
           =4 # define SFR16E(name, fulladdr) /* not supported */
           =4 # define SFR32(name, fulladdr) /* not supported */
           =4 # define SFR32E(name, fulladdr) /* not supported */
           =4 
           =4 # define SEG_GENERIC __generic
           =4 # define SEG_FAR  __xdata
           =4 # define SEG_DATA __data
           =4 # define SEG_NEAR __data
           =4 # define SEG_IDATA __idata
           =4 # define SEG_XDATA __xdata
           =4 # define SEG_PDATA __pdata
           =4 # define SEG_CODE  __code
           =4 # define SEG_BDATA __bdata
           =4 
           =4 #define bit bool
           =4 
           =4 # define _PPTOSTR_(x) #x
           =4 # define _PPARAM_(address) _PPTOSTR_(vector=address * 8 + 3)
           =4 # define _PPARAM2_(regbank) _PPTOSTR_(register_bank=regbank)
           =4 # define INTERRUPT(name, vector) _Pragma(_PPARAM_(vector)) __interrupt void name(void)
           =4 # define INTERRUPT_PROTO(name, vector)  __interrupt void name(void)
           =4 # define INTERRUPT_USING(name, vector, regnum) _Pragma(_PPARAM2_(regnum)) _Pragma(_PPARAM_(vector)) __inte
             -rrupt void name(void)
           =4 # define INTERRUPT_PROTO_USING(name, vector, regnum) __interrupt void name(void)
           =4 
           =4 # define FUNCTION_USING(name, return_value, parameter, regnum) /* not supported */
           =4 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) /* not supported */
           =4 // Note: IAR does not support functions using different register banks. Register
           =4 //       banks can only be specified in interrupts. If a function is called from
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 61  

           =4 //       inside an interrupt, it will use the same register bank as the interrupt.
           =4 
           =4 # define SEGMENT_VARIABLE(name, vartype, locsegment)  locsegment vartype name
           =4 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment  * name
           =4 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =4 
           =4 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment __no_init vartype name @ addr
           =4 
           =4 // used with UU16
           =4 # define LSB 0
           =4 # define MSB 1
           =4 
           =4 // used with UU32 (b0 is least-significant byte)
           =4 # define b0 0
           =4 # define b1 1
           =4 # define b2 2
           =4 # define b3 3
           =4 
           =4 typedef unsigned char U8;
           =4 typedef unsigned int U16;
           =4 typedef unsigned long U32;
           =4 
           =4 typedef signed char S8;
           =4 typedef signed int S16;
           =4 typedef signed long S32;
           =4 
           =4 typedef union UU16
           =4 {
           =4    U16 U16;
           =4    S16 S16;
           =4    U8 U8[2];
           =4    S8 S8[2];
           =4 } UU16;
           =4 
           =4 typedef union UU32
           =4 {
           =4    U32 U32;
           =4    S32 S32;
           =4    UU16 UU16[2];
           =4    U16 U16[2];
           =4    S16 S16[2];
           =4    U8 U8[4];
           =4    S8 S8[4];
           =4 } UU32;
           =4 
           =4 
           =4 #define NOP() __no_operation();
           =4 
           =4 // generic pointer memory type specifiers
           =4 #define SI_GPTR
           =4 #define SI_GPTR_MTYPE_DATA       0x01
           =4 #define SI_GPTR_MTYPE_IDATA      0x01
           =4 #define SI_GPTR_MTYPE_BDATA      0x01
           =4 #define SI_GPTR_MTYPE_PDATA      0x00
           =4 #define SI_GPTR_MTYPE_XDATA      0x00
           =4 #define SI_GPTR_MTYPE_CODE       0x80
           =4 
           =4 // generic pointer access struct
           =4 typedef union SI_GENERIC_PTR
           =4 {
           =4     U8 U8[3];
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 62  

           =4     struct
           =4     {
           =4         UU16 ADDR;
           =4         U8 MTYPE;
           =4     } GPTR;
           =4 } SI_GENERIC_PTR;
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 // Crossware
           =4 // http://www.crossware.com
           =4 
           =4 #elif defined _XC51_VER
           =4 # define SBIT(name, addr, bit)  _sfrbit  name = (addr+bit)
           =4 # define SFR(name, addr)        _sfr     name = addr
           =4 # define SFR16(name, addr)      _sfrword name = addr
           =4 # define SFR16E(name, fulladdr) /* not supported */
           =4 # define SFR32(name, fulladdr)  /* not supported */
           =4 # define SFR32E(name, fulladdr) /* not supported */
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 // Wickenh盲user
           =4 // http://www.wickenhaeuser.de
           =4 
           =4 #elif defined __UC__
           =4 # define SBIT(name, addr, bit)  unsigned char bit  name @ (addr+bit)
           =4 # define SFR(name, addr)        near unsigned char name @ addr
           =4 # define SFR16(name, addr)      /* not supported */
           =4 # define SFR16E(name, fulladdr) /* not supported */
           =4 # define SFR32(name, fulladdr)  /* not supported */
           =4 # define SFR32E(name, fulladdr) /* not supported */
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 // Default
           =4 // Unknown compiler
           =4 
           =4 #else
           =4 # warning unrecognized compiler
           =4 # define SBIT(name, addr, bit)  volatile bool           name
           =4 # define SFR(name, addr)        volatile unsigned char  name
           =4 # define SFRX(name, addr)       volatile unsigned char  name
           =4 # define SFR16(name, addr)      volatile unsigned short name
           =4 # define SFR16E(name, fulladdr) volatile unsigned short name
           =4 # define SFR32(name, fulladdr)  volatile unsigned long  name
           =4 # define SFR32E(name, fulladdr) volatile unsigned long  name
           =4 
           =4 #endif
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 // Header File PreProcessor Directive
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 #endif                                 // #define COMPILER_DEFS_H
 804      =4  
 805      =4  //-----------------------------------------------------------------------------
 806      =4  // End Of File
 807      =4  //-----------------------------------------------------------------------------
   5      =3  #include "C8051F020_defs.h"
   1      =4  //-----------------------------------------------------------------------------
   2      =4  // C8051F020_defs.h
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 63  

   3      =4  //-----------------------------------------------------------------------------
   4      =4  // Copyright 2007, Silicon Laboratories, Inc.
   5      =4  // http://www.silabs.com
   6      =4  //
   7      =4  // Program Description:
   8      =4  //
   9      =4  // Register/bit definitions for the C8051F02x family.
  10      =4  // **Important Note**: The compiler_defs.h header file should be included
  11      =4  // before including this header file.
  12      =4  //
  13      =4  // Target:         C8051F020, 'F021, 'F022, 'F023
  14      =4  // Tool chain:     Generic
  15      =4  // Command Line:   None
  16      =4  //
  17      =4  // Release 1.4 - 20 AUG 2012 (TP)
  18      =4  //    -Added #define for _XPAGE to provide support for SDCC memory paging
  19      =4  //     (pdata)
  20      =4  // Release 1.3 - 07 AUG 2007 (PKC)
  21      =4  //    -Removed #include <compiler_defs.h>. The C source file should include it.
  22      =4  // Release 1.2 - 09 JUL 2007 (PKC)
  23      =4  //    -Reformatted header file to enable portable SFR definitions
  24      =4  
  25      =4  //-----------------------------------------------------------------------------
  26      =4  // Header File Preprocessor Directive
  27      =4  //-----------------------------------------------------------------------------
  28      =4  
  29      =4  #ifndef C8051F020_DEFS_H
           =4 #define C8051F020_DEFS_H
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 // Byte Registers
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 SFR (P0, 0x80);                        // Port 0 Latch
           =4 SFR (SP, 0x81);                        // Stack Pointer
           =4 SFR (DPL, 0x82);                       // Data Pointer Low
           =4 SFR (DPH, 0x83);                       // Data Pointer High
           =4 SFR (P4, 0x84);                        // Port 4 Latch
           =4 SFR (P5, 0x85);                        // Port 5 Latch
           =4 SFR (P6, 0x86);                        // Port 6 Latch
           =4 SFR (PCON, 0x87);                      // Power Control
           =4 SFR (TCON, 0x88);                      // Timer/Counter Control
           =4 SFR (TMOD, 0x89);                      // Timer/Counter Mode
           =4 SFR (TL0, 0x8A);                       // Timer/Counter 0 Low
           =4 SFR (TL1, 0x8B);                       // Timer/Counter 1 Low
           =4 SFR (TH0, 0x8C);                       // Timer/Counter 0 High
           =4 SFR (TH1, 0x8D);                       // Timer/Counter 1 High
           =4 SFR (CKCON, 0x8E);                     // Clock Control
           =4 SFR (PSCTL, 0x8F);                     // Program Store R/W Control
           =4 SFR (P1, 0x90);                        // Port 1 Latch
           =4 SFR (TMR3CN, 0x91);                    // Timer/Counter 3 Control
           =4 SFR (TMR3RLL, 0x92);                   // Timer/Counter 3 Reload Low
           =4 SFR (TMR3RLH, 0x93);                   // Timer/Counter 3 Reload High
           =4 SFR (TMR3L, 0x94);                     // Timer/Counter 3 Low
           =4 SFR (TMR3H, 0x95);                     // Timer/Counter 3 High
           =4 SFR (P7, 0x96);                        // Port 7 Latch
           =4 SFR (SCON0, 0x98);                     // Serial Port UART0 Control
           =4 SFR (SBUF0, 0x99);                     // Serial Port UART0 Data Buffer
           =4 SFR (SPI0CFG, 0x9A);                   // SPI0 Configuration
           =4 SFR (SPI0DAT, 0x9B);                   // SPI0 Data
           =4 SFR (ADC1, 0x9C);                      // ADC1 Data
           =4 SFR (SPI0CKR, 0x9D);                   // SPI0 Clock Rate Control
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 64  

           =4 SFR (CPT0CN, 0x9E);                    // Comparator 0 Control
           =4 SFR (CPT1CN, 0x9F);                    // Comparator 1 Control
           =4 SFR (P2, 0xA0);                        // Port 2 Latch
           =4 SFR (EMI0TC, 0xA1);                    // EMIF Timing Control
           =4 SFR (EMI0CF, 0xA3);                    // EMIF Configuration
           =4 SFR (P0MDOUT, 0xA4);                   // Port 0 Output Mode Configuration
           =4 SFR (P1MDOUT, 0xA5);                   // Port 1 Output Mode Configuration
           =4 SFR (P2MDOUT, 0xA6);                   // Port 2 Output Mode Configuration
           =4 SFR (P3MDOUT, 0xA7);                   // Port 3 Output Mode Configuration
           =4 SFR (IE, 0xA8);                        // Interrupt Enable
           =4 SFR (SADDR0, 0xA9);                    // Serial Port UART0 Slave Address
           =4 SFR (ADC1CN, 0xAA);                    // ADC1 Control
           =4 SFR (ADC1CF, 0xAB);                    // ADC1 Analog Mux Configuration
           =4 SFR (AMX1SL, 0xAC);                    // ADC1 Analog Mux Channel Select
           =4 SFR (P3IF, 0xAD);                      // Port 3 External Interrupt Flags
           =4 SFR (SADEN1, 0xAE);                    // Serial Port UART1 Slave Address Mask
           =4 SFR (EMI0CN, 0xAF);                    // EMIF Control
           =4 SFR (P3, 0xB0);                        // Port 3 Latch
           =4 SFR (OSCXCN, 0xB1);                    // External Oscillator Control
           =4 SFR (OSCICN, 0xB2);                    // Internal Oscillator Control
           =4 SFR (P74OUT, 0xB5);                    // Ports 4 - 7 Output Mode
           =4 SFR (FLSCL, 0xB6);                     // Flash Memory Timing Prescaler
           =4 SFR (FLACL, 0xB7);                     // Flash Acess Limit
           =4 SFR (IP, 0xB8);                        // Interrupt Priority
           =4 SFR (SADEN0, 0xB9);                    // Serial Port UART0 Slave Address Mask
           =4 SFR (AMX0CF, 0xBA);                    // ADC0 Mux Configuration
           =4 SFR (AMX0SL, 0xBB);                    // ADC0 Mux Channel Selection
           =4 SFR (ADC0CF, 0xBC);                    // ADC0 Configuration
           =4 SFR (P1MDIN, 0xBD);                    // Port 1 Input Mode
           =4 SFR (ADC0L, 0xBE);                     // ADC0 Data Low
           =4 SFR (ADC0H, 0xBF);                     // ADC0 Data High
           =4 SFR (SMB0CN, 0xC0);                    // SMBus0 Control
           =4 SFR (SMB0STA, 0xC1);                   // SMBus0 Status
           =4 SFR (SMB0DAT, 0xC2);                   // SMBus0 Data
           =4 SFR (SMB0ADR, 0xC3);                   // SMBus0 Slave Address
           =4 SFR (ADC0GTL, 0xC4);                   // ADC0 Greater-Than Register Low
           =4 SFR (ADC0GTH, 0xC5);                   // ADC0 Greater-Than Register High
           =4 SFR (ADC0LTL, 0xC6);                   // ADC0 Less-Than Register Low
           =4 SFR (ADC0LTH, 0xC7);                   // ADC0 Less-Than Register High
           =4 SFR (T2CON, 0xC8);                     // Timer/Counter 2 Control
           =4 SFR (T4CON, 0xC9);                     // Timer/Counter 4 Control
           =4 SFR (RCAP2L, 0xCA);                    // Timer/Counter 2 Capture Low
           =4 SFR (RCAP2H, 0xCB);                    // Timer/Counter 2 Capture High
           =4 SFR (TL2, 0xCC);                       // Timer/Counter 2 Low
           =4 SFR (TH2, 0xCD);                       // Timer/Counter 2 High
           =4 SFR (SMB0CR, 0xCF);                    // SMBus0 Clock Rate
           =4 SFR (PSW, 0xD0);                       // Program Status Word
           =4 SFR (REF0CN, 0xD1);                    // Voltage Reference 0 Control
           =4 SFR (DAC0L, 0xD2);                     // DAC0 Register Low
           =4 SFR (DAC0H, 0xD3);                     // DAC0 Register High
           =4 SFR (DAC0CN, 0xD4);                    // DAC0 Control
           =4 SFR (DAC1L, 0xD5);                     // DAC1 Register Low
           =4 SFR (DAC1H, 0xD6);                     // DAC1 Register High
           =4 SFR (DAC1CN, 0xD7);                    // DAC1 Control
           =4 SFR (PCA0CN, 0xD8);                    // PCA0 Control
           =4 SFR (PCA0MD, 0xD9);                    // PCA0 Mode
           =4 SFR (PCA0CPM0, 0xDA);                  // PCA0 Module 0 Mode Register
           =4 SFR (PCA0CPM1, 0xDB);                  // PCA0 Module 1 Mode Register
           =4 SFR (PCA0CPM2, 0xDC);                  // PCA0 Module 2 Mode Register
           =4 SFR (PCA0CPM3, 0xDD);                  // PCA0 Module 3 Mode Register
           =4 SFR (PCA0CPM4, 0xDE);                  // PCA0 Module 4 Mode Register
           =4 SFR (ACC, 0xE0);                       // Accumulator
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 65  

           =4 SFR (XBR0, 0xE1);                      // Port I/O Crossbar Control 0
           =4 SFR (XBR1, 0xE2);                      // Port I/O Crossbar Control 1
           =4 SFR (XBR2, 0xE3);                      // Port I/O Crossbar Control 2
           =4 SFR (RCAP4L, 0xE4);                    // Timer 4 Capture Register Low
           =4 SFR (RCAP4H, 0xE5);                    // Timer 4 Capture Register High
           =4 SFR (EIE1, 0xE6);                      // External Interrupt Enable 1
           =4 SFR (EIE2, 0xE7);                      // External Interrupt Enable 2
           =4 SFR (ADC0CN, 0xE8);                    // ADC0 Control
           =4 SFR (PCA0L, 0xE9);                     // PCA0 Counter Low
           =4 SFR (PCA0CPL0, 0xEA);                  // PCA0 Capture 0 Low
           =4 SFR (PCA0CPL1, 0xEB);                  // PCA0 Capture 1 Low
           =4 SFR (PCA0CPL2, 0xEC);                  // PCA0 Capture 2 Low
           =4 SFR (PCA0CPL3, 0xED);                  // PCA0 Capture 3 Low
           =4 SFR (PCA0CPL4, 0xEE);                  // PCA0 Capture 4 Low
           =4 SFR (RSTSRC, 0xEF);                    // Reset Source Configuration/Status
           =4 SFR (B, 0xF0);                         // B Register
           =4 SFR (SCON1, 0xF1);                     // Serial Port UART1 Control
           =4 SFR (SBUF1, 0xF2);                     // Serail Port UART1 Data
           =4 SFR (SADDR1, 0xF3);                    // Serail Port UART1 Slave Address
           =4 SFR (TL4, 0xF4);                       // Timer/Counter 4 Low
           =4 SFR (TH4, 0xF5);                       // Timer/Counter 4 High
           =4 SFR (EIP1, 0xF6);                      // External Interrupt Priority 1
           =4 SFR (EIP2, 0xF7);                      // External Interrupt Priority 2
           =4 SFR (SPI0CN, 0xF8);                    // SPI0 Control
           =4 SFR (PCA0H, 0xF9);                     // PCA0 Counter High
           =4 SFR (PCA0CPH0, 0xFA);                  // PCA0 Capture 0 High
           =4 SFR (PCA0CPH1, 0xFB);                  // PCA0 Capture 1 High
           =4 SFR (PCA0CPH2, 0xFC);                  // PCA0 Capture 2 High
           =4 SFR (PCA0CPH3, 0xFD);                  // PCA0 Capture 3 High
           =4 SFR (PCA0CPH4, 0xFE);                  // PCA0 Capture 4 High
           =4 SFR (WDTCN, 0xFF);                     // Watchdog Timer Control
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 // 16-bit Register Definitions (might not be supported by all compilers)
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 SFR16 (DP, 0x82);                      // Data Pointer
           =4 SFR16 (TMR3RL, 0x92);                  // Timer3 Reload Value
           =4 SFR16 (TMR3, 0x94);                    // Timer3 Counter
           =4 SFR16 (ADC0, 0xBE);                    // ADC0 Data
           =4 SFR16 (ADC0GT, 0xC4);                  // ADC0 Greater Than Window
           =4 SFR16 (ADC0LT, 0xC6);                  // ADC0 Less Than Window
           =4 SFR16 (RCAP2, 0xCA);                   // Timer2 Capture/Reload
           =4 SFR16 (T2, 0xCC);                      // Timer2 Counter
           =4 SFR16 (TMR2RL, 0xCA);                  // Timer2 Capture/Reload
           =4 SFR16 (TMR2, 0xCC);                    // Timer2 Counter
           =4 SFR16 (RCAP4, 0xE4);                   // Timer4 Capture/Reload
           =4 SFR16 (T4, 0xF4);                      // Timer4 Counter
           =4 SFR16 (TMR4RL, 0xE4);                  // Timer4 Capture/Reload
           =4 SFR16 (TMR4, 0xF4);                    // Timer4 Counter
           =4 SFR16 (DAC0, 0xD2);                    // DAC0 Data
           =4 SFR16 (DAC1, 0xD5);                    // DAC1 Data
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 // Address Definitions for bit-addressable SFRs
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 #define SFR_P0       0x80
           =4 #define SFR_TCON     0x88
           =4 #define SFR_P1       0x90
           =4 #define SFR_SCON0    0x98
           =4 #define SFR_P2       0xA0
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 66  

           =4 #define SFR_IE       0xA8
           =4 #define SFR_P3       0xB0
           =4 #define SFR_IP       0xB8
           =4 #define SFR_SMB0CN   0xC0
           =4 #define SFR_T2CON    0xC8
           =4 #define SFR_PSW      0xD0
           =4 #define SFR_PCA0CN   0xD8
           =4 #define SFR_ACC      0xE0
           =4 #define SFR_ADC0CN   0xE8
           =4 #define SFR_B        0xF0
           =4 #define SFR_SPI0CN   0xF8
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 // Bit Definitions
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 // TCON 0x88
           =4 SBIT (TF1, SFR_TCON, 7);               // Timer 1 Overflow Flag
           =4 SBIT (TR1, SFR_TCON, 6);               // Timer 1 On/Off Control
           =4 SBIT (TF0, SFR_TCON, 5);               // Timer 0 Overflow Flag
           =4 SBIT (TR0, SFR_TCON, 4);               // Timer 0 On/Off Control
           =4 SBIT (IE1, SFR_TCON, 3);               // Ext. Interrupt 1 Edge Flag
           =4 SBIT (IT1, SFR_TCON, 2);               // Ext. Interrupt 1 Type
           =4 SBIT (IE0, SFR_TCON, 1);               // Ext. Interrupt 0 Edge Flag
           =4 SBIT (IT0, SFR_TCON, 0);               // Ext. Interrupt 0 Type
           =4 
           =4 // SCON0 0x98
           =4 SBIT (SM00, SFR_SCON0, 7);             // Serial Mode Control Bit 0
           =4 SBIT (SM10, SFR_SCON0, 6);             // Serial Mode Control Bit 1
           =4 SBIT (SM20, SFR_SCON0, 5);             // Multiprocessor Communication Enable
           =4 SBIT (REN0, SFR_SCON0, 4);             // Receive Enable
           =4 SBIT (TB80, SFR_SCON0, 3);             // Transmit Bit 8
           =4 SBIT (RB80, SFR_SCON0, 2);             // Receive Bit 8
           =4 SBIT (TI0, SFR_SCON0, 1);              // Transmit Interrupt Flag
           =4 SBIT (RI0, SFR_SCON0, 0);              // Receive Interrupt Flag
           =4 
           =4 // IE 0xA8
           =4 SBIT (EA, SFR_IE, 7);                  // Global Interrupt Enable
           =4 SBIT (IEGF0, SFR_IE, 6);               // General Purpose Flag 0
           =4 SBIT (ET2, SFR_IE, 5);                 // Timer 2 Interrupt Enable
           =4 SBIT (ES0, SFR_IE, 4);                 // Uart0 Interrupt Enable
           =4 SBIT (ET1, SFR_IE, 3);                 // Timer 1 Interrupt Enable
           =4 SBIT (EX1, SFR_IE, 2);                 // External Interrupt 1 Enable
           =4 SBIT (ET0, SFR_IE, 1);                 // Timer 0 Interrupt Enable
           =4 SBIT (EX0, SFR_IE, 0);                 // External Interrupt 0 Enable
           =4 
           =4 // IP 0xB8
           =4                                        // Bit7 UNUSED
           =4                                        // Bit6 UNUSED
           =4 SBIT (PT2, SFR_IP, 5);                 // Timer 2 Priority
           =4 SBIT (PS, SFR_IP, 4);                  // Serial Port Priority
           =4 SBIT (PT1, SFR_IP, 3);                 // Timer 1 Priority
           =4 SBIT (PX1, SFR_IP, 2);                 // External Interrupt 1 Priority
           =4 SBIT (PT0, SFR_IP, 1);                 // Timer 0 Priority
           =4 SBIT (PX0, SFR_IP, 0);                 // External Interrupt 0 Priority
           =4 
           =4 // SMB0CN 0xC0
           =4 SBIT (BUSY, SFR_SMB0CN, 7);            // SMBus 0 Busy
           =4 SBIT (ENSMB, SFR_SMB0CN, 6);           // SMBus 0 Enable
           =4 SBIT (STA, SFR_SMB0CN, 5);             // SMBus 0 Start Flag
           =4 SBIT (STO, SFR_SMB0CN, 4);             // SMBus 0 Stop Flag
           =4 SBIT (SI, SFR_SMB0CN, 3);              // SMBus 0 Interrupt Pending Flag
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 67  

           =4 SBIT (AA, SFR_SMB0CN, 2);              // SMBus 0 Assert/Acknowledge Flag
           =4 SBIT (SMBFTE, SFR_SMB0CN, 1);          // SMBus 0 Free Timer Enable
           =4 SBIT (SMBTOE, SFR_SMB0CN, 0);          // SMBus 0 Timeout Enable
           =4 
           =4 // T2CON 0xC8
           =4 SBIT (TF2, SFR_T2CON, 7);              // Timer 2 Overflow Flag
           =4 SBIT (EXF2, SFR_T2CON, 6);             // External Flag
           =4 SBIT (RCLK0, SFR_T2CON, 5);            // Uart0 Rx Clock Source
           =4 SBIT (TCLK0, SFR_T2CON, 4);            // Uart0 Tx Clock Source
           =4 SBIT (EXEN2, SFR_T2CON, 3);            // Timer 2 External Enable Flag
           =4 SBIT (TR2, SFR_T2CON, 2);              // Timer 2 On/Off Control
           =4 SBIT (CT2, SFR_T2CON, 1);              // Timer Or Counter Select
           =4 SBIT (CPRL2, SFR_T2CON, 0);            // Capture Or Reload Select
           =4 
           =4 //  PSW 0xD0
           =4 SBIT (CY, SFR_PSW, 7);                 // Carry Flag
           =4 SBIT (AC, SFR_PSW, 6);                 // Auxiliary Carry Flag
           =4 SBIT (F0, SFR_PSW, 5);                 // User Flag 0
           =4 SBIT (RS1, SFR_PSW, 4);                // Register Bank Select 1
           =4 SBIT (RS0, SFR_PSW, 3);                // Register Bank Select 0
           =4 SBIT (OV, SFR_PSW, 2);                 // Overflow Flag
           =4 SBIT (F1, SFR_PSW, 1);                 // User Flag 1
           =4 SBIT (P, SFR_PSW, 0);                  // Accumulator Parity Flag
           =4 
           =4 // PCA0CN 0xD8
           =4 SBIT (CF, SFR_PCA0CN, 7);              // PCA 0 Counter Overflow Flag
           =4 SBIT (CR, SFR_PCA0CN, 6);              // PCA 0 Counter Run Control Bit
           =4                                        // Bit5 UNUSED
           =4 SBIT (CCF4, SFR_PCA0CN, 4);            // PCA 0 Module 4 Interrupt Flag
           =4 SBIT (CCF3, SFR_PCA0CN, 3);            // PCA 0 Module 3 Interrupt Flag
           =4 SBIT (CCF2, SFR_PCA0CN, 2);            // PCA 0 Module 2 Interrupt Flag
           =4 SBIT (CCF1, SFR_PCA0CN, 1);            // PCA 0 Module 1 Interrupt Flag
           =4 SBIT (CCF0, SFR_PCA0CN, 0);            // PCA 0 Module 0 Interrupt Flag
           =4 
           =4 // ADC0CN 0xE8
           =4 SBIT (AD0EN, SFR_ADC0CN, 7);           // ADC 0 Enable
           =4 SBIT (AD0TM, SFR_ADC0CN, 6);           // ADC 0 Track Mode
           =4 SBIT (AD0INT, SFR_ADC0CN, 5);          // ADC 0 Converision Complete Interrupt Flag
           =4 SBIT (AD0BUSY, SFR_ADC0CN, 4);         // ADC 0 Busy Flag
           =4 SBIT (AD0CM1, SFR_ADC0CN, 3);          // ADC 0 Start Of Conversion Mode Bit 1
           =4 SBIT (AD0CM0, SFR_ADC0CN, 2);          // ADC 0 Start Of Conversion Mode Bit 0
           =4 SBIT (AD0WINT, SFR_ADC0CN, 1);         // ADC 0 Window Compare Interrupt Flag
           =4 SBIT (AD0LJST, SFR_ADC0CN, 0);         // ADC 0 Right Justify Data Bit
           =4 
           =4 // SPI0CN 0xF8
           =4 SBIT (SPIF, SFR_SPI0CN, 7);            // SPI 0 Interrupt Flag
           =4 SBIT (WCOL, SFR_SPI0CN, 6);            // SPI 0 Write Collision Flag
           =4 SBIT (MODF, SFR_SPI0CN, 5);            // SPI 0 Mode Fault Flag
           =4 SBIT (RXOVRN, SFR_SPI0CN, 4);          // SPI 0 Rx Overrun Flag
           =4 SBIT (TXBSY, SFR_SPI0CN, 3);           // SPI 0 Tx Busy Flag
           =4 SBIT (SLVSEL, SFR_SPI0CN, 2);          // SPI 0 Slave Select
           =4 SBIT (MSTEN, SFR_SPI0CN, 1);           // SPI 0 Master Enable
           =4 SBIT (SPIEN, SFR_SPI0CN, 0);           // SPI 0 SPI Enable
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 // Interrupt Priorities
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 #define INTERRUPT_INT0           0     // External Interrupt 0
           =4 #define INTERRUPT_TIMER0         1     // Timer0 Overflow
           =4 #define INTERRUPT_INT1           2     // External Interrupt 1
           =4 #define INTERRUPT_TIMER1         3     // Timer1 Overflow
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 68  

           =4 #define INTERRUPT_UART0          4     // Serial Port UART0
           =4 #define INTERRUPT_TIMER2         5     // Timer2 Overflow
           =4 #define INTERRUPT_SPI0           6     // SPI0 Interface
           =4 #define INTERRUPT_SMBUS0         7     // SMBus0 Interface
           =4 #define INTERRUPT_ADC0_WINDOW    8     // ADC0 Window Comparison
           =4 #define INTERRUPT_PCA0           9     // PCA0 Peripheral
           =4 #define INTERRUPT_COMPARATOR0F   10    // Comparator0 Falling Edge
           =4 #define INTERRUPT_COMPARATOR0R   11    // Comparator0 Rising Edge
           =4 #define INTERRUPT_COMPARATOR1F   12    // Comparator1 Falling Edge
           =4 #define INTERRUPT_COMPARATOR1R   13    // Comparator1 Rising Edge
           =4 #define INTERRUPT_TIMER3         14    // Timer3 Overflow
           =4 #define INTERRUPT_ADC0_EOC       15    // ADC0 End Of Conversion
           =4 #define INTERRUPT_TIMER4         16    // Timer4 Overflow
           =4 #define INTERRUPT_ADC1_EOC       17    // ADC1 End Of Conversion
           =4 #define INTERRUPT_INT6           18    // External Interrupt 6
           =4 #define INTERRUPT_INT7           19    // External Interrupt 7
           =4 #define INTERRUPT_UART1          20    // Serial Port UART1
           =4 #define INTERRUPT_XTAL_READY     21    // External Crystal Oscillator Ready
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 // SDCC PDATA External Memory Paging Support
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 #if defined SDCC
           =4 
           =4 SFR(_XPAGE, 0xAF); // Point to the EMI0CN register
           =4 
           =4 #endif
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 // Header File PreProcessor Directive
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 #endif                                 // #define C8051F020_DEFS_H
 347      =4  
 348      =4  //-----------------------------------------------------------------------------
 349      =4  // End Of File
 350      =4  //-----------------------------------------------------------------------------
   6      =3  /*****************************************************************************/
   7      =3  void initDeviceF020(void);
   8      =3  #endif
 139      =2  #endif
 140      =2  #ifdef C8051F580
           =2 #include "InitDeviceF580.h"
           =2 #endif
 143      =2  
 144      =2  #include "delay.h"
   1      =3  #ifndef __DELAY_H__
   2      =3  #define __DELAY_H__
   3      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
           =2 #include "i2c0.h"
           =2 //#include "i2c1.h"
           =2 //#include "i2c2.h"
           =2 //#include "i2c3.h"
           =2 //#include "i2c4.h"
           =2 //#include "i2c5.h"
           =2 //#include "i2c6.h"
           =2 #include "eprom.h"
           =2 //#include "mcp47x6.h"
           =2 //#include "inPca9554.h"
           =2 //#include "outPca9554.h"
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 69  

           =2 /*****************************************************************************/
           =2 #include "Modbus.h"
           =2 #include "ModbusPort.h"
           =2 /*****************************************************************************/
           =2 #include "sPLC.h"
           =2 //#include "pidFuzzy.h"
           =2 /*****************************************************************************/
           =2 //#include "AppMath.h"
           =2 //#include "chipAdc.h"
           =2 //#include "ad5621.h"
           =2 //#include "chipBeem.h"
           =2 
           =2 /*****************************************************************************/
           =2 #endif
   4      =3  #ifndef __DELAY_H__
   4      =3  #define __DELAY_H__
   4      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   5      =3  /*****************************************************************************/
   6      =3  void delayMs(uint8_t ms) reentrant;
   7      =3  void delayUs(uint8_t us) reentrant;
   8      =3  void hwDelayInit(uint8_t reload_h, uint8_t reload_l);
   9      =3  void hwDelay(uint8_t control, uint8_t reload_h, uint8_t reload_l);
  10      =3  /*****************************************************************************/
  11      =3  #endif
  12      =3  
   1      =3  #ifndef __I2C0_H__
   2      =3  #define __I2C0_H__
   3      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   4      =3  #ifndef __I2C0_H__
   4      =3  #define __I2C0_H__
   4      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   5      =3  /*****************************************************************************/
   6      =3  
   7      =3  /*****************************************************************************/
   8      =3  void iic0Init(void);
   9      =3  void iic0Start(void);
  10      =3  void iic0Stop(void);
  11      =3  uint8_t iic0WaitAck(void);
  12      =3  void iic0Ack(void);
  13      =3  void iic0NAck(void);
  14      =3  void iic0SendByte(uint8_t txd);
  15      =3  uint8_t iic0ReadByte(uint8_t ack);
  16      =3  
  17      =3  #endif
  18      =3  
  19      =3  
   1      =3  #ifndef __EPROM_H__
   2      =3  #define __EPROM_H__
   3      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   4      =3  #ifndef __EPROM_H__
   4      =3  #define __EPROM_H__
   4      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   5      =3  /*****************************************************************************/
   6      =3  /*****************************************************************************/
   7      =3  void epromInit(void);
   8      =3  uint8_t epromReadOneByte(uint16_t ReadAddr);
   9      =3  void epromWriteOneByte(uint16_t WriteAddr, uint8_t DataToWrite);
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 70  

  10      =3  void epromWriteLenByte(uint16_t WriteAddr, uint32_t DataToWrite, uint8_t Len);
  11      =3  uint32_t epromReadLenByte(uint16_t ReadAddr, uint8_t Len);
  12      =3  void epromRead(uint16_t ReadAddr,uint8_t *pBuffer,uint16_t NumToRead);
  13      =3  void epromWrite(uint16_t WriteAddr, uint8_t *pBuffer, uint16_t NumToWrite);
  14      =3  void epromTest(void);
  15      =3  #endif
   1      =3  #ifndef __MODBUS__H__
   2      =3  #define __MODBUS__H__
   3      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   4      =3  #ifndef __MODBUS__H__
   4      =3  #define __MODBUS__H__
   4      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   5      =3  /*****************************************************************************/
   6      =3  extern volatile uint16_t modbusTimerValue;
   7      =3  extern volatile uint8_t modbusReceiveCounter;// Collected data number
   8      =3  extern xdata volatile uint8_t modbusReceiveBuffer[CONFIG_MB_RTU_SLAVE_BUFFER_SIZE];
   9      =3  /*****************************************************************************/
  10      =3  extern void initModbus(uint8_t modbusSlaveAddress, uint32_t bd);
  11      =3  extern void modbusPorcess(void);
  12      =3  #endif
   1      =3  #ifndef __MODBUSPORT__H__
   2      =3  #define __MODBUSPORT__H__
   3      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   4      =3  #ifndef __MODBUSPORT__H__
   4      =3  #define __MODBUSPORT__H__
   4      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   5      =3  /*****************************************************************************/
   6      =3  extern void modBusUartInitialise(uint32_t baudrate);
   7      =3  extern void modBusTimerInitialise(void);
   8      =3  extern void modBusUartPutch(uint8_t c);
   9      =3  extern uint8_t modBusUartString(uint8_t *s, uint16_t Length);
  10      =3  extern void receiveInterrupt(uint8_t Data);
  11      =3  /*****************************************************************************/
  12      =3  #endif
   1      =3  #ifndef __SPLC_H__
           =3 #define __SPLC_H__
           =3 /*****************************************************************************/
           =3 #include "appConfig.h"
           =3 //线圈 保持 16 * 16 = 256BIT
           =3 #define MR_START                                                0
           =3 #define MR_END                                                  15
           =3 //线圈寄存器 非保持 16 * 16 = 256BIT
           =3 #define R_START                                                 16
           =3 #define R_END                                                   31
           =3 //数据寄存器 保持 128
           =3 #define DM_START                                                32
           =3 #define DM_END                                                  159
           =3 //数据寄存器 非保持 128个字
           =3 #define EM_START                                                160
           =3 #define EM_END                                                  287
           =3 //延时线圈
           =3 #define T_1MS_START                                             288//16个1mS
           =3 #define T_1MS_END                                               303
           =3 #define T_10MS_START                                    304//16个10mS
           =3 #define T_10MS_END                                              319
           =3 #define T_100MS_START                                   320//16个100mS
           =3 #define T_100MS_END                                             335
           =3 //延时计时器 
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 71  

           =3 #define TD_1MS_START                                    336//16个1mS
           =3 #define TD_1MS_END                                              351
           =3 #define TD_10MS_START                                   352//16个10mS
           =3 #define TD_10MS_END                                             367
           =3 #define TD_100MS_START                                  368//16个100mS
           =3 #define TD_100MS_END                                    383
           =3 //计数器
           =3 #define C_START                                                 384//16个计数器
           =3 #define C_END                                                   399//
           =3 //输入位寄存器 16 * 16 = 256个
           =3 #define X_START                                                 400//
           =3 #define X_END                                                   415// 
           =3 //输出位寄存器 16 * 16 = 256个
           =3 #define Y_START                                                 416// 
           =3 #define Y_END                                                   431//
           =3 //特殊寄存器 128个字
           =3 #define SPREG_START                                             432//
           =3 #define SPREG_END                                               495//
           =3 //特殊线圈      16 * 16 = 256个
           =3 #define SPCOIL_START                                    496
           =3 #define SPCOIL_END                                              511
           =3 /*****************************************************************************/
           =3 #define CONFIG_NVRAM_SIZE                               (SPCOIL_END + 1)
           =3 /*****************************************************************************/
           =3 #define SPREG_ADC_0                                             (SPREG_START)
           =3 #define SPREG_ADC_1                                             (SPREG_START + 1)
           =3 #define SPREG_ADC_2                                             (SPREG_START + 2)
           =3 #define SPREG_ADC_3                                             (SPREG_START + 3)
           =3 #define SPREG_ADC_4                                             (SPREG_START + 4)
           =3 #define SPREG_ADC_5                                             (SPREG_START + 5)
           =3 #define SPREG_ADC_6                                             (SPREG_START + 6)
           =3 #define SPREG_ADC_7                                             (SPREG_START + 7)
           =3 #define SPREG_ADC_8                                             (SPREG_START + 8)
           =3 #define SPREG_ADC_9                                             (SPREG_START + 9)
           =3 #define SPREG_ADC_10                                    (SPREG_START + 10)
           =3 #define SPREG_ADC_11                                    (SPREG_START + 11)
           =3 #define SPREG_ADC_12                                    (SPREG_START + 12)
           =3 #define SPREG_ADC_13                                    (SPREG_START + 13)
           =3 #define SPREG_ADC_14                                    (SPREG_START + 14)
           =3 #define SPREG_ADC_15                                    (SPREG_START + 15)
           =3 #define SPREG_ADC_16                                    (SPREG_START + 16)
           =3 #define SPREG_ADC_17                                    (SPREG_START + 17)
           =3 #define SPREG_ADC_18                                    (SPREG_START + 18)
           =3 #define SPREG_ADC_19                                    (SPREG_START + 19)
           =3 #define SPREG_ADC_20                                    (SPREG_START + 20)
           =3 #define SPREG_ADC_21                                    (SPREG_START + 21)
           =3 #define SPREG_ADC_22                                    (SPREG_START + 22)
           =3 #define SPREG_ADC_23                                    (SPREG_START + 23)
           =3 #define SPREG_ADC_24                                    (SPREG_START + 24)
           =3 #define SPREG_ADC_25                                    (SPREG_START + 25)
           =3 #define SPREG_ADC_26                                    (SPREG_START + 26)
           =3 #define SPREG_ADC_27                                    (SPREG_START + 27)
           =3 #define SPREG_ADC_28                                    (SPREG_START + 28)
           =3 #define SPREG_ADC_29                                    (SPREG_START + 29)
           =3 #define SPREG_ADC_30                                    (SPREG_START + 30)
           =3 #define SPREG_ADC_31                                    (SPREG_START + 31)
           =3 #define SPREG_ADC_32                                    (SPREG_START + 32)
           =3 #define SPREG_ADC_33                                    (SPREG_START + 33)
           =3 #define SPREG_ADC_34                                    (SPREG_START + 34)
           =3 #define SPREG_ADC_35                                    (SPREG_START + 35)
           =3 #define SPREG_ADC_36                                    (SPREG_START + 36)
           =3 #define SPREG_ADC_37                                    (SPREG_START + 37)
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 72  

           =3 #define SPREG_ADC_38                                    (SPREG_START + 38)
           =3 #define SPREG_ADC_39                                    (SPREG_START + 39)
           =3 #define SPREG_ADC_40                                    (SPREG_START + 40)
           =3 #define SPREG_ADC_41                                    (SPREG_START + 41)
           =3 #define SPREG_ADC_42                                    (SPREG_START + 42)
           =3 #define SPREG_ADC_43                                    (SPREG_START + 43)
           =3 #define SPREG_ADC_44                                    (SPREG_START + 44)
           =3 #define SPREG_ADC_45                                    (SPREG_START + 45)
           =3 #define SPREG_ADC_46                                    (SPREG_START + 46)
           =3 #define SPREG_ADC_47                                    (SPREG_START + 47)
           =3 #define SPREG_ADC_48                                    (SPREG_START + 48)
           =3 #define SPREG_ADC_49                                    (SPREG_START + 49)
           =3 #define SPREG_ADC_50                                    (SPREG_START + 50)
           =3 #define SPREG_ADC_51                                    (SPREG_START + 51)
           =3 #define SPREG_ADC_52                                    (SPREG_START + 52)
           =3 #define SPREG_ADC_53                                    (SPREG_START + 53)
           =3 #define SPREG_ADC_54                                    (SPREG_START + 54)
           =3 #define SPREG_ADC_55                                    (SPREG_START + 55)
           =3 #define SPREG_ADC_56                                    (SPREG_START + 56)
           =3 #define SPREG_ADC_57                                    (SPREG_START + 57)
           =3 #define SPREG_ADC_58                                    (SPREG_START + 58)
           =3 #define SPREG_ADC_59                                    (SPREG_START + 59)
           =3 #define SPREG_ADC_60                                    (SPREG_START + 60)
           =3 #define SPREG_ADC_61                                    (SPREG_START + 61)
           =3 #define SPREG_ADC_62                                    (SPREG_START + 62)
           =3 #define SPREG_ADC_63                                    (SPREG_START + 63)
           =3 /*****************************************************************************/
           =3 #define SPREG_DAC_0                                             (SPREG_START + 64)
           =3 #define SPREG_DAC_1                                             (SPREG_START + 65)
           =3 #define SPREG_DAC_2                                             (SPREG_START + 66)
           =3 #define SPREG_DAC_3                                             (SPREG_START + 67)
           =3 #define SPREG_DAC_4                                             (SPREG_START + 68)
           =3 #define SPREG_DAC_5                                             (SPREG_START + 69)
           =3 #define SPREG_DAC_6                                             (SPREG_START + 70)
           =3 #define SPREG_DAC_7                                             (SPREG_START + 71)
           =3 #define SPREG_DAC_8                                             (SPREG_START + 72)
           =3 #define SPREG_DAC_9                                             (SPREG_START + 73)
           =3 #define SPREG_DAC_10                                    (SPREG_START + 74)
           =3 #define SPREG_DAC_11                                    (SPREG_START + 75)
           =3 #define SPREG_DAC_12                                    (SPREG_START + 76)
           =3 #define SPREG_DAC_13                                    (SPREG_START + 77)
           =3 #define SPREG_DAC_14                                    (SPREG_START + 78)
           =3 #define SPREG_DAC_15                                    (SPREG_START + 79)
           =3 #define SPREG_DAC_16                                    (SPREG_START + 80)
           =3 #define SPREG_DAC_17                                    (SPREG_START + 81)
           =3 #define SPREG_DAC_18                                    (SPREG_START + 82)
           =3 #define SPREG_DAC_19                                    (SPREG_START + 83)
           =3 #define SPREG_DAC_20                                    (SPREG_START + 84)
           =3 #define SPREG_DAC_21                                    (SPREG_START + 85)
           =3 #define SPREG_DAC_22                                    (SPREG_START + 86)
           =3 #define SPREG_DAC_23                                    (SPREG_START + 87)
           =3 #define SPREG_DAC_24                                    (SPREG_START + 88)
           =3 #define SPREG_DAC_25                                    (SPREG_START + 89)
           =3 #define SPREG_DAC_26                                    (SPREG_START + 90)
           =3 #define SPREG_DAC_27                                    (SPREG_START + 91)
           =3 #define SPREG_DAC_28                                    (SPREG_START + 92)
           =3 #define SPREG_DAC_29                                    (SPREG_START + 93)
           =3 #define SPREG_DAC_30                                    (SPREG_START + 94)
           =3 #define SPREG_DAC_31                                    (SPREG_START + 95)
           =3 /*****************************************************************************/
           =3 
           =3 #define SPCOIL_ON                                               0//长通线圈
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 73  

           =3 #define SPCOIL_PS1MS                                    1//1mS间隔 50%占空比脉冲
           =3 #define SPCOIL_PS10MS                                   2//10mS
           =3 #define SPCOIL_PS100MS                                  3//100mS
           =3 /*****************************************************************************/
           =3 #define SP_EM_MODBUS_SLAVE_ERR                  300
           =3 #define SP_R_ON                                                 800//上电ON
           =3 #define SP_R_TICK_1MS                                   801//
           =3 #define SP_R_TICK_10MS                                  802//
           =3 #define SP_R_TICK_100MS                                 803//
           =3 #define SP_R_TICK_1S                                    804//
           =3 /*****************************************************************************/
           =3 extern uint16_t ModbusSlaveAsciiOverTimeCounter;//Modbus Slave通信超时计时器
           =3 extern xdata int16_t NVRAM0[CONFIG_NVRAM_SIZE];//掉电保持寄存器 当前
           =3 extern xdata int16_t NVRAM1[CONFIG_NVRAM_SIZE];//掉电保持寄存器 上一次
           =3 /*****************************************************************************/
           =3 void wdtDisable(void);//看门狗屏蔽
           =3 
           =3 void sPlcInit(void);//软逻辑初始化
           =3 void sPlcProcessStart(void);//sPLC轮询起始
           =3 void sPlcProcessEnd(void);//sPLC轮询结束
           =3 /*****************************************************************************/
           =3 void assertCoilAddress(uint16_t adr);
           =3 void assertRegisterAddress(uint16_t adr);
           =3 /*****************************************************************************/
           =3 void nvramUpdata(void);
           =3 void clearDM(void);
           =3 void clearEM(void);
           =3 void clearR(void);
           =3 void clearT(void);
           =3 void clearTD(void);
           =3 void clearC(void);
           =3 void nvramLoad(void);
           =3 void nvramSave(void);
           =3 void nvramUpdata(void);
           =3 /*****************************************************************************/
           =3 void SET(uint16_t A);//置位
           =3 void RESET(uint16_t A);//复位
           =3 void FLIP(uint16_t A);//翻转
           =3 uint8_t LD(uint16_t A);//载入
           =3 uint8_t LDP(uint16_t A);//脉冲上升沿
           =3 uint8_t LDN(uint16_t A);//脉冲下降沿
           =3 void T100US(uint8_t A, uint8_t start, uint16_t value);
           =3 void T1MS(uint8_t A, uint8_t start, uint16_t value);
           =3 void T10MS(uint8_t A, uint8_t start, uint16_t value);
           =3 void T100MS(uint8_t A, uint8_t start, uint16_t value);
           =3 /*****************************************************************************/
           =3 void chipDacInit(void);
           =3 void chipAdcInit(void);
           =3 void sPlcInit(void);
           =3 void refreshInput(void);
           =3 void refreshOutput(void);
           =3 void refreshDac(void);
           =3 /*****************************************************************************/
           =3 #endif
   5      =1  //线圈 保持 16 * 16 = 256BIT
   6      =1  #define MR_START                                                0
   7      =1  #define MR_END                                                  15
   8      =1  //线圈寄存器 非保持 16 * 16 = 256BIT
   9      =1  #define R_START                                                 16
  10      =1  #define R_END                                                   31
  11      =1  //数据寄存器 保持 128
  12      =1  #define DM_START                                                32
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 74  

  13      =1  #define DM_END                                                  159
  14      =1  //数据寄存器 非保持 128个字
  15      =1  #define EM_START                                                160
  16      =1  #define EM_END                                                  287
  17      =1  //延时线圈
  18      =1  #define T_1MS_START                                             288//16个1mS
  19      =1  #define T_1MS_END                                               303
  20      =1  #define T_10MS_START                                    304//16个10mS
  21      =1  #define T_10MS_END                                              319
  22      =1  #define T_100MS_START                                   320//16个100mS
  23      =1  #define T_100MS_END                                             335
  24      =1  //延时计时器 
  25      =1  #define TD_1MS_START                                    336//16个1mS
  26      =1  #define TD_1MS_END                                              351
  27      =1  #define TD_10MS_START                                   352//16个10mS
  28      =1  #define TD_10MS_END                                             367
  29      =1  #define TD_100MS_START                                  368//16个100mS
  30      =1  #define TD_100MS_END                                    383
  31      =1  //计数器
  32      =1  #define C_START                                                 384//16个计数器
  33      =1  #define C_END                                                   399//
  34      =1  //输入位寄存器 16 * 16 = 256个
  35      =1  #define X_START                                                 400//
  36      =1  #define X_END                                                   415// 
  37      =1  //输出位寄存器 16 * 16 = 256个
  38      =1  #define Y_START                                                 416// 
  39      =1  #define Y_END                                                   431//
  40      =1  //特殊寄存器 128个字
  41      =1  #define SPREG_START                                             432//
  42      =1  #define SPREG_END                                               495//
  43      =1  //特殊线圈      16 * 16 = 256个
  44      =1  #define SPCOIL_START                                    496
  45      =1  #define SPCOIL_END                                              511
  46      =1  /*****************************************************************************/
  47      =1  #define CONFIG_NVRAM_SIZE                               (SPCOIL_END + 1)
  48      =1  /*****************************************************************************/
  49      =1  #define SPREG_ADC_0                                             (SPREG_START)
  50      =1  #define SPREG_ADC_1                                             (SPREG_START + 1)
  51      =1  #define SPREG_ADC_2                                             (SPREG_START + 2)
  52      =1  #define SPREG_ADC_3                                             (SPREG_START + 3)
  53      =1  #define SPREG_ADC_4                                             (SPREG_START + 4)
  54      =1  #define SPREG_ADC_5                                             (SPREG_START + 5)
  55      =1  #define SPREG_ADC_6                                             (SPREG_START + 6)
  56      =1  #define SPREG_ADC_7                                             (SPREG_START + 7)
  57      =1  #define SPREG_ADC_8                                             (SPREG_START + 8)
  58      =1  #define SPREG_ADC_9                                             (SPREG_START + 9)
  59      =1  #define SPREG_ADC_10                                    (SPREG_START + 10)
  60      =1  #define SPREG_ADC_11                                    (SPREG_START + 11)
  61      =1  #define SPREG_ADC_12                                    (SPREG_START + 12)
  62      =1  #define SPREG_ADC_13                                    (SPREG_START + 13)
  63      =1  #define SPREG_ADC_14                                    (SPREG_START + 14)
  64      =1  #define SPREG_ADC_15                                    (SPREG_START + 15)
  65      =1  #define SPREG_ADC_16                                    (SPREG_START + 16)
  66      =1  #define SPREG_ADC_17                                    (SPREG_START + 17)
  67      =1  #define SPREG_ADC_18                                    (SPREG_START + 18)
  68      =1  #define SPREG_ADC_19                                    (SPREG_START + 19)
  69      =1  #define SPREG_ADC_20                                    (SPREG_START + 20)
  70      =1  #define SPREG_ADC_21                                    (SPREG_START + 21)
  71      =1  #define SPREG_ADC_22                                    (SPREG_START + 22)
  72      =1  #define SPREG_ADC_23                                    (SPREG_START + 23)
  73      =1  #define SPREG_ADC_24                                    (SPREG_START + 24)
  74      =1  #define SPREG_ADC_25                                    (SPREG_START + 25)
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 75  

  75      =1  #define SPREG_ADC_26                                    (SPREG_START + 26)
  76      =1  #define SPREG_ADC_27                                    (SPREG_START + 27)
  77      =1  #define SPREG_ADC_28                                    (SPREG_START + 28)
  78      =1  #define SPREG_ADC_29                                    (SPREG_START + 29)
  79      =1  #define SPREG_ADC_30                                    (SPREG_START + 30)
  80      =1  #define SPREG_ADC_31                                    (SPREG_START + 31)
  81      =1  #define SPREG_ADC_32                                    (SPREG_START + 32)
  82      =1  #define SPREG_ADC_33                                    (SPREG_START + 33)
  83      =1  #define SPREG_ADC_34                                    (SPREG_START + 34)
  84      =1  #define SPREG_ADC_35                                    (SPREG_START + 35)
  85      =1  #define SPREG_ADC_36                                    (SPREG_START + 36)
  86      =1  #define SPREG_ADC_37                                    (SPREG_START + 37)
  87      =1  #define SPREG_ADC_38                                    (SPREG_START + 38)
  88      =1  #define SPREG_ADC_39                                    (SPREG_START + 39)
  89      =1  #define SPREG_ADC_40                                    (SPREG_START + 40)
  90      =1  #define SPREG_ADC_41                                    (SPREG_START + 41)
  91      =1  #define SPREG_ADC_42                                    (SPREG_START + 42)
  92      =1  #define SPREG_ADC_43                                    (SPREG_START + 43)
  93      =1  #define SPREG_ADC_44                                    (SPREG_START + 44)
  94      =1  #define SPREG_ADC_45                                    (SPREG_START + 45)
  95      =1  #define SPREG_ADC_46                                    (SPREG_START + 46)
  96      =1  #define SPREG_ADC_47                                    (SPREG_START + 47)
  97      =1  #define SPREG_ADC_48                                    (SPREG_START + 48)
  98      =1  #define SPREG_ADC_49                                    (SPREG_START + 49)
  99      =1  #define SPREG_ADC_50                                    (SPREG_START + 50)
 100      =1  #define SPREG_ADC_51                                    (SPREG_START + 51)
 101      =1  #define SPREG_ADC_52                                    (SPREG_START + 52)
 102      =1  #define SPREG_ADC_53                                    (SPREG_START + 53)
 103      =1  #define SPREG_ADC_54                                    (SPREG_START + 54)
 104      =1  #define SPREG_ADC_55                                    (SPREG_START + 55)
 105      =1  #define SPREG_ADC_56                                    (SPREG_START + 56)
 106      =1  #define SPREG_ADC_57                                    (SPREG_START + 57)
 107      =1  #define SPREG_ADC_58                                    (SPREG_START + 58)
 108      =1  #define SPREG_ADC_59                                    (SPREG_START + 59)
 109      =1  #define SPREG_ADC_60                                    (SPREG_START + 60)
 110      =1  #define SPREG_ADC_61                                    (SPREG_START + 61)
 111      =1  #define SPREG_ADC_62                                    (SPREG_START + 62)
 112      =1  #define SPREG_ADC_63                                    (SPREG_START + 63)
 113      =1  /*****************************************************************************/
 114      =1  #define SPREG_DAC_0                                             (SPREG_START + 64)
 115      =1  #define SPREG_DAC_1                                             (SPREG_START + 65)
 116      =1  #define SPREG_DAC_2                                             (SPREG_START + 66)
 117      =1  #define SPREG_DAC_3                                             (SPREG_START + 67)
 118      =1  #define SPREG_DAC_4                                             (SPREG_START + 68)
 119      =1  #define SPREG_DAC_5                                             (SPREG_START + 69)
 120      =1  #define SPREG_DAC_6                                             (SPREG_START + 70)
 121      =1  #define SPREG_DAC_7                                             (SPREG_START + 71)
 122      =1  #define SPREG_DAC_8                                             (SPREG_START + 72)
 123      =1  #define SPREG_DAC_9                                             (SPREG_START + 73)
 124      =1  #define SPREG_DAC_10                                    (SPREG_START + 74)
 125      =1  #define SPREG_DAC_11                                    (SPREG_START + 75)
 126      =1  #define SPREG_DAC_12                                    (SPREG_START + 76)
 127      =1  #define SPREG_DAC_13                                    (SPREG_START + 77)
 128      =1  #define SPREG_DAC_14                                    (SPREG_START + 78)
 129      =1  #define SPREG_DAC_15                                    (SPREG_START + 79)
 130      =1  #define SPREG_DAC_16                                    (SPREG_START + 80)
 131      =1  #define SPREG_DAC_17                                    (SPREG_START + 81)
 132      =1  #define SPREG_DAC_18                                    (SPREG_START + 82)
 133      =1  #define SPREG_DAC_19                                    (SPREG_START + 83)
 134      =1  #define SPREG_DAC_20                                    (SPREG_START + 84)
 135      =1  #define SPREG_DAC_21                                    (SPREG_START + 85)
 136      =1  #define SPREG_DAC_22                                    (SPREG_START + 86)
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 76  

 137      =1  #define SPREG_DAC_23                                    (SPREG_START + 87)
 138      =1  #define SPREG_DAC_24                                    (SPREG_START + 88)
 139      =1  #define SPREG_DAC_25                                    (SPREG_START + 89)
 140      =1  #define SPREG_DAC_26                                    (SPREG_START + 90)
 141      =1  #define SPREG_DAC_27                                    (SPREG_START + 91)
 142      =1  #define SPREG_DAC_28                                    (SPREG_START + 92)
 143      =1  #define SPREG_DAC_29                                    (SPREG_START + 93)
 144      =1  #define SPREG_DAC_30                                    (SPREG_START + 94)
 145      =1  #define SPREG_DAC_31                                    (SPREG_START + 95)
 146      =1  /*****************************************************************************/
 147      =1  
 148      =1  #define SPCOIL_ON                                               0//长通线圈
 149      =1  #define SPCOIL_PS1MS                                    1//1mS间隔 50%占空比脉冲
 150      =1  #define SPCOIL_PS10MS                                   2//10mS
 151      =1  #define SPCOIL_PS100MS                                  3//100mS
 152      =1  /*****************************************************************************/
 153      =1  #define SP_EM_MODBUS_SLAVE_ERR                  300
 154      =1  #define SP_R_ON                                                 800//上电ON
 155      =1  #define SP_R_TICK_1MS                                   801//
 156      =1  #define SP_R_TICK_10MS                                  802//
 157      =1  #define SP_R_TICK_100MS                                 803//
 158      =1  #define SP_R_TICK_1S                                    804//
 159      =1  /*****************************************************************************/
 160      =1  extern uint16_t ModbusSlaveAsciiOverTimeCounter;//Modbus Slave通信超时计时器
 161      =1  extern xdata int16_t NVRAM0[CONFIG_NVRAM_SIZE];//掉电保持寄存器 当前
 162      =1  extern xdata int16_t NVRAM1[CONFIG_NVRAM_SIZE];//掉电保持寄存器 上一次
 163      =1  /*****************************************************************************/
 164      =1  void wdtDisable(void);//看门狗屏蔽
 165      =1  
 166      =1  void sPlcInit(void);//软逻辑初始化
 167      =1  void sPlcProcessStart(void);//sPLC轮询起始
 168      =1  void sPlcProcessEnd(void);//sPLC轮询结束
 169      =1  /*****************************************************************************/
 170      =1  void assertCoilAddress(uint16_t adr);
 171      =1  void assertRegisterAddress(uint16_t adr);
 172      =1  /*****************************************************************************/
 173      =1  void nvramUpdata(void);
 174      =1  void clearDM(void);
 175      =1  void clearEM(void);
 176      =1  void clearR(void);
 177      =1  void clearT(void);
 178      =1  void clearTD(void);
 179      =1  void clearC(void);
 180      =1  void nvramLoad(void);
 181      =1  void nvramSave(void);
 182      =1  void nvramUpdata(void);
 183      =1  /*****************************************************************************/
 184      =1  void SET(uint16_t A);//置位
 185      =1  void RESET(uint16_t A);//复位
 186      =1  void FLIP(uint16_t A);//翻转
 187      =1  uint8_t LD(uint16_t A);//载入
 188      =1  uint8_t LDP(uint16_t A);//脉冲上升沿
 189      =1  uint8_t LDN(uint16_t A);//脉冲下降沿
 190      =1  void T100US(uint8_t A, uint8_t start, uint16_t value);
 191      =1  void T1MS(uint8_t A, uint8_t start, uint16_t value);
 192      =1  void T10MS(uint8_t A, uint8_t start, uint16_t value);
 193      =1  void T100MS(uint8_t A, uint8_t start, uint16_t value);
 194      =1  /*****************************************************************************/
 195      =1  void chipDacInit(void);
 196      =1  void chipAdcInit(void);
 197      =1  void sPlcInit(void);
 198      =1  void refreshInput(void);
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 77  

 199      =1  void refreshOutput(void);
 200      =1  void refreshDac(void);
 201      =1  /*****************************************************************************/
 202      =1  #endif
   2          /*****************************************************************************/                 
   3          /*****************************************************************************/
   4          xdata int16_t NVRAM0[CONFIG_NVRAM_SIZE];//掉电保持寄存器 当前
   5          xdata int16_t NVRAM1[CONFIG_NVRAM_SIZE];//掉电保持寄存器 上一次
   6          static data uint8_t TimerCounter_1mS = 0;
   7          static data uint8_t TimerCounter_10mS = 0;
   8          static data uint8_t Timer0_L, Timer0_H;
   9          /*****************************************************************************/
  10          typedef struct{//ADC滤波器
  11                  uint16_t dat[CONFIG_SPLC_ADC_FILTER_TAP];
  12                  uint16_t out;
  13                  uint8_t wIndex;//写入指针
  14          }adcTempDat_t;
  15          
  16          static pdata int8_t inputFilter[CONFIG_SPLC_IO_INPUT_NUM];//IO输入滤波器缓冲区
  17          static xdata adcTempDat_t adcTempDat[CONFIG_SPLC_ADC_CHANNLE];
  18          uint8_t adcSelect;//ADC通道选择
  19          static void refreshAdcData(adcTempDat_t *s , uint16_t dat);
  20          void adcProcess(void);
  21          static void initAdcData(adcTempDat_t *s);
  22          static void chipDacInit(void);
  23          static void chipAdcInit(void);
  24          /******************************************************************************/
  25          
  26          static void adcProcess(void){//循环采集ADC
  27   1              uint16_t result = 0;
  28   1      #ifdef C8051F020
  29   1              while(!AD0INT);
  30   1      #endif
  31   1              result = (uint16_t)(ADC0H << 8) + (uint16_t)(ADC0L);
  32   1              refreshAdcData(&adcTempDat[adcSelect], result);
  33   1              NVRAM0[SPREG_ADC_0 + adcSelect] = adcTempDat[adcSelect].out;
  34   1              if(adcSelect < (CONFIG_SPLC_ADC_CHANNLE - 1)){
  35   2                      adcSelect ++;
  36   2              }
  37   1              else{
  38   2                      adcSelect = 0;
  39   2              }
  40   1              switch(adcSelect){
  41   2                      case 0:{
  42   3                              AMX0SL = 0x00;break;
  43   3                      }
  44   2                      case 1:{
  45   3                              AMX0SL = 0x01;break;
  46   3                      }
  47   2                      case 2:{
  48   3                              AMX0SL = 0x02;break;
  49   3                      }
  50   2                      case 3:{
  51   3                              AMX0SL = 0x03;break;
  52   3                      }
  53   2                      case 4:{
  54   3                              AMX0SL = 0x04;break;
  55   3                      }
  56   2                      case 5:{
  57   3                              AMX0SL = 0x05;break;
  58   3                      }
  59   2                      case 6:{
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 78  

  60   3                              AMX0SL = 0x06;break;
  61   3                      }
  62   2                      case 7:{
  63   3                              AMX0SL = 0x07;  break;
  64   3                      }
  65   2                      case 8:{
  66   3                              AMX0SL = 0x08;break;
  67   3                      }
  68   2                      case 9:{
  69   3                              break;
  70   3                      }
  71   2                      default:{
  72   3                              break;
  73   3                      }
  74   2              }
  75   1              AD0INT = 0;
  76   1              AD0BUSY = 1;//AD0BUSY写入1
  77   1      }
  78          static void initAdcData(adcTempDat_t *s){//初始化ADC滤波器
  79   1              uint8_t i;
  80   1              for(i = 0;i < CONFIG_SPLC_ADC_FILTER_TAP; i++){
  81   2                      s->dat[i] = 0x0;
  82   2              }
  83   1              s->out = 0;
  84   1              s->wIndex = 0;
  85   1      }
  86          static void refreshAdcData(adcTempDat_t *s , uint16_t dat){//更新ADC采集值
  87   1              uint8_t i;
  88   1              uint16_t temp;
  89   1              uint32_t sum;
  90   1              s->dat[s->wIndex] = dat;
  91   1              s->wIndex ++;
  92   1              if(s->wIndex >= CONFIG_SPLC_ADC_FILTER_TAP){
  93   2                      s->wIndex = 0;
  94   2              }
  95   1              sum = 0;
  96   1              for(i = 0;i < CONFIG_SPLC_ADC_FILTER_TAP;i ++){
  97   2                      sum += s->dat[i];
  98   2              }
  99   1              temp = (uint16_t)(sum / (uint32_t)CONFIG_SPLC_ADC_FILTER_TAP);
 100   1              s->out = temp;
 101   1      }
 102          void assertCoilAddress(uint16_t adr){//检查线圈地址
 103   1              if(adr > (SPREG_END * 16))
 104   1                      while(1);
 105   1      }
 106          void assertRegisterAddress(uint16_t adr){//检查寄存器地址
 107   1              if(adr >= SPREG_END)
 108   1                      while(1);
 109   1      }
 110          void clearDM(void){//清除DM寄存器
 111   1              uint16_t i;
 112   1              for(i = 0;i <= DM_END;i ++)
 113   1              {
 114   2                      NVRAM0[i] = 0x0;
 115   2                      NVRAM1[i] = 0x0;
 116   2              }
 117   1      }
 118          void clearMR(void){//清除MR寄存器
 119   1              uint16_t i;
 120   1              for(i = MR_START;i <= MR_END;i ++)
 121   1              {
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 79  

 122   2                      NVRAM0[i] = 0x0;
 123   2                      NVRAM1[i] = 0x0;
 124   2              }
 125   1      }
 126          void clearEM(void){//清除EM寄存器
 127   1              uint16_t i;
 128   1              for(i = EM_START;i <= EM_END;i ++)
 129   1              {
 130   2                      NVRAM0[i] = 0x0;
 131   2                      NVRAM1[i] = 0x0;
 132   2              }
 133   1      }
 134          void clearR(void){//清除R寄存器
 135   1              uint16_t i;
 136   1              for(i = R_START;i <= R_END;i ++)
 137   1              {
 138   2                      NVRAM0[i] = 0x0;
 139   2                      NVRAM1[i] = 0x0;
 140   2              }
 141   1      }
 142          void clearT(void){//清除T寄存器
 143   1              uint16_t i;
 144   1              for(i = T_1MS_START;i <= T_1MS_END;i ++)
 145   1              {
 146   2                      NVRAM0[i] = 0x0;
 147   2                      NVRAM1[i] = 0x0;
 148   2              }
 149   1              for(i = T_10MS_START;i <= T_10MS_END;i ++)
 150   1              {
 151   2                      NVRAM0[i] = 0x0;
 152   2                      NVRAM1[i] = 0x0;
 153   2              }
 154   1              for(i = T_100MS_START;i <= T_100MS_END;i ++)
 155   1              {
 156   2                      NVRAM0[i] = 0x0;
 157   2                      NVRAM1[i] = 0x0;
 158   2              }
 159   1      }
 160          void clearTD(void){//清除TD寄存器
 161   1              uint16_t i;
 162   1              for(i = TD_1MS_START;i <= TD_1MS_END;i ++)
 163   1              {
 164   2                      NVRAM0[i] = 0x0;
 165   2                      NVRAM1[i] = 0x0;
 166   2              }
 167   1              for(i = TD_10MS_START;i <= TD_10MS_END;i ++)
 168   1              {
 169   2                      NVRAM0[i] = 0x0;
 170   2                      NVRAM1[i] = 0x0;
 171   2              }
 172   1              for(i = TD_100MS_START;i <= TD_100MS_END;i ++)
 173   1              {
 174   2                      NVRAM0[i] = 0x0;
 175   2                      NVRAM1[i] = 0x0;
 176   2              }
 177   1      }
 178          void clearC(void){//清除C寄存器
 179   1              uint16_t i;
 180   1              for(i = C_START;i <= C_END;i ++){
 181   2                      NVRAM0[i] = 0x0;
 182   2                      NVRAM1[i] = 0x0;
 183   2              }
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 80  

 184   1      }
 185          void clearX(void){//清除X寄存器
 186   1              uint16_t i;
 187   1              for(i = X_START;i <= X_END;i ++){
 188   2                      NVRAM0[i] = 0x0;
 189   2                      NVRAM1[i] = 0x0;
 190   2              }
 191   1      }
 192          void clearY(void){//清除Y寄存器
 193   1              uint16_t i;
 194   1              for(i = Y_START;i <= Y_END;i ++){
 195   2                      NVRAM0[i] = 0x0;
 196   2                      NVRAM1[i] = 0x0;
 197   2              }
 198   1      }
 199          void clearSPREG(void){
 200   1              uint16_t i;
 201   1              for(i = SPREG_START;i <= SPREG_END;i ++){
 202   2                      NVRAM0[i] = 0x0;
 203   2                      NVRAM1[i] = 0x0;
 204   2              }
 205   1      }
 206          void clearSPCOIL(){
 207   1              uint16_t i;
 208   1              for(i = SPCOIL_START;i <= SPCOIL_END;i ++){
 209   2                      NVRAM0[i] = 0x0;
 210   2                      NVRAM1[i] = 0x0;
 211   2              }
 212   1      }
 213          static void nvramLoad(void){//从EPROM中载入NVRAM
 214   1              memset(NVRAM0, 0x0, (CONFIG_NVRAM_SIZE * 2));//初始化NVRAM
 215   1              epromRead(0, (uint8_t*)NVRAM0, (CONFIG_NVRAM_SIZE * 2));//从EPROM中恢复MR
 216   1              clearEM();
 217   1              clearR();
 218   1              clearT();
 219   1              clearTD();
 220   1              clearC();
 221   1              clearX();
 222   1              clearY();
 223   1              clearSPREG();
 224   1              clearSPCOIL();
 225   1              memcpy(NVRAM1, NVRAM0, CONFIG_NVRAM_SIZE);
 226   1      }
 227          static void nvramSave(void){//强制将NVRAM存入EPROM
 228   1              DISABLE_INTERRUPT//关闭中断
 229   1              epromWrite(0x0, (uint8_t*)NVRAM0, ((MR_END + 1) * 2));
 230   1              ENABLE_INTERRUPT
 231   1      }
 232          static void nvramUpdata(void){//更新NVRAM->EPROM
 233   1              uint8_t *sp0, *sp1;
 234   1              uint16_t i;
 235   1              sp0 = (uint8_t*)(NVRAM0 + (MR_START * 2));
 236   1              sp1 = (uint8_t*)(NVRAM1 + (MR_START * 2));
 237   1              for(i = MR_START;i < ((MR_END + 1) * 2);i ++){//储存MR
 238   2                      if(*(sp0 + i) != *(sp1 + i)){
 239   3                              epromWriteOneByte(i, *(sp0 + i));
 240   3                      }
 241   2              }
 242   1              sp0 = (uint8_t*)(NVRAM0 + (DM_START * 2));
 243   1              sp1 = (uint8_t*)(NVRAM1 + (DM_START * 2));
 244   1              for(i = DM_START;i < ((DM_END + 1) * 2);i ++){//储存DM
 245   2                      if(*(sp0 + i) != *(sp1 + i)){
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 81  

 246   3                              epromWriteOneByte(i, *(sp0 + i));
 247   3                      }
 248   2              }
 249   1              memcpy(NVRAM1, NVRAM0, (CONFIG_NVRAM_SIZE * 2));
 250   1      }
 251          void SET(uint16_t A){//置位
 252   1              assertCoilAddress(A);//检查地址范围
 253   1              NVRAM0[(A / 16)] |= 1 << (A % 16);
 254   1      }
 255          void RESET(uint16_t A){//置零
 256   1              assertCoilAddress(A);//检查地址范围
 257   1              NVRAM0[(A / 16)] &= ~(1 << (A % 16));
 258   1      }
 259          void FLIP(uint16_t A){//翻转
 260   1              uint16_t temp;
 261   1              assertCoilAddress(A);//检查地址范围
 262   1              temp= NVRAM0[(A / 16)] & (1 << (A % 16));
 263   1              if(temp)
 264   1                      RESET(A);
 265   1              else
 266   1                      SET(A);
 267   1      }
 268          uint8_t LD(uint16_t A){//载入
 269   1              assertCoilAddress(A);//检查地址范围
 270   1              return (uint8_t)(NVRAM0[(A / 16)] >> NVRAM0[(A % 16)]);
 271   1      }
 272          uint8_t LDP(uint16_t A){//脉冲上升沿
 273   1              uint8_t temp0, temp1;
 274   1              assertCoilAddress(A);//检查地址范围
 275   1              temp0 = (uint8_t)(NVRAM0[(A / 16)] >> NVRAM0[(A % 16)]);
 276   1              temp1 = (uint8_t)(NVRAM1[(A / 16)] >> NVRAM1[(A % 16)]);
 277   1              if(temp0 && !temp1)
 278   1                      return 1;
 279   1              else
 280   1                      return 0;
 281   1      }
 282          uint8_t LDN(uint16_t A){//脉冲下降沿
 283   1              uint8_t temp0, temp1;
 284   1              assertCoilAddress(A);
 285   1              temp0 = (uint8_t)(NVRAM0[(A / 16)] >> NVRAM0[(A % 16)]);
 286   1              temp1 = (uint8_t)(NVRAM1[(A / 16)] >> NVRAM1[(A % 16)]);
 287   1              if(!temp0 && temp1)
 288   1                      return 1;
 289   1              else
 290   1                      return 0;
 291   1      }
 292          void T1MS(uint8_t A, uint8_t start, uint16_t value){//1MS延时器
 293   1      #if CONFIG_DEBUG
                      if(A > (TD_1MS_END - TD_1MS_START + 1))
                              printf("T1MS:%d Over Num\n", A);
              #endif
 297   1              if(start){
 298   2                      if(NVRAM0[(TD_1MS_START + A)] >= value){
 299   3                              NVRAM0[(T_1MS_START + (A / 16))] |= 1 << (A % 16);
 300   3                      }
 301   2                      else{
 302   3                              NVRAM0[(T_1MS_START + (A / 16))] &= ~(1 << (A % 16));
 303   3                      }
 304   2                              
 305   2              }
 306   1              else{
 307   2                      NVRAM0[(T_1MS_START + (A / 16))] &= ~(1 << (A % 16));
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 82  

 308   2                      NVRAM0[(TD_1MS_START + A)] = 0x0;
 309   2              }       
 310   1      }
 311          void T10MS(uint8_t A, uint8_t start, uint16_t value){//10MS延时器
 312   1      #if CONFIG_DEBUG
                      if(A > (TD_10MS_END - TD_10MS_START + 1))
                              printf("T10MS:%d Over Num\n", A);
              #endif
 316   1              if(start){
 317   2                      if(NVRAM0[(TD_10MS_START + A)] >= value){
 318   3                              NVRAM0[(T_10MS_START + (A / 16))] |= 1 << (A % 16);
 319   3                      }
 320   2                      else{
 321   3                              NVRAM0[(T_10MS_START + (A / 16))] &= ~(1 << (A % 16));
 322   3                      }
 323   2              }
 324   1              else{
 325   2                      NVRAM0[(T_10MS_START + (A / 16))] &= ~(1 << (A % 16));
 326   2                      NVRAM0[(TD_10MS_START + A)] = 0x0;
 327   2              }       
 328   1      }
 329          void T100MS(uint8_t A, uint8_t start, uint16_t value){//100MS延时器
 330   1      #if CONFIG_DEBUG
                      if(A > (TD_100MS_END - TD_100MS_START + 1))
                              printf("T100MS:%d Over Num\n", A);
              #endif
 334   1              if(start){
 335   2                      if(NVRAM0[(TD_100MS_START + A)] >= value){
 336   3                              NVRAM0[(T_100MS_START + (A / 16))] |= 1 << (A % 16);
 337   3                      }
 338   2                      else{
 339   3                              NVRAM0[(T_100MS_START + (A / 16))] &= ~(1 << (A % 16));
 340   3                      }       
 341   2              }
 342   1              else{
 343   2                      NVRAM0[(T_100MS_START + (A / 16))] &= ~(1 << (A % 16));
 344   2                      NVRAM0[(TD_100MS_START + A)] = 0x0;
 345   2              }
 346   1      }
 347          
 348          int16_t TNTC(int16_t dat){//CODE转换为NTC测量温度温度
 349   1              uint16_t temp;
 350   1              fp32_t ftemp;
 351   1              if(dat >= CONFIG_SPLC_ADC_INTERNAL_VREF) dat = CONFIG_SPLC_ADC_INTERNAL_VREF;//限制输入最大值
 352   1              if(dat < 0) dat = 0;
 353   1              
 354   1              temp = (int16_t)(CONFIG_SPLC_ADC_INTERNAL_VREF * dat / 4096);//单位mV
 355   1              temp = 10000 * 5000 / (5000 - temp);//电源5V 分压电阻10K
 356   1              
 357   1              ftemp = ((1.0 / 3477)*log((fp32_t)(temp) / 10000)) + (1 / (25+273.0));//limo R25=10740,B=3450    uniquemode
             - 3988
 358   1              ftemp = ( 1.0 / ftemp ) - 273.0;
 359   1              if(ftemp >= 100) ftemp = 100;
 360   1              if(ftemp <= -100) ftemp = -100;
 361   1              return (int16_t)(ftemp * 10);
 362   1      }
 363          int16_t TENV(int16_t dat){//CODE转换为环境温度
 364   1              uint16_t temp;
 365   1              temp = (int16_t)(CONFIG_SPLC_ADC_INTERNAL_VREF * dat / 4096);//单位mV
 366   1              temp = (int16_t)((temp - CONFIG_SPLC_ADC_TEMP_SENSOR_OFFSET) * 1000 / CONFIG_SPLC_ADC_TEMP_SENSOR_GAIN);
 367   1              return temp;
 368   1      }
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 83  

 369          static void wdtInit(void){//看门狗初始化
 370   1      #ifdef C8051F020
 371   1              WDTCN = 0;//47mS
 372   1      #endif
 373   1      }
 374          static void wdtEnable(void){//使能看门狗
 375   1      #ifdef C8051F020
 376   1              WDTCN = 0xA5;
 377   1      #endif
 378   1      #ifdef C8051F580
              #endif
 380   1      }
 381          void wdtDisable(void){//关闭看门狗(未锁定)
 382   1              uint8_t flagEA;
 383   1              flagEA = EA;
 384   1              EA = 0;
 385   1      #ifdef C8051F020
 386   1              WDTCN = 0xDE;
 387   1          WDTCN = 0xAD;
 388   1      #endif
 389   1      #ifdef C8051F020
 390   1      #endif
 391   1              EA = flagEA;
 392   1      
 393   1      }
 394          static void wdtFeed(void){//喂狗
 395   1      #ifdef C8051F020
 396   1              WDTCN = 0xA5;
 397   1      #endif
 398   1      }
 399          
 400          static void pcaInit(void){//硬件PCA初始化
 401   1      #ifdef C8051F020
 402   1      
 403   1      #endif
 404   1      #ifdef C8051F580
              //F580 CEX6,7,8 PWM OUT
              //F680 CEX9,10,11 PULSE IN
              #endif
 408   1      }
 409          
 410          static void timer0Init(void){//硬件sTimer计时器初始化
 411   1              data uint16_t temp;
 412   1              TimerCounter_1mS = 0;
 413   1              TimerCounter_10mS = 0;
 414   1      #ifdef C8051F020
 415   1              temp = (uint16_t)(65536 - (CONFIG_SYSCLK / 12 /CONFIG_SOFTPLC_HWTIME));
 416   1              Timer0_L = temp & 0xFF;
 417   1              Timer0_H = (temp >> 8) & 0xFF;
 418   1              TH0 = Timer0_H;// Init T0 High register
 419   1              TL0 = Timer0_L;// Init T0 Low register
 420   1              CKCON &= ~(1 << 3);//SYSCLK / 12        
 421   1              TMOD &= 0xF0;
 422   1              TMOD |= (1 << 0);// T0 in 16-bit mode
 423   1              ET0 = 1;// T0 interrupt enabled
 424   1              TR0 = 1;// T0 ON
 425   1      #endif
 426   1      }
 427          static void timer0Isr(void) interrupt INTERRUPT_TIMER0{//硬件sTimer计时器中断 1mS
 428   1              uint16_t i;
 429   1              TF0 = 0;
 430   1              TR0 = 0;
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 84  

 431   1              TH0 = Timer0_H;
 432   1              TL0 = Timer0_L;
 433   1              TR0 = 1;
 434   1              if((NVRAM0[(SPCOIL_START + (SPCOIL_PS1MS / 16))] >> (SPCOIL_PS1MS % 16)) & 0x01){//ON
 435   2                      NVRAM0[(SPCOIL_START + (SPCOIL_PS1MS / 16))] &= ~(uint16_t)(1 << (SPCOIL_PS1MS % 16));
 436   2              }
 437   1              else{//OFF
 438   2                      NVRAM0[(SPCOIL_START + (SPCOIL_PS1MS / 16))] |= (uint16_t)(1 << (SPCOIL_PS1MS % 16));
 439   2              }
 440   1              
 441   1              for(i = TD_1MS_START;i <= TD_1MS_END;i ++){//1mS计时
 442   2                      if(NVRAM0[i] < SHRT_MAX){
 443   3                              NVRAM0[i] ++;
 444   3                      }
 445   2              }
 446   1              if(TimerCounter_1mS >= 10){//10mS计算
 447   2                      if((NVRAM0[(SPCOIL_START + (SPCOIL_PS10MS / 16))] >> (SPCOIL_PS10MS % 16)) & 0x01){//ON
 448   3                              NVRAM0[(SPCOIL_START + (SPCOIL_PS10MS / 16))] &= ~(uint16_t)(1 << (SPCOIL_PS10MS % 16));
 449   3                      }
 450   2                      else{//OFF
 451   3                              NVRAM0[(SPCOIL_START + (SPCOIL_PS10MS / 16))] |= (uint16_t)(1 << (SPCOIL_PS10MS % 16));
 452   3                      }
 453   2                      for(i = TD_10MS_START;i <= TD_10MS_END;i ++){
 454   3                              if(NVRAM0[i] < SHRT_MAX){
 455   4                                      NVRAM0[i] ++;
 456   4                              }
 457   3                      }
 458   2                      TimerCounter_10mS ++;
 459   2                      TimerCounter_1mS = 0;
 460   2              }
 461   1              if(TimerCounter_10mS >= 10){//100ms计算
 462   2                      if((NVRAM0[(SPCOIL_START + (SPCOIL_PS100MS / 16))] >> (SPCOIL_PS100MS % 16)) & 0x01){//ON
 463   3                              NVRAM0[(SPCOIL_START + (SPCOIL_PS100MS / 16))] &= ~(uint16_t)(1 << (SPCOIL_PS100MS % 16));
 464   3                      }
 465   2                      else{//OFF
 466   3                              NVRAM0[(SPCOIL_START + (SPCOIL_PS100MS / 16))] |= (uint16_t)(1 << (SPCOIL_PS100MS % 16));
 467   3                      }
 468   2                      for(i = TD_100MS_START;i < TD_100MS_END;i ++){
 469   3                              if(NVRAM0[i] < SHRT_MAX){
 470   4                                      NVRAM0[i] ++;
 471   4                              }
 472   3                      }
 473   2                      TimerCounter_10mS = 0;
 474   2              }
 475   1      #if CONFIG_SPLC_USING_ADC == 1
                      adcProcess();//ADC扫描
              #endif
 478   1              TimerCounter_1mS ++;
 479   1      }
 480          
 481          static void inputInit(void){
 482   1              memset(inputFilter, 0x0, CONFIG_SPLC_IO_INPUT_NUM);
 483   1      #ifdef C8051F020
 484   1      #endif
 485   1      #ifdef C8051F580
              #endif
 487   1      }
 488          static void outputInit(void){
 489   1      #ifdef C8051F020
 490   1              
 491   1      #endif
 492   1      #ifdef C8051F580
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 85  

                      
              #endif
 495   1      }
 496          static void inputRefresh(void){//获取输入IO
 497   1              uint8_t ctemp0,ctemp1, i;
 498   1              ctemp0 = 0;
 499   1              ctemp0 = 0;
 500   1      #ifdef C8051F020
 501   1              //P4,P5输入
 502   1              ctemp0 = P4;
 503   1              ctemp1 = P5;
 504   1      #endif
 505   1      #ifdef C8051F580
                      ctemp0 = inPca9554Read() ;
              #endif
 508   1              for(i = 0;i < 8;i ++){//X0-X7
 509   2                      if((ctemp0 >> i) & 0x01){
 510   3                              if(inputFilter[i] < CONFIG_INPUT_FILTER_TIME){
 511   4                                      inputFilter[i] ++;
 512   4                              }
 513   3                              else{
 514   4                                      NVRAM0[X_START] |= (int16_t)(1 << i);
 515   4                              }
 516   3                      }
 517   2                      else{
 518   3                              if(inputFilter[i] > (CONFIG_INPUT_FILTER_TIME * -1)){
 519   4                                      inputFilter[i] --;
 520   4                              }
 521   3                              else{
 522   4                                      NVRAM0[X_START] &= ~(uint16_t)(1 << i);
 523   4                              }
 524   3                      }
 525   2              }
 526   1              for(i = 8;i < 16;i ++){//X8-X15
 527   2                      if((ctemp1 >> (i - 8)) & 0x01){
 528   3                              if(inputFilter[i] < CONFIG_INPUT_FILTER_TIME){
 529   4                                      inputFilter[i] ++;
 530   4                              }
 531   3                              else{
 532   4                                      NVRAM0[X_START] |= (int16_t)(1 << i);
 533   4                              }
 534   3                      }
 535   2                      else{
 536   3                              if(inputFilter[i] > (CONFIG_INPUT_FILTER_TIME * -1)){
 537   4                                      inputFilter[i] --;
 538   4                              }
 539   3                              else{
 540   4                                      NVRAM0[X_START] &= ~(uint16_t)(1 << i);
 541   4                              }
 542   3                      }
 543   2              }
 544   1      }
 545          static void outputRefresh(void){//设置输出IO
 546   1      #ifdef C8051F020
 547   1              //P6,P7输出IO
 548   1              P6 = (NVRAM0[Y_START] & 0x00FF);
 549   1              P7 = ((NVRAM0[Y_START] >> 8) & 0x00FF);
 550   1      #endif
 551   1      #ifdef C8051F580
                      outPca9554Write(NVRAM0[Y_START]);
              #endif
 554   1      }
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 86  

 555          static void chipAdcInit(void){//ADC模块初始化
 556   1              uint8_t i;
 557   1      #ifdef C8051F020
 558   1              ADC0CN = 0x0;//软件触发
 559   1              ADC0CN |= (1 << 6);//AD0TM = 1 启用跟踪
 560   1              ADC0CN |= (1 << 7);//AD0EN = 1 
 561   1              ADC0CF = 0x0;
 562   1              ADC0CF |= (CONFIG_SYSCLK / SAR_CLK) << 3;     // ADC conversion clock = 2.5MHz
 563   1              AMX0CF = 0x00;                      // AIN inputs are single-ended (default)
 564   1              AMX0SL = 0x00;                      // Select AIN0.1 pin as ADC mux input
 565   1              AD0INT = 0;
 566   1              AD0BUSY = 1;//AD0BUSY写入1
 567   1      #endif
 568   1              adcSelect = 0;
 569   1              for(i = 0;i <= CONFIG_SPLC_ADC_CHANNLE;i ++){
 570   2                      initAdcData(&adcTempDat[i]);
 571   2              }
 572   1      }
 573          void sPlcInit(void){//软逻辑初始化
 574   1              wdtInit();//看门狗使能
 575   1              wdtDisable();//屏蔽看门狗
 576   1              
 577   1      #if CONFIG_SPLC_USING_EPROM == 1
                      nvramLoad();//上电恢复NVRAM
              #endif
 580   1              
 581   1      #if CONFIG_SPLC_USING_ADC == 1
                      chipAdcInit();//初始化ADC模块
              #endif
 584   1              
 585   1      #if CONFIG_SPLC_USING_DAC == 1
 586   1              chipDacInit();//初始化DAC模块
 587   1      #endif
 588   1              
 589   1      #if CONFIG_SPLC_USING_MB_RTU_SLAVE == 1
 590   1              initModbus(CONFIG_MB_RTU_SLAVE_ADDRESS, CONFIG_UART0_BAUDRATE);
 591   1      #endif
 592   1              timer0Init();//初始化硬件计时器模块
 593   1              NVRAM0[(SPCOIL_START + (SPCOIL_ON / 16))] |= (uint16_t)(1 << (SPCOIL_ON % 16));
 594   1      }
 595          static void refreshDac(void){//刷新DAC
 596   1      #ifdef C8051F020
 597   1              if(DAC0 != NVRAM0[SPREG_DAC_0]){
 598   2                      DAC0 = NVRAM0[SPREG_DAC_0];
 599   2              }
 600   1              if(DAC1 != NVRAM0[SPREG_DAC_1]){
 601   2                      DAC1 = NVRAM0[SPREG_DAC_1];
 602   2              }
 603   1      #endif
 604   1      }
 605          static void chipDacInit(void){//初始化DAC
 606   1      #ifdef C8051F020
 607   1              DAC0CN = 0x0;
 608   1              DAC0CN |= (1 << 7);
 609   1              DAC0 = 0;
 610   1              DAC1 = 0;
 611   1      #endif
 612   1      }
 613          void sPlcProcessStart(void){//sPLC轮询起始
 614   1      #if CONFIG_SPLC_USING_MB_RTU_SLAVE == 1
 615   1              modbusPorcess();//处理MODBUS
 616   1      #endif
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 87  

 617   1      #if CONFIG_SPLC_USING_IO_INPUT == 1
 618   1              inputRefresh();//读取X口输入
 619   1      #endif
 620   1      #if CONFIG_SPLC_USING_WDT == 1
                      wdtFeed();
              #endif
 623   1      }
 624          void sPlcProcessEnd(void){//sPLC轮询结束
 625   1      #if CONFIG_SPLC_USING_WDT == 1
                      wdtFeed();//喂狗
              #endif
 628   1      #if CONFIG_SPLC_USING_IO_OUTPUT == 1
 629   1              outputRefresh();//更新Y口输出
 630   1      #endif
 631   1      #if CONFIG_SPLC_USING_DAC
 632   1              refreshDac();//更新DAC输出
 633   1      #endif
 634   1      #if CONFIG_SPLC_USING_EPROM == 1
                      nvramUpdata();//更新NVRAM
              #endif
 637   1      }
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 88  

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION Com010F (BEGIN)
0000         L?0272:
0000         L?0273:
0000 ED                MOV     A,R5
0001 25E0              ADD     A,ACC
0003 FF                MOV     R7,A
0004 EC                MOV     A,R4
0005 33                RLC     A
0006 FE                MOV     R6,A
0007 7400        R     MOV     A,#LOW NVRAM0
0009 2F                ADD     A,R7
000A F582              MOV     DPL,A
000C 7400        R     MOV     A,#HIGH NVRAM0
000E 3E                ADDC    A,R6
000F F583              MOV     DPH,A
0011 E4                CLR     A
0012 F0                MOVX    @DPTR,A
0013 A3                INC     DPTR
0014 F0                MOVX    @DPTR,A
0015 7400        R     MOV     A,#LOW NVRAM1
0017 2F                ADD     A,R7
0018 F582              MOV     DPL,A
001A 7400        R     MOV     A,#HIGH NVRAM1
001C         L?0274:
001C 3E                ADDC    A,R6
001D F583              MOV     DPH,A
001F E4                CLR     A
0020 F0                MOVX    @DPTR,A
0021 A3                INC     DPTR
0022 F0                MOVX    @DPTR,A
0023 22                RET     
0024         L?0275:
0024         L?0276:
0024 AD07              MOV     R5,AR7
0026 AC06              MOV     R4,AR6
0028 120000      R     LCALL   _assertCoilAddress
002B ED                MOV     A,R5
002C 540F              ANL     A,#0FH
002E 25E0              ADD     A,ACC
0030 FF                MOV     R7,A
0031 E4                CLR     A
0032 33                RLC     A
0033 FE                MOV     R6,A
0034 7400        R     MOV     A,#LOW NVRAM0
0036 2F                ADD     A,R7
0037 F582              MOV     DPL,A
0039 7400        R     MOV     A,#HIGH NVRAM0
003B 3E                ADDC    A,R6
003C F583              MOV     DPH,A
003E A3                INC     DPTR
003F E0                MOVX    A,@DPTR
0040 FB                MOV     R3,A
0041         L?0277:
0041 EC                MOV     A,R4
0042 C4                SWAP    A
0043 F8                MOV     R0,A
0044 54F0              ANL     A,#0F0H
0046 C8                XCH     A,R0
0047 68                XRL     A,R0
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 89  

0048 FE                MOV     R6,A
0049 ED                MOV     A,R5
004A         L?0278:
004A C4                SWAP    A
004B 540F              ANL     A,#0FH
004D 48                ORL     A,R0
004E 25E0              ADD     A,ACC
0050 FF                MOV     R7,A
0051 EE                MOV     A,R6
0052         L?0279:
0052 33                RLC     A
0053 FE                MOV     R6,A
0054         L?0280:
0054 7400        R     MOV     A,#LOW NVRAM0
0056 2F                ADD     A,R7
0057 F582              MOV     DPL,A
0059 7400        R     MOV     A,#HIGH NVRAM0
005B 3E                ADDC    A,R6
005C F583              MOV     DPH,A
005E 22                RET     
005F         L?0281:
005F         L?0282:
005F E500        R     MOV     A,A
0061         L?0283:
0061 C4                SWAP    A
0062         L?0284:
0062 540F              ANL     A,#0FH
0064         L?0285:
0064 25E0              ADD     A,ACC
0066 FF                MOV     R7,A
0067 E4                CLR     A
0068 33                RLC     A
0069 FE                MOV     R6,A
006A 22                RET     
006B         L?0286:
006B         L?0287:
006B E500        R     MOV     A,A
006D         L?0288:
006D 540F              ANL     A,#0FH
006F FF                MOV     R7,A
0070 7E00              MOV     R6,#00H
0072 7401              MOV     A,#01H
0074 A807              MOV     R0,AR7
0076 08                INC     R0
0077 22                RET     
0078         L?0289:
0078 7400        R     MOV     A,#LOW NVRAM1
007A 2F                ADD     A,R7
007B F582              MOV     DPL,A
007D 7400        R     MOV     A,#HIGH NVRAM1
007F 3E                ADDC    A,R6
0080 F583              MOV     DPH,A
0082 A3                INC     DPTR
0083 E0                MOVX    A,@DPTR
0084 FA                MOV     R2,A
0085 EC                MOV     A,R4
0086 C4                SWAP    A
0087 F8                MOV     R0,A
0088 54F0              ANL     A,#0F0H
008A C8                XCH     A,R0
008B 68                XRL     A,R0
008C FE                MOV     R6,A
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 90  

008D ED                MOV     A,R5
008E C4                SWAP    A
008F 540F              ANL     A,#0FH
0091 48                ORL     A,R0
0092 25E0              ADD     A,ACC
0094 FF                MOV     R7,A
0095 EE                MOV     A,R6
0096 33                RLC     A
0097 FE                MOV     R6,A
0098 7400        R     MOV     A,#LOW NVRAM1
009A 2F                ADD     A,R7
009B F582              MOV     DPL,A
009D 7400        R     MOV     A,#HIGH NVRAM1
009F         L?0290:
009F 3E                ADDC    A,R6
00A0 F583              MOV     DPH,A
00A2 E0                MOVX    A,@DPTR
00A3 FE                MOV     R6,A
00A4 A3                INC     DPTR
00A5 E0                MOVX    A,@DPTR
00A6 22                RET     
00A7         L?0291:
00A7 AB00        R     MOV     R3,sp1
00A9 AA00        R     MOV     R2,sp1+01H
00AB A900        R     MOV     R1,sp1+02H
00AD 850082      R     MOV     DPL,i+01H
00B0 850083      R     MOV     DPH,i
00B3 120000      E     LCALL   ?C?CLDOPTR
00B6 FF                MOV     R7,A
00B7 AB00        R     MOV     R3,sp0
00B9 AA00        R     MOV     R2,sp0+01H
00BB A900        R     MOV     R1,sp0+02H
00BD 850082      R     MOV     DPL,i+01H
00C0 850083      R     MOV     DPH,i
00C3 020000      E     LJMP    ?C?CLDOPTR
00C6         L?0292:
00C6         L?0293:
00C6 F4                CPL     A
00C7 FF                MOV     R7,A
00C8 EE                MOV     A,R6
00C9 F4                CPL     A
00CA FE                MOV     R6,A
00CB E0                MOVX    A,@DPTR
00CC 5E                ANL     A,R6
00CD FE                MOV     R6,A
00CE A3                INC     DPTR
00CF E0                MOVX    A,@DPTR
00D0 5F                ANL     A,R7
00D1 22                RET     
00D2         L?0294:
00D2 E4                CLR     A
00D3 FF                MOV     R7,A
00D4 FE                MOV     R6,A
00D5 7DC8              MOV     R5,#0C8H
00D7         L?0295:
00D7 AB00        R     MOV     R3,ftemp+03H
00D9 AA00        R     MOV     R2,ftemp+02H
00DB A900        R     MOV     R1,ftemp+01H
00DD A800        R     MOV     R0,ftemp
00DF 22                RET     
00E0         L?0296:
00E0 EE                MOV     A,R6
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 91  

00E1 33                RLC     A
00E2 95E0              SUBB    A,ACC
00E4 FD                MOV     R5,A
00E5 FC                MOV     R4,A
00E6 E4                CLR     A
00E7 7B98              MOV     R3,#098H
00E9 7A08              MOV     R2,#08H
00EB F9                MOV     R1,A
00EC F8                MOV     R0,A
00ED 120000      E     LCALL   ?C?LMUL
00F0 E4                CLR     A
00F1 FB                MOV     R3,A
00F2 7A10              MOV     R2,#010H
00F4 F9                MOV     R1,A
00F5 F8                MOV     R0,A
00F6 020000      E     LJMP    ?C?SLDIV
00F9         L?0297:
00F9         L?0298:
00F9 7400        R     MOV     A,#LOW inputFilter
00FB 2C                ADD     A,R4
00FC F8                MOV     R0,A
00FD E2                MOVX    A,@R0
00FE FF                MOV     R7,A
00FF 33                RLC     A
0100 95E0              SUBB    A,ACC
0102 FE                MOV     R6,A
0103 22                RET     
0104         L?0299:
0104 7800        R     MOV     R0,#LOW NVRAM1
0106 7C00        R     MOV     R4,#HIGH NVRAM1
0108 7D01              MOV     R5,#01H
010A         L?0300:
010A 7B01              MOV     R3,#01H
010C 7A00        R     MOV     R2,#HIGH NVRAM0
010E 7900        R     MOV     R1,#LOW NVRAM0
0110 22                RET     
0111         L?0301:
0111         L?0302:
0111 CE                XCH     A,R6
0112 A2E7              MOV     C,ACC.7
0114 13                RRC     A
0115 CE                XCH     A,R6
0116 13                RRC     A
0117 22                RET     
0118         L?0303:
0118         L?0304:
0118 E0                MOVX    A,@DPTR
0119 FA                MOV     R2,A
011A A3                INC     DPTR
011B E0                MOVX    A,@DPTR
011C C3                CLR     C
011D 94FF              SUBB    A,#0FFH
011F EA                MOV     A,R2
0120 6480              XRL     A,#080H
0122 94FF              SUBB    A,#0FFH
0124 22                RET     
0125         L?0305:
0125         L?0306:
0125 7400        R     MOV     A,#LOW NVRAM0+0240H
0127 2F                ADD     A,R7
0128 F582              MOV     DPL,A
012A 7400        R     MOV     A,#HIGH NVRAM0+0240H
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 92  

012C 3E                ADDC    A,R6
012D F583              MOV     DPH,A
012F 22                RET     
0130         L?0307:
0130         L?0308:
0130 7400        R     MOV     A,#LOW NVRAM0+0260H
0132 2F                ADD     A,R7
0133 F582              MOV     DPL,A
0135 7400        R     MOV     A,#HIGH NVRAM0+0260H
0137 3E                ADDC    A,R6
0138 F583              MOV     DPH,A
013A 22                RET     
013B         L?0309:
013B         L?0310:
013B 7400        R     MOV     A,#LOW NVRAM0+0280H
013D 2F                ADD     A,R7
013E F582              MOV     DPL,A
0140 7400        R     MOV     A,#HIGH NVRAM0+0280H
0142 3E                ADDC    A,R6
0143 F583              MOV     DPH,A
0145 22                RET     
0146         L?0311:
0146         L?0312:
0146 7E00              MOV     R6,#00H
0148 7401              MOV     A,#01H
014A A804              MOV     R0,AR4
014C 08                INC     R0
014D 22                RET     
014E         L?0313:
014E F4                CPL     A
014F FF                MOV     R7,A
0150 EE                MOV     A,R6
0151 F4                CPL     A
0152 FE                MOV     R6,A
0153 900000      R     MOV     DPTR,#NVRAM0+0320H
0156 E0                MOVX    A,@DPTR
0157 5E                ANL     A,R6
0158 F0                MOVX    @DPTR,A
0159 A3                INC     DPTR
015A E0                MOVX    A,@DPTR
015B 5F                ANL     A,R7
015C F0                MOVX    @DPTR,A
015D 22                RET     
015E         L?0314:
015E 75F063            MOV     B,#063H
0161 A4                MUL     AB
0162 2400        R     ADD     A,#LOW adcTempDat
0164 F9                MOV     R1,A
0165 7400        R     MOV     A,#HIGH adcTempDat
0167 35F0              ADDC    A,B
0169 FA                MOV     R2,A
016A 7B01              MOV     R3,#01H
016C 22                RET     
016D         L?0315:
016D         L?0316:
016D 75F002            MOV     B,#02H
0170 A4                MUL     AB
0171 F582              MOV     DPL,A
0173 85F083            MOV     DPH,B
0176 22                RET     
0177         L?0317:
0177         L?0318:
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 93  

0177 AB00        R     MOV     R3,s
0179 AA00        R     MOV     R2,s+01H
017B A900        R     MOV     R1,s+02H
017D 22                RET     
017E         L?0319:
017E         L?0320:
017E E0                MOVX    A,@DPTR
017F FE                MOV     R6,A
0180 A3                INC     DPTR
0181 E0                MOVX    A,@DPTR
0182 A803              MOV     R0,AR3
0184 08                INC     R0
0185 22                RET     
0186         L?0321:
0186         L?0322:
0186 FF                MOV     R7,A
0187 E0                MOVX    A,@DPTR
0188 4E                ORL     A,R6
0189 FE                MOV     R6,A
018A A3                INC     DPTR
018B E0                MOVX    A,@DPTR
018C 4F                ORL     A,R7
018D 22                RET     
018E         L?0323:
018E 120000      E     LCALL   ?C?FPADD
0191 8F00        R     MOV     ftemp+03H,R7
0193 8E00        R     MOV     ftemp+02H,R6
0195 8D00        R     MOV     ftemp+01H,R5
0197 8C00        R     MOV     ftemp,R4
0199 22                RET     
019A         L?0324:
019A         L?0325:
019A E4                CLR     A
019B 75F001            MOV     B,#01H
019E 020000      E     LJMP    ?C?IILDX
01A1         L?0326:
01A1         L?0327:
01A1 900000      R     MOV     DPTR,#NVRAM0+03E0H
01A4 E0                MOVX    A,@DPTR
01A5 FE                MOV     R6,A
01A6 A3                INC     DPTR
01A7 E0                MOVX    A,@DPTR
01A8 22                RET     
01A9         L?0328:
01A9 FF                MOV     R7,A
01AA 900000      R     MOV     DPTR,#NVRAM0+0320H
01AD E0                MOVX    A,@DPTR
01AE 4E                ORL     A,R6
01AF F0                MOVX    @DPTR,A
01B0 A3                INC     DPTR
01B1 E0                MOVX    A,@DPTR
01B2 4F                ORL     A,R7
01B3 F0                MOVX    @DPTR,A
01B4 22                RET     
01B5         L?0329:
01B5 C3                CLR     C
01B6         L?0330:
01B6 9430              SUBB    A,#030H
01B8 7480              MOV     A,#080H
01BA 9480              SUBB    A,#080H
01BC 22                RET     
01BD         L?0331:
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 94  

01BD C3                CLR     C
01BE EF                MOV     A,R7
01BF 9403              SUBB    A,#03H
01C1 EE                MOV     A,R6
01C2 6480              XRL     A,#080H
01C4 9480              SUBB    A,#080H
01C6 22                RET     
01C7         L?0332:
01C7 D3                SETB    C
01C8 EF                MOV     A,R7
01C9 94FD              SUBB    A,#0FDH
01CB EE                MOV     A,R6
01CC 6480              XRL     A,#080H
01CE 947F              SUBB    A,#07FH
01D0 22                RET     
             ; FUNCTION Com010F (END)

             ; FUNCTION adcProcess (BEGIN)
                                           ; SOURCE LINE # 26
                                           ; SOURCE LINE # 27
;---- Variable 'result' assigned to Register 'R4/R5' ----
0000 E4                CLR     A
0001 FD                MOV     R5,A
0002 FC                MOV     R4,A
0003         ?C0001:
                                           ; SOURCE LINE # 29
0003 30EDFD            JNB     AD0INT,?C0001
                                           ; SOURCE LINE # 31
0006 AFBF              MOV     R7,ADC0H
0008 EF                MOV     A,R7
0009 FE                MOV     R6,A
000A ADBE              MOV     R5,ADC0L
000C 7C00              MOV     R4,#00H
000E E4                CLR     A
000F 2D                ADD     A,R5
0010 FD                MOV     R5,A
0011 EC                MOV     A,R4
0012 3E                ADDC    A,R6
0013 FC                MOV     R4,A
                                           ; SOURCE LINE # 32
0014 E500        R     MOV     A,adcSelect
0016 120000      R     LCALL   L?0314
0019 120000      R     LCALL   _refreshAdcData
                                           ; SOURCE LINE # 33
001C 75F063            MOV     B,#063H
001F E500        R     MOV     A,adcSelect
0021 A4                MUL     AB
0022 2400        R     ADD     A,#LOW adcTempDat+060H
0024 F582              MOV     DPL,A
0026 E5F0              MOV     A,B
0028 3400        R     ADDC    A,#HIGH adcTempDat+060H
002A F583              MOV     DPH,A
002C E0                MOVX    A,@DPTR
002D FC                MOV     R4,A
002E A3                INC     DPTR
002F E0                MOVX    A,@DPTR
0030 FD                MOV     R5,A
0031 E500        R     MOV     A,adcSelect
0033 120000      R     LCALL   L?0285
0036 7400        R     MOV     A,#LOW NVRAM0+0360H
0038 2F                ADD     A,R7
0039 F582              MOV     DPL,A
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 95  

003B 7400        R     MOV     A,#HIGH NVRAM0+0360H
003D 3E                ADDC    A,R6
003E F583              MOV     DPH,A
0040 EC                MOV     A,R4
0041 F0                MOVX    @DPTR,A
0042 A3                INC     DPTR
0043 ED                MOV     A,R5
0044 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 34
0045 C3                CLR     C
0046 E500        R     MOV     A,adcSelect
0048 9408              SUBB    A,#08H
004A 7480              MOV     A,#080H
004C 9480              SUBB    A,#080H
004E 5004              JNC     ?C0003
                                           ; SOURCE LINE # 35
0050 0500        R     INC     adcSelect
                                           ; SOURCE LINE # 36
0052 8003              SJMP    ?C0004
0054         ?C0003:
                                           ; SOURCE LINE # 37
                                           ; SOURCE LINE # 38
0054 E4                CLR     A
0055 F500        R     MOV     adcSelect,A
                                           ; SOURCE LINE # 39
0057         ?C0004:
                                           ; SOURCE LINE # 40
0057 E500        R     MOV     A,adcSelect
0059 B40900            CJNE    A,#09H,?C0195
005C         ?C0195:
005C 504D              JNC     ?C0005
005E 900000      R     MOV     DPTR,#?C0196
0061 F8                MOV     R0,A
0062 28                ADD     A,R0
0063 28                ADD     A,R0
0064 73                JMP     @A+DPTR
0065         ?C0196:
0065 020000      R     LJMP    ?C0006
0068 020000      R     LJMP    ?C0007
006B 020000      R     LJMP    ?C0008
006E 020000      R     LJMP    ?C0009
0071 020000      R     LJMP    ?C0010
0074 020000      R     LJMP    ?C0011
0077 020000      R     LJMP    ?C0012
007A 020000      R     LJMP    ?C0013
007D 020000      R     LJMP    ?C0014
                                           ; SOURCE LINE # 41
0080         ?C0006:
                                           ; SOURCE LINE # 42
0080 E4                CLR     A
0081 F5BB              MOV     AMX0SL,A
0083 8026              SJMP    ?C0005
                                           ; SOURCE LINE # 43
                                           ; SOURCE LINE # 44
0085         ?C0007:
                                           ; SOURCE LINE # 45
0085 75BB01            MOV     AMX0SL,#01H
0088 8021              SJMP    ?C0005
                                           ; SOURCE LINE # 46
                                           ; SOURCE LINE # 47
008A         ?C0008:
                                           ; SOURCE LINE # 48
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 96  

008A 75BB02            MOV     AMX0SL,#02H
008D 801C              SJMP    ?C0005
                                           ; SOURCE LINE # 49
                                           ; SOURCE LINE # 50
008F         ?C0009:
                                           ; SOURCE LINE # 51
008F 75BB03            MOV     AMX0SL,#03H
0092 8017              SJMP    ?C0005
                                           ; SOURCE LINE # 52
                                           ; SOURCE LINE # 53
0094         ?C0010:
                                           ; SOURCE LINE # 54
0094 75BB04            MOV     AMX0SL,#04H
0097 8012              SJMP    ?C0005
                                           ; SOURCE LINE # 55
                                           ; SOURCE LINE # 56
0099         ?C0011:
                                           ; SOURCE LINE # 57
0099 75BB05            MOV     AMX0SL,#05H
009C 800D              SJMP    ?C0005
                                           ; SOURCE LINE # 58
                                           ; SOURCE LINE # 59
009E         ?C0012:
                                           ; SOURCE LINE # 60
009E 75BB06            MOV     AMX0SL,#06H
00A1 8008              SJMP    ?C0005
                                           ; SOURCE LINE # 61
                                           ; SOURCE LINE # 62
00A3         ?C0013:
                                           ; SOURCE LINE # 63
00A3 75BB07            MOV     AMX0SL,#07H
00A6 8003              SJMP    ?C0005
                                           ; SOURCE LINE # 64
                                           ; SOURCE LINE # 65
00A8         ?C0014:
                                           ; SOURCE LINE # 66
00A8 75BB08            MOV     AMX0SL,#08H
                                           ; SOURCE LINE # 67
                                           ; SOURCE LINE # 68
                                           ; SOURCE LINE # 69
                                           ; SOURCE LINE # 70
                                           ; SOURCE LINE # 71
                                           ; SOURCE LINE # 72
                                           ; SOURCE LINE # 73
                                           ; SOURCE LINE # 74
00AB         ?C0005:
                                           ; SOURCE LINE # 75
00AB C2ED              CLR     AD0INT
                                           ; SOURCE LINE # 76
00AD D2EC              SETB    AD0BUSY
                                           ; SOURCE LINE # 77
00AF 22                RET     
             ; FUNCTION adcProcess (END)

             ; FUNCTION _initAdcData (BEGIN)
                                           ; SOURCE LINE # 78
0000 8B00        R     MOV     s,R3
0002 8A00        R     MOV     s+01H,R2
0004 8900        R     MOV     s+02H,R1
                                           ; SOURCE LINE # 80
;---- Variable 'i' assigned to Register 'R7' ----
0006 E4                CLR     A
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 97  

0007 FF                MOV     R7,A
0008         ?C0018:
0008 EF                MOV     A,R7
0009 120000      R     LCALL   L?0329
000C 5013              JNC     ?C0019
                                           ; SOURCE LINE # 81
000E AB00        R     MOV     R3,s
0010 AA00        R     MOV     R2,s+01H
0012 A900        R     MOV     R1,s+02H
0014 EF                MOV     A,R7
0015 120000      R     LCALL   L?0315
0018 E4                CLR     A
0019 F5F0              MOV     B,A
001B 120000      E     LCALL   ?C?ISTOPTR
                                           ; SOURCE LINE # 82
001E 0F                INC     R7
001F 80E7              SJMP    ?C0018
0021         ?C0019:
                                           ; SOURCE LINE # 83
0021 AB00        R     MOV     R3,s
0023 AA00        R     MOV     R2,s+01H
0025 A900        R     MOV     R1,s+02H
0027 900060            MOV     DPTR,#060H
002A E4                CLR     A
002B F5F0              MOV     B,A
002D 120000      E     LCALL   ?C?ISTOPTR
                                           ; SOURCE LINE # 84
0030 900062            MOV     DPTR,#062H
0033 E4                CLR     A
0034 020000      E     LJMP    ?C?CSTOPTR
             ; FUNCTION _initAdcData (END)

             ; FUNCTION _refreshAdcData (BEGIN)
                                           ; SOURCE LINE # 86
0000 8B00        R     MOV     s,R3
0002 8A00        R     MOV     s+01H,R2
0004 8900        R     MOV     s+02H,R1
;---- Variable 'dat' assigned to Register 'R4/R5' ----
                                           ; SOURCE LINE # 90
0006 900062            MOV     DPTR,#062H
0009 120000      E     LCALL   ?C?CLDOPTR
000C 120000      R     LCALL   L?0316
000F EC                MOV     A,R4
0010 8DF0              MOV     B,R5
0012 120000      E     LCALL   ?C?ISTOPTR
                                           ; SOURCE LINE # 91
0015 120000      R     LCALL   L?0317
0018 900062            MOV     DPTR,#062H
001B 7401              MOV     A,#01H
001D 120000      E     LCALL   ?C?CILDOPTR
                                           ; SOURCE LINE # 92
0020 900062            MOV     DPTR,#062H
0023 120000      E     LCALL   ?C?CLDOPTR
0026 120000      R     LCALL   L?0329
0029 400A              JC      ?C0022
                                           ; SOURCE LINE # 93
002B 120000      R     LCALL   L?0317
002E 900062            MOV     DPTR,#062H
0031 E4                CLR     A
0032 120000      E     LCALL   ?C?CSTOPTR
                                           ; SOURCE LINE # 94
0035         ?C0022:
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 98  

                                           ; SOURCE LINE # 95
0035 E4                CLR     A
0036 F500        R     MOV     sum+03H,A
0038 F500        R     MOV     sum+02H,A
003A F500        R     MOV     sum+01H,A
003C F500        R     MOV     sum,A
                                           ; SOURCE LINE # 96
003E F500        R     MOV     i,A
0040         ?C0023:
0040 C3                CLR     C
0041 E500        R     MOV     A,i
0043 120000      R     LCALL   L?0330
0046 5029              JNC     ?C0024
                                           ; SOURCE LINE # 97
0048 120000      R     LCALL   L?0318
004B E500        R     MOV     A,i
004D 120000      R     LCALL   L?0315
0050 120000      E     LCALL   ?C?ILDOPTR
0053 FF                MOV     R7,A
0054 AEF0              MOV     R6,B
0056 E4                CLR     A
0057 FC                MOV     R4,A
0058 FD                MOV     R5,A
0059 E500        R     MOV     A,sum+03H
005B 2F                ADD     A,R7
005C F500        R     MOV     sum+03H,A
005E E500        R     MOV     A,sum+02H
0060 3E                ADDC    A,R6
0061 F500        R     MOV     sum+02H,A
0063 ED                MOV     A,R5
0064 3500        R     ADDC    A,sum+01H
0066 F500        R     MOV     sum+01H,A
0068 EC                MOV     A,R4
0069 3500        R     ADDC    A,sum
006B F500        R     MOV     sum,A
                                           ; SOURCE LINE # 98
006D 0500        R     INC     i
006F 80CF              SJMP    ?C0023
0071         ?C0024:
                                           ; SOURCE LINE # 99
0071 E4                CLR     A
0072 7B30              MOV     R3,#030H
0074 FA                MOV     R2,A
0075 F9                MOV     R1,A
0076 F8                MOV     R0,A
0077 AF00        R     MOV     R7,sum+03H
0079 AE00        R     MOV     R6,sum+02H
007B AD00        R     MOV     R5,sum+01H
007D AC00        R     MOV     R4,sum
007F 120000      E     LCALL   ?C?ULDIV
;---- Variable 'temp' assigned to Register 'R6/R7' ----
                                           ; SOURCE LINE # 100
0082 120000      R     LCALL   L?0318
0085 900060            MOV     DPTR,#060H
0088 EE                MOV     A,R6
0089 8FF0              MOV     B,R7
008B 020000      E     LJMP    ?C?ISTOPTR
             ; FUNCTION _refreshAdcData (END)

             ; FUNCTION _assertCoilAddress (BEGIN)
                                           ; SOURCE LINE # 102
;---- Variable 'adr' assigned to Register 'R6/R7' ----
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 99  

                                           ; SOURCE LINE # 103
0000 D3                SETB    C
0001 EF                MOV     A,R7
0002 94F0              SUBB    A,#0F0H
0004 EE                MOV     A,R6
0005 941E              SUBB    A,#01EH
0007 4002              JC      ?C0030
0009         ?C0028:
                                           ; SOURCE LINE # 104
0009 80FE              SJMP    ?C0028
                                           ; SOURCE LINE # 105
000B         ?C0030:
000B 22                RET     
             ; FUNCTION _assertCoilAddress (END)

             ; FUNCTION _assertRegisterAddress (BEGIN)
                                           ; SOURCE LINE # 106
;---- Variable 'adr' assigned to Register 'R6/R7' ----
                                           ; SOURCE LINE # 107
0000 C3                CLR     C
0001 EF                MOV     A,R7
0002 94EF              SUBB    A,#0EFH
0004 EE                MOV     A,R6
0005 9401              SUBB    A,#01H
0007 4002              JC      ?C0034
0009         ?C0032:
                                           ; SOURCE LINE # 108
0009 80FE              SJMP    ?C0032
                                           ; SOURCE LINE # 109
000B         ?C0034:
000B 22                RET     
             ; FUNCTION _assertRegisterAddress (END)

             ; FUNCTION clearDM (BEGIN)
                                           ; SOURCE LINE # 110
                                           ; SOURCE LINE # 112
;---- Variable 'i' assigned to Register 'R4/R5' ----
0000 E4                CLR     A
0001 FD                MOV     R5,A
0002 FC                MOV     R4,A
0003         ?C0035:
                                           ; SOURCE LINE # 113
                                           ; SOURCE LINE # 114
                                           ; SOURCE LINE # 115
0003 120000      R     LCALL   L?0272
                                           ; SOURCE LINE # 116
0006 0D                INC     R5
0007 BD0001            CJNE    R5,#00H,?C0197
000A 0C                INC     R4
000B         ?C0197:
000B ED                MOV     A,R5
000C 64A0              XRL     A,#0A0H
000E 4C                ORL     A,R4
000F 70F2              JNZ     ?C0035
                                           ; SOURCE LINE # 117
0011         ?C0038:
0011 22                RET     
             ; FUNCTION clearDM (END)

             ; FUNCTION clearMR (BEGIN)
                                           ; SOURCE LINE # 118
                                           ; SOURCE LINE # 120
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 100 

;---- Variable 'i' assigned to Register 'R4/R5' ----
0000 E4                CLR     A
0001 FD                MOV     R5,A
0002 FC                MOV     R4,A
0003         ?C0039:
                                           ; SOURCE LINE # 121
                                           ; SOURCE LINE # 122
                                           ; SOURCE LINE # 123
0003 120000      R     LCALL   L?0272
                                           ; SOURCE LINE # 124
0006 0D                INC     R5
0007 BD0001            CJNE    R5,#00H,?C0198
000A 0C                INC     R4
000B         ?C0198:
000B ED                MOV     A,R5
000C 6410              XRL     A,#010H
000E 4C                ORL     A,R4
000F 70F2              JNZ     ?C0039
                                           ; SOURCE LINE # 125
0011         ?C0042:
0011 22                RET     
             ; FUNCTION clearMR (END)

             ; FUNCTION clearEM (BEGIN)
                                           ; SOURCE LINE # 126
                                           ; SOURCE LINE # 128
;---- Variable 'i' assigned to Register 'R4/R5' ----
0000 7DA0              MOV     R5,#0A0H
0002 7C00              MOV     R4,#00H
0004         ?C0043:
                                           ; SOURCE LINE # 129
                                           ; SOURCE LINE # 130
                                           ; SOURCE LINE # 131
0004 120000      R     LCALL   L?0273
                                           ; SOURCE LINE # 132
0007 0D                INC     R5
0008 BD0001            CJNE    R5,#00H,?C0199
000B 0C                INC     R4
000C         ?C0199:
000C BC01F5            CJNE    R4,#01H,?C0043
000F BD20F2            CJNE    R5,#020H,?C0043
                                           ; SOURCE LINE # 133
0012         ?C0046:
0012 22                RET     
             ; FUNCTION clearEM (END)

             ; FUNCTION clearR (BEGIN)
                                           ; SOURCE LINE # 134
                                           ; SOURCE LINE # 136
;---- Variable 'i' assigned to Register 'R4/R5' ----
0000 7D10              MOV     R5,#010H
0002 7C00              MOV     R4,#00H
0004         ?C0047:
                                           ; SOURCE LINE # 137
                                           ; SOURCE LINE # 138
                                           ; SOURCE LINE # 139
0004 120000      R     LCALL   L?0273
                                           ; SOURCE LINE # 140
0007 0D                INC     R5
0008 BD0001            CJNE    R5,#00H,?C0200
000B 0C                INC     R4
000C         ?C0200:
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 101 

000C ED                MOV     A,R5
000D 6420              XRL     A,#020H
000F 4C                ORL     A,R4
0010 70F2              JNZ     ?C0047
                                           ; SOURCE LINE # 141
0012         ?C0050:
0012 22                RET     
             ; FUNCTION clearR (END)

             ; FUNCTION clearT (BEGIN)
                                           ; SOURCE LINE # 142
                                           ; SOURCE LINE # 144
;---- Variable 'i' assigned to Register 'R4/R5' ----
0000 7D20              MOV     R5,#020H
0002 7C01              MOV     R4,#01H
0004         ?C0051:
                                           ; SOURCE LINE # 145
                                           ; SOURCE LINE # 146
                                           ; SOURCE LINE # 147
0004 120000      R     LCALL   L?0273
                                           ; SOURCE LINE # 148
0007 0D                INC     R5
0008 BD0001            CJNE    R5,#00H,?C0201
000B 0C                INC     R4
000C         ?C0201:
000C BC01F5            CJNE    R4,#01H,?C0051
000F BD30F2            CJNE    R5,#030H,?C0051
0012         ?C0052:
                                           ; SOURCE LINE # 149
0012 7C01              MOV     R4,#01H
0014 7D30              MOV     R5,#030H
0016         ?C0054:
                                           ; SOURCE LINE # 150
                                           ; SOURCE LINE # 151
                                           ; SOURCE LINE # 152
0016 120000      R     LCALL   L?0273
                                           ; SOURCE LINE # 153
0019 0D                INC     R5
001A BD0001            CJNE    R5,#00H,?C0202
001D 0C                INC     R4
001E         ?C0202:
001E BC01F5            CJNE    R4,#01H,?C0054
0021 BD40F2            CJNE    R5,#040H,?C0054
0024         ?C0055:
                                           ; SOURCE LINE # 154
0024 7C01              MOV     R4,#01H
0026 7D40              MOV     R5,#040H
0028         ?C0057:
                                           ; SOURCE LINE # 155
                                           ; SOURCE LINE # 156
                                           ; SOURCE LINE # 157
0028 120000      R     LCALL   L?0273
                                           ; SOURCE LINE # 158
002B 0D                INC     R5
002C BD0001            CJNE    R5,#00H,?C0203
002F 0C                INC     R4
0030         ?C0203:
0030 BC01F5            CJNE    R4,#01H,?C0057
0033 BD50F2            CJNE    R5,#050H,?C0057
                                           ; SOURCE LINE # 159
0036         ?C0060:
0036 22                RET     
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 102 

             ; FUNCTION clearT (END)

             ; FUNCTION clearTD (BEGIN)
                                           ; SOURCE LINE # 160
                                           ; SOURCE LINE # 162
;---- Variable 'i' assigned to Register 'R4/R5' ----
0000 7D50              MOV     R5,#050H
0002 7C01              MOV     R4,#01H
0004         ?C0061:
                                           ; SOURCE LINE # 163
                                           ; SOURCE LINE # 164
                                           ; SOURCE LINE # 165
0004 120000      R     LCALL   L?0273
                                           ; SOURCE LINE # 166
0007 0D                INC     R5
0008 BD0001            CJNE    R5,#00H,?C0204
000B 0C                INC     R4
000C         ?C0204:
000C BC01F5            CJNE    R4,#01H,?C0061
000F BD60F2            CJNE    R5,#060H,?C0061
0012         ?C0062:
                                           ; SOURCE LINE # 167
0012 7C01              MOV     R4,#01H
0014 7D60              MOV     R5,#060H
0016         ?C0064:
                                           ; SOURCE LINE # 168
                                           ; SOURCE LINE # 169
                                           ; SOURCE LINE # 170
0016 120000      R     LCALL   L?0273
                                           ; SOURCE LINE # 171
0019 0D                INC     R5
001A BD0001            CJNE    R5,#00H,?C0205
001D 0C                INC     R4
001E         ?C0205:
001E BC01F5            CJNE    R4,#01H,?C0064
0021 BD70F2            CJNE    R5,#070H,?C0064
0024         ?C0065:
                                           ; SOURCE LINE # 172
0024 7C01              MOV     R4,#01H
0026 7D70              MOV     R5,#070H
0028         ?C0067:
                                           ; SOURCE LINE # 173
                                           ; SOURCE LINE # 174
                                           ; SOURCE LINE # 175
0028 120000      R     LCALL   L?0273
                                           ; SOURCE LINE # 176
002B 0D                INC     R5
002C BD0001            CJNE    R5,#00H,?C0206
002F 0C                INC     R4
0030         ?C0206:
0030 BC01F5            CJNE    R4,#01H,?C0067
0033 BD80F2            CJNE    R5,#080H,?C0067
                                           ; SOURCE LINE # 177
0036         ?C0070:
0036 22                RET     
             ; FUNCTION clearTD (END)

             ; FUNCTION clearC (BEGIN)
                                           ; SOURCE LINE # 178
                                           ; SOURCE LINE # 180
;---- Variable 'i' assigned to Register 'R4/R5' ----
0000 7D80              MOV     R5,#080H
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 103 

0002 7C01              MOV     R4,#01H
0004         ?C0071:
                                           ; SOURCE LINE # 181
                                           ; SOURCE LINE # 182
0004 120000      R     LCALL   L?0273
                                           ; SOURCE LINE # 183
0007 0D                INC     R5
0008 BD0001            CJNE    R5,#00H,?C0207
000B 0C                INC     R4
000C         ?C0207:
000C BC01F5            CJNE    R4,#01H,?C0071
000F BD90F2            CJNE    R5,#090H,?C0071
                                           ; SOURCE LINE # 184
0012         ?C0074:
0012 22                RET     
             ; FUNCTION clearC (END)

             ; FUNCTION clearX (BEGIN)
                                           ; SOURCE LINE # 185
                                           ; SOURCE LINE # 187
;---- Variable 'i' assigned to Register 'R4/R5' ----
0000 7D90              MOV     R5,#090H
0002 7C01              MOV     R4,#01H
0004         ?C0075:
                                           ; SOURCE LINE # 188
                                           ; SOURCE LINE # 189
0004 120000      R     LCALL   L?0273
                                           ; SOURCE LINE # 190
0007 0D                INC     R5
0008 BD0001            CJNE    R5,#00H,?C0208
000B 0C                INC     R4
000C         ?C0208:
000C BC01F5            CJNE    R4,#01H,?C0075
000F BDA0F2            CJNE    R5,#0A0H,?C0075
                                           ; SOURCE LINE # 191
0012         ?C0078:
0012 22                RET     
             ; FUNCTION clearX (END)

             ; FUNCTION clearY (BEGIN)
                                           ; SOURCE LINE # 192
                                           ; SOURCE LINE # 194
;---- Variable 'i' assigned to Register 'R4/R5' ----
0000 7DA0              MOV     R5,#0A0H
0002 7C01              MOV     R4,#01H
0004         ?C0079:
                                           ; SOURCE LINE # 195
                                           ; SOURCE LINE # 196
0004 120000      R     LCALL   L?0273
                                           ; SOURCE LINE # 197
0007 0D                INC     R5
0008 BD0001            CJNE    R5,#00H,?C0209
000B 0C                INC     R4
000C         ?C0209:
000C BC01F5            CJNE    R4,#01H,?C0079
000F BDB0F2            CJNE    R5,#0B0H,?C0079
                                           ; SOURCE LINE # 198
0012         ?C0082:
0012 22                RET     
             ; FUNCTION clearY (END)

             ; FUNCTION clearSPREG (BEGIN)
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 104 

                                           ; SOURCE LINE # 199
                                           ; SOURCE LINE # 201
;---- Variable 'i' assigned to Register 'R4/R5' ----
0000 7DB0              MOV     R5,#0B0H
0002 7C01              MOV     R4,#01H
0004         ?C0083:
                                           ; SOURCE LINE # 202
                                           ; SOURCE LINE # 203
0004 120000      R     LCALL   L?0273
                                           ; SOURCE LINE # 204
0007 0D                INC     R5
0008 BD0001            CJNE    R5,#00H,?C0210
000B 0C                INC     R4
000C         ?C0210:
000C BC01F5            CJNE    R4,#01H,?C0083
000F BDF0F2            CJNE    R5,#0F0H,?C0083
                                           ; SOURCE LINE # 205
0012         ?C0086:
0012 22                RET     
             ; FUNCTION clearSPREG (END)

             ; FUNCTION clearSPCOIL (BEGIN)
                                           ; SOURCE LINE # 206
                                           ; SOURCE LINE # 208
;---- Variable 'i' assigned to Register 'R4/R5' ----
0000 7DF0              MOV     R5,#0F0H
0002 7C01              MOV     R4,#01H
0004         ?C0087:
                                           ; SOURCE LINE # 209
                                           ; SOURCE LINE # 210
0004 120000      R     LCALL   L?0273
                                           ; SOURCE LINE # 211
0007 0D                INC     R5
0008 BD0001            CJNE    R5,#00H,?C0211
000B 0C                INC     R4
000C         ?C0211:
000C E4                CLR     A
000D B505F4            CJNE    A,AR5,?C0087
0010 EC                MOV     A,R4
0011 B402F0            CJNE    A,#02H,?C0087
                                           ; SOURCE LINE # 212
0014         ?C0090:
0014 22                RET     
             ; FUNCTION clearSPCOIL (END)

             ; FUNCTION nvramLoad (BEGIN)
                                           ; SOURCE LINE # 213
                                           ; SOURCE LINE # 214
0000 7E04              MOV     R6,#04H
0002 7F00              MOV     R7,#00H
0004 7D00              MOV     R5,#00H
0006 120000      R     LCALL   L?0300
0009 120000      E     LCALL   ?C?MEMSET
                                           ; SOURCE LINE # 215
000C 120000      R     LCALL   L?0300
000F 750004      E     MOV     ?_epromRead?BYTE+05H,#04H
0012 750000      E     MOV     ?_epromRead?BYTE+06H,#00H
0015 E4                CLR     A
0016 FF                MOV     R7,A
0017 FE                MOV     R6,A
0018 120000      E     LCALL   _epromRead
                                           ; SOURCE LINE # 216
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 105 

001B 120000      R     LCALL   clearEM
                                           ; SOURCE LINE # 217
001E 120000      R     LCALL   clearR
                                           ; SOURCE LINE # 218
0021 120000      R     LCALL   clearT
                                           ; SOURCE LINE # 219
0024 120000      R     LCALL   clearTD
                                           ; SOURCE LINE # 220
0027 120000      R     LCALL   clearC
                                           ; SOURCE LINE # 221
002A 120000      R     LCALL   clearX
                                           ; SOURCE LINE # 222
002D 120000      R     LCALL   clearY
                                           ; SOURCE LINE # 223
0030 120000      R     LCALL   clearSPREG
                                           ; SOURCE LINE # 224
0033 120000      R     LCALL   clearSPCOIL
                                           ; SOURCE LINE # 225
0036 120000      R     LCALL   L?0299
0039 7E02              MOV     R6,#02H
003B 7F00              MOV     R7,#00H
003D 020000      E     LJMP    ?C?COPY
             ; FUNCTION nvramLoad (END)

             ; FUNCTION nvramSave (BEGIN)
                                           ; SOURCE LINE # 227
                                           ; SOURCE LINE # 228
0000 C2AF              CLR     EA
                                           ; SOURCE LINE # 229
0002 120000      R     LCALL   L?0300
0005 750000      E     MOV     ?_epromWrite?BYTE+05H,#00H
0008 750020      E     MOV     ?_epromWrite?BYTE+06H,#020H
000B E4                CLR     A
000C FF                MOV     R7,A
000D FE                MOV     R6,A
000E 120000      E     LCALL   _epromWrite
                                           ; SOURCE LINE # 230
0011 D2AF              SETB    EA
                                           ; SOURCE LINE # 231
0013 22                RET     
             ; FUNCTION nvramSave (END)

             ; FUNCTION nvramUpdata (BEGIN)
                                           ; SOURCE LINE # 232
                                           ; SOURCE LINE # 235
0000 750001      R     MOV     sp0,#01H
0003 750000      R     MOV     sp0+01H,#HIGH NVRAM0
0006 750000      R     MOV     sp0+02H,#LOW NVRAM0
                                           ; SOURCE LINE # 236
0009 750001      R     MOV     sp1,#01H
000C 750000      R     MOV     sp1+01H,#HIGH NVRAM1
000F 750000      R     MOV     sp1+02H,#LOW NVRAM1
                                           ; SOURCE LINE # 237
0012 E4                CLR     A
0013 F500        R     MOV     i,A
0015 F500        R     MOV     i+01H,A
0017         ?C0093:
                                           ; SOURCE LINE # 238
0017 120000      R     LCALL   L?0291
001A FD                MOV     R5,A
001B 6F                XRL     A,R7
001C 6007              JZ      ?C0095
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 106 

                                           ; SOURCE LINE # 239
001E AF00        R     MOV     R7,i+01H
0020 AE00        R     MOV     R6,i
0022 120000      E     LCALL   _epromWriteOneByte
                                           ; SOURCE LINE # 240
                                           ; SOURCE LINE # 241
0025         ?C0095:
0025 0500        R     INC     i+01H
0027 E500        R     MOV     A,i+01H
0029 7002              JNZ     ?C0213
002B 0500        R     INC     i
002D         ?C0213:
002D C3                CLR     C
002E 9420              SUBB    A,#020H
0030 E500        R     MOV     A,i
0032 9400              SUBB    A,#00H
0034 40E1              JC      ?C0093
0036         ?C0094:
                                           ; SOURCE LINE # 242
0036 750001      R     MOV     sp0,#01H
0039 750000      R     MOV     sp0+01H,#HIGH NVRAM0+080H
003C 750000      R     MOV     sp0+02H,#LOW NVRAM0+080H
                                           ; SOURCE LINE # 243
003F 750001      R     MOV     sp1,#01H
0042 750000      R     MOV     sp1+01H,#HIGH NVRAM1+080H
0045 750000      R     MOV     sp1+02H,#LOW NVRAM1+080H
                                           ; SOURCE LINE # 244
0048 750000      R     MOV     i,#00H
004B 750020      R     MOV     i+01H,#020H
004E         ?C0097:
                                           ; SOURCE LINE # 245
004E 120000      R     LCALL   L?0291
0051 FD                MOV     R5,A
0052 6F                XRL     A,R7
0053 6007              JZ      ?C0099
                                           ; SOURCE LINE # 246
0055 AF00        R     MOV     R7,i+01H
0057 AE00        R     MOV     R6,i
0059 120000      E     LCALL   _epromWriteOneByte
                                           ; SOURCE LINE # 247
                                           ; SOURCE LINE # 248
005C         ?C0099:
005C 0500        R     INC     i+01H
005E E500        R     MOV     A,i+01H
0060 7002              JNZ     ?C0214
0062 0500        R     INC     i
0064         ?C0214:
0064 C3                CLR     C
0065 9440              SUBB    A,#040H
0067 E500        R     MOV     A,i
0069 9401              SUBB    A,#01H
006B 40E1              JC      ?C0097
006D         ?C0098:
                                           ; SOURCE LINE # 249
006D 120000      R     LCALL   L?0299
0070 7E04              MOV     R6,#04H
0072 7F00              MOV     R7,#00H
0074 020000      E     LJMP    ?C?COPY
             ; FUNCTION nvramUpdata (END)

             ; FUNCTION _SET (BEGIN)
                                           ; SOURCE LINE # 251
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 107 

0000 8E00        R     MOV     A,R6
0002 8F00        R     MOV     A+01H,R7
                                           ; SOURCE LINE # 252
0004 120000      R     LCALL   _assertCoilAddress
                                           ; SOURCE LINE # 253
0007 E500        R     MOV     A,A
0009 C4                SWAP    A
000A F8                MOV     R0,A
000B 54F0              ANL     A,#0F0H
000D C8                XCH     A,R0
000E 68                XRL     A,R0
000F FE                MOV     R6,A
0010 E500        R     MOV     A,A+01H
0012 120000      R     LCALL   L?0278
0015 C083              PUSH    DPH
0017 C082              PUSH    DPL
0019 E0                MOVX    A,@DPTR
001A FC                MOV     R4,A
001B A3                INC     DPTR
001C E0                MOVX    A,@DPTR
001D FD                MOV     R5,A
001E E500        R     MOV     A,A+01H
0020 120000      R     LCALL   L?0288
0023 8005              SJMP    ?C0216
0025         ?C0215:
0025 C3                CLR     C
0026 33                RLC     A
0027 CE                XCH     A,R6
0028 33                RLC     A
0029 CE                XCH     A,R6
002A         ?C0216:
002A D8F9              DJNZ    R0,?C0215
002C FF                MOV     R7,A
002D EC                MOV     A,R4
002E 4E                ORL     A,R6
002F FE                MOV     R6,A
0030 ED                MOV     A,R5
0031 4F                ORL     A,R7
0032 FF                MOV     R7,A
0033 D082              POP     DPL
0035 D083              POP     DPH
0037 EE                MOV     A,R6
0038 F0                MOVX    @DPTR,A
0039 A3                INC     DPTR
003A EF                MOV     A,R7
003B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 254
003C 22                RET     
             ; FUNCTION _SET (END)

             ; FUNCTION _RESET (BEGIN)
                                           ; SOURCE LINE # 255
0000 8E00        R     MOV     A,R6
0002 8F00        R     MOV     A+01H,R7
                                           ; SOURCE LINE # 256
0004 120000      R     LCALL   _assertCoilAddress
                                           ; SOURCE LINE # 257
0007 E500        R     MOV     A,A
0009 C4                SWAP    A
000A F8                MOV     R0,A
000B 54F0              ANL     A,#0F0H
000D C8                XCH     A,R0
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 108 

000E 68                XRL     A,R0
000F FE                MOV     R6,A
0010 E500        R     MOV     A,A+01H
0012 120000      R     LCALL   L?0278
0015 C083              PUSH    DPH
0017 C082              PUSH    DPL
0019 E0                MOVX    A,@DPTR
001A FC                MOV     R4,A
001B A3                INC     DPTR
001C E0                MOVX    A,@DPTR
001D FD                MOV     R5,A
001E E500        R     MOV     A,A+01H
0020 120000      R     LCALL   L?0288
0023 8005              SJMP    ?C0218
0025         ?C0217:
0025 C3                CLR     C
0026 33                RLC     A
0027 CE                XCH     A,R6
0028 33                RLC     A
0029 CE                XCH     A,R6
002A         ?C0218:
002A D8F9              DJNZ    R0,?C0217
002C F4                CPL     A
002D FF                MOV     R7,A
002E EE                MOV     A,R6
002F F4                CPL     A
0030 5C                ANL     A,R4
0031 FE                MOV     R6,A
0032 ED                MOV     A,R5
0033 5F                ANL     A,R7
0034 FF                MOV     R7,A
0035 D082              POP     DPL
0037 D083              POP     DPH
0039 EE                MOV     A,R6
003A F0                MOVX    @DPTR,A
003B A3                INC     DPTR
003C EF                MOV     A,R7
003D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 258
003E 22                RET     
             ; FUNCTION _RESET (END)

             ; FUNCTION _FLIP (BEGIN)
                                           ; SOURCE LINE # 259
;---- Variable 'A' assigned to Register 'R4/R5' ----
0000 AD07              MOV     R5,AR7
0002 AC06              MOV     R4,AR6
                                           ; SOURCE LINE # 261
0004 120000      R     LCALL   _assertCoilAddress
                                           ; SOURCE LINE # 262
0007 120000      R     LCALL   L?0277
000A E0                MOVX    A,@DPTR
000B FA                MOV     R2,A
000C A3                INC     DPTR
000D E0                MOVX    A,@DPTR
000E FB                MOV     R3,A
000F ED                MOV     A,R5
0010 120000      R     LCALL   L?0288
0013 8005              SJMP    ?C0220
0015         ?C0219:
0015 C3                CLR     C
0016 33                RLC     A
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 109 

0017 CE                XCH     A,R6
0018 33                RLC     A
0019 CE                XCH     A,R6
001A         ?C0220:
001A D8F9              DJNZ    R0,?C0219
001C FF                MOV     R7,A
001D EA                MOV     A,R2
001E 5E                ANL     A,R6
001F FE                MOV     R6,A
0020 EB                MOV     A,R3
0021 5F                ANL     A,R7
;---- Variable 'temp' assigned to Register 'R6/R7' ----
                                           ; SOURCE LINE # 263
0022 4E                ORL     A,R6
0023 AF05              MOV     R7,AR5
0025 AE04              MOV     R6,AR4
0027 6003              JZ      ?C0104
                                           ; SOURCE LINE # 264
0029 020000      R     LJMP    _RESET
002C         ?C0104:
                                           ; SOURCE LINE # 266
002C 120000      R     LCALL   _SET
                                           ; SOURCE LINE # 267
002F         ?C0106:
002F 22                RET     
             ; FUNCTION _FLIP (END)

             ; FUNCTION _LD (BEGIN)
                                           ; SOURCE LINE # 268
;---- Variable 'A' assigned to Register 'R4/R5' ----
                                           ; SOURCE LINE # 269
                                           ; SOURCE LINE # 270
0000 120000      R     LCALL   L?0275
0003 120000      R     LCALL   L?0319
0006 8003              SJMP    ?C0222
0008         ?C0221:
0008 120000      R     LCALL   L?0301
000B         ?C0222:
000B D8FB              DJNZ    R0,?C0221
000D FF                MOV     R7,A
                                           ; SOURCE LINE # 271
000E 22                RET     
             ; FUNCTION _LD (END)

             ; FUNCTION _LDP (BEGIN)
                                           ; SOURCE LINE # 272
;---- Variable 'A' assigned to Register 'R4/R5' ----
                                           ; SOURCE LINE # 274
                                           ; SOURCE LINE # 275
0000 120000      R     LCALL   L?0275
0003 120000      R     LCALL   L?0319
0006 8003              SJMP    ?C0224
0008         ?C0223:
0008 120000      R     LCALL   L?0301
000B         ?C0224:
000B D8FB              DJNZ    R0,?C0223
;---- Variable 'temp0' assigned to Register 'R3' ----
000D FB                MOV     R3,A
                                           ; SOURCE LINE # 276
000E ED                MOV     A,R5
000F 120000      R     LCALL   L?0284
0012 120000      R     LCALL   L?0289
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 110 

0015 A802              MOV     R0,AR2
0017 08                INC     R0
0018 8003              SJMP    ?C0226
001A         ?C0225:
001A 120000      R     LCALL   L?0302
001D         ?C0226:
001D D8FB              DJNZ    R0,?C0225
001F FF                MOV     R7,A
;---- Variable 'temp1' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 277
0020 EB                MOV     A,R3
0021 6006              JZ      ?C0108
0023 EF                MOV     A,R7
0024 7003              JNZ     ?C0108
                                           ; SOURCE LINE # 278
0026 7F01              MOV     R7,#01H
0028 22                RET     
0029         ?C0108:
                                           ; SOURCE LINE # 280
0029 7F00              MOV     R7,#00H
                                           ; SOURCE LINE # 281
002B         ?C0109:
002B 22                RET     
             ; FUNCTION _LDP (END)

             ; FUNCTION _LDN (BEGIN)
                                           ; SOURCE LINE # 282
;---- Variable 'A' assigned to Register 'R4/R5' ----
                                           ; SOURCE LINE # 284
                                           ; SOURCE LINE # 285
0000 120000      R     LCALL   L?0276
0003 120000      R     LCALL   L?0320
0006 8003              SJMP    ?C0228
0008         ?C0227:
0008 120000      R     LCALL   L?0302
000B         ?C0228:
000B D8FB              DJNZ    R0,?C0227
;---- Variable 'temp0' assigned to Register 'R3' ----
000D FB                MOV     R3,A
                                           ; SOURCE LINE # 286
000E ED                MOV     A,R5
000F 120000      R     LCALL   L?0284
0012 120000      R     LCALL   L?0289
0015 A802              MOV     R0,AR2
0017 08                INC     R0
0018 8003              SJMP    ?C0230
001A         ?C0229:
001A 120000      R     LCALL   L?0302
001D         ?C0230:
001D D8FB              DJNZ    R0,?C0229
001F FF                MOV     R7,A
;---- Variable 'temp1' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 287
0020 EB                MOV     A,R3
0021 7006              JNZ     ?C0111
0023 EF                MOV     A,R7
0024 6003              JZ      ?C0111
                                           ; SOURCE LINE # 288
0026 7F01              MOV     R7,#01H
0028 22                RET     
0029         ?C0111:
                                           ; SOURCE LINE # 290
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 111 

0029 7F00              MOV     R7,#00H
                                           ; SOURCE LINE # 291
002B         ?C0112:
002B 22                RET     
             ; FUNCTION _LDN (END)

             ; FUNCTION _T1MS (BEGIN)
                                           ; SOURCE LINE # 292
0000 8F00        R     MOV     A,R7
;---- Variable 'value' assigned to Register 'R2/R3' ----
;---- Variable 'start' assigned to Register 'R5' ----
                                           ; SOURCE LINE # 297
0002 ED                MOV     A,R5
0003 6053              JZ      ?C0114
                                           ; SOURCE LINE # 298
0005 EF                MOV     A,R7
0006 120000      R     LCALL   L?0285
0009 7400        R     MOV     A,#LOW NVRAM0+02A0H
000B 2F                ADD     A,R7
000C F582              MOV     DPL,A
000E 7400        R     MOV     A,#HIGH NVRAM0+02A0H
0010 120000      R     LCALL   L?0290
0013 C3                CLR     C
0014 9B                SUBB    A,R3
0015 EE                MOV     A,R6
0016 9A                SUBB    A,R2
0017 401B              JC      ?C0115
                                           ; SOURCE LINE # 299
0019 120000      R     LCALL   L?0281
001C 120000      R     LCALL   L?0305
001F C083              PUSH    DPH
0021 C082              PUSH    DPL
0023 120000      R     LCALL   L?0286
0026 8005              SJMP    ?C0232
0028         ?C0231:
0028 C3                CLR     C
0029 33                RLC     A
002A CE                XCH     A,R6
002B 33                RLC     A
002C CE                XCH     A,R6
002D         ?C0232:
002D D8F9              DJNZ    R0,?C0231
002F 120000      R     LCALL   L?0321
                                           ; SOURCE LINE # 300
0032 8019              SJMP    ?C0268
0034         ?C0115:
                                           ; SOURCE LINE # 301
                                           ; SOURCE LINE # 302
0034 120000      R     LCALL   L?0281
0037 120000      R     LCALL   L?0305
003A C083              PUSH    DPH
003C C082              PUSH    DPL
003E 120000      R     LCALL   L?0286
0041 8005              SJMP    ?C0234
0043         ?C0233:
0043 C3                CLR     C
0044 33                RLC     A
0045 CE                XCH     A,R6
0046 33                RLC     A
0047 CE                XCH     A,R6
0048         ?C0234:
0048 D8F9              DJNZ    R0,?C0233
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 112 

004A 120000      R     LCALL   L?0292
004D         ?C0268:
004D FF                MOV     R7,A
004E D082              POP     DPL
0050 D083              POP     DPH
0052 EE                MOV     A,R6
0053 F0                MOVX    @DPTR,A
0054 A3                INC     DPTR
0055 EF                MOV     A,R7
0056 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 303
                                           ; SOURCE LINE # 305
0057 22                RET     
0058         ?C0114:
                                           ; SOURCE LINE # 306
                                           ; SOURCE LINE # 307
0058 120000      R     LCALL   L?0282
005B 120000      R     LCALL   L?0306
005E C083              PUSH    DPH
0060 C082              PUSH    DPL
0062 120000      R     LCALL   L?0287
0065 8005              SJMP    ?C0236
0067         ?C0235:
0067 C3                CLR     C
0068 33                RLC     A
0069 CE                XCH     A,R6
006A 33                RLC     A
006B CE                XCH     A,R6
006C         ?C0236:
006C D8F9              DJNZ    R0,?C0235
006E 120000      R     LCALL   L?0292
0071 FF                MOV     R7,A
0072 D082              POP     DPL
0074 D083              POP     DPH
0076 EE                MOV     A,R6
0077 F0                MOVX    @DPTR,A
0078 A3                INC     DPTR
0079 EF                MOV     A,R7
007A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 308
007B E500        R     MOV     A,A
007D 120000      R     LCALL   L?0285
0080 7400        R     MOV     A,#LOW NVRAM0+02A0H
0082 2F                ADD     A,R7
0083 F582              MOV     DPL,A
0085 7400        R     MOV     A,#HIGH NVRAM0+02A0H
0087 120000      R     LCALL   L?0274
                                           ; SOURCE LINE # 309
                                           ; SOURCE LINE # 310
008A         ?C0118:
008A 22                RET     
             ; FUNCTION _T1MS (END)

             ; FUNCTION _T10MS (BEGIN)
                                           ; SOURCE LINE # 311
0000 8F00        R     MOV     A,R7
;---- Variable 'value' assigned to Register 'R2/R3' ----
;---- Variable 'start' assigned to Register 'R5' ----
                                           ; SOURCE LINE # 316
0002 ED                MOV     A,R5
0003 605B              JZ      ?C0119
                                           ; SOURCE LINE # 317
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 113 

0005 EF                MOV     A,R7
0006 120000      R     LCALL   L?0285
0009 7400        R     MOV     A,#LOW NVRAM0+02C0H
000B 2F                ADD     A,R7
000C F582              MOV     DPL,A
000E 7400        R     MOV     A,#HIGH NVRAM0+02C0H
0010 120000      R     LCALL   L?0290
0013 C3                CLR     C
0014 9B                SUBB    A,R3
0015 EE                MOV     A,R6
0016 9A                SUBB    A,R2
0017 401F              JC      ?C0120
                                           ; SOURCE LINE # 318
0019 E500        R     MOV     A,A
001B 120000      R     LCALL   L?0283
001E 120000      R     LCALL   L?0307
0021 C083              PUSH    DPH
0023 C082              PUSH    DPL
0025 E500        R     MOV     A,A
0027 120000      R     LCALL   L?0288
002A 8005              SJMP    ?C0238
002C         ?C0237:
002C C3                CLR     C
002D 33                RLC     A
002E CE                XCH     A,R6
002F 33                RLC     A
0030 CE                XCH     A,R6
0031         ?C0238:
0031 D8F9              DJNZ    R0,?C0237
0033 120000      R     LCALL   L?0321
                                           ; SOURCE LINE # 319
0036 801D              SJMP    ?C0269
0038         ?C0120:
                                           ; SOURCE LINE # 320
                                           ; SOURCE LINE # 321
0038 E500        R     MOV     A,A
003A 120000      R     LCALL   L?0283
003D 120000      R     LCALL   L?0307
0040 C083              PUSH    DPH
0042 C082              PUSH    DPL
0044 E500        R     MOV     A,A
0046 120000      R     LCALL   L?0288
0049 8005              SJMP    ?C0240
004B         ?C0239:
004B C3                CLR     C
004C 33                RLC     A
004D CE                XCH     A,R6
004E 33                RLC     A
004F CE                XCH     A,R6
0050         ?C0240:
0050 D8F9              DJNZ    R0,?C0239
0052 120000      R     LCALL   L?0293
0055         ?C0269:
0055 FF                MOV     R7,A
0056 D082              POP     DPL
0058 D083              POP     DPH
005A EE                MOV     A,R6
005B F0                MOVX    @DPTR,A
005C A3                INC     DPTR
005D EF                MOV     A,R7
005E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 322
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 114 

                                           ; SOURCE LINE # 323
005F 22                RET     
0060         ?C0119:
                                           ; SOURCE LINE # 324
                                           ; SOURCE LINE # 325
0060 E500        R     MOV     A,A
0062 120000      R     LCALL   L?0283
0065 120000      R     LCALL   L?0308
0068 C083              PUSH    DPH
006A C082              PUSH    DPL
006C E500        R     MOV     A,A
006E 120000      R     LCALL   L?0288
0071 8005              SJMP    ?C0242
0073         ?C0241:
0073 C3                CLR     C
0074 33                RLC     A
0075 CE                XCH     A,R6
0076 33                RLC     A
0077 CE                XCH     A,R6
0078         ?C0242:
0078 D8F9              DJNZ    R0,?C0241
007A 120000      R     LCALL   L?0293
007D FF                MOV     R7,A
007E D082              POP     DPL
0080 D083              POP     DPH
0082 EE                MOV     A,R6
0083 F0                MOVX    @DPTR,A
0084 A3                INC     DPTR
0085 EF                MOV     A,R7
0086 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 326
0087 E500        R     MOV     A,A
0089 120000      R     LCALL   L?0285
008C 7400        R     MOV     A,#LOW NVRAM0+02C0H
008E 2F                ADD     A,R7
008F F582              MOV     DPL,A
0091 7400        R     MOV     A,#HIGH NVRAM0+02C0H
0093 120000      R     LCALL   L?0274
                                           ; SOURCE LINE # 327
                                           ; SOURCE LINE # 328
0096         ?C0123:
0096 22                RET     
             ; FUNCTION _T10MS (END)

             ; FUNCTION _T100MS (BEGIN)
                                           ; SOURCE LINE # 329
0000 8F00        R     MOV     A,R7
;---- Variable 'value' assigned to Register 'R2/R3' ----
;---- Variable 'start' assigned to Register 'R5' ----
                                           ; SOURCE LINE # 334
0002 ED                MOV     A,R5
0003 605B              JZ      ?C0124
                                           ; SOURCE LINE # 335
0005 EF                MOV     A,R7
0006 120000      R     LCALL   L?0285
0009 7400        R     MOV     A,#LOW NVRAM0+02E0H
000B 2F                ADD     A,R7
000C F582              MOV     DPL,A
000E 7400        R     MOV     A,#HIGH NVRAM0+02E0H
0010 120000      R     LCALL   L?0290
0013 C3                CLR     C
0014 9B                SUBB    A,R3
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 115 

0015 EE                MOV     A,R6
0016 9A                SUBB    A,R2
0017 401F              JC      ?C0125
                                           ; SOURCE LINE # 336
0019 E500        R     MOV     A,A
001B 120000      R     LCALL   L?0283
001E 120000      R     LCALL   L?0309
0021 C083              PUSH    DPH
0023 C082              PUSH    DPL
0025 E500        R     MOV     A,A
0027 120000      R     LCALL   L?0288
002A 8005              SJMP    ?C0244
002C         ?C0243:
002C C3                CLR     C
002D 33                RLC     A
002E CE                XCH     A,R6
002F 33                RLC     A
0030 CE                XCH     A,R6
0031         ?C0244:
0031 D8F9              DJNZ    R0,?C0243
0033 120000      R     LCALL   L?0322
                                           ; SOURCE LINE # 337
0036 801D              SJMP    ?C0270
0038         ?C0125:
                                           ; SOURCE LINE # 338
                                           ; SOURCE LINE # 339
0038 E500        R     MOV     A,A
003A 120000      R     LCALL   L?0283
003D 120000      R     LCALL   L?0309
0040 C083              PUSH    DPH
0042 C082              PUSH    DPL
0044 E500        R     MOV     A,A
0046 120000      R     LCALL   L?0288
0049 8005              SJMP    ?C0246
004B         ?C0245:
004B C3                CLR     C
004C 33                RLC     A
004D CE                XCH     A,R6
004E 33                RLC     A
004F CE                XCH     A,R6
0050         ?C0246:
0050 D8F9              DJNZ    R0,?C0245
0052 120000      R     LCALL   L?0293
0055         ?C0270:
0055 FF                MOV     R7,A
0056 D082              POP     DPL
0058 D083              POP     DPH
005A EE                MOV     A,R6
005B F0                MOVX    @DPTR,A
005C A3                INC     DPTR
005D EF                MOV     A,R7
005E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 340
                                           ; SOURCE LINE # 341
005F 22                RET     
0060         ?C0124:
                                           ; SOURCE LINE # 342
                                           ; SOURCE LINE # 343
0060 E500        R     MOV     A,A
0062 120000      R     LCALL   L?0283
0065 120000      R     LCALL   L?0310
0068 C083              PUSH    DPH
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 116 

006A C082              PUSH    DPL
006C E500        R     MOV     A,A
006E 120000      R     LCALL   L?0288
0071 8005              SJMP    ?C0248
0073         ?C0247:
0073 C3                CLR     C
0074 33                RLC     A
0075 CE                XCH     A,R6
0076 33                RLC     A
0077 CE                XCH     A,R6
0078         ?C0248:
0078 D8F9              DJNZ    R0,?C0247
007A 120000      R     LCALL   L?0293
007D FF                MOV     R7,A
007E D082              POP     DPL
0080 D083              POP     DPH
0082 EE                MOV     A,R6
0083 F0                MOVX    @DPTR,A
0084 A3                INC     DPTR
0085 EF                MOV     A,R7
0086 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 344
0087 E500        R     MOV     A,A
0089 120000      R     LCALL   L?0285
008C 7400        R     MOV     A,#LOW NVRAM0+02E0H
008E 2F                ADD     A,R7
008F F582              MOV     DPL,A
0091 7400        R     MOV     A,#HIGH NVRAM0+02E0H
0093 120000      R     LCALL   L?0274
                                           ; SOURCE LINE # 345
                                           ; SOURCE LINE # 346
0096         ?C0128:
0096 22                RET     
             ; FUNCTION _T100MS (END)

             ; FUNCTION _TNTC (BEGIN)
                                           ; SOURCE LINE # 348
;---- Variable 'dat' assigned to Register 'DPTR' ----
0000 8F82              MOV     DPL,R7
0002 8E83              MOV     DPH,R6
                                           ; SOURCE LINE # 351
0004 EE                MOV     A,R6
0005 33                RLC     A
0006 95E0              SUBB    A,ACC
0008 FD                MOV     R5,A
0009 FC                MOV     R4,A
000A E4                CLR     A
000B 7B98              MOV     R3,#098H
000D 7A08              MOV     R2,#08H
000F F9                MOV     R1,A
0010 F8                MOV     R0,A
0011 D3                SETB    C
0012 120000      E     LCALL   ?C?SLCMP
0015 5003              JNC     ?C0129
0017 900898            MOV     DPTR,#0898H
001A         ?C0129:
                                           ; SOURCE LINE # 352
001A C3                CLR     C
001B E583              MOV     A,DPH
001D 6480              XRL     A,#080H
001F 9480              SUBB    A,#080H
0021 5005              JNC     ?C0130
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 117 

0023 E4                CLR     A
0024 F583              MOV     DPH,A
0026 F582              MOV     DPL,A
0028         ?C0130:
                                           ; SOURCE LINE # 354
0028 AE83              MOV     R6,DPH
002A AF82              MOV     R7,DPL
002C 120000      R     LCALL   L?0296
;---- Variable 'temp' assigned to Register 'R6/R7' ----
                                           ; SOURCE LINE # 355
002F C3                CLR     C
0030 7488              MOV     A,#088H
0032 9F                SUBB    A,R7
0033 FD                MOV     R5,A
0034 7413              MOV     A,#013H
0036 9E                SUBB    A,R6
0037 FC                MOV     R4,A
0038 7EF0              MOV     R6,#0F0H
003A 7F80              MOV     R7,#080H
003C 120000      E     LCALL   ?C?UIDIV
                                           ; SOURCE LINE # 357
003F AD07              MOV     R5,AR7
0041 AC06              MOV     R4,AR6
0043 E4                CLR     A
0044 120000      E     LCALL   ?C?FCASTI
0047 7B00              MOV     R3,#00H
0049 7A40              MOV     R2,#040H
004B 791C              MOV     R1,#01CH
004D 7846              MOV     R0,#046H
004F 120000      E     LCALL   ?C?FPDIV
0052 120000      E     LCALL   _log
0055 7B97              MOV     R3,#097H
0057 7AC9              MOV     R2,#0C9H
0059 7996              MOV     R1,#096H
005B 7839              MOV     R0,#039H
005D 120000      E     LCALL   ?C?FPMUL
0060 7B62              MOV     R3,#062H
0062 7AEB              MOV     R2,#0EBH
0064 795B              MOV     R1,#05BH
0066 783B              MOV     R0,#03BH
0068 120000      R     LCALL   L?0323
                                           ; SOURCE LINE # 358
006B 120000      R     LCALL   L?0295
006E E4                CLR     A
006F FF                MOV     R7,A
0070 FE                MOV     R6,A
0071 7D80              MOV     R5,#080H
0073 7C3F              MOV     R4,#03FH
0075 120000      E     LCALL   ?C?FPDIV
0078 7B00              MOV     R3,#00H
007A 7A80              MOV     R2,#080H
007C 7988              MOV     R1,#088H
007E 78C3              MOV     R0,#0C3H
0080 120000      R     LCALL   L?0323
                                           ; SOURCE LINE # 359
0083 7C42              MOV     R4,#042H
0085 120000      R     LCALL   L?0294
0088 120000      E     LCALL   ?C?FPCMP3
008B 400B              JC      ?C0131
008D E4                CLR     A
008E F500        R     MOV     ftemp+03H,A
0090 F500        R     MOV     ftemp+02H,A
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 118 

0092 7500C8      R     MOV     ftemp+01H,#0C8H
0095 750042      R     MOV     ftemp,#042H
0098         ?C0131:
                                           ; SOURCE LINE # 360
0098 7CC2              MOV     R4,#0C2H
009A 120000      R     LCALL   L?0294
009D 120000      E     LCALL   ?C?FPCMP3
00A0 6002              JZ      $ + 4H
00A2 500B              JNC     ?C0132
00A4 E4                CLR     A
00A5 F500        R     MOV     ftemp+03H,A
00A7 F500        R     MOV     ftemp+02H,A
00A9 7500C8      R     MOV     ftemp+01H,#0C8H
00AC 7500C2      R     MOV     ftemp,#0C2H
00AF         ?C0132:
                                           ; SOURCE LINE # 361
00AF E4                CLR     A
00B0 FF                MOV     R7,A
00B1 FE                MOV     R6,A
00B2 7D20              MOV     R5,#020H
00B4 7C41              MOV     R4,#041H
00B6 120000      R     LCALL   L?0295
00B9 120000      E     LCALL   ?C?FPMUL
00BC 020000      E     LJMP    ?C?CASTF
             ; FUNCTION _TNTC (END)

             ; FUNCTION _TENV (BEGIN)
                                           ; SOURCE LINE # 363
;---- Variable 'dat' assigned to Register 'R6/R7' ----
                                           ; SOURCE LINE # 365
0000 120000      R     LCALL   L?0296
;---- Variable 'temp' assigned to Register 'R6/R7' ----
                                           ; SOURCE LINE # 366
0003 EF                MOV     A,R7
0004 24A8              ADD     A,#0A8H
0006 FF                MOV     R7,A
0007 EE                MOV     A,R6
0008 34FC              ADDC    A,#0FCH
000A FE                MOV     R6,A
000B E4                CLR     A
000C 34FF              ADDC    A,#0FFH
000E FD                MOV     R5,A
000F E4                CLR     A
0010 34FF              ADDC    A,#0FFH
0012 FC                MOV     R4,A
0013 E4                CLR     A
0014 7BE8              MOV     R3,#0E8H
0016 7A03              MOV     R2,#03H
0018 F9                MOV     R1,A
0019 F8                MOV     R0,A
001A 120000      E     LCALL   ?C?LMUL
001D E4                CLR     A
001E 7B02              MOV     R3,#02H
0020 7A0D              MOV     R2,#0DH
0022 F9                MOV     R1,A
0023 F8                MOV     R0,A
0024 020000      E     LJMP    ?C?SLDIV
             ; FUNCTION _TENV (END)

             ; FUNCTION wdtInit (BEGIN)
                                           ; SOURCE LINE # 369
                                           ; SOURCE LINE # 371
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 119 

0000 E4                CLR     A
0001 F5FF              MOV     WDTCN,A
                                           ; SOURCE LINE # 373
0003 22                RET     
             ; FUNCTION wdtInit (END)

             ; FUNCTION wdtEnable (BEGIN)
                                           ; SOURCE LINE # 374
                                           ; SOURCE LINE # 376
0000 75FFA5            MOV     WDTCN,#0A5H
                                           ; SOURCE LINE # 380
0003 22                RET     
             ; FUNCTION wdtEnable (END)

             ; FUNCTION wdtDisable (BEGIN)
                                           ; SOURCE LINE # 381
                                           ; SOURCE LINE # 383
0000 A2AF              MOV     C,EA
0002 E4                CLR     A
0003 33                RLC     A
;---- Variable 'flagEA' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 384
0004 C2AF              CLR     EA
                                           ; SOURCE LINE # 386
0006 75FFDE            MOV     WDTCN,#0DEH
                                           ; SOURCE LINE # 387
0009 75FFAD            MOV     WDTCN,#0ADH
                                           ; SOURCE LINE # 391
000C 24FF              ADD     A,#0FFH
000E 92AF              MOV     EA,C
                                           ; SOURCE LINE # 393
0010 22                RET     
             ; FUNCTION wdtDisable (END)

             ; FUNCTION wdtFeed (BEGIN)
                                           ; SOURCE LINE # 394
                                           ; SOURCE LINE # 396
0000 75FFA5            MOV     WDTCN,#0A5H
                                           ; SOURCE LINE # 398
0003 22                RET     
             ; FUNCTION wdtFeed (END)

             ; FUNCTION pcaInit (BEGIN)
                                           ; SOURCE LINE # 400
                                           ; SOURCE LINE # 408
0000 22                RET     
             ; FUNCTION pcaInit (END)

             ; FUNCTION timer0Init (BEGIN)
                                           ; SOURCE LINE # 410
                                           ; SOURCE LINE # 412
0000 E4                CLR     A
0001 F500        R     MOV     TimerCounter_1mS,A
                                           ; SOURCE LINE # 413
0003 F500        R     MOV     TimerCounter_10mS,A
                                           ; SOURCE LINE # 415
;---- Variable 'temp' assigned to Register 'R6/R7' ----
                                           ; SOURCE LINE # 416
0005 74CD              MOV     A,#0CDH
0007 F500        R     MOV     Timer0_L,A
                                           ; SOURCE LINE # 417
0009 74F8              MOV     A,#0F8H
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 120 

000B F500        R     MOV     Timer0_H,A
                                           ; SOURCE LINE # 418
000D 85008C      R     MOV     TH0,Timer0_H
                                           ; SOURCE LINE # 419
0010 85008A      R     MOV     TL0,Timer0_L
                                           ; SOURCE LINE # 420
0013 538EF7            ANL     CKCON,#0F7H
                                           ; SOURCE LINE # 421
0016 5389F0            ANL     TMOD,#0F0H
                                           ; SOURCE LINE # 422
0019 438901            ORL     TMOD,#01H
                                           ; SOURCE LINE # 423
001C D2A9              SETB    ET0
                                           ; SOURCE LINE # 424
001E D28C              SETB    TR0
                                           ; SOURCE LINE # 426
0020 22                RET     
             ; FUNCTION timer0Init (END)

             ; FUNCTION timer0Isr (BEGIN)
0000 C0E0              PUSH    ACC
0002 C0F0              PUSH    B
0004 C083              PUSH    DPH
0006 C082              PUSH    DPL
0008 C0D0              PUSH    PSW
000A 75D000            MOV     PSW,#00H
000D C000              PUSH    AR0
000F C002              PUSH    AR2
0011 C004              PUSH    AR4
0013 C005              PUSH    AR5
0015 C006              PUSH    AR6
0017 C007              PUSH    AR7
                                           ; SOURCE LINE # 427
                                           ; SOURCE LINE # 429
0019 C28D              CLR     TF0
                                           ; SOURCE LINE # 430
001B C28C              CLR     TR0
                                           ; SOURCE LINE # 431
001D 85008C      R     MOV     TH0,Timer0_H
                                           ; SOURCE LINE # 432
0020 85008A      R     MOV     TL0,Timer0_L
                                           ; SOURCE LINE # 433
0023 D28C              SETB    TR0
                                           ; SOURCE LINE # 434
0025 900000      R     MOV     DPTR,#NVRAM0+03E0H
0028 E0                MOVX    A,@DPTR
0029 A2E7              MOV     C,ACC.7
002B 13                RRC     A
002C A3                INC     DPTR
002D E0                MOVX    A,@DPTR
002E 13                RRC     A
002F 30E006            JNB     ACC.0,?C0141
                                           ; SOURCE LINE # 435
0032 E0                MOVX    A,@DPTR
0033 54FD              ANL     A,#0FDH
0035 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 436
0036 8007              SJMP    ?C0142
0038         ?C0141:
                                           ; SOURCE LINE # 437
                                           ; SOURCE LINE # 438
0038 900000      R     MOV     DPTR,#NVRAM0+03E1H
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 121 

003B E0                MOVX    A,@DPTR
003C 4402              ORL     A,#02H
003E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 439
003F         ?C0142:
                                           ; SOURCE LINE # 441
;---- Variable 'i' assigned to Register 'R4/R5' ----
003F 7D50              MOV     R5,#050H
0041 7C01              MOV     R4,#01H
0043         ?C0143:
                                           ; SOURCE LINE # 442
0043 ED                MOV     A,R5
0044 25E0              ADD     A,ACC
0046 FF                MOV     R7,A
0047 EC                MOV     A,R4
0048 120000      R     LCALL   L?0279
004B 120000      R     LCALL   L?0303
004E 5006              JNC     ?C0145
                                           ; SOURCE LINE # 443
0050 120000      R     LCALL   L?0280
0053 120000      R     LCALL   L?0324
                                           ; SOURCE LINE # 444
                                           ; SOURCE LINE # 445
0056         ?C0145:
0056 0D                INC     R5
0057 BD0001            CJNE    R5,#00H,?C0249
005A 0C                INC     R4
005B         ?C0249:
005B BC01E5            CJNE    R4,#01H,?C0143
005E BD60E2            CJNE    R5,#060H,?C0143
0061         ?C0144:
                                           ; SOURCE LINE # 446
0061 C3                CLR     C
0062 E500        R     MOV     A,TimerCounter_1mS
0064 940A              SUBB    A,#0AH
0066 7480              MOV     A,#080H
0068 9480              SUBB    A,#080H
006A 4041              JC      ?C0147
                                           ; SOURCE LINE # 447
006C 120000      R     LCALL   L?0326
006F 7802              MOV     R0,#02H
0071         ?C0250:
0071 120000      R     LCALL   L?0302
0074 D8FB              DJNZ    R0,?C0250
0076 900000      R     MOV     DPTR,#NVRAM0+03E1H
0079 30E006            JNB     ACC.0,?C0148
                                           ; SOURCE LINE # 448
007C E0                MOVX    A,@DPTR
007D 54FB              ANL     A,#0FBH
007F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 449
0080 8004              SJMP    ?C0149
0082         ?C0148:
                                           ; SOURCE LINE # 450
                                           ; SOURCE LINE # 451
0082 E0                MOVX    A,@DPTR
0083 4404              ORL     A,#04H
0085 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 452
0086         ?C0149:
                                           ; SOURCE LINE # 453
0086 7C01              MOV     R4,#01H
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 122 

0088 7D60              MOV     R5,#060H
008A         ?C0150:
                                           ; SOURCE LINE # 454
008A ED                MOV     A,R5
008B 25E0              ADD     A,ACC
008D FF                MOV     R7,A
008E EC                MOV     A,R4
008F 120000      R     LCALL   L?0279
0092 120000      R     LCALL   L?0303
0095 5006              JNC     ?C0152
                                           ; SOURCE LINE # 455
0097 120000      R     LCALL   L?0280
009A 120000      R     LCALL   L?0324
                                           ; SOURCE LINE # 456
                                           ; SOURCE LINE # 457
009D         ?C0152:
009D 0D                INC     R5
009E BD0001            CJNE    R5,#00H,?C0251
00A1 0C                INC     R4
00A2         ?C0251:
00A2 BC01E5            CJNE    R4,#01H,?C0150
00A5 BD70E2            CJNE    R5,#070H,?C0150
00A8         ?C0151:
                                           ; SOURCE LINE # 458
00A8 0500        R     INC     TimerCounter_10mS
                                           ; SOURCE LINE # 459
00AA 750000      R     MOV     TimerCounter_1mS,#00H
                                           ; SOURCE LINE # 460
00AD         ?C0147:
                                           ; SOURCE LINE # 461
00AD C3                CLR     C
00AE E500        R     MOV     A,TimerCounter_10mS
00B0 940A              SUBB    A,#0AH
00B2 7480              MOV     A,#080H
00B4 9480              SUBB    A,#080H
00B6 403F              JC      ?C0154
                                           ; SOURCE LINE # 462
00B8 120000      R     LCALL   L?0326
00BB 7803              MOV     R0,#03H
00BD         ?C0252:
00BD 120000      R     LCALL   L?0302
00C0 D8FB              DJNZ    R0,?C0252
00C2 900000      R     MOV     DPTR,#NVRAM0+03E1H
00C5 30E006            JNB     ACC.0,?C0155
                                           ; SOURCE LINE # 463
00C8 E0                MOVX    A,@DPTR
00C9 54F7              ANL     A,#0F7H
00CB F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 464
00CC 8004              SJMP    ?C0156
00CE         ?C0155:
                                           ; SOURCE LINE # 465
                                           ; SOURCE LINE # 466
00CE E0                MOVX    A,@DPTR
00CF 4408              ORL     A,#08H
00D1 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 467
00D2         ?C0156:
                                           ; SOURCE LINE # 468
00D2 7C01              MOV     R4,#01H
00D4 7D70              MOV     R5,#070H
00D6         ?C0157:
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 123 

                                           ; SOURCE LINE # 469
00D6 ED                MOV     A,R5
00D7 25E0              ADD     A,ACC
00D9 FF                MOV     R7,A
00DA EC                MOV     A,R4
00DB 120000      R     LCALL   L?0279
00DE 120000      R     LCALL   L?0304
00E1 5006              JNC     ?C0159
                                           ; SOURCE LINE # 470
00E3 120000      R     LCALL   L?0280
00E6 120000      R     LCALL   L?0325
                                           ; SOURCE LINE # 471
                                           ; SOURCE LINE # 472
00E9         ?C0159:
00E9 0D                INC     R5
00EA BD0001            CJNE    R5,#00H,?C0253
00ED 0C                INC     R4
00EE         ?C0253:
00EE BC01E5            CJNE    R4,#01H,?C0157
00F1 BD7FE2            CJNE    R5,#07FH,?C0157
00F4         ?C0158:
                                           ; SOURCE LINE # 473
00F4 750000      R     MOV     TimerCounter_10mS,#00H
                                           ; SOURCE LINE # 474
00F7         ?C0154:
                                           ; SOURCE LINE # 478
00F7 0500        R     INC     TimerCounter_1mS
                                           ; SOURCE LINE # 479
00F9 D007              POP     AR7
00FB D006              POP     AR6
00FD D005              POP     AR5
00FF D004              POP     AR4
0101 D002              POP     AR2
0103 D000              POP     AR0
0105 D0D0              POP     PSW
0107 D082              POP     DPL
0109 D083              POP     DPH
010B D0F0              POP     B
010D D0E0              POP     ACC
010F 32                RETI    
             ; FUNCTION timer0Isr (END)

             ; FUNCTION inputInit (BEGIN)
                                           ; SOURCE LINE # 481
                                           ; SOURCE LINE # 482
0000 7E00              MOV     R6,#00H
0002 7F10              MOV     R7,#010H
0004 7D00              MOV     R5,#00H
0006 7BFE              MOV     R3,#0FEH
0008 7A00        R     MOV     R2,#HIGH inputFilter
000A 7900        R     MOV     R1,#LOW inputFilter
000C 020000      E     LJMP    ?C?MEMSET
             ; FUNCTION inputInit (END)

             ; FUNCTION outputInit (BEGIN)
                                           ; SOURCE LINE # 488
                                           ; SOURCE LINE # 495
0000 22                RET     
             ; FUNCTION outputInit (END)

             ; FUNCTION inputRefresh (BEGIN)
                                           ; SOURCE LINE # 496
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 124 

                                           ; SOURCE LINE # 498
;---- Variable 'ctemp0' assigned to Register 'R5' ----
0000 E4                CLR     A
                                           ; SOURCE LINE # 499
                                           ; SOURCE LINE # 502
0001 AD84              MOV     R5,P4
                                           ; SOURCE LINE # 503
;---- Variable 'ctemp1' assigned to Register 'R1' ----
0003 A985              MOV     R1,P5
                                           ; SOURCE LINE # 508
;---- Variable 'i' assigned to Register 'R4' ----
0005 FC                MOV     R4,A
0006         ?C0164:
0006 EC                MOV     A,R4
0007 C3                CLR     C
0008 9408              SUBB    A,#08H
000A 7480              MOV     A,#080H
000C 9480              SUBB    A,#080H
000E 5053              JNC     ?C0165
                                           ; SOURCE LINE # 509
0010 A804              MOV     R0,AR4
0012 ED                MOV     A,R5
0013 08                INC     R0
0014 8002              SJMP    ?C0255
0016         ?C0254:
0016 C3                CLR     C
0017 13                RRC     A
0018         ?C0255:
0018 D8FC              DJNZ    R0,?C0254
001A 30E022            JNB     ACC.0,?C0167
                                           ; SOURCE LINE # 510
001D 120000      R     LCALL   L?0297
0020 120000      R     LCALL   L?0331
0023 5009              JNC     ?C0168
                                           ; SOURCE LINE # 511
0025 7400        R     MOV     A,#LOW inputFilter
0027 2C                ADD     A,R4
0028 F8                MOV     R0,A
0029 E2                MOVX    A,@R0
002A 04                INC     A
002B F2                MOVX    @R0,A
                                           ; SOURCE LINE # 512
002C 8031              SJMP    ?C0166
002E         ?C0168:
                                           ; SOURCE LINE # 513
                                           ; SOURCE LINE # 514
002E 120000      R     LCALL   L?0311
0031 8005              SJMP    ?C0257
0033         ?C0256:
0033 C3                CLR     C
0034 33                RLC     A
0035 CE                XCH     A,R6
0036 33                RLC     A
0037 CE                XCH     A,R6
0038         ?C0257:
0038 D8F9              DJNZ    R0,?C0256
003A 120000      R     LCALL   L?0328
                                           ; SOURCE LINE # 515
                                           ; SOURCE LINE # 516
003D 8020              SJMP    ?C0166
003F         ?C0167:
                                           ; SOURCE LINE # 517
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 125 

                                           ; SOURCE LINE # 518
003F 120000      R     LCALL   L?0297
0042 120000      R     LCALL   L?0332
0045 4009              JC      ?C0171
                                           ; SOURCE LINE # 519
0047 7400        R     MOV     A,#LOW inputFilter
0049 2C                ADD     A,R4
004A F8                MOV     R0,A
004B E2                MOVX    A,@R0
004C 14                DEC     A
004D F2                MOVX    @R0,A
                                           ; SOURCE LINE # 520
004E 800F              SJMP    ?C0166
0050         ?C0171:
                                           ; SOURCE LINE # 521
                                           ; SOURCE LINE # 522
0050 120000      R     LCALL   L?0311
0053 8005              SJMP    ?C0259
0055         ?C0258:
0055 C3                CLR     C
0056 33                RLC     A
0057 CE                XCH     A,R6
0058 33                RLC     A
0059 CE                XCH     A,R6
005A         ?C0259:
005A D8F9              DJNZ    R0,?C0258
005C 120000      R     LCALL   L?0313
                                           ; SOURCE LINE # 523
                                           ; SOURCE LINE # 524
                                           ; SOURCE LINE # 525
005F         ?C0166:
005F 0C                INC     R4
0060 020000      R     LJMP    ?C0164
0063         ?C0165:
                                           ; SOURCE LINE # 526
0063 7C08              MOV     R4,#08H
0065         ?C0173:
0065 EC                MOV     A,R4
0066 C3                CLR     C
0067 9410              SUBB    A,#010H
0069 7480              MOV     A,#080H
006B 9480              SUBB    A,#080H
006D 5056              JNC     ?C0182
                                           ; SOURCE LINE # 527
006F EC                MOV     A,R4
0070 24F8              ADD     A,#0F8H
0072 FF                MOV     R7,A
0073 F8                MOV     R0,A
0074 E9                MOV     A,R1
0075 08                INC     R0
0076 8002              SJMP    ?C0261
0078         ?C0260:
0078 C3                CLR     C
0079 13                RRC     A
007A         ?C0261:
007A D8FC              DJNZ    R0,?C0260
007C 30E022            JNB     ACC.0,?C0176
                                           ; SOURCE LINE # 528
007F 120000      R     LCALL   L?0298
0082 120000      R     LCALL   L?0331
0085 5009              JNC     ?C0177
                                           ; SOURCE LINE # 529
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 126 

0087 7400        R     MOV     A,#LOW inputFilter
0089 2C                ADD     A,R4
008A F8                MOV     R0,A
008B E2                MOVX    A,@R0
008C 04                INC     A
008D F2                MOVX    @R0,A
                                           ; SOURCE LINE # 530
008E 8031              SJMP    ?C0175
0090         ?C0177:
                                           ; SOURCE LINE # 531
                                           ; SOURCE LINE # 532
0090 120000      R     LCALL   L?0312
0093 8005              SJMP    ?C0263
0095         ?C0262:
0095 C3                CLR     C
0096 33                RLC     A
0097 CE                XCH     A,R6
0098 33                RLC     A
0099 CE                XCH     A,R6
009A         ?C0263:
009A D8F9              DJNZ    R0,?C0262
009C 120000      R     LCALL   L?0328
                                           ; SOURCE LINE # 533
                                           ; SOURCE LINE # 534
009F 8020              SJMP    ?C0175
00A1         ?C0176:
                                           ; SOURCE LINE # 535
                                           ; SOURCE LINE # 536
00A1 120000      R     LCALL   L?0298
00A4 120000      R     LCALL   L?0332
00A7 4009              JC      ?C0180
                                           ; SOURCE LINE # 537
00A9 7400        R     MOV     A,#LOW inputFilter
00AB 2C                ADD     A,R4
00AC F8                MOV     R0,A
00AD E2                MOVX    A,@R0
00AE 14                DEC     A
00AF F2                MOVX    @R0,A
                                           ; SOURCE LINE # 538
00B0 800F              SJMP    ?C0175
00B2         ?C0180:
                                           ; SOURCE LINE # 539
                                           ; SOURCE LINE # 540
00B2 120000      R     LCALL   L?0312
00B5 8005              SJMP    ?C0265
00B7         ?C0264:
00B7 C3                CLR     C
00B8 33                RLC     A
00B9 CE                XCH     A,R6
00BA 33                RLC     A
00BB CE                XCH     A,R6
00BC         ?C0265:
00BC D8F9              DJNZ    R0,?C0264
00BE 120000      R     LCALL   L?0313
                                           ; SOURCE LINE # 541
                                           ; SOURCE LINE # 542
                                           ; SOURCE LINE # 543
00C1         ?C0175:
00C1 0C                INC     R4
00C2 020000      R     LJMP    ?C0173
                                           ; SOURCE LINE # 544
00C5         ?C0182:
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 127 

00C5 22                RET     
             ; FUNCTION inputRefresh (END)

             ; FUNCTION outputRefresh (BEGIN)
                                           ; SOURCE LINE # 545
                                           ; SOURCE LINE # 548
0000 900000      R     MOV     DPTR,#NVRAM0+0340H
0003 E0                MOVX    A,@DPTR
0004 FE                MOV     R6,A
0005 A3                INC     DPTR
0006 E0                MOVX    A,@DPTR
0007 F586              MOV     P6,A
                                           ; SOURCE LINE # 549
0009 EE                MOV     A,R6
000A FF                MOV     R7,A
000B EF                MOV     A,R7
000C F596              MOV     P7,A
                                           ; SOURCE LINE # 554
000E 22                RET     
             ; FUNCTION outputRefresh (END)

             ; FUNCTION chipAdcInit (BEGIN)
                                           ; SOURCE LINE # 555
                                           ; SOURCE LINE # 558
0000 E4                CLR     A
0001 F5E8              MOV     ADC0CN,A
                                           ; SOURCE LINE # 559
0003 43E840            ORL     ADC0CN,#040H
                                           ; SOURCE LINE # 560
0006 43E880            ORL     ADC0CN,#080H
                                           ; SOURCE LINE # 561
0009 F5BC              MOV     ADC0CF,A
                                           ; SOURCE LINE # 562
000B 43BC58            ORL     ADC0CF,#058H
                                           ; SOURCE LINE # 563
000E F5BA              MOV     AMX0CF,A
                                           ; SOURCE LINE # 564
0010 F5BB              MOV     AMX0SL,A
                                           ; SOURCE LINE # 565
0012 C2ED              CLR     AD0INT
                                           ; SOURCE LINE # 566
0014 D2EC              SETB    AD0BUSY
                                           ; SOURCE LINE # 568
0016 F500        R     MOV     adcSelect,A
                                           ; SOURCE LINE # 569
0018 F500        R     MOV     i,A
001A         ?C0184:
001A D3                SETB    C
001B E500        R     MOV     A,i
001D 9409              SUBB    A,#09H
001F 7480              MOV     A,#080H
0021 9480              SUBB    A,#080H
0023 500C              JNC     ?C0187
                                           ; SOURCE LINE # 570
0025 E500        R     MOV     A,i
0027 120000      R     LCALL   L?0314
002A 120000      R     LCALL   _initAdcData
                                           ; SOURCE LINE # 571
002D 0500        R     INC     i
002F 80E9              SJMP    ?C0184
                                           ; SOURCE LINE # 572
0031         ?C0187:
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 128 

0031 22                RET     
             ; FUNCTION chipAdcInit (END)

             ; FUNCTION sPlcInit (BEGIN)
                                           ; SOURCE LINE # 573
                                           ; SOURCE LINE # 574
0000 120000      R     LCALL   wdtInit
                                           ; SOURCE LINE # 575
0003 120000      R     LCALL   wdtDisable
                                           ; SOURCE LINE # 586
0006 120000      R     LCALL   chipDacInit
                                           ; SOURCE LINE # 590
0009 E4                CLR     A
000A F500        E     MOV     ?_initModbus?BYTE+04H,A
000C 7500E1      E     MOV     ?_initModbus?BYTE+03H,#0E1H
000F F500        E     MOV     ?_initModbus?BYTE+02H,A
0011 F500        E     MOV     ?_initModbus?BYTE+01H,A
0013 7F01              MOV     R7,#01H
0015 120000      E     LCALL   _initModbus
                                           ; SOURCE LINE # 592
0018 120000      R     LCALL   timer0Init
                                           ; SOURCE LINE # 593
001B 900000      R     MOV     DPTR,#NVRAM0+03E1H
001E E0                MOVX    A,@DPTR
001F 4401              ORL     A,#01H
0021 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 594
0022 22                RET     
             ; FUNCTION sPlcInit (END)

             ; FUNCTION refreshDac (BEGIN)
                                           ; SOURCE LINE # 595
                                           ; SOURCE LINE # 597
0000 120000      R     LCALL   L?0327
0003 FF                MOV     R7,A
0004 65D2              XRL     A,DAC0
0006 7003              JNZ     ?C0266
0008 EE                MOV     A,R6
0009 65D3              XRL     A,DAC0+01H
000B         ?C0266:
000B 6004              JZ      ?C0189
                                           ; SOURCE LINE # 598
000D 8ED3              MOV     DAC0+01H,R6
000F 8FD2              MOV     DAC0,R7
                                           ; SOURCE LINE # 599
0011         ?C0189:
                                           ; SOURCE LINE # 600
0011 900000      R     MOV     DPTR,#NVRAM0+03E2H
0014 E0                MOVX    A,@DPTR
0015 FE                MOV     R6,A
0016 A3                INC     DPTR
0017 E0                MOVX    A,@DPTR
0018 FF                MOV     R7,A
0019 65D5              XRL     A,DAC1
001B 7003              JNZ     ?C0267
001D EE                MOV     A,R6
001E 65D6              XRL     A,DAC1+01H
0020         ?C0267:
0020 6004              JZ      ?C0191
                                           ; SOURCE LINE # 601
0022 8ED6              MOV     DAC1+01H,R6
0024 8FD5              MOV     DAC1,R7
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 129 

                                           ; SOURCE LINE # 602
                                           ; SOURCE LINE # 604
0026         ?C0191:
0026 22                RET     
             ; FUNCTION refreshDac (END)

             ; FUNCTION chipDacInit (BEGIN)
                                           ; SOURCE LINE # 605
                                           ; SOURCE LINE # 607
0000 E4                CLR     A
0001 F5D4              MOV     DAC0CN,A
                                           ; SOURCE LINE # 608
0003 43D480            ORL     DAC0CN,#080H
                                           ; SOURCE LINE # 609
0006 F5D3              MOV     DAC0+01H,A
0008 F5D2              MOV     DAC0,A
                                           ; SOURCE LINE # 610
000A F5D6              MOV     DAC1+01H,A
000C F5D5              MOV     DAC1,A
                                           ; SOURCE LINE # 612
000E 22                RET     
             ; FUNCTION chipDacInit (END)

             ; FUNCTION sPlcProcessStart (BEGIN)
                                           ; SOURCE LINE # 613
                                           ; SOURCE LINE # 615
0000 120000      E     LCALL   modbusPorcess
                                           ; SOURCE LINE # 618
0003 020000      R     LJMP    inputRefresh
             ; FUNCTION sPlcProcessStart (END)

             ; FUNCTION sPlcProcessEnd (BEGIN)
                                           ; SOURCE LINE # 624
                                           ; SOURCE LINE # 629
0000 120000      R     LCALL   outputRefresh
                                           ; SOURCE LINE # 632
0003 020000      R     LJMP    refreshDac
             ; FUNCTION sPlcProcessEnd (END)

C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 130 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


uint8_t. . . . . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
uint16_t . . . . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
uint32_t . . . . . . . . . . . . . . .  TYPEDEF  -----  U_LONG   -----  4
uint64_t . . . . . . . . . . . . . . .  TYPEDEF  -----  ARRAY    -----  8
int8_t . . . . . . . . . . . . . . . .  TYPEDEF  -----  CHAR     -----  1
int16_t. . . . . . . . . . . . . . . .  TYPEDEF  -----  INT      -----  2
int32_t. . . . . . . . . . . . . . . .  TYPEDEF  -----  LONG     -----  4
int64_t. . . . . . . . . . . . . . . .  TYPEDEF  -----  ARRAY    -----  8
fp32_t . . . . . . . . . . . . . . . .  TYPEDEF  -----  FLOAT    -----  4
fp64_t . . . . . . . . . . . . . . . .  TYPEDEF  -----  FLOAT    -----  4
bool . . . . . . . . . . . . . . . . .  TYPEDEF  -----  BIT      -----  1
false. . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
true . . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
SI_UU16. . . . . . . . . . . . . . . .  * TAG *  -----  UNION    -----  2
  u16. . . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0000H  2
  s16. . . . . . . . . . . . . . . . .  MEMBER   -----  INT      0000H  2
  u8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
  s8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
SI_UU16_t. . . . . . . . . . . . . . .  TYPEDEF  -----  UNION    -----  2
  u16. . . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0000H  2
  s16. . . . . . . . . . . . . . . . .  MEMBER   -----  INT      0000H  2
  u8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
  s8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
SI_UU32. . . . . . . . . . . . . . . .  * TAG *  -----  UNION    -----  4
  u32. . . . . . . . . . . . . . . . .  MEMBER   -----  U_LONG   0000H  4
  s32. . . . . . . . . . . . . . . . .  MEMBER   -----  LONG     0000H  4
  uu16 . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  u16. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  s16. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  u8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  s8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
SI_UU32_t. . . . . . . . . . . . . . .  TYPEDEF  -----  UNION    -----  4
  u32. . . . . . . . . . . . . . . . .  MEMBER   -----  U_LONG   0000H  4
  s32. . . . . . . . . . . . . . . . .  MEMBER   -----  LONG     0000H  4
  uu16 . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  u16. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  s16. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  u8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  s8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
GPTR_t . . . . . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  3
  memtype. . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  address. . . . . . . . . . . . . . .  MEMBER   -----  UNION    0001H  2
SI_GEN_PTR . . . . . . . . . . . . . .  * TAG *  -----  UNION    -----  3
  u8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  3
  gptr . . . . . . . . . . . . . . . .  MEMBER   -----  STRUCT   0000H  3
SI_GEN_PTR_t . . . . . . . . . . . . .  TYPEDEF  -----  UNION    -----  3
  u8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  3
  gptr . . . . . . . . . . . . . . . .  MEMBER   -----  STRUCT   0000H  3
U8 . . . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
U16. . . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
U32. . . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_LONG   -----  4
S8 . . . . . . . . . . . . . . . . . .  TYPEDEF  -----  CHAR     -----  1
S16. . . . . . . . . . . . . . . . . .  TYPEDEF  -----  INT      -----  2
S32. . . . . . . . . . . . . . . . . .  TYPEDEF  -----  LONG     -----  4
UU16 . . . . . . . . . . . . . . . . .  * TAG *  -----  UNION    -----  2
  U16. . . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0000H  2
  S16. . . . . . . . . . . . . . . . .  MEMBER   -----  INT      0000H  2
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 131 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


  U8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
  S8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
UU16 . . . . . . . . . . . . . . . . .  TYPEDEF  -----  UNION    -----  2
  U16. . . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0000H  2
  S16. . . . . . . . . . . . . . . . .  MEMBER   -----  INT      0000H  2
  U8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
  S8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
UU32 . . . . . . . . . . . . . . . . .  * TAG *  -----  UNION    -----  4
  U32. . . . . . . . . . . . . . . . .  MEMBER   -----  U_LONG   0000H  4
  S32. . . . . . . . . . . . . . . . .  MEMBER   -----  LONG     0000H  4
  UU16 . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  U16. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  S16. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  U8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  S8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
UU32 . . . . . . . . . . . . . . . . .  TYPEDEF  -----  UNION    -----  4
  U32. . . . . . . . . . . . . . . . .  MEMBER   -----  U_LONG   0000H  4
  S32. . . . . . . . . . . . . . . . .  MEMBER   -----  LONG     0000H  4
  UU16 . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  U16. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  S16. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  U8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  S8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
SI_GENERIC_PTR . . . . . . . . . . . .  * TAG *  -----  UNION    -----  3
  U8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  3
  GPTR . . . . . . . . . . . . . . . .  MEMBER   -----  STRUCT   0000H  3
SI_GENERIC_PTR . . . . . . . . . . . .  TYPEDEF  -----  UNION    -----  3
  U8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  3
  GPTR . . . . . . . . . . . . . . . .  MEMBER   -----  STRUCT   0000H  3
P4 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0084H  1
P5 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0085H  1
P6 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0086H  1
TMOD . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0089H  1
TL0. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008AH  1
TH0. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008CH  1
CKCON. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008EH  1
P7 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0096H  1
AMX0CF . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00BAH  1
AMX0SL . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00BBH  1
ADC0CF . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00BCH  1
ADC0L. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00BEH  1
ADC0H. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00BFH  1
DAC0CN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D4H  1
ADC0CN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E8H  1
WDTCN. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FFH  1
DAC0 . . . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00D2H  2
DAC1 . . . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00D5H  2
TF0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008DH  1
TR0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008CH  1
EA . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00AFH  1
ET0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A9H  1
AD0INT . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00EDH  1
AD0BUSY. . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00ECH  1
size_t . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
wchar_t. . . . . . . . . . . . . . . .  TYPEDEF  -----  CHAR     -----  1
_log . . . . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
_epromWriteOneByte . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 132 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


_epromRead . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
_epromWrite. . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
_initModbus. . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
modbusPorcess. . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
NVRAM0 . . . . . . . . . . . . . . . .  PUBLIC   XDATA  ARRAY    0000H  1024
NVRAM1 . . . . . . . . . . . . . . . .  PUBLIC   XDATA  ARRAY    0400H  1024
wdtDisable . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  flagEA . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
sPlcInit . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
sPlcProcessStart . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
sPlcProcessEnd . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
_assertCoilAddress . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  adr. . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0006H  2
_assertRegisterAddress . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  adr. . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0006H  2
nvramUpdata. . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
  sp0. . . . . . . . . . . . . . . . .  AUTO     DATA   PTR      0000H  3
  sp1. . . . . . . . . . . . . . . . .  AUTO     DATA   PTR      0003H  3
  i. . . . . . . . . . . . . . . . . .  AUTO     DATA   U_INT    0006H  2
clearDM. . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  i. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0004H  2
clearEM. . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  i. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0004H  2
clearR . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  i. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0004H  2
clearT . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  i. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0004H  2
clearTD. . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  i. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0004H  2
clearC . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  i. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0004H  2
nvramLoad. . . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
nvramSave. . . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
_SET . . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  A. . . . . . . . . . . . . . . . . .  AUTO     DATA   U_INT    0000H  2
_RESET . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  A. . . . . . . . . . . . . . . . . .  AUTO     DATA   U_INT    0000H  2
_FLIP. . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  A. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0004H  2
  temp . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0006H  2
_LD. . . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  A. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0004H  2
_LDP . . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  A. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0004H  2
  temp0. . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0003H  1
  temp1. . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
_LDN . . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  A. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0004H  2
  temp0. . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0003H  1
  temp1. . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
_T1MS. . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  A. . . . . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0000H  1
  start. . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0005H  1
  value. . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0002H  2
_T10MS . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  A. . . . . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0000H  1
  start. . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0005H  1
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 133 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


  value. . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0002H  2
_T100MS. . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  A. . . . . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0000H  1
  start. . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0005H  1
  value. . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0002H  2
chipDacInit. . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
chipAdcInit. . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
  i. . . . . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0000H  1
refreshDac . . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
TimerCounter_1mS . . . . . . . . . . .  STATIC   DATA   U_CHAR   0000H  1
TimerCounter_10mS. . . . . . . . . . .  STATIC   DATA   U_CHAR   0001H  1
Timer0_L . . . . . . . . . . . . . . .  STATIC   DATA   U_CHAR   0002H  1
Timer0_H . . . . . . . . . . . . . . .  STATIC   DATA   U_CHAR   0003H  1
adcTempDat_t . . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  99
  dat. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  96
  out. . . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0060H  2
  wIndex . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0062H  1
inputFilter. . . . . . . . . . . . . .  STATIC   PDATA  ARRAY    0000H  16
adcTempDat . . . . . . . . . . . . . .  STATIC   XDATA  ARRAY    0800H  891
adcSelect. . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0004H  1
_refreshAdcData. . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
  s. . . . . . . . . . . . . . . . . .  AUTO     DATA   PTR      0000H  3
  dat. . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0004H  2
  i. . . . . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0003H  1
  temp . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0006H  2
  sum. . . . . . . . . . . . . . . . .  AUTO     DATA   U_LONG   0004H  4
adcProcess . . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
  result . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0004H  2
_initAdcData . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
  s. . . . . . . . . . . . . . . . . .  AUTO     DATA   PTR      0000H  3
  i. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
clearMR. . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  i. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0004H  2
clearX . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  i. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0004H  2
clearY . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  i. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0004H  2
clearSPREG . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  i. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0004H  2
clearSPCOIL. . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  i. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0004H  2
_TNTC. . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  dat. . . . . . . . . . . . . . . . .  * REG *  DATA   INT      0082H  2
  temp . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0006H  2
  ftemp. . . . . . . . . . . . . . . .  AUTO     DATA   FLOAT    0000H  4
_TENV. . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  dat. . . . . . . . . . . . . . . . .  * REG *  DATA   INT      0006H  2
  temp . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0006H  2
wdtInit. . . . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
wdtEnable. . . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
wdtFeed. . . . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
pcaInit. . . . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
timer0Init . . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
  temp . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0006H  2
timer0Isr. . . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
  i. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0004H  2
inputInit. . . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
C51 COMPILER V9.59.0.0   SPLC                                                              12/27/2018 23:24:08 PAGE 134 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


outputInit . . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
inputRefresh . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
  ctemp0 . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0005H  1
  ctemp1 . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0001H  1
  i. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0004H  1
outputRefresh. . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3007    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   2939    ----
   PDATA SIZE       =     16    ----
   DATA SIZE        =      5      31
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
