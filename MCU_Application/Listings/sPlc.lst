C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE SPLC
OBJECT MODULE PLACED IN .\Objects\sPlc.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE MainApp\sPlc.c OMF2 OPTIMIZE(8,SPEED) REGFILE(.\Objects\dwLaser_F020.ORC
                    -) BROWSE ORDER INCDIR(.\Lib;.\Driver;.\MainApp;.\Modbus) DEFINE(C8051F580) DEBUG CODE LISTINCLUDE SYMBOLS PRINT(.\Listin
                    -gs\sPlc.lst) PREPRINT(.\Listings\sPlc.i) OBJECT(.\Objects\sPlc.obj)

line level    source

   1          #include "sPlc.h"
   1      =1  #ifndef __SPLC_H__
   2      =1  #define __SPLC_H__
   3      =1  /*****************************************************************************/
   4      =1  #include "appConfig.h"
   1      =2  #ifndef __APPCONFIG_H__
   2      =2  #define __APPCONFIG_H__
   3      =2  /*****************************************************************************/
   4      =2  #define CONFIG_SYSCLK                       (22118400L)
   5      =2  #ifdef C8051F020
           =2 #define SAR_CLK                                                 2000000L//ADC0时钟 <2.5MHz
           =2 #endif
   8      =2  #define CONFIG_DEBUG                        0//调试功能
   9      =2  #define CONFIG_USING_WDT                                        0//使能看门狗
  10      =2  #define CONFIG_USING_RESET                                      0//使能PLC复位MCU功能
  11      =2  #define CONFIG_LADDER_SECTORS_START                     64//指令起始地址
  12      =2  #define CONFIG_LADDER_SECTORS_END                       128//指令结束地址
  13      =2  #define CONFIG_LASERTIMER_OVERFLOW_US           1000L//定时器周期 1mS
  14      =2  #define CONFIG_VERSION                                          0x0001
  15      =2  #define CONFIG_CHECK_CODE                                       0x5A7E
  16      =2  
  17      =2  /*****************************************************************************/
  18      =2  #define CONFIG_UART0_BAUDRATE                           57600//串口波特率
  19      =2  #define CONFIG_UART0_PARITY                                     NONE
  20      =2  #define CONFIG_UART0_STOPBIT                            1
  21      =2  #define CONFIG_UART0_DATABIT                            8
  22      =2  
  23      =2  #define CONFIG_UART1_BAUDRATE                           115200//串口波特率
  24      =2  #define CONFIG_UART1_PARITY                                     NONE
  25      =2  #define CONFIG_UART1_STOPBIT                            1
  26      =2  #define CONFIG_UART1_DATABIT                            8
  27      =2  /*****************************************************************************/
  28      =2  #define CONFIG_I2C0_FREQ                                        (100000L)               
  29      =2  #define CONFIG_I2C1_FREQ                                        (100000L)
  30      =2  #define CONFIG_I2C2_FREQ                                        (100000L)
  31      =2  #define CONFIG_I2C3_FREQ                                        (100000L)
  32      =2  #define CONFIG_I2C4_FREQ                                        (100000L)
  33      =2  /*****************************************************************************/
  34      =2  #define CONFIG_EPROM_SIZE                                       CONFIG_AT24C64_SIZE
  35      =2  #define CONFIG_AT24C02_SIZE                             256
  36      =2  #define CONFIG_AT24C04_SIZE                             512
  37      =2  #define CONFIG_AT24C08_SIZE                             1024
  38      =2  #define CONFIG_AT24C16_SIZE                             2048
  39      =2  #define CONFIG_AT24C32_SIZE                             4096
  40      =2  #define CONFIG_AT24C64_SIZE                                     8192
  41      =2  #define CONFIG_AT24C128_SIZE                            16384
  42      =2  #define CONFIG_AT24C256_SIZE                            32768
  43      =2  #define CONFIG_EPROM_ADDRESS                            0x50
  44      =2  #define CONFIG_EPROM_FRAM                                       0//铁电存储体无写入等待
  45      =2  #define CONFIG_EPROM_FREQ                                       1//
  46      =2  /*****************************************************************************/
  47      =2  #define CONFIG_USE_IPID                                         1//使能IPID温度控制
  48      =2  /*****************************************************************************/
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 2   

  49      =2  #define CONFIG_USE_HWVER_SHOW                           1//使能固件版本显示
  50      =2  #define CONFIG_USE_MPD1_SHOW                            1//使能MPD1测量显示
  51      =2  #define CONFIG_USE_MPD2_SHOW                            1//使能MPD2测量显示
  52      =2  #define CONFIG_USE_FBS1                                         1//使能FBS1检测
  53      =2  #define CONFIG_USE_FBS2                                         1//使能FBS2检测
  54      =2  #define CONFIG_USE_LASER_TEMP                           1//使能激光器温度显示
  55      =2  #define CONFIG_USE_RADIATOR_TEMP                        1//使能散热器温度显示
  56      =2  #define CONFIG_USE_ENVI_TEMP                            1//使能环境温度显示
  57      =2  #define CONFIG_USE_IPID_UPDATE                          1//使能IPID参数更新功能
  58      =2  #define CONFIG_USE_IPID_OUTSHOW                         1//使能IPID输出显示
  59      =2  /*****************************************************************************/
  60      =2  //SPLC设置
  61      =2  #define CONFIG_SPLC_IO_INPUT_NUM                        16//硬件输入点数
  62      =2  #define CONFIG_SPLC_IO_OUTPUT_NUM                       16//硬件输出点数
  63      =2  #define CONFIG_SOFTPLC_HWTIME                           1000L//1mS
  64      =2  #define CONFIG_INPUT_FILTER_TIME                        3//输入数字滤波扫描周期 1mS * N
  65      =2  #define CONFIG_IPID_RUN_CYCLE                           40//IPID运行周期 默认 40 * 100mS
  66      =2  #define CONFIG_IPID_PWM_CYCLE                           20//IPID输出周期 默认 20 * 100mS
  67      =2  /*****************************************************************************/
  68      =2  #define CONFIG_SPLC_USING_WDT                           0//看门狗启用
  69      =2  /*****************************************************************************/
  70      =2  #define CONFIG_SPLC_USING_IO_INPUT                      1//输入IO刷新启用
  71      =2  /*****************************************************************************/
  72      =2  #define CONFIG_SPLC_USING_IO_OUTPUT                     1//输出IO刷新启用
  73      =2  /*****************************************************************************/
  74      =2  #define CONFIG_SPLC_USING_EPROM                         0//EPROM掉电存储启用
  75      =2  /*****************************************************************************/
  76      =2  #define CONFIG_SPLC_USING_ADC                           0//使能ADC模块
  77      =2  #define CONFIG_SPLC_ADC_FILTER_TAP                      48//ADC位移滤波次数
  78      =2  #define CONFIG_SPLC_ADC_CHANNLE                         9//ADC通道数
  79      =2  #define CONFIG_SPLC_ADC_TEMP_SENSOR_GAIN    3330L// Temp Sensor Gain in (uV / degC)
  80      =2  #define CONFIG_SPLC_ADC_TEMP_SENSOR_OFFSET  856L// Temp Sensor Offset in mV
  81      =2  #define CONFIG_SPLC_ADC_INTERNAL_VREF           2200L// ADC Voltage Reference (mV)
  82      =2  #define CONFIG_SPLC_ADC_AMBIENT             25L// Ambient temp in deg C
  83      =2  /*****************************************************************************/
  84      =2  #define CONFIG_SPLC_USING_DAC                           1//是能DAC模块
  85      =2  /*****************************************************************************/
  86      =2  #define CONFIG_SPLC_USING_MB_RTU_SLAVE          1//是能MODBUS RTU从站
  87      =2  #define CONFIG_MB_RTU_SLAVE_TIMER                       1000L//1000uS
  88      =2  #define CONFIG_MB_RTU_SLAVE_ADDRESS                     0x01//从设备地址
  89      =2  #define CONFIG_MB_RTU_SLAVE_BUFFER_SIZE         256//发送接收缓冲区
  90      =2  #define CONFIG_MB_RTU_SLAVE_TIMEOUT                     100//接收通讯超时 10mS
  91      =2  #define CONFIG_MB_RTU_SLAVE_IO_DELAY            1//RX TX切换延时
  92      =2  /*****************************************************************************/
  93      =2  
  94      =2  /*****************************************************************************/
  95      =2  #define ID_ONLY_1_CHANNEL                                       4321
  96      =2  #define ID_ONLY_2_CHANNEL                                       8765
  97      =2  #define ID_BOTH_CHANNEL                                         9431
  98      =2  #define ID_LASER_MODE_CW                                        7631
  99      =2  #define ID_LASER_MODE_SP                                        8934
 100      =2  #define ID_LASER_MODE_MP                                        2453
 101      =2  #define ID_LASER_MODE_GP                                        3876
 102      =2  /*****************************************************************************/
 103      =2  #define FBS1_IN_PORT                                            3
 104      =2  #define FBS2_IN_PORT                                            2
 105      =2  #define COOLON_OUT_PORT                                         (1 * 8 + 3)
 106      =2  /*****************************************************************************/
 107      =2  //PID FUZZY 模糊PID配置
 108      =2  #define CONFIG_TECOUT_CYCLE                                     4000//PID输出转PWM周期
 109      =2  /*****************************************************************************/
 110      =2  /*****************************************************************************/
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 3   

 111      =2  #define DISABLE_MODBUS_SERIAL_INTERRUPT         ES0 = 0;
 112      =2  #define ENABLE_MODBUS_SERIAL_INTERRUPT          ES0 = 1;
 113      =2  #define DISABLE_INTERRUPT                                       EA = 0;
 114      =2  #define ENABLE_INTERRUPT                                        EA = 1;
 115      =2  /*****************************************************************************/
 116      =2  #include "stdint.h"
   1      =3  /**************************************************************************//**
   2      =3   * Copyright (c) 2015 by Silicon Laboratories Inc. All rights reserved.
   3      =3   *
   4      =3   * http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   5      =3   *****************************************************************************/
   6      =3  
   7      =3  #ifndef STDINT_H
   8      =3  #define STDINT_H
   9      =3  
  10      =3  #if defined __C51__
  11      =3  
  12      =3  typedef unsigned char uint8_t;
  13      =3  typedef unsigned short uint16_t;
  14      =3  typedef unsigned long uint32_t;
  15      =3  typedef uint32_t uint64_t[2];
  16      =3  
  17      =3  typedef signed char int8_t;
  18      =3  typedef short int16_t;
  19      =3  typedef long int32_t;
  20      =3  typedef int32_t int64_t[2];
  21      =3  typedef float fp32_t;
  22      =3  typedef double fp64_t;
  23      =3  
  24      =3  #elif defined __ICC8051__
           =3 
           =3 /* Fixed size types. These are all optional. */
           =3 #ifdef __INT8_T_TYPE__
           =3   typedef __INT8_T_TYPE__   int8_t;
           =3   typedef __UINT8_T_TYPE__ uint8_t;
           =3 #endif /* __INT8_T_TYPE__ */
           =3 
           =3 #ifdef __INT16_T_TYPE__
           =3   typedef __INT16_T_TYPE__   int16_t;
           =3   typedef __UINT16_T_TYPE__ uint16_t;
           =3 #endif /* __INT16_T_TYPE__ */
           =3 
           =3 #ifdef __INT32_T_TYPE__
           =3   typedef __INT32_T_TYPE__   int32_t;
           =3   typedef __UINT32_T_TYPE__ uint32_t;
           =3 #endif /* __INT32_T_TYPE__ */
           =3 
           =3 #ifdef __INT64_T_TYPE__
           =3   #pragma language=save
           =3   #pragma language=extended
           =3   typedef __INT64_T_TYPE__   int64_t;
           =3   typedef __UINT64_T_TYPE__ uint64_t;
           =3   #pragma language=restore
           =3 #endif /* __INT64_T_TYPE__ */
           =3 
           =3 #endif
  51      =3  
  52      =3  #endif
 117      =2  #include "stdbool.h"
   1      =3  /**************************************************************************//**
   2      =3   * Copyright (c) 2015 by Silicon Laboratories Inc. All rights reserved.
   3      =3   *
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 4   

   4      =3   * http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   5      =3   *****************************************************************************/
   6      =3  
   7      =3  #ifndef STDBOOL_H
   8      =3  #define STDBOOL_H
   9      =3  
  10      =3  #if defined __C51__
  11      =3  
  12      =3  typedef bit bool;
  13      =3  enum{
  14      =3    false = 0,
  15      =3    true = 1,
  16      =3  };
  17      =3  
  18      =3  #elif defined __ICC8051__
           =3 
           =3 #ifndef _SYSTEM_BUILD
           =3   #pragma system_include
           =3 #endif
           =3 
           =3 #ifndef __cplusplus
           =3 
           =3 #define bool _Bool
           =3 #define true 1
           =3 #define false 0
           =3 
           =3 #define __bool_true_false_are_defined 1
           =3 
           =3 #endif /* !__cplusplus */
           =3 
           =3 #else  // __SLS_IDE__ : Macros defined to remove syntax errors within Simplicity Studio
           =3 
           =3 typedef bit bool;
           =3 enum{
           =3   false = 0,
           =3   true = 1,
           =3 };
           =3 
           =3 #endif
  43      =3  
  44      =3  #endif //STDBOOL_H
  45      =3  
 118      =2  #include "endian.h"
   1      =3  /**************************************************************************//**
   2      =3   * Copyright (c) 2015 by Silicon Laboratories Inc. All rights reserved.
   3      =3   *
   4      =3   * http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   5      =3   *****************************************************************************/
   6      =3  
   7      =3  #ifndef __ENDIAN_H__
   8      =3  #define __ENDIAN_H__
   9      =3  
  10      =3  #define bswapu16(x) (((x) >> 8) | ((x) << 8))
  11      =3  #define bswapu32(x) (((x) >> 24) | (((x) & 0x00FF0000) >> 8) \
  12      =3                    | (((x) & 0x0000FF00) << 8) | ((x) << 24))
  13      =3  
  14      =3  #define bswap16(x) bswapu16((uint16_t)(x))
  15      =3  #define bswap32(x) bswapu32((uint32_t)(x))
  16      =3  
  17      =3  // Big Endian Compilers
  18      =3  #if ((defined __C51__) || (defined __RC51__) || (defined _CC51))
  19      =3  
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 5   

  20      =3  #define htobe16(x) (x)
  21      =3  #define htobe32(x) (x)
  22      =3  #define be16toh(x) (x)
  23      =3  #define be32toh(x) (x)
  24      =3  
  25      =3  #define htole16(x) bswap16(x)
  26      =3  #define htole32(x) bswap32(x)
  27      =3  #define le16toh(x) bswap16(x)
  28      =3  #define le32toh(x) bswap32(x)
  29      =3  
  30      =3  #elif ((defined SDCC) || (defined HI_TECH_C) || (defined __ICC8051__))
           =3 
           =3 #define htobe16(x) bswap16(x)
           =3 #define htobe32(x) bswap32(x)
           =3 #define be16toh(x) bswap16(x)
           =3 #define be32toh(x) bswap32(x)
           =3 
           =3 #define htole16(x) (x)
           =3 #define htole32(x) (x)
           =3 #define le16toh(x) (x)
           =3 #define le32toh(x) (x)
           =3 
           =3 #else
           =3 
           =3 #define htobe16(x) (x)
           =3 #define htobe32(x) (x)
           =3 #define be16toh(x) (x)
           =3 #define be32toh(x) (x)
           =3 
           =3 #define htole16(x) (x)
           =3 #define htole32(x) (x)
           =3 #define le16toh(x) (x)
           =3 #define le32toh(x) (x)
           =3 
           =3 #endif  // Compiler Definitions
  55      =3  
  56      =3  #endif  // __ENDIAN_H__
 119      =2  #include "si_toolchain.h"
   1      =3  /******************************************************************************
   2      =3   * Copyright (c) 2015 by Silicon Laboratories Inc. All rights reserved.
   3      =3   *
   4      =3   * http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   5      =3   *****************************************************************************/
   6      =3  
   7      =3  #ifndef __SI_TOOLCHAIN_H__
   8      =3  #define __SI_TOOLCHAIN_H__
   9      =3  
  10      =3  #include <stdint.h>
   1      =4  /**************************************************************************//**
   2      =4   * Copyright (c) 2015 by Silicon Laboratories Inc. All rights reserved.
   3      =4   *
   4      =4   * http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   5      =4   *****************************************************************************/
   6      =4  
   7      =4  #ifndef STDINT_H
           =4 #define STDINT_H
           =4 
           =4 #if defined __C51__
           =4 
           =4 typedef unsigned char uint8_t;
           =4 typedef unsigned short uint16_t;
           =4 typedef unsigned long uint32_t;
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 6   

           =4 typedef uint32_t uint64_t[2];
           =4 
           =4 typedef signed char int8_t;
           =4 typedef short int16_t;
           =4 typedef long int32_t;
           =4 typedef int32_t int64_t[2];
           =4 typedef float fp32_t;
           =4 typedef double fp64_t;
           =4 
           =4 #elif defined __ICC8051__
           =4 
           =4 /* Fixed size types. These are all optional. */
           =4 #ifdef __INT8_T_TYPE__
           =4   typedef __INT8_T_TYPE__   int8_t;
           =4   typedef __UINT8_T_TYPE__ uint8_t;
           =4 #endif /* __INT8_T_TYPE__ */
           =4 
           =4 #ifdef __INT16_T_TYPE__
           =4   typedef __INT16_T_TYPE__   int16_t;
           =4   typedef __UINT16_T_TYPE__ uint16_t;
           =4 #endif /* __INT16_T_TYPE__ */
           =4 
           =4 #ifdef __INT32_T_TYPE__
           =4   typedef __INT32_T_TYPE__   int32_t;
           =4   typedef __UINT32_T_TYPE__ uint32_t;
           =4 #endif /* __INT32_T_TYPE__ */
           =4 
           =4 #ifdef __INT64_T_TYPE__
           =4   #pragma language=save
           =4   #pragma language=extended
           =4   typedef __INT64_T_TYPE__   int64_t;
           =4   typedef __UINT64_T_TYPE__ uint64_t;
           =4   #pragma language=restore
           =4 #endif /* __INT64_T_TYPE__ */
           =4 
           =4 #endif
           =4 
           =4 #endif
  11      =3  #include <stdbool.h>
   1      =4  /**************************************************************************//**
   2      =4   * Copyright (c) 2015 by Silicon Laboratories Inc. All rights reserved.
   3      =4   *
   4      =4   * http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   5      =4   *****************************************************************************/
   6      =4  
   7      =4  #ifndef STDBOOL_H
           =4 #define STDBOOL_H
           =4 
           =4 #if defined __C51__
           =4 
           =4 typedef bit bool;
           =4 enum{
           =4   false = 0,
           =4   true = 1,
           =4 };
           =4 
           =4 #elif defined __ICC8051__
           =4 
           =4 #ifndef _SYSTEM_BUILD
           =4   #pragma system_include
           =4 #endif
           =4 
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 7   

           =4 #ifndef __cplusplus
           =4 
           =4 #define bool _Bool
           =4 #define true 1
           =4 #define false 0
           =4 
           =4 #define __bool_true_false_are_defined 1
           =4 
           =4 #endif /* !__cplusplus */
           =4 
           =4 #else  // __SLS_IDE__ : Macros defined to remove syntax errors within Simplicity Studio
           =4 
           =4 typedef bit bool;
           =4 enum{
           =4   false = 0,
           =4   true = 1,
           =4 };
           =4 
           =4 #endif
           =4 
           =4 #endif //STDBOOL_H
  45      =4  
  12      =3  
  13      =3  /**************************************************************************//**
  14      =3   *
  15      =3   * @addtogroup toolchain_group Toolchain Abstraction
  16      =3   *
  17      =3   * @brief Macros for toolchain abstraction.
  18      =3   *
  19      =3   * # Introduction #
  20      =3   *
  21      =3   * This header file contains macros that are used to provide an abstraction
  22      =3   * for toolchain use in source code.  The 8051 compiler requires C-language
  23      =3   * extensions in order to fully use features of the 8051 architecture.  All
  24      =3   * compilers for 8051 implement a set of extensions but use different names
  25      =3   * and ways of implementing those extensions.  This header file provides
  26      =3   * macros that are defined for each supported toolchain and can be used in
  27      =3   * the source code.  This allows the source code to use 8051 extensions and
  28      =3   * remain independent of which toolchain is used for compilation.
  29      =3   *
  30      =3   * ## Variable and Pointer Declarations ##
  31      =3   *
  32      =3   * It is often useful to specify the memory area (or segment) of a variable,
  33      =3   * pointer, or pointer target.  For example, you may wish to place all
  34      =3   * variables in XDATA by default, but for variables used in time-sensitive
  35      =3   * code you use DATA for efficient access.  In this case you declare the
  36      =3   * XDATA variable in the normal C way, but declare the variables to be located
  37      =3   * in the DATA segment using @ref SI_SEGMENT_VARIABLE.
  38      =3   *
  39      =3   * Pointers are more complicated because there are two memory spaces
  40      =3   * associated with a pointer, the pointer target, and the pointer variable
  41      =3   * itself.  When using default memory segment for the pointer location and
  42      =3   * target, then no special macro is needed.  But if you wish to specify the
  43      =3   * pointer variable location, or target memory segment, then you can use one
  44      =3   * of the following macros to do this in a toolchain-independent way.
  45      =3   *
  46      =3   * |Pointer segment|Target segment|Macro                                   |
  47      =3   * |---------------|--------------|----------------------------------------|
  48      =3   * |default        |generic       |None                                    |
  49      =3   * |default        |specific      |@ref SI_VARIABLE_SEGMENT_POINTER        |
  50      =3   * |specific       |generic       |@ref SI_SEGMENT_POINTER                 |
  51      =3   * |specific       |specific      |@ref SI_SEGMENT_VARIABLE_SEGMENT_POINTER|
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 8   

  52      =3   *
  53      =3   * ## Prior Toolchain Abstraction Header File ##
  54      =3   *
  55      =3   * This file supercedes an earlier header file named `compiler_defs.h`.  We
  56      =3   * are deprecating the use of compiler_defs.h, however it will remain for
  57      =3   * backwards compatibility.  This file was created to normalize macro names,
  58      =3   * remove unused macros, and to provide documentation.
  59      =3   *
  60      =3   * ## Supported Toolchains ##
  61      =3   *
  62      =3   * - Keil/ARM C51
  63      =3   *
  64      =3   * @{
  65      =3   *
  66      =3   *****************************************************************************/
  67      =3  
  68      =3  // Make sure there is a NULL defined if the toolchain does not provide it.
  69      =3  #ifndef NULL
  70      =3  #define NULL ((void *)0)
  71      =3  #endif
  72      =3  
  73      =3  // -------------------------------
  74      =3  // Keil/ARM C51
  75      =3  //
  76      =3  #if defined(__C51__)
  77      =3  
  78      =3  /// Used with pointers, declares a generic pointer.  Generic pointers
  79      =3  /// work with any memory space but are inefficient.
  80      =3  #define SI_SEG_GENERIC
  81      =3  
  82      =3  /// Declares a variable to be located in 8051 DATA space.
  83      =3  #define SI_SEG_DATA data
  84      =3  
  85      =3  /// Declares a variable to be located in 8051 IDATA space.
  86      =3  #define SI_SEG_IDATA idata
  87      =3  
  88      =3  /// Declares a variable to be located in 8051 XDATA space.
  89      =3  #define SI_SEG_XDATA xdata
  90      =3  
  91      =3  /// Declares a variable to be located in 8051 PDATA space.
  92      =3  #define SI_SEG_PDATA pdata
  93      =3  
  94      =3  /// Declares a variable to be located in 8051 BDATA (bit-addressable) space.
  95      =3  #define SI_SEG_BDATA bdata
  96      =3  
  97      =3  /// Declares a variable to be located in 8051 CODE space.
  98      =3  #define SI_SEG_CODE code
  99      =3  
 100      =3  /**************************************************************************//**
 101      =3   * Declares a bit variable in a bit-addressable memory space.
 102      =3   *
 103      =3   * @param name The name of the bit variable.
 104      =3   *****************************************************************************/
 105      =3  #define SI_BIT(name) bit name
 106      =3  
 107      =3  /**************************************************************************//**
 108      =3   * Declares a bit variable in a bit-addressable SFR or memory space.
 109      =3   *
 110      =3   * @param name The name of the bit variable.
 111      =3   * @param address The address of the byte containing the bit.
 112      =3   * @param bitnum The bit number (0-7) within the byte.
 113      =3   *
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 9   

 114      =3   * This cannot be used to make any arbitrary SFR or variable into
 115      =3   * a bit variable.  The underlying memory must support bit-addressability.
 116      =3   *****************************************************************************/
 117      =3  #define SI_SBIT(name, address, bitnum) sbit name = address^bitnum
 118      =3  
 119      =3  /**************************************************************************//**
 120      =3   * Declares an 8-bit special function register (SFR) variable.
 121      =3   *
 122      =3   * @param name The name of the SFR variable.
 123      =3   * @param address The address of the SFR.
 124      =3   *
 125      =3   * This creates a C variable (8-bit) that maps to a physical special function
 126      =3   * register of the 8051.  This cannot be used to make any arbitrary memory
 127      =3   * location into an SFR.  The _address_ must map to a real SFR in the memory
 128      =3   * map.
 129      =3   *****************************************************************************/
 130      =3  #define SI_SFR(name, address) sfr name = address
 131      =3  
 132      =3  /**************************************************************************//**
 133      =3   * Declares a 16-bit special function register (SFR) variable.
 134      =3   *
 135      =3   * @param name The name of the SFR variable.
 136      =3   * @param address The address of the 16-bit SFR.
 137      =3   *
 138      =3   * This creates a C variable (16-bit) that maps to a physical special function
 139      =3   * register of the 8051.  This cannot be used to make any arbitrary memory
 140      =3   * location into an SFR.  The _address_ must map to a real 16-bit SFR in the
 141      =3   * memory map.
 142      =3   *****************************************************************************/
 143      =3  #define SI_SFR16(name, address) sfr16 name = address
 144      =3  
 145      =3  #ifndef __SLS_IDE__
 146      =3  /**************************************************************************//**
 147      =3   * Define an interrupt handler function for an interrupt vector.
 148      =3   *
 149      =3   * @param name The name of the interrupt handler function.
 150      =3   * @param vector The interrupt vector number.
 151      =3   *
 152      =3   * This macro defines a function to be an interrupt handler.  The _vector_
 153      =3   * parameter is the 8051 interrupt vector number, not the address.  This
 154      =3   * will cause the compiler to treat the function as the interrupt handler
 155      =3   * and generate the appropriate prolog/epilog code.
 156      =3   *
 157      =3   * @note This macro is used to define the function implementation.  To declare
 158      =3   * the interrupt function prototype, use @ref SI_INTERRUPT_PROTO.
 159      =3   *****************************************************************************/
 160      =3  #define SI_INTERRUPT(name, vector) void name (void) interrupt vector
 161      =3  
 162      =3  /**************************************************************************//**
 163      =3   * Define an interrupt handler function using a specific register bank.
 164      =3   *
 165      =3   * @param name The name of the interrupt handler function.
 166      =3   * @param vector The interrupt vector number.
 167      =3   * @param regnum The register bank number (0-3).
 168      =3   *
 169      =3   * This macro defines a function to be an interrupt handler, using a specific
 170      =3   * register bank for the interrupt code.  The _vector_ parameter is the 8051
 171      =3   * interrupt vector number, not the address.  The _regnum_ parameter is the
 172      =3   * register bank number (0-3) that will be used as general purpose registers
 173      =3   * for the instructions in the compiled code.  Using dedicated register banks
 174      =3   * for interrupt handlers allows the prolog code to just switch banks instead
 175      =3   * of saving and restoring all the general purpose registers.  This can make
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 10  

 176      =3   * interrupt entry/exit faster but requires dedicating a register bank for
 177      =3   * the interrupt handler.
 178      =3   *
 179      =3   * @note This macro is used to define the function implementation.  To declare
 180      =3   * the interrupt function prototype, use @ref SI_INTERRUPT_PROTO_USING.
 181      =3   *****************************************************************************/
 182      =3  #define SI_INTERRUPT_USING(name, vector, regnum)                             \
 183      =3               void name (void) interrupt vector using regnum
 184      =3  
 185      =3  /**************************************************************************//**
 186      =3   * Declare an interrupt handler prototype for an interrupt vector.
 187      =3   *
 188      =3   * @param name The name of the interrupt handler function.
 189      =3   * @param vector The interrupt vector number.
 190      =3   *
 191      =3   * This macro declares a function prototype for an interrupt handler.  The
 192      =3   * _vector_ parameter is the 8051 interrupt vector number, not the address.
 193      =3   * Declaring the function prototype this way will cause the compiler to
 194      =3   * recognize that the function is an interrupt handler and not a normal C
 195      =3   * function.
 196      =3   *
 197      =3   * @note This macro is used to declare a prototype for the interrupt function.
 198      =3   * To define the interrupt function implementation, use @ref SI_INTERRUPT.
 199      =3   *****************************************************************************/
 200      =3  #define SI_INTERRUPT_PROTO(name, vector) void name (void)
 201      =3  
 202      =3  /**************************************************************************//**
 203      =3   * Declare an interrupt handler prototype using a specific register bank.
 204      =3   *
 205      =3   * @param name The name of the interrupt handler function.
 206      =3   * @param vector The interrupt vector number.
 207      =3   * @param regnum The register bank number (0-3).
 208      =3   *
 209      =3   * This macro declares a function prototype for an interrupt handler, for a
 210      =3   * function that uses a specific register bank for the interrupt code.  The
 211      =3   * _vector_ parameter is the 8051 interrupt vector number, not the address.
 212      =3   * The _regnum_ parameter is the register bank number (0-3) that will be used
 213      =3   * as general purpose registers in the function.  Declaring the function
 214      =3   * prototype this way will cause the compiler to recognize that the function
 215      =3   * is an interrupt handler and is not a normal C function.
 216      =3   *
 217      =3   * @note This macro is used to declare a prototype for the interrupt function.
 218      =3   * To define the interrupt function implementation,
 219      =3   * use @ref SI_INTERRUPT_USING.
 220      =3   *****************************************************************************/
 221      =3  #define SI_INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
 222      =3  
 223      =3  /**************************************************************************//**
 224      =3   * Define a function to be reentrant (store local variables on the stack).
 225      =3   *
 226      =3   * @param name The name of the function.
 227      =3   * @param return_type The data type of the function return value
 228      =3   * (void, int, etc).
 229      =3   * @param parameter One C function parameter (or "void") (type and name).
 230      =3   *
 231      =3   * This macro defines a function to be reentrant.
 232      =3   *
 233      =3   * You must specify the _return_type_ which is the type of the function.  It
 234      =3   * can be `void` or any other C type or typedef.  The _parameters_ argument
 235      =3   * is the list of function parameters.  It can be `void` or else it must be
 236      =3   * a parameter data type and name.  It can also be multiple parameters but
 237      =3   * they must be enclosed in parentheses and separated by commas.
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 11  

 238      =3   *
 239      =3   * __Example__
 240      =3   *
 241      =3   * ~~~~~~~~.c
 242      =3   * // The following is used to implement a function with the following
 243      =3   * // signature...
 244      =3   * uint16_t myFunction(uint8_t parm1, uint8_t parm2);
 245      =3   *
 246      =3   * SI_REENTRANT_FUNCTION(myFunction, uint16_t, (uint8_t parm1, uint8_t parm2))
 247      =3   * {
 248      =3   *   // Function implementation body
 249      =3   * }
 250      =3   * ~~~~~~~~
 251      =3   *
 252      =3   * @note This macro is used to define the function implementation.  To declare
 253      =3   * the function prototype, use @ref SI_REENTRANT_FUNCTION_PROTO.
 254      =3   *****************************************************************************/
 255      =3  #define SI_REENTRANT_FUNCTION(name, return_type, parameter) \
 256      =3    return_type name parameter reentrant
 257      =3  
 258      =3  /**************************************************************************//**
 259      =3   * Declare a function to be reentrant (store local variables on the stack).
 260      =3   *
 261      =3   * @param name The name of the function.
 262      =3   * @param return_type The data type of the function return value
 263      =3   * (void, int, etc).
 264      =3   * @param parameter One C function parameter (or "void") (type and name).
 265      =3   *
 266      =3   * This macro declares a function prototype for a C function that is reentrant.
 267      =3   * See the documentation for @ref SI_REENTRANT_FUNCTION for an explanation of
 268      =3   * the macro arguments.  This is an advanced feature.
 269      =3   *
 270      =3   * @note This macro is used to declare a prototype for the function.  To
 271      =3   * define the function implementation, use @ref SI_REENTRANT_FUNCTION.
 272      =3   *****************************************************************************/
 273      =3  #define SI_REENTRANT_FUNCTION_PROTO(name, return_type, parameter) \
 274      =3    return_type name parameter reentrant
 275      =3                 
 276      =3  /**************************************************************************//**
 277      =3   * Define a function to use a specific register bank.
 278      =3   *
 279      =3   * @param name The name of the function.
 280      =3   * @param return_value The data type of the function return value
 281      =3   * (void, int, etc).
 282      =3   * @param parameter One C function parameter (or "void") (type and name).
 283      =3   * @param regnum The register bank number (0-3).
 284      =3   *
 285      =3   * This macro defines a function that uses a specific register bank.  The
 286      =3   * _regnum_ parameter is the register bank number (0-3) that will be used as
 287      =3   * general purpose registers for the instructions in the compiled function
 288      =3   * code.  Using dedicated register banks for a function can reduce the amount
 289      =3   * of registers saving and restoring needed on entry and exit to the
 290      =3   * function.  However, this is an advanced feature and you should not use it
 291      =3   * unless you fully understand how and when to use register banking.
 292      =3   *
 293      =3   * You must specify the _return_value_ which is the type of the function.  It
 294      =3   * can be `void` or any other C type or typedef.  The _parameters_ argument
 295      =3   * is the list of function parameters.  It can be `void` or else it must be
 296      =3   * a parameter data type and name.  It can also be multiple parameters but
 297      =3   * they must be enclosed in parentheses and separated by commas.
 298      =3   *
 299      =3   * __Example__
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 12  

 300      =3   *
 301      =3   * ~~~~~~~~.c
 302      =3   * // The following is used to implement a function with the following
 303      =3   * // signature, and that uses register bank 3 ...
 304      =3   * uint16_t myFunction(uint8_t parm1, uint8_t parm2);
 305      =3   *
 306      =3   * SI_FUNCTION_USING(myFunction, uint16_t, (uint8_t parm1, uint8_t parm2), 3)
 307      =3   * {
 308      =3   *   // Function implementation body
 309      =3   * }
 310      =3   * ~~~~~~~~
 311      =3   *
 312      =3   * @note This macro is used to define the function implementation.  To declare
 313      =3   * the function prototype, use @ref SI_FUNCTION_PROTO_USING.
 314      =3   *****************************************************************************/
 315      =3  #define SI_FUNCTION_USING(name, return_value, parameter, regnum)              \
 316      =3               return_value name parameter using regnum
 317      =3  
 318      =3  /**************************************************************************//**
 319      =3   * Declare a function that uses a specific register bank.
 320      =3   *
 321      =3   * @param name The name of the function.
 322      =3   * @param return_value The data type of the function return value
 323      =3   * (void, int, etc).
 324      =3   * @param parameter One C function parameter (or "void") (type and name).
 325      =3   * @param regnum The register bank number (0-3).
 326      =3   *
 327      =3   * This macro declares a function prototype for a C function that uses a
 328      =3   * specific register its working registers.  See the documentation for
 329      =3   * @ref SI_FUNCTION_USING for an explanation of the macro arguments.  This is
 330      =3   * an advanced feature.
 331      =3   *
 332      =3   * @note This macro is used to declare a prototype for the function.  To
 333      =3   * define the function implementation, use @ref SI_FUNCTION_USING.
 334      =3   *****************************************************************************/
 335      =3  #define SI_FUNCTION_PROTO_USING(name, return_value, parameter, regnum)        \
 336      =3               return_value name parameter
 337      =3  
 338      =3  /**************************************************************************//**
 339      =3   * Declare a variable to be located in a specific memory segment.
 340      =3   *
 341      =3   * @param name The variable name.
 342      =3   * @param vartype The variable data type.* @param memseg The memory segment to use for the variable.
 343      =3   *
 344      =3   * This macro declares a variable to be located in a specific memory area
 345      =3   * (or segment) of the 8051 memory space.  It is only necessary to use this
 346      =3   * macro if you want to force the variable into a specific memory space instead
 347      =3   * of the default memory space used by the compiler.  The segment can be
 348      =3   * one of the following:
 349      =3   *
 350      =3   * - @ref SI_SEG_DATA
 351      =3   * - @ref SI_SEG_IDATA
 352      =3   * - @ref SI_SEG_BDATA
 353      =3   * - @ref SI_SEG_PDATA
 354      =3   * - @ref SI_SEG_XDATA
 355      =3   * - @ref SI_SEG_CODE
 356      =3   *
 357      =3   * __Example__
 358      =3   *
 359      =3   * ~~~~~~~~.c
 360      =3   * // The following macro can be used to create a variable located in
 361      =3   * // XDATA with the following signature:
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 13  

 362      =3   * uint8_t myVar;
 363      =3   *
 364      =3   * SI_SEGMENT_VARIABLE(myVar, uint8_t, SEG_XDATA);
 365      =3   * ~~~~~~~~
 366      =3   *****************************************************************************/
 367      =3  #define SI_SEGMENT_VARIABLE(name, vartype, memseg) vartype memseg name
 368      =3  
 369      =3  /**************************************************************************//**
 370      =3   * Declare a memory segment specific pointer variable.
 371      =3   *
 372      =3   * @param name The pointer variable name.
 373      =3   * @param vartype The pointer data type.
 374      =3   * @param targseg The target memory segment for the pointer.
 375      =3   *
 376      =3   * This macro declares a pointer that points at a specific memory area
 377      =3   * (or segment).  The memory segment of the pointer variable itself is not
 378      =3   * specified and the default is used.  The segment can be one of the following:
 379      =3   *
 380      =3   * - @ref SI_SEG_DATA
 381      =3   * - @ref SI_SEG_IDATA
 382      =3   * - @ref SI_SEG_BDATA
 383      =3   * - @ref SI_SEG_PDATA
 384      =3   * - @ref SI_SEG_XDATA
 385      =3   * - @ref SI_SEG_CODE
 386      =3   *
 387      =3   * __Example__
 388      =3   *
 389      =3   * ~~~~~~~~.c
 390      =3   * // The following macro can be used to create a pointer that points to
 391      =3   * // a location in XDATA with the following signature:
 392      =3   * uint8_t *pVar; // where pVar is pointing at XDATA
 393      =3   *
 394      =3   * SI_VARIABLE_SEGMENT_POINTER(pVar, uint8_t, SEG_XDATA);
 395      =3   * ~~~~~~~~
 396      =3   *****************************************************************************/
 397      =3  #define SI_VARIABLE_SEGMENT_POINTER(name, vartype, targseg)                  \
 398      =3               vartype targseg * name
 399      =3  
 400      =3  /**************************************************************************//**
 401      =3   * Declare a memory segment specific pointer variable, in a specific segment.
 402      =3   *
 403      =3   * @param name The pointer variable name.
 404      =3   * @param vartype The pointer data type.
 405      =3   * @param targseg The target memory segment for the pointer.
 406      =3   * @param memseg The memory segment to use for the pointer variable.
 407      =3   *
 408      =3   * This macro declares a pointer that points at a specific memory area
 409      =3   * (or segment).  The pointer variable itself is also located in a specified
 410      =3   * memory segment by _memseg_.  The arguments _targseg_ and _memseg_ can be
 411      =3   * one of the following:
 412      =3   *
 413      =3   * - @ref SI_SEG_DATA
 414      =3   * - @ref SI_SEG_IDATA
 415      =3   * - @ref SI_SEG_BDATA
 416      =3   * - @ref SI_SEG_PDATA
 417      =3   * - @ref SI_SEG_XDATA
 418      =3   * - @ref SI_SEG_CODE
 419      =3   *
 420      =3   * __Example__
 421      =3   *
 422      =3   * ~~~~~~~~.c
 423      =3   * // The following macro can be used to create a pointer that points to
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 14  

 424      =3   * // a location in XDATA while the pointer itself is located in DATA, with
 425      =3   * // the following signature:
 426      =3   * uint8_t *pVar; // where pVar is located in DATA and is pointing at XDATA
 427      =3   *
 428      =3   * SI_SEGMENT_VARIABLE_SEGMENT_POINTER(pVar, uint8_t, SEG_XDATA, SEG_DATA);
 429      =3   * ~~~~~~~~
 430      =3   *****************************************************************************/
 431      =3  #define SI_SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targseg, memseg)  \
 432      =3               vartype targseg * memseg name
 433      =3  
 434      =3  /**************************************************************************//**
 435      =3   * Declare a generic pointer variable that is located in a specific segment.
 436      =3   *
 437      =3   * @param name The pointer variable name.
 438      =3   * @param vartype The pointer data type.
 439      =3   * @param memseg The memory segment to use for the pointer variable.
 440      =3   *
 441      =3   * This macro declares a pointer that is a generic pointer.  This means it can
 442      =3   * point at any kind of memory location.  However the pointer variable itself
 443      =3   * is located in a specific memory segment by _memseg_, which can be one of
 444      =3   * the following:
 445      =3   *
 446      =3   * - @ref SI_SEG_DATA
 447      =3   * - @ref SI_SEG_IDATA
 448      =3   * - @ref SI_SEG_BDATA
 449      =3   * - @ref SI_SEG_PDATA
 450      =3   * - @ref SI_SEG_XDATA
 451      =3   * - @ref SI_SEG_CODE
 452      =3   *
 453      =3   * __Example__
 454      =3   *
 455      =3   * ~~~~~~~~.c
 456      =3   * // The following macro can be used to create a generic pointer that
 457      =3   * // is located in DATA and points at any memory type, with the
 458      =3   * // following signature:
 459      =3   * uint8_t *pVar; // where pVar is located in DATA and is a generic pointer
 460      =3   *
 461      =3   * SI_SEGMENT_POINTER(pVar, uint8_t, SEG_DATA);
 462      =3   * ~~~~~~~~
 463      =3   *****************************************************************************/
 464      =3  #define SI_SEGMENT_POINTER(name, vartype, memseg) vartype * memseg name
 465      =3  
 466      =3  /**************************************************************************//**
 467      =3   * Declare an uninitialized variable that is located at a specific address.
 468      =3   *
 469      =3   * @param name The variable name.
 470      =3   * @param vartype The variable data type.
 471      =3   * @param memseg The memory segment to use for the variable.
 472      =3   * @param address The memory address of the variable.
 473      =3   *
 474      =3   * This macro allows declaring a variable that can be placed at a specific
 475      =3   * location in memory.  This can only be used for variables that do not need
 476      =3   * initializers.  The _address_ is the memory address within the specified
 477      =3   * segment.  The memory segment, _memseg_, can be one of the following:
 478      =3   *
 479      =3   * - @ref SI_SEG_DATA
 480      =3   * - @ref SI_SEG_IDATA
 481      =3   * - @ref SI_SEG_BDATA
 482      =3   * - @ref SI_SEG_PDATA
 483      =3   * - @ref SI_SEG_XDATA
 484      =3   * - @ref SI_SEG_CODE
 485      =3   *
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 15  

 486      =3   * __Example__
 487      =3   *
 488      =3   * ~~~~~~~~.c
 489      =3   * // The following declares a variable located at 0x4000 in XDATA with
 490      =3   * // the following signature:
 491      =3   * uint8_t myMemVar;
 492      =3   *
 493      =3   * SI_LOCATED_VARIABLE_NO_INIT(myMemVar, uint8_t, SEG_DATA, 0x4000);
 494      =3   * ~~~~~~~~
 495      =3   *****************************************************************************/
 496      =3  #define SI_LOCATED_VARIABLE_NO_INIT(name, vartype, memseg, address)          \
 497      =3               vartype memseg name _at_ address
 498      =3  
 499      =3  
 500      =3  #else  // __SLS_IDE__ : Macros defined to remove syntax errors within Simplicity Studio
           =3 #define SI_INTERRUPT(name, vector) void name (void)
           =3 #define SI_INTERRUPT_USING(name, vector, regnum) void name (void)
           =3 #define SI_INTERRUPT_PROTO(name, vector) void name (void)
           =3 #define SI_INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
           =3 
           =3 #define SI_REENTRANT_FUNCTION(name, return_value, parameter, regnum) return_value name (parameter)
           =3 #define SI_REENTRANT_FUNCTION_PROTO(name, return_value, parameter, regnum) return_value name (parameter)
           =3 
           =3 #define SI_FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =3 #define SI_FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =3 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =3 
           =3 #define SI_SEGMENT_VARIABLE(name, vartype, locsegment) vartype name
           =3 #define SI_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype * name
           =3 #define SI_SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype * name
           =3 #define SI_SEGMENT_POINTER(name, vartype, locsegment) vartype * name
           =3 #define SI_LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) vartype name
           =3 #endif // __SLS_IDE__
 519      =3  
 520      =3  // The following are used for byte ordering when referring to individual
 521      =3  // bytes within a SI_UU32_t.  B0 is the least significant byte.
 522      =3  #define B0 3 ///< Least significant byte of a 4 byte word
 523      =3  #define B1 2 ///< Byte 1 of a 4-byte word, where byte 0 is LSB
 524      =3  #define B2 1 ///< Byte 2 of a 4-byte word, where byte 0 is LSB
 525      =3  #define B3 0 ///< Most significant byte of a 4-byte word
 526      =3  
 527      =3  #define LSB 1 ///< Index to least significant bit of a 2 byte word
 528      =3  #define MSB 0 ///< Index to most significant bit of a 2 byte word
 529      =3  
 530      =3  /// A union type to make it easier to access individual bytes of a 16-bit
 531      =3  /// word, and to use as signed or unsigned type.
 532      =3  typedef union SI_UU16
 533      =3  {
 534      =3    uint16_t u16;   ///< The two byte value as a 16-bit unsigned integer.
 535      =3    int16_t s16;    ///< The two byte value as a 16-bit signed integer.
 536      =3    uint8_t u8[2];  ///< The two byte value as two unsigned 8-bit integers.
 537      =3    int8_t s8[2];   ///< The two byte value as two signed 8-bit integers.
 538      =3  } SI_UU16_t;
 539      =3  
 540      =3  /// A union type to make it easier to access individual bytes within a
 541      =3  /// 32-bit word, or to access it as variations of 16-bit words, or to
 542      =3  /// use as signed or unsigned type.
 543      =3  typedef union SI_UU32
 544      =3  {
 545      =3    uint32_t u32;       ///< The 4-byte value as a 32-bit unsigned integer.
 546      =3    int32_t s32;        ///< The 4-byte value as a 32-bit signed integer.
 547      =3    SI_UU16_t uu16[2];  ///< The 4-byte value as a SI_UU16_t.
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 16  

 548      =3    uint16_t u16[2];    ///< The 4-byte value as two unsigned 16-bit integers.
 549      =3    int16_t s16[2];     ///< The 4-byte value as two signed 16-bit integers.
 550      =3    uint8_t u8[4];      ///< The 4-byte value as 4 unsigned 8-bit integers.
 551      =3    int8_t s8[4];       ///< The 4-byte value as 4 signed 8-bit integers.
 552      =3  } SI_UU32_t;
 553      =3  
 554      =3  // Generic pointer memory segment constants.
 555      =3  #define SI_GPTR                   ///< Generic pointer indeterminate type.
 556      =3  #define SI_GPTR_MTYPE_DATA  0x00  ///< Generic pointer for DATA segment.
 557      =3  #define SI_GPTR_MTYPE_IDATA 0x00  ///< Generic pointer for IDATA segment.
 558      =3  #define SI_GPTR_MTYPE_BDATA 0x00  ///< Generic pointer for BDATA segment.
 559      =3  #define SI_GPTR_MTYPE_PDATA 0xFE  ///< Generic pointer for PDATA segment.
 560      =3  #define SI_GPTR_MTYPE_XDATA 0x01  ///< Generic pointer for XDATA segment.
 561      =3  #define SI_GPTR_MTYPE_CODE  0xFF  ///< Generic pointer for CODE segment.
 562      =3  
 563      =3  /// Generic pointer structure containing the type and address.
 564      =3  typedef struct
 565      =3  {
 566      =3    uint8_t memtype;    ///< The type of memory of the generic pointer.
 567      =3    SI_UU16_t address;  ///< The address of the generic pointer.
 568      =3  } GPTR_t;
 569      =3  
 570      =3  /// A union type to allow access to the fields of a generic pointer.
 571      =3  /// A generic pointer has a field indicating the type of memory and an
 572      =3  /// address within the memory.
 573      =3  typedef union SI_GEN_PTR
 574      =3  {
 575      =3    uint8_t u8[3];    ///< 3-byte generic pointer as 3 unsigned 8-bit integers.
 576      =3    GPTR_t gptr;      ///< 3-byte generic pointer as pointer structure
 577      =3  } SI_GEN_PTR_t;
 578      =3  
 579      =3  // Declaration of Keil intrinisc
 580      =3  extern void _nop_(void);
 581      =3  /// Macro to insert a no-operation (NOP) instruction.
 582      =3  #define NOP() _nop_()
 583      =3  
 584      =3  // -------------------------------
 585      =3  // GCC for ARM Cortex-M
 586      =3  // Provides support for code that can be compiled for 8 or 32-bit
 587      =3  //
 588      =3  #elif defined (__GNUC__)
           =3 #if defined(__ARMEL__) && ((__ARMEL__ == 1) && ((__ARM_ARCH == 6) || (__ARM_ARCH == 7)))
           =3 
           =3 // these ignore any memory segment directives
           =3 #define SI_SEG_GENERIC
           =3 #define SI_SEG_DATA
           =3 #define SI_SEG_IDATA
           =3 #define SI_SEG_XDATA
           =3 #define SI_SEG_PDATA
           =3 #define SI_SEG_BDATA
           =3 #define SI_SEG_CODE
           =3 
           =3 // the following create a variable of the specified name but ignore the
           =3 // address and bit number.  If the using-code cares about the actual
           =3 // address or bit number, this probably will break it
           =3 #define SI_SBIT(name, address, bitnum) uint8_t name
           =3 #define SI_SFR(name, address) uint8_t name
           =3 #define SI_SFR16(name, address) uint16_t name
           =3 
           =3 // the following create function and variable names of the specified types
           =3 // but the 8051-specific aspects (like memory segment) are ignored
           =3 #define SI_INTERRUPT(name, vector) void name (void)
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 17  

           =3 #define SI_INTERRUPT_USING(name, vector, regnum) void name (void)
           =3 #define SI_INTERRUPT_PROTO(name, vector) void name (void)
           =3 #define SI_INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
           =3 #define SI_FUNCTION_USING(name, return_value, parameter, regnum)              \
           =3              return_value name (parameter)
           =3 #define SI_FUNCTION_PROTO_USING(name, return_value, parameter, regnum)        \
           =3              return_value name (parameter)
           =3 #define SI_SEGMENT_VARIABLE(name, vartype, memseg) vartype name
           =3 #define SI_VARIABLE_SEGMENT_POINTER(name, vartype, targseg)                  \
           =3              vartype * name
           =3 #define SI_SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targseg, memseg)  \
           =3              vartype * name
           =3 #define SI_SEGMENT_POINTER(name, vartype, memseg) vartype * name
           =3 #define SI_LOCATED_VARIABLE_NO_INIT(name, vartype, memseg, address)          \
           =3              vartype name
           =3 
           =3 #define B0 0
           =3 #define B1 1
           =3 #define B2 2
           =3 #define B3 3
           =3 #define LSB 0
           =3 #define MSB 1
           =3 typedef union SI_UU16
           =3 {
           =3   uint16_t u16;
           =3   int16_t s16;
           =3   uint8_t u8[2];
           =3   int8_t s8[2];
           =3 } SI_UU16_t;
           =3 
           =3 typedef union SI_UU32
           =3 {
           =3   uint32_t u32;
           =3   int32_t s32;
           =3   SI_UU16_t uu16[2];
           =3   uint16_t u16[2];
           =3   int16_t s16[2];
           =3   uint8_t u8[4];
           =3   int8_t s8[4];
           =3 } SI_UU32_t;
           =3 
           =3 // Generic pointer stuff is left out because if you are accessing
           =3 // generic pointer fields then it will need to be rewritten for 32-bit
           =3 
           =3 // __NOP should be declared in cmsis header core_cmInstr.h
           =3 extern void __NOP(void);
           =3 /// Macro to insert a no-operation (NOP) instruction.
           =3 #define NOP() __NOP()
           =3 
           =3 #else // ARM_ARCH 6 | 7
           =3 #error unsupported ARM arch
           =3 #endif
           =3 
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 // IAR 8051
           =3 // http://www.iar.com
           =3 #elif defined __ICC8051__
           =3 
           =3 #include <intrinsics.h>
           =3 
           =3 #define SI_BIT(name)              __no_init bool __bit name
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 18  

           =3 #define SI_SBIT(name, addr, bit)  __bit __no_init volatile bool name @ (addr+bit)
           =3 #define SI_SFR(name, addr)        __sfr __no_init volatile unsigned char name @ addr
           =3 #define SI_SFR16(name, addr)      __sfr __no_init volatile unsigned int  name @ addr
           =3 
           =3 #define SI_SEG_GENERIC __generic
           =3 #define SI_SEG_FAR  __xdata
           =3 #define SI_SEG_DATA __data
           =3 #define SI_SEG_NEAR __data
           =3 #define SI_SEG_IDATA __idata
           =3 #define SI_SEG_XDATA __xdata
           =3 #define SI_SEG_PDATA __pdata
           =3 #define SI_SEG_CODE  __code
           =3 #define SI_SEG_BDATA __bdata
           =3 
           =3 #define _PPTOSTR_(x) #x
           =3 #define _PPARAM_(address) _PPTOSTR_(vector=address * 8 + 3)
           =3 #define _PPARAM2_(regbank) _PPTOSTR_(register_bank=regbank)
           =3 #define SI_INTERRUPT(name, vector) _Pragma(_PPARAM_(vector)) __interrupt void name(void)
           =3 #define SI_INTERRUPT_PROTO(name, vector)  __interrupt void name(void)
           =3 #define SI_INTERRUPT_USING(name, vector, regnum) _Pragma(_PPARAM2_(regnum)) _Pragma(_PPARAM_(vector)) __in
             -terrupt void name(void)
           =3 #define SI_INTERRUPT_PROTO_USING(name, vector, regnum) __interrupt void name(void)
           =3 
           =3 #if (__DATA_MODEL__ == 0) /* TINY */ || \
           =3     (__DATA_MODEL__ == 1) /* SMALL */
           =3 #define SI_REENTRANT_FUNCTION(name, return_type, parameter) \
           =3   __idata_reentrant return_type name parameter
           =3 #define SI_REENTRANT_FUNCTION_PROTO(name, return_type, parameter) \
           =3   __idata_reentrant return_type name parameter
           =3 #elif (__DATA_MODEL__ == 2) /* LARGE */ || \
           =3       (__DATA_MODEL__ == 3) /* GENERIC */ || \
           =3       (__DATA_MODEL__ == 4) /* FAR */
           =3 #define SI_REENTRANT_FUNCTION(name, return_type, parameter) \
           =3   __xdata_reentrant return_type name parameter
           =3 #define SI_REENTRANT_FUNCTION_PROTO(name, return_type, parameter) \
           =3   __xdata_reentrant return_type name (parameter)
           =3 #else
           =3 #error "Illegal memory model setting."
           =3 #endif
           =3 
           =3 // Note: IAR does not support functions using different register banks. Register
           =3 //       banks can only be specified in interrupts. If a function is called from
           =3 //       inside an interrupt, it will use the same register bank as the interrupt.
           =3 #define SI_FUNCTION_USING(name, return_value, parameter, regnum)              \
           =3              return_value name parameter
           =3 #define SI_FUNCTION_PROTO_USING(name, return_value, parameter, regnum)        \
           =3              return_value name parameter
           =3 
           =3 #define SI_SEGMENT_VARIABLE(name, vartype, locsegment)  vartype locsegment name
           =3 #define SI_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment  * name
           =3 #define SI_SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * 
             -locsegment name
           =3                
           =3 #define SI_SEGMENT_POINTER(name, vartype, ptrseg) vartype __generic * ptrseg name
           =3 
           =3 #define SI_LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment __no_init vartype name @ add
             -r
           =3 
           =3 #define SI_LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) locsegment __no_init vartype name @ a
             -ddr
           =3 
           =3 // The following are used for byte ordering when referring to individual
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 19  

           =3 // bytes within a SI_UU32_t.  B0 is the least significant byte.
           =3 #define B0 0 ///< Least significant byte of a 4 byte word
           =3 #define B1 1 ///< Byte 1 of a 4-byte word, where byte 0 is LSB
           =3 #define B2 2 ///< Byte 2 of a 4-byte word, where byte 0 is LSB
           =3 #define B3 3 ///< Most significant byte of a 4-byte word
           =3 
           =3 #define LSB 0 ///< Index to least significant bit of a 2 byte word
           =3 #define MSB 1 ///< Index to most significant bit of a 2 byte word
           =3 
           =3 /// A union type to make it easier to access individual bytes of a 16-bit
           =3 /// word, and to use as signed or unsigned type.
           =3 typedef union SI_UU16
           =3 {
           =3   uint16_t u16;   ///< The two byte value as a 16-bit unsigned integer.
           =3   int16_t s16;    ///< The two byte value as a 16-bit signed integer.
           =3   uint8_t u8[2];  ///< The two byte value as two unsigned 8-bit integers.
           =3   int8_t s8[2];   ///< The two byte value as two signed 8-bit integers.
           =3 } SI_UU16_t;
           =3 
           =3 /// A union type to make it easier to access individual bytes within a
           =3 /// 32-bit word, or to access it as variations of 16-bit words, or to
           =3 /// use as signed or unsigned type.
           =3 typedef union SI_UU32
           =3 {
           =3   uint32_t u32;       ///< The 4-byte value as a 32-bit unsigned integer.
           =3   int32_t s32;        ///< The 4-byte value as a 32-bit signed integer.
           =3   SI_UU16_t uu16[2];  ///< The 4-byte value as a SI_UU16_t.
           =3   uint16_t u16[2];    ///< The 4-byte value as two unsigned 16-bit integers.
           =3   int16_t s16[2];     ///< The 4-byte value as two signed 16-bit integers.
           =3   uint8_t u8[4];      ///< The 4-byte value as 4 unsigned 8-bit integers.
           =3   int8_t s8[4];       ///< The 4-byte value as 4 signed 8-bit integers.
           =3 } SI_UU32_t;
           =3 
           =3 // Generic pointer memory segment constants.
           =3 #define SI_GPTR                   ///< Generic pointer indeterminate type.
           =3 #define SI_GPTR_MTYPE_DATA  0x01  ///< Generic pointer for DATA segment.
           =3 #define SI_GPTR_MTYPE_IDATA 0x01  ///< Generic pointer for IDATA segment.
           =3 #define SI_GPTR_MTYPE_BDATA 0x01  ///< Generic pointer for BDATA segment.
           =3 #define SI_GPTR_MTYPE_PDATA 0x00  ///< Generic pointer for PDATA segment.
           =3 #define SI_GPTR_MTYPE_XDATA 0x00  ///< Generic pointer for XDATA segment.
           =3 #define SI_GPTR_MTYPE_CODE  0x80  ///< Generic pointer for CODE segment.
           =3 
           =3 /// Generic pointer structure containing the type and address.
           =3 typedef struct
           =3 {
           =3   SI_UU16_t address;  ///< The address of the generic pointer.
           =3   uint8_t memtype;    ///< The type of memory of the generic pointer.  
           =3 } GPTR_t;
           =3 
           =3 /// A union type to allow access to the fields of a generic pointer.
           =3 /// A generic pointer has a field indicating the type of memory and an
           =3 /// address within the memory.
           =3 typedef union SI_GEN_PTR
           =3 {
           =3   uint8_t u8[3];    ///< 3-byte generic pointer as 3 unsigned 8-bit integers.
           =3   GPTR_t gptr;      ///< 3-byte generic pointer as pointer structure
           =3 } SI_GEN_PTR_t;
           =3 
           =3 /// Macro to insert a no-operation (NOP) instruction.
           =3 #define NOP() __no_operation()
           =3 
           =3 #else // unknown toolchain
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 20  

           =3 #error Unrecognized toolchain in si_toolchain.h
           =3 #endif
 794      =3  
 795      =3  /** @} */
 796      =3  
 797      =3  #endif
 120      =2  #include "compiler_defs.h"
   1      =3  //-----------------------------------------------------------------------------
   2      =3  // compiler_defs.h
   3      =3  //-----------------------------------------------------------------------------
   4      =3  // Portions of this file are copyright Maarten Brock
   5      =3  // http://sdcc.sourceforge.net
   6      =3  // Portions of this file are Copyright 2014 Silicon Laboratories, Inc.
   7      =3  // http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   8      =3  //
   9      =3  // GNU LGPL boilerplate:
  10      =3  /** This library is free software; you can redistribute it and/or
  11      =3    * modify it under the terms of the GNU Lesser General Public
  12      =3    * License as published by the Free Software Foundation; either
  13      =3    * version 2.1 of the License, or (at your option) any later version.
  14      =3    *
  15      =3    * This library is distributed in the hope that it will be useful,
  16      =3    * but WITHOUT ANY WARRANTY; without even the implied warranty of
  17      =3    * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
  18      =3    * Lesser General Public License for more details.
  19      =3    *
  20      =3    * You should have received a copy of the GNU Lesser General Public
  21      =3    * License along with this library; if not, write to the Free Software
  22      =3    * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  23      =3    *
  24      =3    * In other words, you are welcome to use, share and improve this program.
  25      =3    * You are forbidden to forbid anyone else to use, share and improve
  26      =3    * what you give them. Help stamp out software-hoarding!
  27      =3  **/
  28      =3  // Program Description:
  29      =3  //
  30      =3  // **Important Note**: This header file should be included before including
  31      =3  // a device-specific header file such as C8051F300_defs.h.
  32      =3  //
  33      =3  // Macro definitions to accomodate 8051 compiler differences in specifying
  34      =3  // special function registers and other 8051-specific features such as NOP
  35      =3  // generation, and locating variables in memory-specific segments.  The
  36      =3  // compilers are identified by their unique predefined macros. See also:
  37      =3  // http://predef.sourceforge.net/precomp.html
  38      =3  //
  39      =3  // SBIT and SFR define special bit and special function registers at the given
  40      =3  // address. SFR16 and SFR32 define sfr combinations at adjacent addresses in
  41      =3  // little-endian format. SFR16E and SFR32E define sfr combinations without
  42      =3  // prerequisite byte order or adjacency. None of these multi-byte sfr
  43      =3  // combinations will guarantee the order in which they are accessed when read
  44      =3  // or written.
  45      =3  //
  46      =3  // SFR16X and SFR32X for 16 bit and 32 bit xdata registers are not defined
  47      =3  // to avoid portability issues because of compiler endianness.
  48      =3  //
  49      =3  // Example:
  50      =3  // // my_mcu.c: main 'c' file for my mcu
  51      =3  // #include <compiler_defs.h>  // this file
  52      =3  // #include <C8051xxxx_defs.h> // SFR definitions for specific MCU target
  53      =3  //
  54      =3  // SBIT  (P0_1, 0x80, 1);      // Port 0 pin 1
  55      =3  // SFR   (P0, 0x80);           // Port 0
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 21  

  56      =3  // SFRX  (CPUCS, 0xE600);      // Cypress FX2 Control and Status register in
  57      =3  //                             // xdata memory at 0xE600
  58      =3  // SFR16 (TMR2, 0xCC);         // Timer 2, lsb at 0xCC, msb at 0xCD
  59      =3  // SFR16E(TMR0, 0x8C8A);       // Timer 0, lsb at 0x8A, msb at 0x8C
  60      =3  // SFR32 (MAC0ACC, 0x93);      // SiLabs C8051F120 32 bits MAC0 Accumulator,
  61      =3  //                             // lsb at 0x93, msb at 0x96
  62      =3  // SFR32E(SUMR, 0xE5E4E3E2);   // TI MSC1210 SUMR 32 bits Summation register,
  63      =3  //                             // lsb at 0xE2, msb at 0xE5
  64      =3  //
  65      =3  // Target:         C8051xxxx
  66      =3  // Tool chain:     Generic
  67      =3  // Command Line:   None
  68      =3  // 
  69      =3  // Release 2.7 - 25 JUN 2014 (JM)
  70      =3  //    -Added SI_GENERIC_PTR struct for accessing generic pointers
  71      =3  //    -Added SI_GPTR_MTYPE_XXXX definitions for determining the memory type
  72      =3  //     pointed at by a generic poitner
  73      =3  // Release 2.6 - 14 DEC 2012 (GO)
  74      =3  //        -Added define for deprecated SDCC keyword 'at'
  75      =3  // Release 2.5 - 12 SEP 2012 (TP)
  76      =3  //    -Added defines for deprecated SDCC keywords bit and code
  77      =3  // Release 2.4 - 27 AUG 2012 (TP)
  78      =3  //    -Added defines for deprecated SDCC keywords interrupt, _asm, and _endasm
  79      =3  // Release 2.3 - 27 MAY 2010 (DM)
  80      =3  //    -Removed 'LOCATED_VARIABLE' pragma from Keil because it is not supported
  81      =3  // Release 2.2 - 06 APR 2010 (ES)
  82      =3  //    -Removed 'PATHINCLUDE' pragma from Raisonance section
  83      =3  // Release 2.1 - 16 JUL 2009 (ES)
  84      =3  //    -Added SEGMENT_POINTER macro definitions for SDCC, Keil, and Raisonance
  85      =3  //    -Added LOCATED_VARIABLE_NO_INIT macro definitions for Raisonance
  86      =3  // Release 2.0 - 19 MAY 2009 (ES)
  87      =3  //    -Added LOCATED_VARIABLE_NO_INIT macro definitions for SDCC and Keil
  88      =3  // Release 1.9 - 23 OCT 2008 (ES)
  89      =3  //    -Updated Hi-Tech INTERRUPT and INTERRUPT_USING macro definitions
  90      =3  //    -Added SFR16 macro defintion for Hi-Tech
  91      =3  // Release 1.8 - 31 JUL 2008 (ES)
  92      =3  //    -Added INTERRUPT_USING and FUNCTION_USING macro's
  93      =3  //    -Added macro's for IAR
  94      =3  //    -Corrected Union definitions for Hi-Tech and added SFR16 macro defintion
  95      =3  // Release 1.7 - 11 SEP 2007 (BW)
  96      =3  //    -Added support for Raisonance EVAL 03.03.42 and Tasking Eval 7.2r1
  97      =3  // Release 1.6 - 27 AUG 2007 (BW)
  98      =3  //    -Updated copyright notice per agreement with Maartin Brock
  99      =3  //    -Added SDCC 2.7.0 "compiler.h" bug fixes
 100      =3  //    -Added memory segment defines (SEG_XDATA, for example)
 101      =3  // Release 1.5 - 24 AUG 2007 (BW)
 102      =3  //    -Added support for NOP () macro
 103      =3  //    -Added support for Hi-Tech ver 9.01
 104      =3  // Release 1.4 - 07 AUG 2007 (PKC)
 105      =3  //    -Removed FID and fixed formatting.
 106      =3  // Release 1.3 - 30 SEP 2007 (TP)
 107      =3  //    -Added INTERRUPT_PROTO_USING to properly support ISR context switching
 108      =3  //     under SDCC.
 109      =3  // Release 1.2 - (BW)
 110      =3  //    -Added support for U8,U16,U32,S8,S16,S32,UU16,UU32 data types
 111      =3  // Release 1.1 - (BW)
 112      =3  //    -Added support for INTERRUPT, INTERRUPT_USING, INTERRUPT_PROTO,
 113      =3  //     SEGMENT_VARIABLE, VARIABLE_SEGMENT_POINTER,
 114      =3  //     SEGMENT_VARIABLE_SEGMENT_POINTER, and LOCATED_VARIABLE
 115      =3  // Release 1.0 - 29 SEP 2006 (PKC)
 116      =3  //    -Initial revision
 117      =3  
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 22  

 118      =3  //-----------------------------------------------------------------------------
 119      =3  // Header File Preprocessor Directive
 120      =3  //-----------------------------------------------------------------------------
 121      =3  
 122      =3  #ifndef COMPILER_DEFS_H
 123      =3  #define COMPILER_DEFS_H
 124      =3  
 125      =3  #include "stdbool.h"
   1      =4  /**************************************************************************//**
   2      =4   * Copyright (c) 2015 by Silicon Laboratories Inc. All rights reserved.
   3      =4   *
   4      =4   * http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   5      =4   *****************************************************************************/
   6      =4  
   7      =4  #ifndef STDBOOL_H
           =4 #define STDBOOL_H
           =4 
           =4 #if defined __C51__
           =4 
           =4 typedef bit bool;
           =4 enum{
           =4   false = 0,
           =4   true = 1,
           =4 };
           =4 
           =4 #elif defined __ICC8051__
           =4 
           =4 #ifndef _SYSTEM_BUILD
           =4   #pragma system_include
           =4 #endif
           =4 
           =4 #ifndef __cplusplus
           =4 
           =4 #define bool _Bool
           =4 #define true 1
           =4 #define false 0
           =4 
           =4 #define __bool_true_false_are_defined 1
           =4 
           =4 #endif /* !__cplusplus */
           =4 
           =4 #else  // __SLS_IDE__ : Macros defined to remove syntax errors within Simplicity Studio
           =4 
           =4 typedef bit bool;
           =4 enum{
           =4   false = 0,
           =4   true = 1,
           =4 };
           =4 
           =4 #endif
           =4 
           =4 #endif //STDBOOL_H
  45      =4  
 126      =3  #include "stdint.h"
   1      =4  /**************************************************************************//**
   2      =4   * Copyright (c) 2015 by Silicon Laboratories Inc. All rights reserved.
   3      =4   *
   4      =4   * http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   5      =4   *****************************************************************************/
   6      =4  
   7      =4  #ifndef STDINT_H
           =4 #define STDINT_H
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 23  

           =4 
           =4 #if defined __C51__
           =4 
           =4 typedef unsigned char uint8_t;
           =4 typedef unsigned short uint16_t;
           =4 typedef unsigned long uint32_t;
           =4 typedef uint32_t uint64_t[2];
           =4 
           =4 typedef signed char int8_t;
           =4 typedef short int16_t;
           =4 typedef long int32_t;
           =4 typedef int32_t int64_t[2];
           =4 typedef float fp32_t;
           =4 typedef double fp64_t;
           =4 
           =4 #elif defined __ICC8051__
           =4 
           =4 /* Fixed size types. These are all optional. */
           =4 #ifdef __INT8_T_TYPE__
           =4   typedef __INT8_T_TYPE__   int8_t;
           =4   typedef __UINT8_T_TYPE__ uint8_t;
           =4 #endif /* __INT8_T_TYPE__ */
           =4 
           =4 #ifdef __INT16_T_TYPE__
           =4   typedef __INT16_T_TYPE__   int16_t;
           =4   typedef __UINT16_T_TYPE__ uint16_t;
           =4 #endif /* __INT16_T_TYPE__ */
           =4 
           =4 #ifdef __INT32_T_TYPE__
           =4   typedef __INT32_T_TYPE__   int32_t;
           =4   typedef __UINT32_T_TYPE__ uint32_t;
           =4 #endif /* __INT32_T_TYPE__ */
           =4 
           =4 #ifdef __INT64_T_TYPE__
           =4   #pragma language=save
           =4   #pragma language=extended
           =4   typedef __INT64_T_TYPE__   int64_t;
           =4   typedef __UINT64_T_TYPE__ uint64_t;
           =4   #pragma language=restore
           =4 #endif /* __INT64_T_TYPE__ */
           =4 
           =4 #endif
           =4 
           =4 #endif
 127      =3  
 128      =3  //-----------------------------------------------------------------------------
 129      =3  // Macro definitions
 130      =3  //-----------------------------------------------------------------------------
 131      =3  
 132      =3  //SDK Version
 133      =3  #define SDK_VERSION   2
 134      =3  
 135      =3  #ifndef NULL
           =3 #define NULL ((void*) 0)
           =3 #endif
 138      =3  
 139      =3  
 140      =3  // SDCC - Small Device C Compiler
 141      =3  // http://sdcc.sourceforge.net
 142      =3  
 143      =3  #if defined SDCC
           =3 
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 24  

           =3 #if (SDCC >= 300)
           =3 
           =3 #define interrupt __interrupt
           =3 #define _asm __asm
           =3 #define _endasm __endasm
           =3 #define bit __bit
           =3 #define code __code
           =3 #define at __at
           =3 
           =3 #endif
           =3 
           =3 # define SEG_GENERIC
           =3 # define SEG_FAR   __xdata
           =3 # define SEG_DATA  __data
           =3 # define SEG_NEAR  __data
           =3 # define SEG_IDATA __idata
           =3 # define SEG_XDATA __xdata
           =3 # define SEG_PDATA __pdata
           =3 # define SEG_CODE  __code
           =3 # define SEG_BDATA __bdata
           =3 
           =3 # define SBIT(name, addr, bit)  __sbit  __at(addr+bit)                  name
           =3 # define SFR(name, addr)        __sfr   __at(addr)                      name
           =3 # define SFRX(name, addr)       xdata volatile unsigned char __at(addr) name
           =3 # define SFR16(name, addr)      __sfr16 __at(((addr+1U)<<8) | addr)     name
           =3 # define SFR16E(name, fulladdr) __sfr16 __at(fulladdr)                  name
           =3 # define SFR32(name, addr)      __sfr32 __at(((addr+3UL)<<24) | ((addr+2UL)<<16) | ((addr+1UL)<<8) | addr)
             - name
           =3 # define SFR32E(name, fulladdr) __sfr32 __at(fulladdr)                  name
           =3 
           =3 # define INTERRUPT(name, vector) void name (void) interrupt (vector)
           =3 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt (vector) using (regnum)
           =3 # define INTERRUPT_PROTO(name, vector) void name (void) interrupt (vector)
           =3 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void) interrupt (vector) using (regnum)
           =3 
           =3 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using (regnum
             -)
           =3 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter) using (
             -regnum)
           =3 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =3 
           =3 # define SEGMENT_VARIABLE(name, vartype, locsegment) locsegment vartype name
           =3 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) targsegment vartype * name
           =3 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) targsegment vartype * lo
             -csegment name
           =3 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
           =3 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment at (addr) vartype name = init
           =3 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) locsegment at (addr) vartype name
           =3 
           =3 // used with UU16
           =3 # define LSB 0
           =3 # define MSB 1
           =3 
           =3 // used with UU32 (b0 is least-significant byte)
           =3 # define b0 0
           =3 # define b1 1
           =3 # define b2 2
           =3 # define b3 3
           =3 
           =3 typedef unsigned char U8;
           =3 typedef unsigned int U16;
           =3 typedef unsigned long U32;
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 25  

           =3 
           =3 typedef signed char S8;
           =3 typedef signed int S16;
           =3 typedef signed long S32;
           =3 
           =3 typedef union UU16
           =3 {
           =3    U16 U16;
           =3    S16 S16;
           =3    U8 U8[2];
           =3    S8 S8[2];
           =3 } UU16;
           =3 
           =3 typedef union UU32
           =3 {
           =3    U32 U32;
           =3    S32 S32;
           =3    UU16 UU16[2];
           =3    U16 U16[2];
           =3    S16 S16[2];
           =3    U8 U8[4];
           =3    S8 S8[4];
           =3 } UU32;
           =3 
           =3 // NOP () macro support
           =3 #define NOP() _asm NOP _endasm
           =3 
           =3 // generic pointer memory type specifiers
           =3 #define SI_GPTR
           =3 #define SI_GPTR_MTYPE_DATA       0x40
           =3 #define SI_GPTR_MTYPE_IDATA      0x40
           =3 #define SI_GPTR_MTYPE_BDATA      0x40
           =3 #define SI_GPTR_MTYPE_PDATA      0x60
           =3 #define SI_GPTR_MTYPE_XDATA      0x00
           =3 #define SI_GPTR_MTYPE_CODE       0x80
           =3 
           =3 // generic pointer access struct
           =3 typedef union SI_GENERIC_PTR
           =3 {
           =3     U8 U8[3];
           =3     struct
           =3     {
           =3         UU16 ADDR;
           =3         U8 MTYPE;
           =3     } GPTR;
           =3 } SI_GENERIC_PTR;
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 // Raisonance (must be placed before Keil C51)
           =3 // http://www.raisonance.com
           =3 
           =3 #elif defined __RC51__
           =3 
           =3 //#error Raisonance C51 detected.
           =3 
           =3 # define SEG_GENERIC generic     //SEG_GENERIC only applies to pointers in Raisonance, not variables.
           =3 # define SEG_FAR   xdata
           =3 # define SEG_DATA  data
           =3 # define SEG_NEAR  data
           =3 # define SEG_IDATA idata
           =3 # define SEG_XDATA xdata
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 26  

           =3 # define SEG_PDATA pdata
           =3 # define SEG_CODE  code
           =3 # define SEG_BDATA bdata
           =3 
           =3 # define SBIT(name, addr, bit)  at (addr+bit) sbit         name
           =3 # define SFR(name, addr)        sfr at addr                name
           =3 # define SFR16(name, addr)      sfr16 at addr              name
           =3 # define SFR16E(name, fulladdr) /* not supported */
           =3 # define SFR32(name, fulladdr)  /* not supported */
           =3 # define SFR32E(name, fulladdr) /* not supported */
           =3 
           =3 # define INTERRUPT(name, vector) void name (void) interrupt vector
           =3 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
           =3 # define INTERRUPT_PROTO(name, vector) void name (void)
           =3 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
           =3 
           =3 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using regnum
           =3 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =3 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =3 
           =3 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =3 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =3 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =3 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
           =3 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) at addr locsegment vartype name
           =3 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) at addr locsegment vartype name
           =3 
           =3 
           =3 // used with UU16
           =3 # define LSB 1
           =3 # define MSB 0
           =3 
           =3 // used with UU32 (b0 is least-significant byte)
           =3 # define b0 3
           =3 # define b1 2
           =3 # define b2 1
           =3 # define b3 0
           =3 
           =3 typedef unsigned char U8;
           =3 typedef unsigned int U16;
           =3 typedef unsigned long U32;
           =3 
           =3 typedef signed char S8;
           =3 typedef signed int S16;
           =3 typedef signed long S32;
           =3 
           =3 typedef union UU16
           =3 {
           =3    U16 U16;
           =3    S16 S16;
           =3    U8 U8[2];
           =3    S8 S8[2];
           =3 } UU16;
           =3 
           =3 typedef union UU32
           =3 {
           =3    U32 U32;
           =3    S32 S32;
           =3    UU16 UU16[2];
           =3    U16 U16[2];
           =3    S16 S16[2];
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 27  

           =3    U8 U8[4];
           =3    S8 S8[4];
           =3 } UU32;
           =3 
           =3 // NOP () macro support -- NOP is opcode 0x00
           =3 #define NOP() asm { 0x00 }
           =3 
           =3 // generic pointer memory type specifiers
           =3 #define SI_GPTR
           =3 #define SI_GPTR_MTYPE_DATA       0x04
           =3 #define SI_GPTR_MTYPE_IDATA      0x01
           =3 #define SI_GPTR_MTYPE_BDATA      0x04
           =3 #define SI_GPTR_MTYPE_PDATA      0x03
           =3 #define SI_GPTR_MTYPE_XDATA      0x02
           =3 #define SI_GPTR_MTYPE_CODE       0x05
           =3 
           =3 // generic pointer access struct
           =3 typedef union SI_GENERIC_PTR
           =3 {
           =3     U8 U8[3];
           =3     struct
           =3     {
           =3         U8 MTYPE;
           =3         UU16 ADDR;
           =3     } GPTR;
           =3 } SI_GENERIC_PTR;
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 
           =3 // Keil C51
           =3 // http://www.keil.com
           =3 
           =3 #elif defined __C51__
 360      =3  
 361      =3  //#error Keil C51 detected.
 362      =3  
 363      =3  # define SEG_GENERIC
 364      =3  # define SEG_FAR   xdata
 365      =3  # define SEG_DATA  data
 366      =3  # define SEG_NEAR  data
 367      =3  # define SEG_IDATA idata
 368      =3  # define SEG_XDATA xdata
 369      =3  # define SEG_PDATA pdata
 370      =3  # define SEG_CODE  code
 371      =3  # define SEG_BDATA bdata
 372      =3  
 373      =3  # define SBIT(name, addr, bit)  sbit  name = addr^bit
 374      =3  # define SFR(name, addr)        sfr   name = addr
 375      =3  # define SFR16(name, addr)      sfr16 name = addr
 376      =3  # define SFR16E(name, fulladdr) /* not supported */
 377      =3  # define SFR32(name, fulladdr)  /* not supported */
 378      =3  # define SFR32E(name, fulladdr) /* not supported */
 379      =3  
 380      =3  # ifndef __SLS_IDE__
 381      =3  
 382      =3  # define INTERRUPT(name, vector) void name (void) interrupt vector
 383      =3  # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
 384      =3  # define INTERRUPT_PROTO(name, vector) void name (void)
 385      =3  # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
 386      =3  
 387      =3  # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using regnum
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 28  

 388      =3  # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter)
 389      =3  // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
 390      =3  
 391      =3  # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
 392      =3  # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
 393      =3  # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
 394      =3  # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
 395      =3  # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) vartype locsegment name _at_ addr
 396      =3  
 397      =3  # else  // __SLS_IDE__
           =3 
           =3 # define INTERRUPT(name, vector) void name (void)
           =3 # define INTERRUPT_USING(name, vector, regnum) void name (void)
           =3 # define INTERRUPT_PROTO(name, vector) void name (void)
           =3 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
           =3 
           =3 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =3 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =3 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =3 
           =3 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype name
           =3 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype * name
           =3 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype * name
           =3 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * name
           =3 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) vartype name
           =3 
           =3 # endif // __SLS_IDE__
 415      =3  
 416      =3  // used with UU16
 417      =3  # define LSB 1
 418      =3  # define MSB 0
 419      =3  
 420      =3  // used with UU32 (b0 is least-significant byte)
 421      =3  # define b0 3
 422      =3  # define b1 2
 423      =3  # define b2 1
 424      =3  # define b3 0
 425      =3  
 426      =3  typedef unsigned char U8;
 427      =3  typedef unsigned int U16;
 428      =3  typedef unsigned long U32;
 429      =3  
 430      =3  typedef signed char S8;
 431      =3  typedef signed int S16;
 432      =3  typedef signed long S32;
 433      =3  
 434      =3  typedef union UU16
 435      =3  {
 436      =3     U16 U16;
 437      =3     S16 S16;
 438      =3     U8 U8[2];
 439      =3     S8 S8[2];
 440      =3  } UU16;
 441      =3  
 442      =3  typedef union UU32
 443      =3  {
 444      =3     U32 U32;
 445      =3     S32 S32;
 446      =3     UU16 UU16[2];
 447      =3     U16 U16[2];
 448      =3     S16 S16[2];
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 29  

 449      =3     U8 U8[4];
 450      =3     S8 S8[4];
 451      =3  } UU32;
 452      =3  
 453      =3  // NOP () macro support
 454      =3  extern void _nop_ (void);
 455      =3  #define NOP() _nop_()
 456      =3  
 457      =3  // generic pointer memory type specifiers
 458      =3  #define SI_GPTR
 459      =3  #define SI_GPTR_MTYPE_DATA      0x00
 460      =3  #define SI_GPTR_MTYPE_IDATA     0x00
 461      =3  #define SI_GPTR_MTYPE_BDATA     0x00
 462      =3  #define SI_GPTR_MTYPE_PDATA     0xFE
 463      =3  #define SI_GPTR_MTYPE_XDATA     0x01
 464      =3  #define SI_GPTR_MTYPE_CODE      0xFF
 465      =3  
 466      =3  // generic pointer access struct
 467      =3  typedef union SI_GENERIC_PTR
 468      =3  {
 469      =3      U8 U8[3];
 470      =3      struct
 471      =3      {
 472      =3          U8 MTYPE;
 473      =3          UU16 ADDR;
 474      =3      } GPTR;
 475      =3  } SI_GENERIC_PTR;
 476      =3  
 477      =3  //-----------------------------------------------------------------------------
 478      =3  
 479      =3  // Hi-Tech 8051
 480      =3  // http://www.htsoft.com
 481      =3  
 482      =3  #elif defined HI_TECH_C
           =3 
           =3 # define SEG_GENERIC
           =3 # define SEG_FAR   far
           =3 # define SEG_DATA  data
           =3 # define SEG_NEAR  near
           =3 # define SEG_IDATA idata
           =3 # define SEG_XDATA xdata
           =3 # define SEG_PDATA pdata
           =3 # define SEG_CODE  code
           =3 # define SEG_BDATA bdata
           =3 
           =3 
           =3 # define SBIT(name, addr, thebit) static volatile bit name @ (addr + thebit)
           =3 # define SFR(name, addr)          static volatile unsigned char name @ addr
           =3 # define SFR16(name, addr)        static volatile unsigned int name @ addr
           =3 # define SFR16E(name, fulladdr) /* not supported */
           =3 # define SFR32(name, fulladdr)  /* not supported */
           =3 # define SFR32E(name, fulladdr) /* not supported */
           =3 
           =3 # define INTERRUPT(name, vector)       void name (void) interrupt vector
           =3 # define INTERRUPT_PROTO(name, vector)
           =3 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
           =3 # define INTERRUPT_PROTO_USING(name, vector, regnum)
           =3 
           =3 # define FUNCTION_USING(name, return_value, parameter, regnum) /* not supported */
           =3 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) /* not supported */
           =3 // Note: Hi-Tech does not support functions using different register banks. Register
           =3 //       banks can only be specified in interrupts. If a function is called from
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 30  

           =3 //       inside an interrupt, it will use the same register bank as the interrupt.
           =3 
           =3 # define SEGMENT_VARIABLE(name, vartype, locsegment) locsegment vartype name
           =3 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) targsegment vartype * name
           =3 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) targsegment vartype * lo
             -csegment name
           =3 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment vartype name @ addr
           =3 
           =3 // used with UU16
           =3 # define LSB 0
           =3 # define MSB 1
           =3 
           =3 // used with UU32 (b0 is least-significant byte)
           =3 # define b0 0
           =3 # define b1 1
           =3 # define b2 2
           =3 # define b3 3
           =3 
           =3 typedef unsigned char U8;
           =3 typedef unsigned int U16;
           =3 typedef unsigned long U32;
           =3 
           =3 typedef signed char S8;
           =3 typedef signed int S16;
           =3 typedef signed long S32;
           =3 
           =3 typedef union UU16
           =3 {
           =3    U16 U16;
           =3    S16 S16;
           =3    U8 U8[2];
           =3    S8 S8[2];
           =3 } UU16;
           =3 
           =3 typedef union UU32
           =3 {
           =3    U32 U32;
           =3    S32 S32;
           =3    UU16 UU16[2];
           =3    U16 U16[2];
           =3    S16 S16[2];
           =3    U8 U8[4];
           =3    S8 S8[4];
           =3 } UU32;
           =3 
           =3 // NOP () macro support
           =3 #define NOP() asm(" nop ")
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 // Tasking / Altium
           =3 // http://www.altium.com/tasking
           =3 
           =3 
           =3 #elif defined _CC51
           =3 
           =3 # define SEG_GENERIC
           =3 # define SEG_FAR   _xdat
           =3 # define SEG_DATA  _data
           =3 # define SEG_NEAR  _data
           =3 # define SEG_IDATA _idat
           =3 # define SEG_XDATA _xdat
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 31  

           =3 # define SEG_PDATA _pdat
           =3 # define SEG_CODE  _rom
           =3 # define SEG_BDATA _bdat
           =3 
           =3 # define SBIT(name, addr, bit)  _sfrbit  name _at(addr+bit)
           =3 # define SFR(name, addr)        _sfrbyte name _at(addr)
           =3 # define SFRX(name, addr)       _xdat volatile unsigned char name _at(addr)
           =3 #if _CC51 > 71
           =3 # define SFR16(name, addr)      _sfrword _little name _at(addr)
           =3 #else
           =3 # define SFR16(name, addr)      /* not supported */
           =3 #endif
           =3 # define SFR16E(name, fulladdr) /* not supported */
           =3 # define SFR32(name, fulladdr)  /* not supported */
           =3 # define SFR32E(name, fulladdr) /* not supported */
           =3 
           =3 # define INTERRUPT(name, vector) _interrupt (vector) void name (void)
           =3 # define INTERRUPT_USING(name, vector, regnum) _interrupt (vector) _using(regnum) void name (void)
           =3 # define INTERRUPT_PROTO(name, vector) _interrupt (vector) void name (void)
           =3 # define INTERRUPT_PROTO_USING(name, vector, regnum) _interrupt (vector) _using(regnum) void name (void)
           =3 
           =3 // When calling FUNCTION_USING in Tasking, the function must be called from an interrupt or Main which
           =3 // is also using the same register bank. If not, the compiler will generate an error.
           =3 # define FUNCTION_USING(name, return_value, parameter, regnum) _using(regnum) return_value name (parameter
             -)
           =3 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) _using(regnum) return_value name (par
             -ameter)
           =3 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =3 
           =3 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =3 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =3 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =3 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) vartype locsegment name _at( addr )
           =3 
           =3 // used with UU16
           =3 # define LSB 1
           =3 # define MSB 0
           =3 
           =3 // used with UU32 (b0 is least-significant byte)
           =3 # define b0 3
           =3 # define b1 2
           =3 # define b2 1
           =3 # define b3 0
           =3 
           =3 typedef unsigned char U8;
           =3 typedef unsigned int U16;
           =3 typedef unsigned long U32;
           =3 
           =3 typedef signed char S8;
           =3 typedef signed int S16;
           =3 typedef signed long S32;
           =3 
           =3 typedef union UU16
           =3 {
           =3    U16 U16;
           =3    S16 S16;
           =3    U8 U8[2];
           =3    S8 S8[2];
           =3 } UU16;
           =3 
           =3 typedef union UU32
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 32  

           =3 {
           =3    U32 U32;
           =3    S32 S32;
           =3    UU16 UU16[2];
           =3    U16 U16[2];
           =3    S16 S16[2];
           =3    U8 U8[4];
           =3    S8 S8[4];
           =3 } UU32;
           =3 
           =3 // NOP () macro support
           =3 extern void _nop (void);
           =3 #define NOP() _nop()
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 
           =3 // IAR 8051
           =3 // http://www.iar.com
           =3 
           =3 #elif defined __ICC8051__
           =3 
           =3 #include <stdbool.h>
           =3 #include <intrinsics.h>
           =3 
           =3 # define SBIT(name, addr, bit)  __bit __no_init volatile bool name @ (addr+bit)
           =3 # define SFR(name, addr)        __sfr __no_init volatile unsigned char name @ addr
           =3 # define SFRX(name, addr)       __xdata __no_init volatile unsigned char name @ addr
           =3 # define SFR16(name, addr)      __sfr __no_init volatile unsigned int  name @ addr
           =3 # define SFR16E(name, fulladdr) /* not supported */
           =3 # define SFR32(name, fulladdr) /* not supported */
           =3 # define SFR32E(name, fulladdr) /* not supported */
           =3 
           =3 # define SEG_GENERIC __generic
           =3 # define SEG_FAR  __xdata
           =3 # define SEG_DATA __data
           =3 # define SEG_NEAR __data
           =3 # define SEG_IDATA __idata
           =3 # define SEG_XDATA __xdata
           =3 # define SEG_PDATA __pdata
           =3 # define SEG_CODE  __code
           =3 # define SEG_BDATA __bdata
           =3 
           =3 #define bit bool
           =3 
           =3 # define _PPTOSTR_(x) #x
           =3 # define _PPARAM_(address) _PPTOSTR_(vector=address * 8 + 3)
           =3 # define _PPARAM2_(regbank) _PPTOSTR_(register_bank=regbank)
           =3 # define INTERRUPT(name, vector) _Pragma(_PPARAM_(vector)) __interrupt void name(void)
           =3 # define INTERRUPT_PROTO(name, vector)  __interrupt void name(void)
           =3 # define INTERRUPT_USING(name, vector, regnum) _Pragma(_PPARAM2_(regnum)) _Pragma(_PPARAM_(vector)) __inte
             -rrupt void name(void)
           =3 # define INTERRUPT_PROTO_USING(name, vector, regnum) __interrupt void name(void)
           =3 
           =3 # define FUNCTION_USING(name, return_value, parameter, regnum) /* not supported */
           =3 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) /* not supported */
           =3 // Note: IAR does not support functions using different register banks. Register
           =3 //       banks can only be specified in interrupts. If a function is called from
           =3 //       inside an interrupt, it will use the same register bank as the interrupt.
           =3 
           =3 # define SEGMENT_VARIABLE(name, vartype, locsegment)  locsegment vartype name
           =3 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment  * name
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 33  

           =3 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =3 
           =3 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment __no_init vartype name @ addr
           =3 
           =3 // used with UU16
           =3 # define LSB 0
           =3 # define MSB 1
           =3 
           =3 // used with UU32 (b0 is least-significant byte)
           =3 # define b0 0
           =3 # define b1 1
           =3 # define b2 2
           =3 # define b3 3
           =3 
           =3 typedef unsigned char U8;
           =3 typedef unsigned int U16;
           =3 typedef unsigned long U32;
           =3 
           =3 typedef signed char S8;
           =3 typedef signed int S16;
           =3 typedef signed long S32;
           =3 
           =3 typedef union UU16
           =3 {
           =3    U16 U16;
           =3    S16 S16;
           =3    U8 U8[2];
           =3    S8 S8[2];
           =3 } UU16;
           =3 
           =3 typedef union UU32
           =3 {
           =3    U32 U32;
           =3    S32 S32;
           =3    UU16 UU16[2];
           =3    U16 U16[2];
           =3    S16 S16[2];
           =3    U8 U8[4];
           =3    S8 S8[4];
           =3 } UU32;
           =3 
           =3 
           =3 #define NOP() __no_operation();
           =3 
           =3 // generic pointer memory type specifiers
           =3 #define SI_GPTR
           =3 #define SI_GPTR_MTYPE_DATA       0x01
           =3 #define SI_GPTR_MTYPE_IDATA      0x01
           =3 #define SI_GPTR_MTYPE_BDATA      0x01
           =3 #define SI_GPTR_MTYPE_PDATA      0x00
           =3 #define SI_GPTR_MTYPE_XDATA      0x00
           =3 #define SI_GPTR_MTYPE_CODE       0x80
           =3 
           =3 // generic pointer access struct
           =3 typedef union SI_GENERIC_PTR
           =3 {
           =3     U8 U8[3];
           =3     struct
           =3     {
           =3         UU16 ADDR;
           =3         U8 MTYPE;
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 34  

           =3     } GPTR;
           =3 } SI_GENERIC_PTR;
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 // Crossware
           =3 // http://www.crossware.com
           =3 
           =3 #elif defined _XC51_VER
           =3 # define SBIT(name, addr, bit)  _sfrbit  name = (addr+bit)
           =3 # define SFR(name, addr)        _sfr     name = addr
           =3 # define SFR16(name, addr)      _sfrword name = addr
           =3 # define SFR16E(name, fulladdr) /* not supported */
           =3 # define SFR32(name, fulladdr)  /* not supported */
           =3 # define SFR32E(name, fulladdr) /* not supported */
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 // Wickenh盲user
           =3 // http://www.wickenhaeuser.de
           =3 
           =3 #elif defined __UC__
           =3 # define SBIT(name, addr, bit)  unsigned char bit  name @ (addr+bit)
           =3 # define SFR(name, addr)        near unsigned char name @ addr
           =3 # define SFR16(name, addr)      /* not supported */
           =3 # define SFR16E(name, fulladdr) /* not supported */
           =3 # define SFR32(name, fulladdr)  /* not supported */
           =3 # define SFR32E(name, fulladdr) /* not supported */
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 // Default
           =3 // Unknown compiler
           =3 
           =3 #else
           =3 # warning unrecognized compiler
           =3 # define SBIT(name, addr, bit)  volatile bool           name
           =3 # define SFR(name, addr)        volatile unsigned char  name
           =3 # define SFRX(name, addr)       volatile unsigned char  name
           =3 # define SFR16(name, addr)      volatile unsigned short name
           =3 # define SFR16E(name, fulladdr) volatile unsigned short name
           =3 # define SFR32(name, fulladdr)  volatile unsigned long  name
           =3 # define SFR32E(name, fulladdr) volatile unsigned long  name
           =3 
           =3 #endif
 798      =3  
 799      =3  //-----------------------------------------------------------------------------
 800      =3  // Header File PreProcessor Directive
 801      =3  //-----------------------------------------------------------------------------
 802      =3  
 803      =3  #endif                                 // #define COMPILER_DEFS_H
 804      =3  
 805      =3  //-----------------------------------------------------------------------------
 806      =3  // End Of File
 807      =3  //-----------------------------------------------------------------------------
 121      =2  #ifdef C8051F020
           =2 #include "C8051F020_defs.h"
           =2 #endif
 124      =2  #ifdef C8051F340
           =2 #include "C8051F340_defs.h"
           =2 #endif
 127      =2  #ifdef C8051F580
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 35  

 128      =2  #include "C8051F580_defs.h"
   1      =3  //-----------------------------------------------------------------------------
   2      =3  // C8051F580_defs.h
   3      =3  //-----------------------------------------------------------------------------
   4      =3  // Copyright 2008, Silicon Laboratories, Inc.
   5      =3  // http://www.silabs.com
   6      =3  //
   7      =3  // Program Description:
   8      =3  //
   9      =3  // Register/bit definitions for the C8051F58x family.
  10      =3  // **Important Note**: The compiler_defs.h header file should be included
  11      =3  // before including this header file.
  12      =3  //
  13      =3  // Target:         C8051F580/1/2/3/4/5/6/7,8/9-F590/1
  14      =3  // Tool chain:     Generic
  15      =3  // Command Line:   None
  16      =3  //
  17      =3  // Release 0.6 - 20 AUG 2012 (TP)
  18      =3  //    -Added #define for _XPAGE to provide support for SDCC memory paging
  19      =3  //     (pdata)
  20      =3  //
  21      =3  // Release 0.5 - 10 SEP 2011 (GP)
  22      =3  //    - Fixed SFR16 definition for CAN0IF2MC
  23      =3  //
  24      =3  // Release 0.4 - 08 OCT 2010 (TP)
  25      =3  //    - Fixed bit definitions for SCON0
  26      =3  //
  27      =3  // Release 0.3 - 01 APR 2009 (GP)
  28      =3  //    - Added SN0-SN3
  29      =3  //
  30      =3  // Release 0.2 - 29 JUL 2008 (ADT)
  31      =3  //    - Added Timer 4 bit definitions
  32      =3  //
  33      =3  // Release 0.1 - 09 JUL 2008 (GP)
  34      =3  //    - Initial Revision
  35      =3  //
  36      =3  //-----------------------------------------------------------------------------
  37      =3  // Header File Preprocessor Directive
  38      =3  //-----------------------------------------------------------------------------
  39      =3  
  40      =3  #ifndef C8051F580_DEFS_H
  41      =3  #define C8051F580_DEFS_H
  42      =3  
  43      =3  //-----------------------------------------------------------------------------
  44      =3  // Page 0, Page 1 and Page F Registers
  45      =3  //-----------------------------------------------------------------------------
  46      =3  
  47      =3  SFR (P0, 0x80);                        // Port 0 Latch
  48      =3  SFR (SP, 0x81);                        // Stack Pointer
  49      =3  SFR (DPL, 0x82);                       // Data Pointer Low
  50      =3  SFR (DPH, 0x83);                       // Data Pointer High
  51      =3  SFR (SFR0CN, 0x84);                    // SFR Page Control
  52      =3  SFR (SFRNEXT, 0x85);                   // SFR stack next page
  53      =3  SFR (SFRLAST, 0x86);                   // SFR stack last page
  54      =3  SFR (PCON, 0x87);                      // Power Control
  55      =3  SFR (TCON, 0x88);                      // Timer/Counter Control
  56      =3  SFR (TMOD, 0x89);                      // Timer/Counter Mode
  57      =3  SFR (TL0, 0x8A);                       // Timer/Counter 0 Low
  58      =3  SFR (TL1, 0x8B);                       // Timer/Counter 1 Low
  59      =3  SFR (TH0, 0x8C);                       // Timer/Counter 0 High
  60      =3  SFR (TH1, 0x8D);                       // Timer/Counter 1 High
  61      =3  SFR (CKCON, 0x8E);                     // Clock Control
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 36  

  62      =3  SFR (PSCTL, 0x8F);                     // Program Store R/W Control
  63      =3  SFR (CLKSEL, 0x8F);                    // System clock select
  64      =3  SFR (P1, 0x90);                        // Port 1 Latch
  65      =3  SFR (TMR3CN, 0x91);                    // Timer/Counter 3 Control
  66      =3  SFR (TMR5CN, 0x91);                    // Timer/Counter 5 Control
  67      =3  SFR (TMR3RLL, 0x92);                   // Timer/Counter 3 Reload Low
  68      =3  SFR (TMR5CAPL, 0x92);                  // Timer/Counter 5 Capture Low
  69      =3  SFR (TMR3RLH, 0x93);                   // Timer/Counter 3 Reload High
  70      =3  SFR (TMR5CAPH, 0x93);                  // Timer/Counter 5 Capture High
  71      =3  SFR (TMR3L, 0x94);                     // Timer/Counter 3 Low
  72      =3  SFR (TMR5L, 0x94);                     // Timer/Counter 5 Low
  73      =3  SFR (TMR3H, 0x95);                     // Timer/Counter 3 High
  74      =3  SFR (TMR5H, 0x95);                     // Timer/Counter 5 High
  75      =3  SFR (TMR5CF, 0x96);                    // Timer/Counter 5 Configuration
  76      =3  SFR (CLKMUL, 0x97);                    // Clock Multiplier
  77      =3  SFR (SCON0, 0x98);                     // UART0 Control
  78      =3  SFR (SCON1, 0x98);                     // UART1 Control
  79      =3  SFR (SBUF0, 0x99);                     // UART0 Data Buffer
  80      =3  SFR (SBUF1, 0x99);                     // UART1 Data Buffer
  81      =3  SFR (CPT0CN, 0x9A);                    // Comparator 0 Control
  82      =3  SFR (CPT2CN, 0x9A);                    // Comparator 2 Control
  83      =3  SFR (CPT0MD, 0x9B);                    // Comparator 0 Mode
  84      =3  SFR (CPT2MD, 0x9B);                    // Comparator 2 Mode
  85      =3  SFR (CPT0MX, 0x9C);                    // Comparator 0 Mux
  86      =3  SFR (CPT2MX, 0x9C);                    // Comparator 2 Mux
  87      =3  SFR (CPT1CN, 0x9D);                    // Comparator 1 Control
  88      =3  SFR (CPT1MD, 0x9E);                    // Comparator 0 Mode
  89      =3  SFR (OSCIFIN, 0x9E);                   // Internal Oscillator Fine Control
  90      =3  SFR (CPT1MX, 0x9F);                    // Comparator 1 Mux
  91      =3  SFR (OSCXCN, 0x9F);                    // External Oscillator Control
  92      =3  SFR (P2, 0xA0);                        // Port 2 Latch
  93      =3  SFR (SPI0CFG, 0xA1);                   // SPI0 Configuration
  94      =3  SFR (OSCICN, 0xA1);                    // Internal Oscillator Control
  95      =3  SFR (SPI0CKR, 0xA2);                   // SPI0 Clock rate control
  96      =3  SFR (OSCICRS, 0xA2);                   // Internal Oscillator Coarse Control
  97      =3  SFR (SPI0DAT, 0xA3);                   // SPI0 Data Buffer
  98      =3  SFR (P0MDOUT, 0xA4);                   // Port 0 Output Mode
  99      =3  SFR (P1MDOUT, 0xA5);                   // Port 1 Output Mode
 100      =3  SFR (P2MDOUT, 0xA6);                   // Port 2 Output Mode
 101      =3  SFR (SFRPAGE, 0xA7);                   // SFR Page Select
 102      =3  SFR (IE, 0xA8);                        // Interrupt Enable
 103      =3  SFR (SMOD0, 0xA9);                     // Serial Port 0 Control
 104      =3  SFR (EMI0CN, 0xAA);                    // EMIF Control
 105      =3  SFR (EMI0TC, 0xAA);                    // EMIF Timing control
 106      =3  SFR (SBCON0, 0xAB);                    // UART0 Baud Rate Generator Control
 107      =3  SFR (SBRLL0, 0xAC);                    // UART0 Baud Rate Generator Low
 108      =3  SFR (SBRLH0, 0xAD);                    // UART0 Baud Rate Generator High
 109      =3  SFR (P3MAT, 0xAE);                     // Port 3 Match
 110      =3  SFR (P3MDOUT, 0xAE);                   // Port 3 Mode
 111      =3  SFR (P3MASK, 0xAF);                    // Port 3 Mask
 112      =3  SFR (P4MDOUT, 0xAF);                   // Port 4 Mode
 113      =3  SFR (P3, 0xB0);                        // Port 3 Latch
 114      =3  SFR (P2MAT, 0xB1);                     // Port 2 Match
 115      =3  SFR (P2MASK, 0xB2);                    // Port 2 Mask
 116      =3  SFR (EMI0CF, 0xB2);                    // EMIF Configuration
 117      =3  SFR (P4, 0xB5);                        // Port 4 Latch
 118      =3  SFR (FLSCL, 0xB6);                     // Flash Scale
 119      =3  SFR (FLKEY, 0xB7);                     // Flash access limit
 120      =3  SFR (IP, 0xB8);                        // Interrupt Priority
 121      =3  SFR (SMB0ADR, 0xB9);                   // SMBus0 Slave address
 122      =3  SFR (ADC0TK, 0xBA);                    // ADC0 Tracking Mode Select
 123      =3  SFR (SMB0ADM, 0xBA);                   // SMBus0 Address Mask
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 37  

 124      =3  SFR (ADC0MX, 0xBB);                    // AMUX0 Channel select
 125      =3  SFR (ADC0CF, 0xBC);                    // AMUX0 Channel configuration
 126      =3  SFR (ADC0L, 0xBD);                     // ADC0 Data Low
 127      =3  SFR (ADC0H, 0xBE);                     // ADC0 Data High
 128      =3  SFR (SMB0CN, 0xC0);                    // SMBus0 Control
 129      =3  SFR (SMB0CF, 0xC1);                    // SMBus0 Configuration
 130      =3  SFR (SMB0DAT, 0xC2);                   // SMBus0 Data
 131      =3  SFR (ADC0GTL, 0xC3);                   // ADC0 Greater-Than Compare Low
 132      =3  SFR (ADC0GTH, 0xC4);                   // ADC0 Greater-Than Compare High
 133      =3  SFR (ADC0LTL, 0xC5);                   // ADC0 Less-Than Compare Word Low
 134      =3  SFR (ADC0LTH, 0xC6);                   // ADC0 Less-Than Compare Word High
 135      =3  SFR (XBR3, 0xC6);                      // Port I/O Crossbar Control 3
 136      =3  SFR (XBR2, 0xC7);                      // Port I/O Crossbar Control 2
 137      =3  SFR (TMR2CN, 0xC8);                    // Timer/Counter 2 Control
 138      =3  SFR (TMR4CN, 0xC8);                    // Timer/Counter 4 Control
 139      =3  SFR (REG0CN, 0xC9);                    // Regulator Control
 140      =3  SFR (LIN0CF, 0xC9);                    // LIN 0 Configuration
 141      =3  SFR (TMR4CF, 0xC9);                    // Timer/Counter 4 Configuration
 142      =3  SFR (TMR2RLL, 0xCA);                   // Timer/Counter 2 Reload Low
 143      =3  SFR (TMR4CAPL, 0xCA);                  // Timer/Counter 4 Capture Low
 144      =3  SFR (TMR2RLH, 0xCB);                   // Timer/Counter 2 Reload High
 145      =3  SFR (TMR4CAPH, 0xCB);                  // Timer/Counter 4 Capture High
 146      =3  SFR (TMR2L, 0xCC);                     // Timer/Counter 2 Low
 147      =3  SFR (TMR4L, 0xCC);                     // Timer/Counter 4 Low
 148      =3  SFR (TMR2H, 0xCD);                     // Timer/Counter 2 High
 149      =3  SFR (TMR4H, 0xCD);                     // Timer/Counter 4 High
 150      =3  SFR (PCA0CPL5, 0xCE);                  // PCA0 Capture 5 Low
 151      =3  SFR (PCA1CPL11, 0xCE);                 // PCA1 Capture 11 Low
 152      =3  SFR (PCA0CPH5, 0xCF);                  // PCA0 Capture 5 High
 153      =3  SFR (PCA1CPH11, 0xCF);                 // PCA1 Capture 11 High
 154      =3  SFR (PSW, 0xD0);                       // Program Status Word
 155      =3  SFR (REF0CN, 0xD1);                    // Voltage Reference Control
 156      =3  SFR (LIN0DAT, 0xD2);                   // LIN0 Data
 157      =3  SFR (LIN0ADR, 0xD3);                   // LIN0 Address
 158      =3  SFR (P0SKIP, 0xD4);                    // Port 0 Skip
 159      =3  SFR (P1SKIP, 0xD5);                    // Port 1 Skip
 160      =3  SFR (P2SKIP, 0xD6);                    // Port 2 Skip
 161      =3  SFR (P3SKIP, 0xD7);                    // Port 3 Skip
 162      =3  SFR (PCA0CN, 0xD8);                    // PCA0 Control
 163      =3  SFR (PCA1CN, 0xD8);                    // PCA1 Control
 164      =3  SFR (PCA0MD, 0xD9);                    // PCA0 Mode
 165      =3  SFR (PCA1MD, 0xD9);                    // PCA1 Mode
 166      =3  SFR (PCA0PWM, 0xD9);                   // PCA0 PWM Control
 167      =3  SFR (PCA0CPM0, 0xDA);                  // PCA0 Module 0 Mode
 168      =3  SFR (PCA1CPM6, 0xDA);                  // PCA1 Module 6 Mode
 169      =3  SFR (PCA1PWM, 0xDA);                   // PCA1 PWM Control
 170      =3  SFR (PCA0CPM1, 0xDB);                  // PCA0 Module 1  Mode
 171      =3  SFR (PCA1CPM7, 0xDB);                  // PCA1 Module 7  Mode
 172      =3  SFR (PCA0CPM2, 0xDC);                  // PCA0 Module 2  Mode
 173      =3  SFR (PCA1CPM8, 0xDC);                  // PCA1 Module 8  Mode
 174      =3  SFR (PCA0CPM3, 0xDD);                  // PCA0 Module 3  Mode
 175      =3  SFR (PCA1CPM9, 0xDD);                  // PCA1 Module 9  Mode
 176      =3  SFR (PCA0CPM4, 0xDE);                  // PCA0 Module 4  Mode
 177      =3  SFR (PCA1CPM10, 0xDE);                  // PCA1 Module 10 Mode
 178      =3  SFR (PCA0CPM5, 0xDF);                  // PCA0 Module 5  Mode
 179      =3  SFR (PCA1CPM11, 0xDF);                  // PCA1 Module 11 Mode
 180      =3  SFR (ACC, 0xE0);                       // Accumulator
 181      =3  SFR (XBR0, 0xE1);                      // Port I/O Crossbar Control 0
 182      =3  SFR (XBR1, 0xE2);                      // Port I/O Crossbar Control 1
 183      =3  SFR (CCH0CN, 0xE3);                    // Cache control
 184      =3  SFR (IT01CF, 0xE4);                    // INT0/INT1 Configuration
 185      =3  SFR (EIE1, 0xE6);                      // Extended Interrupt Enable 2
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 38  

 186      =3  SFR (EIE2, 0xE7);                      // Extended Interrupt Enable 2
 187      =3  SFR (ADC0CN, 0xE8);                    // ADC0 Control
 188      =3  SFR (PCA0CPL1, 0xE9);                  // PCA0 Capture 1 Low
 189      =3  SFR (PCA1CPL1, 0xE9);                  // PCA1 Capture 7 Low
 190      =3  SFR (PCA0CPH1, 0xEA);                  // PCA0 Capture 1 High
 191      =3  SFR (PCA1CPH1, 0xEA);                  // PCA1 Capture 7 High
 192      =3  SFR (PCA0CPL2, 0xEB);                  // PCA0 Capture 2 Low
 193      =3  SFR (PCA1CPL2, 0xEB);                  // PCA1 Capture 8 Low
 194      =3  SFR (PCA0CPH2, 0xEC);                  // PCA0 Capture 2 High
 195      =3  SFR (PCA1CPH2, 0xEC);                  // PCA1 Capture 8 High
 196      =3  SFR (PCA0CPL3, 0xED);                  // PCA0 Capture 3 Low
 197      =3  SFR (PCA1CPL3, 0xED);                  // PCA1 Capture 9 Low
 198      =3  SFR (PCA0CPH3, 0xEE);                  // PCA0 Capture 3 High
 199      =3  SFR (PCA1CPH3, 0xEE);                  // PCA1 Capture 9 High
 200      =3  SFR (RSTSRC, 0xEF);                    // Reset Source Configuration/Status
 201      =3  SFR (B, 0xF0);                         // B Register
 202      =3  SFR (P0MAT, 0xF1);                     // Port 0 Match
 203      =3  SFR (P0MDIN, 0xF1);                    // Port 0 Input Mode
 204      =3  SFR (P0MASK, 0xF2);                    // Port 0 Mask
 205      =3  SFR (P1MDIN, 0xF2);                    // Port 1 Input Mode
 206      =3  SFR (P1MAT, 0xF3);                     // Port 1 Match
 207      =3  SFR (P2MDIN, 0xF3);                    // Port 2 Input Mode
 208      =3  SFR (P1MASK, 0xF4);                    // Port 1 Mask
 209      =3  SFR (P3MDIN, 0xF4);                    // Port 3 Input Mode
 210      =3  SFR (PSBANK, 0xF5);                    // Program Space Bank Select
 211      =3  SFR (EIP1, 0xF6);                      // External Interrupt Priority 1
 212      =3  SFR (EIP2, 0xF7);                      // External Interrupt Priority 2
 213      =3  SFR (SPI0CN, 0xF8);                    // SPI0 Control
 214      =3  SFR (PCA0L, 0xF9);                     // PCA0 Counter Low
 215      =3  SFR (PCA1L, 0xF9);                     // PCA1 Counter Low
 216      =3  SFR (SN0, 0xF9);                       // Serial Number 0
 217      =3  SFR (PCA0H, 0xFA);                     // PCA0 Counter High
 218      =3  SFR (PCA1H, 0xFA);                     // PCA1 Counter High
 219      =3  SFR (SN1, 0xFA);                       // Serial Number 1
 220      =3  SFR (PCA0CPL0, 0xFB);                  // PCA0 Capture 0 Low
 221      =3  SFR (PCA1CPL6, 0xFB);                  // PCA1 Capture 6 Low
 222      =3  SFR (SN2, 0xFB);                       // Serial Number 2
 223      =3  SFR (PCA0CPH0, 0xFC);                  // PCA0 Capture 0 High
 224      =3  SFR (PCA1CPH6, 0xFC);                  // PCA1 Capture 6 High
 225      =3  SFR (SN3, 0xFC);                       // Serial Number 3
 226      =3  SFR (PCA0CPL4, 0xFD);                  // PCA0 Capture 4 Low
 227      =3  SFR (PCA1CPL10, 0xFD);                 // PCA1 Capture 10 Low
 228      =3  SFR (PCA0CPH4, 0xFE);                  // PCA0 Capture 4 High
 229      =3  SFR (PCA1CPH10, 0xFE);                 // PCA1 Capture 10 High
 230      =3  SFR (VDM0CN, 0xFF);                    // VDD Monitor Control
 231      =3  
 232      =3  //-----------------------------------------------------------------------------
 233      =3  // Page C (CAN0) Registers
 234      =3  //-----------------------------------------------------------------------------
 235      =3  
 236      =3  SFR (CAN0CFG, 0x92);                   // CAN0 Clock Configuration
 237      =3  SFR (CAN0STAT, 0x94);                  // Status Register Low Byte
 238      =3  SFR (CAN0ERRL, 0x96);                  // Error Counter Low Byte
 239      =3  SFR (CAN0ERRH, 0x97);                  // Error Counter High Byte
 240      =3  SFR (CAN0BTL, 0x9A);                   // Bit Timing Register Low Byte
 241      =3  SFR (CAN0BTH, 0x9B);                   // Bit Timing Register High Byte
 242      =3  SFR (CAN0IIDL, 0x9C);                  // Interrupt Register Low Byte
 243      =3  SFR (CAN0IIDH, 0x9D);                  // Interrupt Register High Byte
 244      =3  SFR (CAN0TST, 0x9E);                   // Test Register Low Byte
 245      =3  SFR (CAN0BRPE, 0xA1);                  // BRP Extension Register Low Byte
 246      =3  SFR (CAN0TR1L, 0xA2);                  // Transmission Request 1 Low Byte
 247      =3  SFR (CAN0TR1H, 0xA3);                  // Transmission Request 1 High Byte
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 39  

 248      =3  SFR (CAN0TR2L, 0xA4);                  // Transmission Request 2 Low Byte
 249      =3  SFR (CAN0TR2H, 0xA5);                  // Transmission Request 2 High Byte
 250      =3  SFR (CAN0ND1L, 0xAA);                  // New Data 1 Low Byte
 251      =3  SFR (CAN0ND1H, 0xAB);                  // New Data 1 High Byte
 252      =3  SFR (CAN0ND2L, 0xAC);                  // New Data 2 Low Byte
 253      =3  SFR (CAN0ND2H, 0xAD);                  // New Data 2 High Byte
 254      =3  SFR (CAN0IP1L, 0xAE);                  // Interrupt Pending 1 Low Byte
 255      =3  SFR (CAN0IP1H, 0xAF);                  // Interrupt Pending 1 High Byte
 256      =3  SFR (CAN0IP2L, 0xB2);                  // Interrupt Pending 2 Low Byte
 257      =3  SFR (CAN0IP2H, 0xB3);                  // Interrupt Pending 2 High Byte
 258      =3  SFR (CAN0MV1L, 0xBA);                  // Message Valid 1 Low Byte
 259      =3  SFR (CAN0MV1H, 0xBB);                  // Message Valid 1 High Byte
 260      =3  SFR (CAN0MV2L, 0xBC);                  // Message Valid 2 Low Byte
 261      =3  SFR (CAN0MV2H, 0xBD);                  // Message Valid 2 High Byte
 262      =3  SFR (CAN0IF1CRL, 0xBE);                // IF1 Command Request Low Byte
 263      =3  SFR (CAN0IF1CRH, 0xBF);                // IF1 Command Request High Byte
 264      =3  SFR (CAN0CN, 0xC0);                    // CAN Control Register Low Byte
 265      =3  SFR (CAN0IF1CML, 0xC2);                // IF1 Command Mask Low Byte
 266      =3  SFR (CAN0IF1CMH, 0xC3);                // IF1 Command Mask High Byte
 267      =3  SFR (CAN0IF1M1L, 0xC4);                // IF1 Mask 1 Low Byte
 268      =3  SFR (CAN0IF1M1H, 0xC5);                // IF1 Mask 1 High Byte
 269      =3  SFR (CAN0IF1M2L, 0xC6);                // IF1 Mask 2 Low Byte
 270      =3  SFR (CAN0IF1M2H, 0xC7);                // IF1 Mask 2 High Byte
 271      =3  SFR (CAN0IF1A1L, 0xCA);                // IF1 Arbitration 1 Low Byte
 272      =3  SFR (CAN0IF1A1H, 0xCB);                // IF1 Arbitration 1 High Byte
 273      =3  SFR (CAN0IF1A2L, 0xCC);                // IF1 Arbitration 2 Low Byte
 274      =3  SFR (CAN0IF1A2H, 0xCD);                // IF1 Arbitration 2 High Byte
 275      =3  SFR (CAN0IF2MCL, 0xCE);                // IF2 Message Control Low Byte
 276      =3  SFR (CAN0IF2MCH, 0xCF);                // IF2 Message Control High Byte
 277      =3  SFR (CAN0IF1MCL, 0xD2);                // IF1 Message Control Low Byte
 278      =3  SFR (CAN0IF1MCH, 0xD3);                // IF1 Message Control High Byte
 279      =3  SFR (CAN0IF1DA1L, 0xD4);               // IF1 Data A 1 Low Byte
 280      =3  SFR (CAN0IF1DA1H, 0xD5);               // IF1 Data A 1 High Byte
 281      =3  SFR (CAN0IF1DA2L, 0xD6);               // IF1 Data A 2 Low Byte
 282      =3  SFR (CAN0IF1DA2H, 0xD7);               // IF1 Data A 2 High Byte
 283      =3  SFR (CAN0IF1DB1L, 0xDA);               // IF1 Data B 1 Low Byte
 284      =3  SFR (CAN0IF1DB1H, 0xDB);               // IF1 Data B 1 High Byte
 285      =3  SFR (CAN0IF1DB2L, 0xDC);               // IF1 Data B 2 Low Byte
 286      =3  SFR (CAN0IF1DB2H, 0xDD);               // IF1 Data B 2 High Byte
 287      =3  SFR (CAN0IF2CRL, 0xDE);                // IF2 Command Request Low Byte
 288      =3  SFR (CAN0IF2CRH, 0xDF);                // IF2 Command Request High Byte
 289      =3  SFR (CAN0IF2CML, 0xE2);                // IF2 Command Mask Low Byte
 290      =3  SFR (CAN0IF2CMH, 0xE3);                // IF2 Command Mask High Byte
 291      =3  SFR (CAN0IF2M1L, 0xEA);                // IF2 Mask 1 Low Byte
 292      =3  SFR (CAN0IF2M1H, 0xEB);                // IF2 Mask 1 High Byte
 293      =3  SFR (CAN0IF2M2L, 0xEC);                // IF2 Mask 2 Low Byte
 294      =3  SFR (CAN0IF2M2H, 0xED);                // IF2 Mask 2 High Byte
 295      =3  SFR (CAN0IF2A1L, 0xEE);                // IF2 Arbitration 1 Low Byte
 296      =3  SFR (CAN0IF2A1H, 0xEF);                // IF2 Arbitration 1 High Byte
 297      =3  SFR (CAN0IF2A2L, 0xF2);                // IF2 Arbitration 2 Low Byte
 298      =3  SFR (CAN0IF2A2H, 0xF3);                // IF2 Arbitration 2 High Byte
 299      =3  SFR (CAN0IF2DA1L, 0xF6);               // IF2 Data A 1 Low Byte
 300      =3  SFR (CAN0IF2DA1H, 0xF7);               // IF2 Data A 1 High Byte
 301      =3  SFR (CAN0IF2DA2L, 0xFA);               // IF2 Data A 2 Low Byte
 302      =3  SFR (CAN0IF2DA2H, 0xFB);               // IF2 Data A 2 High Byte
 303      =3  SFR (CAN0IF2DB1L, 0xFC);               // IF2 Data B 1 Low Byte
 304      =3  SFR (CAN0IF2DB1H, 0xFD);               // IF2 Data B 1 High Byte
 305      =3  SFR (CAN0IF2DB2L, 0xFE);               // IF2 Data B 2 Low Byte
 306      =3  SFR (CAN0IF2DB2H, 0xFF);               // IF2 Data B 2 High Byte
 307      =3  
 308      =3  
 309      =3  //-----------------------------------------------------------------------------
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 40  

 310      =3  // 16-bit Register Definitions (might not be supported by all compilers)
 311      =3  //-----------------------------------------------------------------------------
 312      =3  
 313      =3  SFR16 (DP, 0x82);                      // Data Pointer
 314      =3  SFR16 (TMR3RL, 0x92);                  // Timer 3 Reload
 315      =3  SFR16 (TMR5CAP, 0x92);                 // Timer 5 Capture
 316      =3  SFR16 (TMR3, 0x94);                    // Timer 3 Capture / Reload
 317      =3  SFR16 (TMR5, 0x94);                    // Timer 5
 318      =3  SFR16 (SBRL0, 0xAC);                   // UART0 Reload
 319      =3  SFR16 (ADC0, 0xBD);                    // ADC0 data
 320      =3  SFR16 (ADC0GT, 0xC3);                  // ADC0 Greater Than Window
 321      =3  SFR16 (ADC0LT, 0xC5);                  // ADC0 Less Than Window
 322      =3  SFR16 (TMR2RL, 0xCA);                  // Timer 2 Reload
 323      =3  SFR16 (TMR4CAP, 0xCA);                 // Timer 4 Capture
 324      =3  SFR16 (TMR2, 0xCC);                    // Timer 2 Capture / Reload
 325      =3  SFR16 (TMR4, 0xCC);                    // Timer 4
 326      =3  SFR16 (PCA0CP5, 0xCE);                 // PCA0 Module 5 Capture
 327      =3  SFR16 (PCA1CP11, 0xCE);                // PCA1 Module 11 Capture
 328      =3  SFR16 (PCA0CP1, 0xE9);                 // PCA0 Module 1 Capture
 329      =3  SFR16 (PCA1CP7, 0xE9);                 // PCA1 Module 7 Capture
 330      =3  SFR16 (PCA0CP2, 0xEB);                 // PCA0 Module 2 Capture
 331      =3  SFR16 (PCA1CP8, 0xEB);                 // PCA1 Module 8 Capture
 332      =3  SFR16 (PCA0CP3, 0xED);                 // PCA0 Module 3 Capture
 333      =3  SFR16 (PCA1CP9, 0xED);                 // PCA1 Module 9 Capture
 334      =3  SFR16 (PCA0, 0xF9);                    // PCA0 Counter
 335      =3  SFR16 (PCA1, 0xF9);                    // PCA1 Counter
 336      =3  SFR16 (PCA0CP0, 0xFB);                 // PCA0 Module 0 Capture
 337      =3  SFR16 (PCA1CP6, 0xFB);                 // PCA1 Module 6 Capture
 338      =3  SFR16 (PCA0CP4, 0xFD);                 // PCA0 Module 4 Capture
 339      =3  SFR16 (PCA1CP10, 0xFD);                 // PCA1 Module 10 Capture
 340      =3  
 341      =3  SFR16 (CAN0ERR, 0x96);                 // Error Counter
 342      =3  SFR16 (CAN0BT, 0x9A);                  // Bit Timing Register
 343      =3  SFR16 (CAN0IID, 0x9C);                 // Interrupt Register
 344      =3  SFR16 (CAN0TR1, 0xA2);                 // Transmission Request 1
 345      =3  SFR16 (CAN0TR2, 0xA4);                 // Transmission Request 2
 346      =3  SFR16 (CAN0ND1, 0xAA);                 // New Data 1
 347      =3  SFR16 (CAN0ND2, 0xAC);                 // New Data 2
 348      =3  SFR16 (CAN0IP1, 0xAE);                 // Interrupt Pending 1
 349      =3  SFR16 (CAN0IP2, 0xB2);                 // Interrupt Pending 2
 350      =3  SFR16 (CAN0MV1, 0xBA);                 // Message Valid 1
 351      =3  SFR16 (CAN0MV2, 0xBC);                 // Message Valid 2
 352      =3  SFR16 (CAN0IF1CR, 0xBE);               // IF1 Command Request
 353      =3  SFR16 (CAN0IF1CM, 0xC2);               // IF1 Command Mask
 354      =3  SFR16 (CAN0IF1M1, 0xC4);               // IF1 Mask 1
 355      =3  SFR16 (CAN0IF1M2, 0xC6);               // IF1 Mask 2
 356      =3  SFR16 (CAN0IF1A1, 0xCA);               // IF1 Arbitration 1
 357      =3  SFR16 (CAN0IF1A2, 0xCC);               // IF1 Arbitration 2
 358      =3  SFR16 (CAN0IF1MC, 0xD2);               // IF1 Message Control
 359      =3  SFR16 (CAN0IF1DA1, 0xD4);              // IF1 Data A 1
 360      =3  SFR16 (CAN0IF1DA2, 0xD6);              // IF1 Data A 2
 361      =3  SFR16 (CAN0IF1DB1, 0xDA);              // IF1 Data B 1
 362      =3  SFR16 (CAN0IF1DB2, 0xDC);              // IF1 Data B 2
 363      =3  SFR16 (CAN0IF2CR, 0xDE);               // IF2 Command Request
 364      =3  SFR16 (CAN0IF2CM, 0xE2);               // IF2 Command Mask
 365      =3  SFR16 (CAN0IF2M1, 0xEA);               // IF2 Mask 1
 366      =3  SFR16 (CAN0IF2M2, 0xEC);               // IF2 Mask 2
 367      =3  SFR16 (CAN0IF2A1, 0xEE);               // IF2 Arbitration 1
 368      =3  SFR16 (CAN0IF2A2, 0xF2);               // IF2 Arbitration 2
 369      =3  SFR16 (CAN0IF2MC, 0xCE);               // IF2 Message Control
 370      =3  SFR16 (CAN0IF2DA1, 0xF6);              // IF2 Data A 1
 371      =3  SFR16 (CAN0IF2DA2, 0xFA);              // IF2 Data A 2
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 41  

 372      =3  SFR16 (CAN0IF2DB1, 0xFC);              // IF2 Data B 1
 373      =3  SFR16 (CAN0IF2DB2, 0xFE);              // IF2 Data B 2
 374      =3  
 375      =3  //-----------------------------------------------------------------------------
 376      =3  // LIN0 Indirect Registers
 377      =3  //-----------------------------------------------------------------------------
 378      =3  
 379      =3  #define  LIN0DT1   0x00                // LIN0 Data Byte 1
 380      =3  #define  LIN0DT2   0x01                // LIN0 Data Byte 2
 381      =3  #define  LIN0DT3   0x02                // LIN0 Data Byte 3
 382      =3  #define  LIN0DT4   0x03                // LIN0 Data Byte 4
 383      =3  #define  LIN0DT5   0x04                // LIN0 Data Byte 5
 384      =3  #define  LIN0DT6   0x05                // LIN0 Data Byte 6
 385      =3  #define  LIN0DT7   0x06                // LIN0 Data Byte 7
 386      =3  #define  LIN0DT8   0x07                // LIN0 Data Byte 8
 387      =3  #define  LIN0CTRL  0x08                // LIN0 Control
 388      =3  #define  LIN0ST    0x09                // LIN0 Status
 389      =3  #define  LIN0ERR   0x0A                // LIN0 Error
 390      =3  #define  LIN0SIZE  0x0B                // LIN0 Message Size
 391      =3  #define  LIN0DIV   0x0C                // LIN0 Divider
 392      =3  #define  LIN0MUL   0x0D                // LIN0 Multiplier
 393      =3  #define  LIN0ID    0x0E                // LIN0 Identifier
 394      =3  
 395      =3  //-----------------------------------------------------------------------------
 396      =3  // Address Definitions for Bit-addressable Registers
 397      =3  //-----------------------------------------------------------------------------
 398      =3  
 399      =3  #define SFR_P0       0x80
 400      =3  #define SFR_TCON     0x88
 401      =3  #define SFR_P1       0x90
 402      =3  #define SFR_SCON0    0x98
 403      =3  #define SFR_SCON1    0x98
 404      =3  #define SFR_P2       0xA0
 405      =3  #define SFR_IE       0xA8
 406      =3  #define SFR_P3       0xB0
 407      =3  #define SFR_IP       0xB8
 408      =3  #define SFR_SMB0CN   0xC0
 409      =3  #define SFR_TMR2CN   0xC8
 410      =3  #define SFR_TMR4CN   0xC8
 411      =3  #define SFR_PSW      0xD0
 412      =3  #define SFR_PCA0CN   0xD8
 413      =3  #define SFR_PCA1CN   0xD8
 414      =3  #define SFR_ACC      0xE0
 415      =3  #define SFR_ADC0CN   0xE8
 416      =3  #define SFR_B        0xF0
 417      =3  #define SFR_SPI0CN   0xF8
 418      =3  
 419      =3  //-----------------------------------------------------------------------------
 420      =3  // Bit Definitions
 421      =3  //-----------------------------------------------------------------------------
 422      =3  
 423      =3  // TCON 0x88
 424      =3  SBIT (TF1, SFR_TCON, 7);               // Timer 1 Overflow Flag
 425      =3  SBIT (TR1, SFR_TCON, 6);               // Timer 1 On/Off Control
 426      =3  SBIT (TF0, SFR_TCON, 5);               // Timer 0 Overflow Flag
 427      =3  SBIT (TR0, SFR_TCON, 4);               // Timer 0 On/Off Control
 428      =3  SBIT (IE1, SFR_TCON, 3);               // Ext. Interrupt 1 Edge Flag
 429      =3  SBIT (IT1, SFR_TCON, 2);               // Ext. Interrupt 1 Type
 430      =3  SBIT (IE0, SFR_TCON, 1);               // Ext. Interrupt 0 Edge Flag
 431      =3  SBIT (IT0, SFR_TCON, 0);               // Ext. Interrupt 0 Type
 432      =3  
 433      =3  // SCON0 0x98
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 42  

 434      =3  SBIT (OVR0, SFR_SCON0, 7);             // UART0 Receive FIFO Overrun Flag
 435      =3  SBIT (PERR0, SFR_SCON0, 6);            // UART0 Parity Error Flag
 436      =3  SBIT (THRE0, SFR_SCON0, 5);            // UART0 Transmit Register Empty Flag
 437      =3  SBIT (REN0, SFR_SCON0, 4);             // UART0 RX Enable
 438      =3  SBIT (TBX0, SFR_SCON0, 3);             // UART0 Extra Transmission Bit
 439      =3  SBIT (RBX0, SFR_SCON0, 2);             // UART0 Extra Receive Bit
 440      =3  SBIT (TI0, SFR_SCON0, 1);              // UART0 TX Interrupt Flag
 441      =3  SBIT (RI0, SFR_SCON0, 0);              // UART0 RX Interrupt Flag
 442      =3  
 443      =3  // SCON1 0x98
 444      =3  SBIT (S1MODE, SFR_SCON1, 7);           // UART1 Mode 0
 445      =3                                         // Bit 6 UNUSED
 446      =3  SBIT (MCE1, SFR_SCON1, 5);             // UART1 Multiprocessor enable
 447      =3  SBIT (REN1, SFR_SCON1, 4);             // UART1 RX Enable
 448      =3  SBIT (TB81, SFR_SCON1, 3);             // UART1 TX Bit 8
 449      =3  SBIT (RB81, SFR_SCON1, 2);             // UART1 RX Bit 8
 450      =3  SBIT (TI1, SFR_SCON1, 1);              // UART1 TX Interrupt Flag
 451      =3  SBIT (RI1, SFR_SCON1, 0);              // UART1 RX Interrupt Flag
 452      =3  
 453      =3  // IE 0xA8
 454      =3  SBIT (EA, SFR_IE, 7);                  // Global Interrupt Enable
 455      =3  SBIT (ESPI0, SFR_IE, 6);               // SPI0 Interrupt Enable
 456      =3  SBIT (ET2, SFR_IE, 5);                 // Timer 2 Interrupt Enable
 457      =3  SBIT (ES0, SFR_IE, 4);                 // UART0 Interrupt Enable
 458      =3  SBIT (ET1, SFR_IE, 3);                 // Timer 1 Interrupt Enable
 459      =3  SBIT (EX1, SFR_IE, 2);                 // External Interrupt 1 Enable
 460      =3  SBIT (ET0, SFR_IE, 1);                 // Timer 0 Interrupt Enable
 461      =3  SBIT (EX0, SFR_IE, 0);                 // External Interrupt 0 Enable
 462      =3  
 463      =3  // IP 0xB8
 464      =3                                         // Bit 7 unused
 465      =3  SBIT (PSPI0, SFR_IP, 6);               // SPI0 Interrupt Priority
 466      =3  SBIT (PT2, SFR_IP, 5);                 // Timer 2 Priority
 467      =3  SBIT (PS0, SFR_IP, 4);                 // UART0 Priority
 468      =3  SBIT (PS, SFR_IP, 4);                  // UART0 Priority
 469      =3  SBIT (PT1, SFR_IP, 3);                 // Timer 1 Priority
 470      =3  SBIT (PX1, SFR_IP, 2);                 // External Interrupt 1 Priority
 471      =3  SBIT (PT0, SFR_IP, 1);                 // Timer 0 Priority
 472      =3  SBIT (PX0, SFR_IP, 0);                 // External Interrupt 0 Priority
 473      =3  
 474      =3  // SMB0CN 0xC0
 475      =3  SBIT (MASTER, SFR_SMB0CN, 7);          // SMBus0 Master/Slave Indicator
 476      =3  SBIT (TXMODE, SFR_SMB0CN, 6);          // SMBus0 Transmit Mode Indicator
 477      =3  SBIT (STA, SFR_SMB0CN, 5);             // SMBus0 Start Flag
 478      =3  SBIT (STO, SFR_SMB0CN, 4);             // SMBus0 Stop Flag
 479      =3  SBIT (ACKRQ, SFR_SMB0CN, 3);           // SMBus0 Acknowledge Request
 480      =3  SBIT (ARBLOST, SFR_SMB0CN, 2);         // SMBus0 Arbitration Lost Indicator
 481      =3  SBIT (ACK, SFR_SMB0CN, 1);             // SMBus0 Acknowledge
 482      =3  SBIT (SI, SFR_SMB0CN, 0);              // SMBus0 Interrupt Flag
 483      =3  
 484      =3  // TMR2CN 0xC8
 485      =3  SBIT (TF2H, SFR_TMR2CN, 7);            // Timer 2 High-Byte Overflow Flag
 486      =3  SBIT (TF2L, SFR_TMR2CN, 6);            // Timer 2 Low-Byte  Overflow Flag
 487      =3  SBIT (TF2LEN, SFR_TMR2CN, 5);          // Timer 2 Low-Byte Flag Enable
 488      =3  SBIT (TF2CEN, SFR_TMR2CN, 4);          // Timer 2 Capture Enable
 489      =3  SBIT (T2SPLIT, SFR_TMR2CN, 3);         // Timer 2 Split-Mode Enable
 490      =3  SBIT (TR2, SFR_TMR2CN, 2);             // Timer 2 Run Enable
 491      =3  SBIT (T2RCLK, SFR_TMR2CN, 1);          // Timer 2 Xclk/Rclk Select
 492      =3  SBIT (T2XCLK, SFR_TMR2CN, 0);          // Timer 2 Clk/8 Clock Source
 493      =3  
 494      =3  // TMR4CN 0xC8
 495      =3  SBIT (TF4, SFR_TMR4CN, 7);             // Timer 4 Overflow/Underflow Flag
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 43  

 496      =3  SBIT (EXF4, SFR_TMR4CN, 6);            // Timer 4 External Flag
 497      =3                                         // Bit 5 unused
 498      =3                                         // Bit 4 unused
 499      =3  SBIT (EXE4, SFR_TMR4CN, 3);            // Timer 4 External Enable
 500      =3  SBIT (TR4, SFR_TMR4CN, 2);             // Timer 4 Run Enable
 501      =3  SBIT (CT4, SFR_TMR4CN, 1);             // Timer 4 Counter/Timer Select
 502      =3  SBIT (CPRL4, SFR_TMR4CN, 0);           // Timer 4 Capture/Reload Select
 503      =3  
 504      =3  // PSW 0xD0
 505      =3  SBIT (CY, SFR_PSW, 7);                 // Carry Flag
 506      =3  SBIT (AC, SFR_PSW, 6);                 // Auxiliary Carry Flag
 507      =3  SBIT (F0, SFR_PSW, 5);                 // User Flag 0
 508      =3  SBIT (RS1, SFR_PSW, 4);                // Register Bank Select 1
 509      =3  SBIT (RS0, SFR_PSW, 3);                // Register Bank Select 0
 510      =3  SBIT (OV, SFR_PSW, 2);                 // Overflow Flag
 511      =3  SBIT (F1, SFR_PSW, 1);                 // User Flag 1
 512      =3  SBIT (P, SFR_PSW, 0);                  // Accumulator Parity Flag
 513      =3  
 514      =3  // PCA0CN 0xD8
 515      =3  SBIT (CF, SFR_PCA0CN, 7);              // PCA0 Counter Overflow Flag
 516      =3  SBIT (CR, SFR_PCA0CN, 6);              // PCA0 Counter Run Control Bit
 517      =3  SBIT (CCF5, SFR_PCA0CN, 5);            // PCA0 Module 5 Interrupt Flag
 518      =3  SBIT (CCF4, SFR_PCA0CN, 4);            // PCA0 Module 4 Interrupt Flag
 519      =3  SBIT (CCF3, SFR_PCA0CN, 3);            // PCA0 Module 3 Interrupt Flag
 520      =3  SBIT (CCF2, SFR_PCA0CN, 2);            // PCA0 Module 2 Interrupt Flag
 521      =3  SBIT (CCF1, SFR_PCA0CN, 1);            // PCA0 Module 1 Interrupt Flag
 522      =3  SBIT (CCF0, SFR_PCA0CN, 0);            // PCA0 Module 0 Interrupt Flag
 523      =3  
 524      =3  // PCA1CN 0xD8
 525      =3  SBIT (CF1, SFR_PCA1CN, 7);             // PCA1 Counter Overflow Flag
 526      =3  SBIT (CR1, SFR_PCA1CN, 6);             // PCA1 Counter Run Control Bit
 527      =3  SBIT (CCF11, SFR_PCA1CN, 5);           // PCA1 Module 11 Interrupt Flag
 528      =3  SBIT (CCF10, SFR_PCA1CN, 4);           // PCA1 Module 10 Interrupt Flag
 529      =3  SBIT (CCF9, SFR_PCA1CN, 3);            // PCA1 Module 9 Interrupt Flag
 530      =3  SBIT (CCF8, SFR_PCA1CN, 2);            // PCA1 Module 8 Interrupt Flag
 531      =3  SBIT (CCF7, SFR_PCA1CN, 1);            // PCA1 Module 7 Interrupt Flag
 532      =3  SBIT (CCF6, SFR_PCA1CN, 0);            // PCA1 Module 6 Interrupt Flag
 533      =3  
 534      =3  // ADC0CN 0xE8
 535      =3  SBIT (AD0EN, SFR_ADC0CN, 7);           // ADC0 Enable
 536      =3  SBIT (BURSTEN, SFR_ADC0CN, 6);         // ADC0 Burst Enable
 537      =3  SBIT (AD0INT, SFR_ADC0CN, 5);          // ADC0 EOC Interrupt Flag
 538      =3  SBIT (AD0BUSY, SFR_ADC0CN, 4);         // ADC0 Busy Flag
 539      =3  SBIT (AD0WINT, SFR_ADC0CN, 3);         // ADC0 Window Compare Interrupt Flag
 540      =3  SBIT (AD0LJST, SFR_ADC0CN, 2);         // ADC0 Left Justified
 541      =3  SBIT (AD0CM1, SFR_ADC0CN, 1);          // ADC0 Start Of Conversion Mode Bit 1
 542      =3  SBIT (AD0CM0, SFR_ADC0CN, 0);          // ADC0 Start Of Conversion Mode Bit 0
 543      =3  
 544      =3  // SPI0CN 0xF8
 545      =3  SBIT (SPIF, SFR_SPI0CN, 7);            // SPI0 Interrupt Flag
 546      =3  SBIT (WCOL, SFR_SPI0CN, 6);            // SPI0 Write Collision Flag
 547      =3  SBIT (MODF, SFR_SPI0CN, 5);            // SPI0 Mode Fault Flag
 548      =3  SBIT (RXOVRN, SFR_SPI0CN, 4);          // SPI0 RX Overrun Flag
 549      =3  SBIT (NSSMD1, SFR_SPI0CN, 3);          // SPI0 Slave Select Mode 1
 550      =3  SBIT (NSSMD0, SFR_SPI0CN, 2);          // SPI0 Slave Select Mode 0
 551      =3  SBIT (TXBMT, SFR_SPI0CN, 1);           // SPI0 TX Buffer Empty Flag
 552      =3  SBIT (SPIEN, SFR_SPI0CN, 0);           // SPI0 Enable
 553      =3  
 554      =3  //-----------------------------------------------------------------------------
 555      =3  // Interrupt Priorities
 556      =3  //-----------------------------------------------------------------------------
 557      =3  
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 44  

 558      =3  #define INTERRUPT_INT0             0   // External Interrupt 0
 559      =3  #define INTERRUPT_TIMER0           1   // Timer 0 Overflow
 560      =3  #define INTERRUPT_INT1             2   // External Interrupt 1
 561      =3  #define INTERRUPT_TIMER1           3   // Timer 1 Overflow
 562      =3  #define INTERRUPT_UART0            4   // UART0
 563      =3  #define INTERRUPT_TIMER2           5   // Timer 2 Overflow
 564      =3  #define INTERRUPT_SPI0             6   // SPI0
 565      =3  #define INTERRUPT_SMBUS0           7   // SMBus0 Interface
 566      =3  #define INTERRUPT_ADC0_WINDOW      8   // ADC0 Window Comparison
 567      =3  #define INTERRUPT_ADC0_EOC         9   // ADC0 End Of Conversion
 568      =3  #define INTERRUPT_PCA0            10   // PCA0 Peripheral
 569      =3  #define INTERRUPT_COMPARATOR0     11   // Comparator 0 Comparison
 570      =3  #define INTERRUPT_COMPARATOR1     12   // Comparator 1 Comparison
 571      =3  #define INTERRUPT_TIMER3          13   // Timer 3 Overflow
 572      =3  #define INTERRUPT_LIN0            14   // LIN Bus Interrupt
 573      =3  #define INTERRUPT_VREG            15   // Voltage Regulator
 574      =3  #define INTERRUPT_CAN0            16   // CAN Bus Interrupt
 575      =3  #define INTERRUPT_PORT_MATCH      17   // Port Match
 576      =3  #define INTERRUPT_UART1           18   // UART1
 577      =3  #define INTERRUPT_PCA1            19   // PCA1 Peripheral
 578      =3  #define INTERRUPT_COMPARATOR2     20   // Comparator 2 Comparison
 579      =3  #define INTERRUPT_TIMER4          21   // Timer 4 Overflow
 580      =3  #define INTERRUPT_TIMER5          22   // Timer 5 Overflow
 581      =3  
 582      =3  
 583      =3  //-----------------------------------------------------------------------------
 584      =3  // SFR Page Definitions
 585      =3  //-----------------------------------------------------------------------------
 586      =3  
 587      =3  #define  CONFIG_PAGE       0x0F        // System and Port Configuration Page
 588      =3  #define  ACTIVE_PAGE       0x00        // Active Use Page
 589      =3  #define  ACTIVE2_PAGE      0x10        // Active Use Page 2
 590      =3  #define  CAN0_PAGE         0x0C        // CAN0 Registers
 591      =3  
 592      =3  //-----------------------------------------------------------------------------
 593      =3  // SDCC PDATA External Memory Paging Support
 594      =3  //-----------------------------------------------------------------------------
 595      =3  
 596      =3  #if defined SDCC
           =3 
           =3 SFR(_XPAGE, 0xAA); // Point to the EMI0CN register
           =3 
           =3 #endif
 601      =3  
 602      =3  //-----------------------------------------------------------------------------
 603      =3  // Header File PreProcessor Directive
 604      =3  //-----------------------------------------------------------------------------
 605      =3  
 606      =3  #endif                                 // #define C8051F580_DEFS_H
 607      =3  
 608      =3  //-----------------------------------------------------------------------------
 609      =3  // End Of File
 610      =3  //-----------------------------------------------------------------------------
 129      =2  #endif
 130      =2  /*****************************************************************************/
 131      =2  #include <stdio.h>
   1      =3  /*--------------------------------------------------------------------------
   2      =3  STDIO.H
   3      =3  
   4      =3  Prototypes for standard I/O functions.
   5      =3  Copyright (c) 1988-2002 Keil Elektronik GmbH and Keil Software, Inc.
   6      =3  All rights reserved.
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 45  

   7      =3  --------------------------------------------------------------------------*/
   8      =3  
   9      =3  #ifndef __STDIO_H__
  10      =3  #define __STDIO_H__
  11      =3  
  12      =3  #ifndef EOF
  13      =3   #define EOF -1
  14      =3  #endif
  15      =3  
  16      =3  #ifndef NULL
           =3  #define NULL ((void *) 0)
           =3 #endif
  19      =3  
  20      =3  #ifndef _SIZE_T
  21      =3   #define _SIZE_T
  22      =3   typedef unsigned int size_t;
  23      =3  #endif
  24      =3  
  25      =3  #pragma SAVE
  26      =3  #pragma REGPARMS
  27      =3  extern char _getkey (void);
  28      =3  extern char getchar (void);
  29      =3  extern char ungetchar (char);
  30      =3  extern char putchar (char);
  31      =3  extern int printf   (const char *, ...);
  32      =3  extern int sprintf  (char *, const char *, ...);
  33      =3  extern int vprintf  (const char *, char *);
  34      =3  extern int vsprintf (char *, const char *, char *);
  35      =3  extern char *gets (char *, int n);
  36      =3  extern int scanf (const char *, ...);
  37      =3  extern int sscanf (char *, const char *, ...);
  38      =3  extern int puts (const char *);
  39      =3  
  40      =3  #pragma RESTORE
  41      =3  
  42      =3  #endif
  43      =3  
 132      =2  #include <stdlib.h> 
   1      =3  /*--------------------------------------------------------------------------
   2      =3  STDLIB.H
   3      =3  
   4      =3  Standard functions.
   5      =3  Copyright (c) 1988-2008 Keil Elektronik GmbH and Keil Software, Inc.
   6      =3  Copyright (c) 2008-2016 ARM Germany GmbH
   7      =3  All rights reserved.
   8      =3  --------------------------------------------------------------------------*/
   9      =3  
  10      =3  #ifndef __STDLIB_H__
  11      =3  #define __STDLIB_H__
  12      =3  
  13      =3  #ifndef _SIZE_T
           =3  #define _SIZE_T
           =3  typedef unsigned int size_t;
           =3 #endif
  17      =3  
  18      =3  #ifndef NULL
           =3  #define NULL ((void *)0)
           =3 #endif
  21      =3  
  22      =3  #ifndef _WCHAR_T_DEFINED_
  23      =3  #define _WCHAR_T_DEFINED_
  24      =3  typedef char wchar_t;
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 46  

  25      =3  #endif
  26      =3  
  27      =3  #if defined (__CX2__)
           =3 #ifndef _DIV_T_DEFINED
           =3 typedef struct _div_t {
           =3         int quot;
           =3         int rem;
           =3 } div_t;
           =3 typedef struct _ldiv_t {
           =3         long quot;
           =3         long rem;
           =3 } ldiv_t;
           =3 #define _DIV_T_DEFINED
           =3 #endif // _DIV_T_DEFINED
           =3 #endif // __CX2__
  40      =3  
  41      =3  #ifndef RAND_MAX
  42      =3   #define RAND_MAX  32767u
  43      =3  #endif
  44      =3  
  45      =3  #if defined (__CX2__)
           =3 #pragma SAVE
           =3 #pragma FUNCTIONS(STATIC)
           =3 /* intrinsic functions are reentrant, but need static attribute */
           =3 extern int    abs  (int   val);
           =3 #pragma RESTORE
           =3 #endif // __CX2__
  52      =3  
  53      =3  #pragma SAVE
  54      =3  #pragma REGPARMS
  55      =3  
  56      =3  extern char   cabs (char  val);
  57      =3  #if !defined (__CX2__)
  58      =3  extern int    abs  (int   val);
  59      =3  #endif // __CX2__
  60      =3  extern long   labs (long  val);
  61      =3  
  62      =3  extern float  atof (const char *s1);
  63      =3  extern long   atol (const char *s1);
  64      =3  extern int    atoi (const char *s1);
  65      =3  extern int    rand (void);
  66      =3  extern void   srand (unsigned int seed);
  67      =3  
  68      =3  #ifdef _DIV_T_DEFINED
           =3 extern div_t  __div (int numer, int denom);
           =3 #define div(numer,denom)  __div((numer),(denom));
           =3 extern ldiv_t ldiv (long numer, long denom);
           =3 #endif // _DIV_T_DEFINED
  73      =3  
  74      =3  extern float         strtod  (const char *nptr, char **endptr);
  75      =3  extern long          strtol  (const char *nptr, char **endptr, unsigned char base);
  76      =3  extern unsigned long strtoul (const char *nptr, char **endptr, unsigned char base);
  77      =3  
  78      =3  #define _MALLOC_MEM_    xdata
  79      =3  
  80      =3  extern void init_mempool          (void _MALLOC_MEM_ *p, size_t size);
  81      =3  extern void _MALLOC_MEM_ *malloc  (size_t size);
  82      =3  extern void free                  (void _MALLOC_MEM_ *p);
  83      =3  extern void _MALLOC_MEM_ *realloc (void _MALLOC_MEM_ *p, size_t size);
  84      =3  extern void _MALLOC_MEM_ *calloc  (size_t nmemb, size_t size);
  85      =3  
  86      =3  #if defined (__CX2__)
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 47  

           =3 extern void abort(void);
           =3 #endif // __CX2__
  89      =3  
  90      =3  #pragma RESTORE
  91      =3  
  92      =3  #endif // __STDLIB_H__
 133      =2  #include <string.h>
   1      =3  /*--------------------------------------------------------------------------
   2      =3  STRING.H
   3      =3  
   4      =3  String functions.
   5      =3  Copyright (c) 1988-2008 Keil Elektronik GmbH and Keil Software, Inc.
   6      =3  Copyright (c) 2008-2016 ARM Germany GmbH
   7      =3  All rights reserved.
   8      =3  --------------------------------------------------------------------------*/
   9      =3  
  10      =3  #ifndef __STRING_H__
  11      =3  #define __STRING_H__
  12      =3  
  13      =3  #ifndef _SIZE_T
           =3  #define _SIZE_T
           =3  typedef unsigned int size_t;
           =3 #endif
  17      =3  
  18      =3  #ifndef NULL
           =3  #define NULL ((void *)0)
           =3 #endif
  21      =3  
  22      =3  #pragma SAVE
  23      =3  #pragma REGPARMS
  24      =3  extern char  *strcat  (char *s1, const char *s2);
  25      =3  extern char  *strncat (char *s1, const char *s2, size_t n);
  26      =3  
  27      =3  extern char   strcmp  (const char *s1, const char *s2);
  28      =3  extern char   strncmp (const char *s1, const char *s2, size_t n);
  29      =3  
  30      =3  extern char  *strcpy  (char *s1, const char *s2);
  31      =3  extern char  *strncpy (char *s1, const char *s2, size_t n);
  32      =3  
  33      =3  extern size_t strlen  (const char *);
  34      =3  
  35      =3  extern char  *strchr  (const char *s, char c);
  36      =3  extern int    strpos  (const char *s, char c);
  37      =3  extern char  *strrchr (const char *s, char c);
  38      =3  extern int    strrpos (const char *s, char c);
  39      =3  
  40      =3  extern size_t strspn  (const char *s, const char *set);
  41      =3  extern size_t strcspn (const char *s, const char *set);
  42      =3  extern char  *strpbrk (const char *s, const char *set);
  43      =3  extern char  *strrpbrk(const char *s, const char *set);
  44      =3  extern char  *strstr  (const char *s, const char *sub);
  45      =3  extern char  *strtok  (char *str, const char *set);
  46      =3  
  47      =3  extern char   memcmp  (const void *s1, const void *s2, size_t n);
  48      =3  extern void  *memcpy  (void *s1, const void *s2, size_t n);
  49      =3  extern void  *memchr  (const void *s, char val, size_t n);
  50      =3  extern void  *memccpy (void *s1, const void *s2, char val, size_t n);
  51      =3  extern void  *memmove (void *s1, const void *s2, size_t n);
  52      =3  extern void  *memset  (void *s, char val, size_t n);
  53      =3  #pragma RESTORE
  54      =3  
  55      =3  #endif
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 48  

 134      =2  #include <INTRINS.H>
   1      =3  /*--------------------------------------------------------------------------
   2      =3  INTRINS.H
   3      =3  
   4      =3  Intrinsic functions for C51.
   5      =3  Copyright (c) 1988-2010 Keil Elektronik GmbH and ARM Germany GmbH
   6      =3  All rights reserved.
   7      =3  --------------------------------------------------------------------------*/
   8      =3  
   9      =3  #ifndef __INTRINS_H__
  10      =3  #define __INTRINS_H__
  11      =3  
  12      =3  #pragma SAVE
  13      =3  
  14      =3  #if defined (__CX2__)
           =3 #pragma FUNCTIONS(STATIC)
           =3 /* intrinsic functions are reentrant, but need static attribute */
           =3 #endif
  18      =3  
  19      =3  extern void          _nop_     (void);
  20      =3  extern bit           _testbit_ (bit);
  21      =3  extern unsigned char _cror_    (unsigned char, unsigned char);
  22      =3  extern unsigned int  _iror_    (unsigned int,  unsigned char);
  23      =3  extern unsigned long _lror_    (unsigned long, unsigned char);
  24      =3  extern unsigned char _crol_    (unsigned char, unsigned char);
  25      =3  extern unsigned int  _irol_    (unsigned int,  unsigned char);
  26      =3  extern unsigned long _lrol_    (unsigned long, unsigned char);
  27      =3  extern unsigned char _chkfloat_(float);
  28      =3  #if defined (__CX2__)
           =3 extern int           abs       (int);
           =3 extern void          _illop_   (void);
           =3 #endif
  32      =3  #if !defined (__CX2__)
  33      =3  extern void          _push_    (unsigned char _sfr);
  34      =3  extern void          _pop_     (unsigned char _sfr);
  35      =3  #endif
  36      =3  
  37      =3  #pragma RESTORE
  38      =3  
  39      =3  #endif
  40      =3  
 135      =2  #include <ctype.h>
   1      =3  /*--------------------------------------------------------------------------
   2      =3  CTYPE.H
   3      =3  
   4      =3  Prototypes for character functions.
   5      =3  Copyright (c) 1988-2002 Keil Elektronik GmbH and Keil Software, Inc.
   6      =3  All rights reserved.
   7      =3  --------------------------------------------------------------------------*/
   8      =3  
   9      =3  #ifndef __CTYPE_H__
  10      =3  #define __CTYPE_H__
  11      =3  
  12      =3  #pragma SAVE
  13      =3  #pragma REGPARMS
  14      =3  extern bit isalpha (unsigned char);
  15      =3  extern bit isalnum (unsigned char);
  16      =3  extern bit iscntrl (unsigned char);
  17      =3  extern bit isdigit (unsigned char);
  18      =3  extern bit isgraph (unsigned char);
  19      =3  extern bit isprint (unsigned char);
  20      =3  extern bit ispunct (unsigned char);
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 49  

  21      =3  extern bit islower (unsigned char);
  22      =3  extern bit isupper (unsigned char);
  23      =3  extern bit isspace (unsigned char);
  24      =3  extern bit isxdigit (unsigned char);
  25      =3  extern unsigned char tolower (unsigned char);
  26      =3  extern unsigned char toupper (unsigned char);
  27      =3  extern unsigned char toint (unsigned char);
  28      =3  
  29      =3  #define _tolower(c) ( (c)-'A'+'a' )
  30      =3  #define _toupper(c) ( (c)-'a'+'A' )
  31      =3  #define toascii(c)  ( (c) & 0x7F )
  32      =3  #pragma RESTORE
  33      =3  
  34      =3  #endif
 136      =2  #include <LIMITS.H>
   1      =3  /*--------------------------------------------------------------------------
   2      =3  LIMITS.H
   3      =3  
   4      =3  ANSI standard include file.
   5      =3  Copyright (c) 1988-2008 Keil Elektronik GmbH and Keil Software, Inc.
   6      =3  Copyright (c) 2009 ARM Germany GmbH
   7      =3  All rights reserved.
   8      =3  --------------------------------------------------------------------------*/
   9      =3  
  10      =3  #ifndef __LIMITS_H__
  11      =3  #define __LIMITS_H__
  12      =3  
  13      =3  #define CHAR_BIT         8              /* Number of bits in any "char" */
  14      =3  #define CHAR_MAX         127            /* Max             "char" value */
  15      =3  #define CHAR_MIN       (-128)           /* Min             "char" value */
  16      =3  #define SCHAR_MAX        127            /* Max "signed"    "char" value */
  17      =3  #define SCHAR_MIN      (-128)           /* Min "signed"    "char" value */
  18      =3  #define UCHAR_MAX        255            /* Max "unsigned"  "char" value */
  19      =3  #define SHRT_MAX         32767          /* Max ("signed") "short" value */
  20      =3  #define SHRT_MIN       (-32767-1)       /* Min ("signed") "short" value */
  21      =3  #define USHRT_MAX        0xFFFF         /* Max "unsigned" "short" value */
  22      =3  #define INT_MAX          32767          /* Max ("signed")   "int" value */
  23      =3  #define INT_MIN        (-32767-1)       /* Min ("signed")   "int" value */
  24      =3  #define UINT_MAX         0xFFFF         /* Max "unsigned"   "int" value */
  25      =3  #define LONG_MAX         2147483647     /* Max ("signed")  "long" value */
  26      =3  #define LONG_MIN   (-2147483647L-1L)    /* Min ("signed")  "long" value */
  27      =3  #define ULONG_MAX        0xFFFFFFFF     /* Max "unsigned"  "long" value */
  28      =3  
  29      =3  #endif
 137      =2  #include <math.h>
   1      =3  /*--------------------------------------------------------------------------
   2      =3  MATH.H
   3      =3  
   4      =3  Prototypes for mathematic functions.
   5      =3  Copyright (c) 1988-2008 Keil Elektronik GmbH and Keil Software, Inc.
   6      =3  Copyright (c) 2008-2016 ARM Germany GmbH
   7      =3  All rights reserved.
   8      =3  --------------------------------------------------------------------------*/
   9      =3  
  10      =3  #ifndef __MATH_H__
  11      =3  #define __MATH_H__
  12      =3  
  13      =3  #if defined __CX2__ && (__CX2__ >= 558 || __CX2__ == 556 && __CX2_MINOR__ >= 207)
           =3 #ifndef HUGE_VAL
           =3 #define HUGE_VAL __inf__
           =3 #endif // HUGE_VAL
           =3 
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 50  

           =3 #ifndef NAN
           =3 #define NAN __nan__
           =3 #endif // NAN
           =3 
           =3 #pragma SAVE
           =3 #pragma FUNCTIONS(STATIC)
           =3 /* intrinsic functions are reentrant, but need static attribute */
           =3 extern int    abs  (int   val);
           =3 #pragma RESTORE
           =3 #endif
  28      =3  
  29      =3  #pragma SAVE
  30      =3  #pragma REGPARMS
  31      =3  #if !defined (__CX2__)
  32      =3  extern char  cabs  (char  val);
  33      =3  extern int    abs  (int   val);
  34      =3  extern long  labs  (long  val);
  35      =3  #endif
  36      =3  
  37      =3  extern float fabs  (float val);
  38      =3  extern float sqrt  (float val);
  39      =3  extern float exp   (float val);
  40      =3  extern float log   (float val);
  41      =3  extern float log10 (float val);
  42      =3  extern float sin   (float val);
  43      =3  extern float cos   (float val);
  44      =3  extern float tan   (float val);
  45      =3  extern float asin  (float val);
  46      =3  extern float acos  (float val);
  47      =3  extern float atan  (float val);
  48      =3  extern float sinh  (float val);
  49      =3  extern float cosh  (float val);
  50      =3  extern float tanh  (float val);
  51      =3  extern float atan2 (float y, float x);
  52      =3  
  53      =3  extern float ceil  (float val);
  54      =3  extern float floor (float val);
  55      =3  extern float modf  (float val, float *n);
  56      =3  extern float fmod  (float x, float y);
  57      =3  extern float pow   (float x, float y);
  58      =3  
  59      =3  #if defined (__CX2__)
           =3 extern float frexp (float val, int *exp);
           =3 extern float ldexp (float val, int exp);
           =3 #endif
  63      =3  
  64      =3  #pragma RESTORE
  65      =3  
  66      =3  #endif
 138      =2  #include "crc32.h"
   1      =3  #ifndef __CRC32_H__
   2      =3  #define __CRC32_H__
   3      =3  
   4      =3  //#ifdef __cplusplus
   5      =3  //extern "C" {
   6      =3  //#endif
   7      =3  /*****************************************************************************/
   8      =3  #include "AppConfig.h"
   1      =4  #ifndef __APPCONFIG_H__
           =4 #define __APPCONFIG_H__
           =4 /*****************************************************************************/
           =4 #define CONFIG_SYSCLK                       (22118400L)
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 51  

           =4 #ifdef C8051F020
           =4 #define SAR_CLK                                                 2000000L//ADC0时钟 <2.5MHz
           =4 #endif
           =4 #define CONFIG_DEBUG                        0//调试功能
           =4 #define CONFIG_USING_WDT                                        0//使能看门狗
           =4 #define CONFIG_USING_RESET                                      0//使能PLC复位MCU功能
           =4 #define CONFIG_LADDER_SECTORS_START                     64//指令起始地址
           =4 #define CONFIG_LADDER_SECTORS_END                       128//指令结束地址
           =4 #define CONFIG_LASERTIMER_OVERFLOW_US           1000L//定时器周期 1mS
           =4 #define CONFIG_VERSION                                          0x0001
           =4 #define CONFIG_CHECK_CODE                                       0x5A7E
           =4 
           =4 /*****************************************************************************/
           =4 #define CONFIG_UART0_BAUDRATE                           57600//串口波特率
           =4 #define CONFIG_UART0_PARITY                                     NONE
           =4 #define CONFIG_UART0_STOPBIT                            1
           =4 #define CONFIG_UART0_DATABIT                            8
           =4 
           =4 #define CONFIG_UART1_BAUDRATE                           115200//串口波特率
           =4 #define CONFIG_UART1_PARITY                                     NONE
           =4 #define CONFIG_UART1_STOPBIT                            1
           =4 #define CONFIG_UART1_DATABIT                            8
           =4 /*****************************************************************************/
           =4 #define CONFIG_I2C0_FREQ                                        (100000L)               
           =4 #define CONFIG_I2C1_FREQ                                        (100000L)
           =4 #define CONFIG_I2C2_FREQ                                        (100000L)
           =4 #define CONFIG_I2C3_FREQ                                        (100000L)
           =4 #define CONFIG_I2C4_FREQ                                        (100000L)
           =4 /*****************************************************************************/
           =4 #define CONFIG_EPROM_SIZE                                       CONFIG_AT24C64_SIZE
           =4 #define CONFIG_AT24C02_SIZE                             256
           =4 #define CONFIG_AT24C04_SIZE                             512
           =4 #define CONFIG_AT24C08_SIZE                             1024
           =4 #define CONFIG_AT24C16_SIZE                             2048
           =4 #define CONFIG_AT24C32_SIZE                             4096
           =4 #define CONFIG_AT24C64_SIZE                                     8192
           =4 #define CONFIG_AT24C128_SIZE                            16384
           =4 #define CONFIG_AT24C256_SIZE                            32768
           =4 #define CONFIG_EPROM_ADDRESS                            0x50
           =4 #define CONFIG_EPROM_FRAM                                       0//铁电存储体无写入等待
           =4 #define CONFIG_EPROM_FREQ                                       1//
           =4 /*****************************************************************************/
           =4 #define CONFIG_USE_IPID                                         1//使能IPID温度控制
           =4 /*****************************************************************************/
           =4 #define CONFIG_USE_HWVER_SHOW                           1//使能固件版本显示
           =4 #define CONFIG_USE_MPD1_SHOW                            1//使能MPD1测量显示
           =4 #define CONFIG_USE_MPD2_SHOW                            1//使能MPD2测量显示
           =4 #define CONFIG_USE_FBS1                                         1//使能FBS1检测
           =4 #define CONFIG_USE_FBS2                                         1//使能FBS2检测
           =4 #define CONFIG_USE_LASER_TEMP                           1//使能激光器温度显示
           =4 #define CONFIG_USE_RADIATOR_TEMP                        1//使能散热器温度显示
           =4 #define CONFIG_USE_ENVI_TEMP                            1//使能环境温度显示
           =4 #define CONFIG_USE_IPID_UPDATE                          1//使能IPID参数更新功能
           =4 #define CONFIG_USE_IPID_OUTSHOW                         1//使能IPID输出显示
           =4 /*****************************************************************************/
           =4 //SPLC设置
           =4 #define CONFIG_SPLC_IO_INPUT_NUM                        16//硬件输入点数
           =4 #define CONFIG_SPLC_IO_OUTPUT_NUM                       16//硬件输出点数
           =4 #define CONFIG_SOFTPLC_HWTIME                           1000L//1mS
           =4 #define CONFIG_INPUT_FILTER_TIME                        3//输入数字滤波扫描周期 1mS * N
           =4 #define CONFIG_IPID_RUN_CYCLE                           40//IPID运行周期 默认 40 * 100mS
           =4 #define CONFIG_IPID_PWM_CYCLE                           20//IPID输出周期 默认 20 * 100mS
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 52  

           =4 /*****************************************************************************/
           =4 #define CONFIG_SPLC_USING_WDT                           0//看门狗启用
           =4 /*****************************************************************************/
           =4 #define CONFIG_SPLC_USING_IO_INPUT                      1//输入IO刷新启用
           =4 /*****************************************************************************/
           =4 #define CONFIG_SPLC_USING_IO_OUTPUT                     1//输出IO刷新启用
           =4 /*****************************************************************************/
           =4 #define CONFIG_SPLC_USING_EPROM                         0//EPROM掉电存储启用
           =4 /*****************************************************************************/
           =4 #define CONFIG_SPLC_USING_ADC                           0//使能ADC模块
           =4 #define CONFIG_SPLC_ADC_FILTER_TAP                      48//ADC位移滤波次数
           =4 #define CONFIG_SPLC_ADC_CHANNLE                         9//ADC通道数
           =4 #define CONFIG_SPLC_ADC_TEMP_SENSOR_GAIN    3330L// Temp Sensor Gain in (uV / degC)
           =4 #define CONFIG_SPLC_ADC_TEMP_SENSOR_OFFSET  856L// Temp Sensor Offset in mV
           =4 #define CONFIG_SPLC_ADC_INTERNAL_VREF           2200L// ADC Voltage Reference (mV)
           =4 #define CONFIG_SPLC_ADC_AMBIENT             25L// Ambient temp in deg C
           =4 /*****************************************************************************/
           =4 #define CONFIG_SPLC_USING_DAC                           1//是能DAC模块
           =4 /*****************************************************************************/
           =4 #define CONFIG_SPLC_USING_MB_RTU_SLAVE          1//是能MODBUS RTU从站
           =4 #define CONFIG_MB_RTU_SLAVE_TIMER                       1000L//1000uS
           =4 #define CONFIG_MB_RTU_SLAVE_ADDRESS                     0x01//从设备地址
           =4 #define CONFIG_MB_RTU_SLAVE_BUFFER_SIZE         256//发送接收缓冲区
           =4 #define CONFIG_MB_RTU_SLAVE_TIMEOUT                     100//接收通讯超时 10mS
           =4 #define CONFIG_MB_RTU_SLAVE_IO_DELAY            1//RX TX切换延时
           =4 /*****************************************************************************/
           =4 
           =4 /*****************************************************************************/
           =4 #define ID_ONLY_1_CHANNEL                                       4321
           =4 #define ID_ONLY_2_CHANNEL                                       8765
           =4 #define ID_BOTH_CHANNEL                                         9431
           =4 #define ID_LASER_MODE_CW                                        7631
           =4 #define ID_LASER_MODE_SP                                        8934
           =4 #define ID_LASER_MODE_MP                                        2453
           =4 #define ID_LASER_MODE_GP                                        3876
           =4 /*****************************************************************************/
           =4 #define FBS1_IN_PORT                                            3
           =4 #define FBS2_IN_PORT                                            2
           =4 #define COOLON_OUT_PORT                                         (1 * 8 + 3)
           =4 /*****************************************************************************/
           =4 //PID FUZZY 模糊PID配置
           =4 #define CONFIG_TECOUT_CYCLE                                     4000//PID输出转PWM周期
           =4 /*****************************************************************************/
           =4 /*****************************************************************************/
           =4 #define DISABLE_MODBUS_SERIAL_INTERRUPT         ES0 = 0;
           =4 #define ENABLE_MODBUS_SERIAL_INTERRUPT          ES0 = 1;
           =4 #define DISABLE_INTERRUPT                                       EA = 0;
           =4 #define ENABLE_INTERRUPT                                        EA = 1;
           =4 /*****************************************************************************/
           =4 #include "stdint.h"
           =4 #include "stdbool.h"
           =4 #include "endian.h"
           =4 #include "si_toolchain.h"
           =4 #include "compiler_defs.h"
           =4 #ifdef C8051F020
           =4 #include "C8051F020_defs.h"
           =4 #endif
           =4 #ifdef C8051F340
           =4 #include "C8051F340_defs.h"
           =4 #endif
           =4 #ifdef C8051F580
           =4 #include "C8051F580_defs.h"
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 53  

           =4 #endif
           =4 /*****************************************************************************/
           =4 #include <stdio.h>
           =4 #include <stdlib.h> 
           =4 #include <string.h>
           =4 #include <INTRINS.H>
           =4 #include <ctype.h>
           =4 #include <LIMITS.H>
           =4 #include <math.h>
           =4 #include "crc32.h"
           =4 /*****************************************************************************/
           =4 #ifdef C8051F020
           =4 #include "InitDeviceF020.h"
           =4 #endif
           =4 #ifdef C8051F580
           =4 #include "InitDeviceF580.h"
           =4 #endif
           =4 
           =4 #include "delay.h"
           =4 #include "i2c0.h"
           =4 #include "i2c1.h"
           =4 #include "i2c2.h"
           =4 #include "i2c3.h"
           =4 #include "i2c4.h"
           =4 #include "i2c5.h"
           =4 #include "i2c6.h"
           =4 #include "eprom.h"
           =4 #include "mcp47x6.h"
           =4 #include "inPca9554.h"
           =4 #include "outPca9554.h"
           =4 /*****************************************************************************/
           =4 #include "Modbus.h"
           =4 #include "ModbusPort.h"
           =4 /*****************************************************************************/
           =4 #include "sPlc.h"
           =4 #include "sPlcLaser.h"
           =4 //#include "pidFuzzy.h"
           =4 /*****************************************************************************/
           =4 //#include "AppMath.h"
           =4 //#include "chipAdc.h"
           =4 //#include "ad5621.h"
           =4 //#include "chipBeem.h"
           =4 
           =4 /*****************************************************************************/
           =4 #endif
   9      =3  /*****************************************************************************/
  10      =3  uint32_t crc32Calculate(uint8_t *buf, uint32_t len);//CRC32 计算数组
  11      =3  uint32_t crc32CalculateAdd(uint8_t dat);//CRC32 计算连续字节
  12      =3  void crc32Clear(void);//清空旧CRC32结果
  13      =3  void crc32SetCrcOld(uint32_t old);
  14      =3  /*****************************************************************************/
  15      =3  //#ifdef __cplusplus
  16      =3  //}
  17      =3  //#endif
  18      =3  #endif
  19      =3  
  20      =3  
  21      =3  
 139      =2  /*****************************************************************************/
 140      =2  #ifdef C8051F020
           =2 #include "InitDeviceF020.h"
           =2 #endif
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 54  

 143      =2  #ifdef C8051F580
 144      =2  #include "InitDeviceF580.h"
   1      =3  #ifndef __INITDEVICEF020_H__
   2      =3  #define __INITDEVICEF020_H__
   3      =3  /*****************************************************************************/
   4      =3  #include "compiler_defs.h"
   1      =4  //-----------------------------------------------------------------------------
   2      =4  // compiler_defs.h
   3      =4  //-----------------------------------------------------------------------------
   4      =4  // Portions of this file are copyright Maarten Brock
   5      =4  // http://sdcc.sourceforge.net
   6      =4  // Portions of this file are Copyright 2014 Silicon Laboratories, Inc.
   7      =4  // http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   8      =4  //
   9      =4  // GNU LGPL boilerplate:
  10      =4  /** This library is free software; you can redistribute it and/or
  11      =4    * modify it under the terms of the GNU Lesser General Public
  12      =4    * License as published by the Free Software Foundation; either
  13      =4    * version 2.1 of the License, or (at your option) any later version.
  14      =4    *
  15      =4    * This library is distributed in the hope that it will be useful,
  16      =4    * but WITHOUT ANY WARRANTY; without even the implied warranty of
  17      =4    * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
  18      =4    * Lesser General Public License for more details.
  19      =4    *
  20      =4    * You should have received a copy of the GNU Lesser General Public
  21      =4    * License along with this library; if not, write to the Free Software
  22      =4    * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  23      =4    *
  24      =4    * In other words, you are welcome to use, share and improve this program.
  25      =4    * You are forbidden to forbid anyone else to use, share and improve
  26      =4    * what you give them. Help stamp out software-hoarding!
  27      =4  **/
  28      =4  // Program Description:
  29      =4  //
  30      =4  // **Important Note**: This header file should be included before including
  31      =4  // a device-specific header file such as C8051F300_defs.h.
  32      =4  //
  33      =4  // Macro definitions to accomodate 8051 compiler differences in specifying
  34      =4  // special function registers and other 8051-specific features such as NOP
  35      =4  // generation, and locating variables in memory-specific segments.  The
  36      =4  // compilers are identified by their unique predefined macros. See also:
  37      =4  // http://predef.sourceforge.net/precomp.html
  38      =4  //
  39      =4  // SBIT and SFR define special bit and special function registers at the given
  40      =4  // address. SFR16 and SFR32 define sfr combinations at adjacent addresses in
  41      =4  // little-endian format. SFR16E and SFR32E define sfr combinations without
  42      =4  // prerequisite byte order or adjacency. None of these multi-byte sfr
  43      =4  // combinations will guarantee the order in which they are accessed when read
  44      =4  // or written.
  45      =4  //
  46      =4  // SFR16X and SFR32X for 16 bit and 32 bit xdata registers are not defined
  47      =4  // to avoid portability issues because of compiler endianness.
  48      =4  //
  49      =4  // Example:
  50      =4  // // my_mcu.c: main 'c' file for my mcu
  51      =4  // #include <compiler_defs.h>  // this file
  52      =4  // #include <C8051xxxx_defs.h> // SFR definitions for specific MCU target
  53      =4  //
  54      =4  // SBIT  (P0_1, 0x80, 1);      // Port 0 pin 1
  55      =4  // SFR   (P0, 0x80);           // Port 0
  56      =4  // SFRX  (CPUCS, 0xE600);      // Cypress FX2 Control and Status register in
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 55  

  57      =4  //                             // xdata memory at 0xE600
  58      =4  // SFR16 (TMR2, 0xCC);         // Timer 2, lsb at 0xCC, msb at 0xCD
  59      =4  // SFR16E(TMR0, 0x8C8A);       // Timer 0, lsb at 0x8A, msb at 0x8C
  60      =4  // SFR32 (MAC0ACC, 0x93);      // SiLabs C8051F120 32 bits MAC0 Accumulator,
  61      =4  //                             // lsb at 0x93, msb at 0x96
  62      =4  // SFR32E(SUMR, 0xE5E4E3E2);   // TI MSC1210 SUMR 32 bits Summation register,
  63      =4  //                             // lsb at 0xE2, msb at 0xE5
  64      =4  //
  65      =4  // Target:         C8051xxxx
  66      =4  // Tool chain:     Generic
  67      =4  // Command Line:   None
  68      =4  // 
  69      =4  // Release 2.7 - 25 JUN 2014 (JM)
  70      =4  //    -Added SI_GENERIC_PTR struct for accessing generic pointers
  71      =4  //    -Added SI_GPTR_MTYPE_XXXX definitions for determining the memory type
  72      =4  //     pointed at by a generic poitner
  73      =4  // Release 2.6 - 14 DEC 2012 (GO)
  74      =4  //        -Added define for deprecated SDCC keyword 'at'
  75      =4  // Release 2.5 - 12 SEP 2012 (TP)
  76      =4  //    -Added defines for deprecated SDCC keywords bit and code
  77      =4  // Release 2.4 - 27 AUG 2012 (TP)
  78      =4  //    -Added defines for deprecated SDCC keywords interrupt, _asm, and _endasm
  79      =4  // Release 2.3 - 27 MAY 2010 (DM)
  80      =4  //    -Removed 'LOCATED_VARIABLE' pragma from Keil because it is not supported
  81      =4  // Release 2.2 - 06 APR 2010 (ES)
  82      =4  //    -Removed 'PATHINCLUDE' pragma from Raisonance section
  83      =4  // Release 2.1 - 16 JUL 2009 (ES)
  84      =4  //    -Added SEGMENT_POINTER macro definitions for SDCC, Keil, and Raisonance
  85      =4  //    -Added LOCATED_VARIABLE_NO_INIT macro definitions for Raisonance
  86      =4  // Release 2.0 - 19 MAY 2009 (ES)
  87      =4  //    -Added LOCATED_VARIABLE_NO_INIT macro definitions for SDCC and Keil
  88      =4  // Release 1.9 - 23 OCT 2008 (ES)
  89      =4  //    -Updated Hi-Tech INTERRUPT and INTERRUPT_USING macro definitions
  90      =4  //    -Added SFR16 macro defintion for Hi-Tech
  91      =4  // Release 1.8 - 31 JUL 2008 (ES)
  92      =4  //    -Added INTERRUPT_USING and FUNCTION_USING macro's
  93      =4  //    -Added macro's for IAR
  94      =4  //    -Corrected Union definitions for Hi-Tech and added SFR16 macro defintion
  95      =4  // Release 1.7 - 11 SEP 2007 (BW)
  96      =4  //    -Added support for Raisonance EVAL 03.03.42 and Tasking Eval 7.2r1
  97      =4  // Release 1.6 - 27 AUG 2007 (BW)
  98      =4  //    -Updated copyright notice per agreement with Maartin Brock
  99      =4  //    -Added SDCC 2.7.0 "compiler.h" bug fixes
 100      =4  //    -Added memory segment defines (SEG_XDATA, for example)
 101      =4  // Release 1.5 - 24 AUG 2007 (BW)
 102      =4  //    -Added support for NOP () macro
 103      =4  //    -Added support for Hi-Tech ver 9.01
 104      =4  // Release 1.4 - 07 AUG 2007 (PKC)
 105      =4  //    -Removed FID and fixed formatting.
 106      =4  // Release 1.3 - 30 SEP 2007 (TP)
 107      =4  //    -Added INTERRUPT_PROTO_USING to properly support ISR context switching
 108      =4  //     under SDCC.
 109      =4  // Release 1.2 - (BW)
 110      =4  //    -Added support for U8,U16,U32,S8,S16,S32,UU16,UU32 data types
 111      =4  // Release 1.1 - (BW)
 112      =4  //    -Added support for INTERRUPT, INTERRUPT_USING, INTERRUPT_PROTO,
 113      =4  //     SEGMENT_VARIABLE, VARIABLE_SEGMENT_POINTER,
 114      =4  //     SEGMENT_VARIABLE_SEGMENT_POINTER, and LOCATED_VARIABLE
 115      =4  // Release 1.0 - 29 SEP 2006 (PKC)
 116      =4  //    -Initial revision
 117      =4  
 118      =4  //-----------------------------------------------------------------------------
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 56  

 119      =4  // Header File Preprocessor Directive
 120      =4  //-----------------------------------------------------------------------------
 121      =4  
 122      =4  #ifndef COMPILER_DEFS_H
           =4 #define COMPILER_DEFS_H
           =4 
           =4 #include "stdbool.h"
           =4 #include "stdint.h"
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 // Macro definitions
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 //SDK Version
           =4 #define SDK_VERSION   2
           =4 
           =4 #ifndef NULL
           =4 #define NULL ((void*) 0)
           =4 #endif
           =4 
           =4 
           =4 // SDCC - Small Device C Compiler
           =4 // http://sdcc.sourceforge.net
           =4 
           =4 #if defined SDCC
           =4 
           =4 #if (SDCC >= 300)
           =4 
           =4 #define interrupt __interrupt
           =4 #define _asm __asm
           =4 #define _endasm __endasm
           =4 #define bit __bit
           =4 #define code __code
           =4 #define at __at
           =4 
           =4 #endif
           =4 
           =4 # define SEG_GENERIC
           =4 # define SEG_FAR   __xdata
           =4 # define SEG_DATA  __data
           =4 # define SEG_NEAR  __data
           =4 # define SEG_IDATA __idata
           =4 # define SEG_XDATA __xdata
           =4 # define SEG_PDATA __pdata
           =4 # define SEG_CODE  __code
           =4 # define SEG_BDATA __bdata
           =4 
           =4 # define SBIT(name, addr, bit)  __sbit  __at(addr+bit)                  name
           =4 # define SFR(name, addr)        __sfr   __at(addr)                      name
           =4 # define SFRX(name, addr)       xdata volatile unsigned char __at(addr) name
           =4 # define SFR16(name, addr)      __sfr16 __at(((addr+1U)<<8) | addr)     name
           =4 # define SFR16E(name, fulladdr) __sfr16 __at(fulladdr)                  name
           =4 # define SFR32(name, addr)      __sfr32 __at(((addr+3UL)<<24) | ((addr+2UL)<<16) | ((addr+1UL)<<8) | addr)
             - name
           =4 # define SFR32E(name, fulladdr) __sfr32 __at(fulladdr)                  name
           =4 
           =4 # define INTERRUPT(name, vector) void name (void) interrupt (vector)
           =4 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt (vector) using (regnum)
           =4 # define INTERRUPT_PROTO(name, vector) void name (void) interrupt (vector)
           =4 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void) interrupt (vector) using (regnum)
           =4 
           =4 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using (regnum
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 57  

             -)
           =4 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter) using (
             -regnum)
           =4 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =4 
           =4 # define SEGMENT_VARIABLE(name, vartype, locsegment) locsegment vartype name
           =4 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) targsegment vartype * name
           =4 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) targsegment vartype * lo
             -csegment name
           =4 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
           =4 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment at (addr) vartype name = init
           =4 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) locsegment at (addr) vartype name
           =4 
           =4 // used with UU16
           =4 # define LSB 0
           =4 # define MSB 1
           =4 
           =4 // used with UU32 (b0 is least-significant byte)
           =4 # define b0 0
           =4 # define b1 1
           =4 # define b2 2
           =4 # define b3 3
           =4 
           =4 typedef unsigned char U8;
           =4 typedef unsigned int U16;
           =4 typedef unsigned long U32;
           =4 
           =4 typedef signed char S8;
           =4 typedef signed int S16;
           =4 typedef signed long S32;
           =4 
           =4 typedef union UU16
           =4 {
           =4    U16 U16;
           =4    S16 S16;
           =4    U8 U8[2];
           =4    S8 S8[2];
           =4 } UU16;
           =4 
           =4 typedef union UU32
           =4 {
           =4    U32 U32;
           =4    S32 S32;
           =4    UU16 UU16[2];
           =4    U16 U16[2];
           =4    S16 S16[2];
           =4    U8 U8[4];
           =4    S8 S8[4];
           =4 } UU32;
           =4 
           =4 // NOP () macro support
           =4 #define NOP() _asm NOP _endasm
           =4 
           =4 // generic pointer memory type specifiers
           =4 #define SI_GPTR
           =4 #define SI_GPTR_MTYPE_DATA       0x40
           =4 #define SI_GPTR_MTYPE_IDATA      0x40
           =4 #define SI_GPTR_MTYPE_BDATA      0x40
           =4 #define SI_GPTR_MTYPE_PDATA      0x60
           =4 #define SI_GPTR_MTYPE_XDATA      0x00
           =4 #define SI_GPTR_MTYPE_CODE       0x80
           =4 
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 58  

           =4 // generic pointer access struct
           =4 typedef union SI_GENERIC_PTR
           =4 {
           =4     U8 U8[3];
           =4     struct
           =4     {
           =4         UU16 ADDR;
           =4         U8 MTYPE;
           =4     } GPTR;
           =4 } SI_GENERIC_PTR;
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 // Raisonance (must be placed before Keil C51)
           =4 // http://www.raisonance.com
           =4 
           =4 #elif defined __RC51__
           =4 
           =4 //#error Raisonance C51 detected.
           =4 
           =4 # define SEG_GENERIC generic     //SEG_GENERIC only applies to pointers in Raisonance, not variables.
           =4 # define SEG_FAR   xdata
           =4 # define SEG_DATA  data
           =4 # define SEG_NEAR  data
           =4 # define SEG_IDATA idata
           =4 # define SEG_XDATA xdata
           =4 # define SEG_PDATA pdata
           =4 # define SEG_CODE  code
           =4 # define SEG_BDATA bdata
           =4 
           =4 # define SBIT(name, addr, bit)  at (addr+bit) sbit         name
           =4 # define SFR(name, addr)        sfr at addr                name
           =4 # define SFR16(name, addr)      sfr16 at addr              name
           =4 # define SFR16E(name, fulladdr) /* not supported */
           =4 # define SFR32(name, fulladdr)  /* not supported */
           =4 # define SFR32E(name, fulladdr) /* not supported */
           =4 
           =4 # define INTERRUPT(name, vector) void name (void) interrupt vector
           =4 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
           =4 # define INTERRUPT_PROTO(name, vector) void name (void)
           =4 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
           =4 
           =4 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using regnum
           =4 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =4 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =4 
           =4 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =4 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =4 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =4 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
           =4 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) at addr locsegment vartype name
           =4 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) at addr locsegment vartype name
           =4 
           =4 
           =4 // used with UU16
           =4 # define LSB 1
           =4 # define MSB 0
           =4 
           =4 // used with UU32 (b0 is least-significant byte)
           =4 # define b0 3
           =4 # define b1 2
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 59  

           =4 # define b2 1
           =4 # define b3 0
           =4 
           =4 typedef unsigned char U8;
           =4 typedef unsigned int U16;
           =4 typedef unsigned long U32;
           =4 
           =4 typedef signed char S8;
           =4 typedef signed int S16;
           =4 typedef signed long S32;
           =4 
           =4 typedef union UU16
           =4 {
           =4    U16 U16;
           =4    S16 S16;
           =4    U8 U8[2];
           =4    S8 S8[2];
           =4 } UU16;
           =4 
           =4 typedef union UU32
           =4 {
           =4    U32 U32;
           =4    S32 S32;
           =4    UU16 UU16[2];
           =4    U16 U16[2];
           =4    S16 S16[2];
           =4    U8 U8[4];
           =4    S8 S8[4];
           =4 } UU32;
           =4 
           =4 // NOP () macro support -- NOP is opcode 0x00
           =4 #define NOP() asm { 0x00 }
           =4 
           =4 // generic pointer memory type specifiers
           =4 #define SI_GPTR
           =4 #define SI_GPTR_MTYPE_DATA       0x04
           =4 #define SI_GPTR_MTYPE_IDATA      0x01
           =4 #define SI_GPTR_MTYPE_BDATA      0x04
           =4 #define SI_GPTR_MTYPE_PDATA      0x03
           =4 #define SI_GPTR_MTYPE_XDATA      0x02
           =4 #define SI_GPTR_MTYPE_CODE       0x05
           =4 
           =4 // generic pointer access struct
           =4 typedef union SI_GENERIC_PTR
           =4 {
           =4     U8 U8[3];
           =4     struct
           =4     {
           =4         U8 MTYPE;
           =4         UU16 ADDR;
           =4     } GPTR;
           =4 } SI_GENERIC_PTR;
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 
           =4 // Keil C51
           =4 // http://www.keil.com
           =4 
           =4 #elif defined __C51__
           =4 
           =4 //#error Keil C51 detected.
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 60  

           =4 
           =4 # define SEG_GENERIC
           =4 # define SEG_FAR   xdata
           =4 # define SEG_DATA  data
           =4 # define SEG_NEAR  data
           =4 # define SEG_IDATA idata
           =4 # define SEG_XDATA xdata
           =4 # define SEG_PDATA pdata
           =4 # define SEG_CODE  code
           =4 # define SEG_BDATA bdata
           =4 
           =4 # define SBIT(name, addr, bit)  sbit  name = addr^bit
           =4 # define SFR(name, addr)        sfr   name = addr
           =4 # define SFR16(name, addr)      sfr16 name = addr
           =4 # define SFR16E(name, fulladdr) /* not supported */
           =4 # define SFR32(name, fulladdr)  /* not supported */
           =4 # define SFR32E(name, fulladdr) /* not supported */
           =4 
           =4 # ifndef __SLS_IDE__
           =4 
           =4 # define INTERRUPT(name, vector) void name (void) interrupt vector
           =4 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
           =4 # define INTERRUPT_PROTO(name, vector) void name (void)
           =4 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
           =4 
           =4 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using regnum
           =4 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =4 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =4 
           =4 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =4 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =4 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =4 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
           =4 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) vartype locsegment name _at_ addr
           =4 
           =4 # else  // __SLS_IDE__
           =4 
           =4 # define INTERRUPT(name, vector) void name (void)
           =4 # define INTERRUPT_USING(name, vector, regnum) void name (void)
           =4 # define INTERRUPT_PROTO(name, vector) void name (void)
           =4 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
           =4 
           =4 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =4 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =4 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =4 
           =4 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype name
           =4 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype * name
           =4 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype * name
           =4 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * name
           =4 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) vartype name
           =4 
           =4 # endif // __SLS_IDE__
           =4 
           =4 // used with UU16
           =4 # define LSB 1
           =4 # define MSB 0
           =4 
           =4 // used with UU32 (b0 is least-significant byte)
           =4 # define b0 3
           =4 # define b1 2
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 61  

           =4 # define b2 1
           =4 # define b3 0
           =4 
           =4 typedef unsigned char U8;
           =4 typedef unsigned int U16;
           =4 typedef unsigned long U32;
           =4 
           =4 typedef signed char S8;
           =4 typedef signed int S16;
           =4 typedef signed long S32;
           =4 
           =4 typedef union UU16
           =4 {
           =4    U16 U16;
           =4    S16 S16;
           =4    U8 U8[2];
           =4    S8 S8[2];
           =4 } UU16;
           =4 
           =4 typedef union UU32
           =4 {
           =4    U32 U32;
           =4    S32 S32;
           =4    UU16 UU16[2];
           =4    U16 U16[2];
           =4    S16 S16[2];
           =4    U8 U8[4];
           =4    S8 S8[4];
           =4 } UU32;
           =4 
           =4 // NOP () macro support
           =4 extern void _nop_ (void);
           =4 #define NOP() _nop_()
           =4 
           =4 // generic pointer memory type specifiers
           =4 #define SI_GPTR
           =4 #define SI_GPTR_MTYPE_DATA      0x00
           =4 #define SI_GPTR_MTYPE_IDATA     0x00
           =4 #define SI_GPTR_MTYPE_BDATA     0x00
           =4 #define SI_GPTR_MTYPE_PDATA     0xFE
           =4 #define SI_GPTR_MTYPE_XDATA     0x01
           =4 #define SI_GPTR_MTYPE_CODE      0xFF
           =4 
           =4 // generic pointer access struct
           =4 typedef union SI_GENERIC_PTR
           =4 {
           =4     U8 U8[3];
           =4     struct
           =4     {
           =4         U8 MTYPE;
           =4         UU16 ADDR;
           =4     } GPTR;
           =4 } SI_GENERIC_PTR;
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 // Hi-Tech 8051
           =4 // http://www.htsoft.com
           =4 
           =4 #elif defined HI_TECH_C
           =4 
           =4 # define SEG_GENERIC
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 62  

           =4 # define SEG_FAR   far
           =4 # define SEG_DATA  data
           =4 # define SEG_NEAR  near
           =4 # define SEG_IDATA idata
           =4 # define SEG_XDATA xdata
           =4 # define SEG_PDATA pdata
           =4 # define SEG_CODE  code
           =4 # define SEG_BDATA bdata
           =4 
           =4 
           =4 # define SBIT(name, addr, thebit) static volatile bit name @ (addr + thebit)
           =4 # define SFR(name, addr)          static volatile unsigned char name @ addr
           =4 # define SFR16(name, addr)        static volatile unsigned int name @ addr
           =4 # define SFR16E(name, fulladdr) /* not supported */
           =4 # define SFR32(name, fulladdr)  /* not supported */
           =4 # define SFR32E(name, fulladdr) /* not supported */
           =4 
           =4 # define INTERRUPT(name, vector)       void name (void) interrupt vector
           =4 # define INTERRUPT_PROTO(name, vector)
           =4 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
           =4 # define INTERRUPT_PROTO_USING(name, vector, regnum)
           =4 
           =4 # define FUNCTION_USING(name, return_value, parameter, regnum) /* not supported */
           =4 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) /* not supported */
           =4 // Note: Hi-Tech does not support functions using different register banks. Register
           =4 //       banks can only be specified in interrupts. If a function is called from
           =4 //       inside an interrupt, it will use the same register bank as the interrupt.
           =4 
           =4 # define SEGMENT_VARIABLE(name, vartype, locsegment) locsegment vartype name
           =4 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) targsegment vartype * name
           =4 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) targsegment vartype * lo
             -csegment name
           =4 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment vartype name @ addr
           =4 
           =4 // used with UU16
           =4 # define LSB 0
           =4 # define MSB 1
           =4 
           =4 // used with UU32 (b0 is least-significant byte)
           =4 # define b0 0
           =4 # define b1 1
           =4 # define b2 2
           =4 # define b3 3
           =4 
           =4 typedef unsigned char U8;
           =4 typedef unsigned int U16;
           =4 typedef unsigned long U32;
           =4 
           =4 typedef signed char S8;
           =4 typedef signed int S16;
           =4 typedef signed long S32;
           =4 
           =4 typedef union UU16
           =4 {
           =4    U16 U16;
           =4    S16 S16;
           =4    U8 U8[2];
           =4    S8 S8[2];
           =4 } UU16;
           =4 
           =4 typedef union UU32
           =4 {
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 63  

           =4    U32 U32;
           =4    S32 S32;
           =4    UU16 UU16[2];
           =4    U16 U16[2];
           =4    S16 S16[2];
           =4    U8 U8[4];
           =4    S8 S8[4];
           =4 } UU32;
           =4 
           =4 // NOP () macro support
           =4 #define NOP() asm(" nop ")
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 // Tasking / Altium
           =4 // http://www.altium.com/tasking
           =4 
           =4 
           =4 #elif defined _CC51
           =4 
           =4 # define SEG_GENERIC
           =4 # define SEG_FAR   _xdat
           =4 # define SEG_DATA  _data
           =4 # define SEG_NEAR  _data
           =4 # define SEG_IDATA _idat
           =4 # define SEG_XDATA _xdat
           =4 # define SEG_PDATA _pdat
           =4 # define SEG_CODE  _rom
           =4 # define SEG_BDATA _bdat
           =4 
           =4 # define SBIT(name, addr, bit)  _sfrbit  name _at(addr+bit)
           =4 # define SFR(name, addr)        _sfrbyte name _at(addr)
           =4 # define SFRX(name, addr)       _xdat volatile unsigned char name _at(addr)
           =4 #if _CC51 > 71
           =4 # define SFR16(name, addr)      _sfrword _little name _at(addr)
           =4 #else
           =4 # define SFR16(name, addr)      /* not supported */
           =4 #endif
           =4 # define SFR16E(name, fulladdr) /* not supported */
           =4 # define SFR32(name, fulladdr)  /* not supported */
           =4 # define SFR32E(name, fulladdr) /* not supported */
           =4 
           =4 # define INTERRUPT(name, vector) _interrupt (vector) void name (void)
           =4 # define INTERRUPT_USING(name, vector, regnum) _interrupt (vector) _using(regnum) void name (void)
           =4 # define INTERRUPT_PROTO(name, vector) _interrupt (vector) void name (void)
           =4 # define INTERRUPT_PROTO_USING(name, vector, regnum) _interrupt (vector) _using(regnum) void name (void)
           =4 
           =4 // When calling FUNCTION_USING in Tasking, the function must be called from an interrupt or Main which
           =4 // is also using the same register bank. If not, the compiler will generate an error.
           =4 # define FUNCTION_USING(name, return_value, parameter, regnum) _using(regnum) return_value name (parameter
             -)
           =4 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) _using(regnum) return_value name (par
             -ameter)
           =4 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =4 
           =4 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =4 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =4 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =4 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) vartype locsegment name _at( addr )
           =4 
           =4 // used with UU16
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 64  

           =4 # define LSB 1
           =4 # define MSB 0
           =4 
           =4 // used with UU32 (b0 is least-significant byte)
           =4 # define b0 3
           =4 # define b1 2
           =4 # define b2 1
           =4 # define b3 0
           =4 
           =4 typedef unsigned char U8;
           =4 typedef unsigned int U16;
           =4 typedef unsigned long U32;
           =4 
           =4 typedef signed char S8;
           =4 typedef signed int S16;
           =4 typedef signed long S32;
           =4 
           =4 typedef union UU16
           =4 {
           =4    U16 U16;
           =4    S16 S16;
           =4    U8 U8[2];
           =4    S8 S8[2];
           =4 } UU16;
           =4 
           =4 typedef union UU32
           =4 {
           =4    U32 U32;
           =4    S32 S32;
           =4    UU16 UU16[2];
           =4    U16 U16[2];
           =4    S16 S16[2];
           =4    U8 U8[4];
           =4    S8 S8[4];
           =4 } UU32;
           =4 
           =4 // NOP () macro support
           =4 extern void _nop (void);
           =4 #define NOP() _nop()
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 
           =4 // IAR 8051
           =4 // http://www.iar.com
           =4 
           =4 #elif defined __ICC8051__
           =4 
           =4 #include <stdbool.h>
           =4 #include <intrinsics.h>
           =4 
           =4 # define SBIT(name, addr, bit)  __bit __no_init volatile bool name @ (addr+bit)
           =4 # define SFR(name, addr)        __sfr __no_init volatile unsigned char name @ addr
           =4 # define SFRX(name, addr)       __xdata __no_init volatile unsigned char name @ addr
           =4 # define SFR16(name, addr)      __sfr __no_init volatile unsigned int  name @ addr
           =4 # define SFR16E(name, fulladdr) /* not supported */
           =4 # define SFR32(name, fulladdr) /* not supported */
           =4 # define SFR32E(name, fulladdr) /* not supported */
           =4 
           =4 # define SEG_GENERIC __generic
           =4 # define SEG_FAR  __xdata
           =4 # define SEG_DATA __data
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 65  

           =4 # define SEG_NEAR __data
           =4 # define SEG_IDATA __idata
           =4 # define SEG_XDATA __xdata
           =4 # define SEG_PDATA __pdata
           =4 # define SEG_CODE  __code
           =4 # define SEG_BDATA __bdata
           =4 
           =4 #define bit bool
           =4 
           =4 # define _PPTOSTR_(x) #x
           =4 # define _PPARAM_(address) _PPTOSTR_(vector=address * 8 + 3)
           =4 # define _PPARAM2_(regbank) _PPTOSTR_(register_bank=regbank)
           =4 # define INTERRUPT(name, vector) _Pragma(_PPARAM_(vector)) __interrupt void name(void)
           =4 # define INTERRUPT_PROTO(name, vector)  __interrupt void name(void)
           =4 # define INTERRUPT_USING(name, vector, regnum) _Pragma(_PPARAM2_(regnum)) _Pragma(_PPARAM_(vector)) __inte
             -rrupt void name(void)
           =4 # define INTERRUPT_PROTO_USING(name, vector, regnum) __interrupt void name(void)
           =4 
           =4 # define FUNCTION_USING(name, return_value, parameter, regnum) /* not supported */
           =4 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) /* not supported */
           =4 // Note: IAR does not support functions using different register banks. Register
           =4 //       banks can only be specified in interrupts. If a function is called from
           =4 //       inside an interrupt, it will use the same register bank as the interrupt.
           =4 
           =4 # define SEGMENT_VARIABLE(name, vartype, locsegment)  locsegment vartype name
           =4 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment  * name
           =4 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =4 
           =4 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment __no_init vartype name @ addr
           =4 
           =4 // used with UU16
           =4 # define LSB 0
           =4 # define MSB 1
           =4 
           =4 // used with UU32 (b0 is least-significant byte)
           =4 # define b0 0
           =4 # define b1 1
           =4 # define b2 2
           =4 # define b3 3
           =4 
           =4 typedef unsigned char U8;
           =4 typedef unsigned int U16;
           =4 typedef unsigned long U32;
           =4 
           =4 typedef signed char S8;
           =4 typedef signed int S16;
           =4 typedef signed long S32;
           =4 
           =4 typedef union UU16
           =4 {
           =4    U16 U16;
           =4    S16 S16;
           =4    U8 U8[2];
           =4    S8 S8[2];
           =4 } UU16;
           =4 
           =4 typedef union UU32
           =4 {
           =4    U32 U32;
           =4    S32 S32;
           =4    UU16 UU16[2];
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 66  

           =4    U16 U16[2];
           =4    S16 S16[2];
           =4    U8 U8[4];
           =4    S8 S8[4];
           =4 } UU32;
           =4 
           =4 
           =4 #define NOP() __no_operation();
           =4 
           =4 // generic pointer memory type specifiers
           =4 #define SI_GPTR
           =4 #define SI_GPTR_MTYPE_DATA       0x01
           =4 #define SI_GPTR_MTYPE_IDATA      0x01
           =4 #define SI_GPTR_MTYPE_BDATA      0x01
           =4 #define SI_GPTR_MTYPE_PDATA      0x00
           =4 #define SI_GPTR_MTYPE_XDATA      0x00
           =4 #define SI_GPTR_MTYPE_CODE       0x80
           =4 
           =4 // generic pointer access struct
           =4 typedef union SI_GENERIC_PTR
           =4 {
           =4     U8 U8[3];
           =4     struct
           =4     {
           =4         UU16 ADDR;
           =4         U8 MTYPE;
           =4     } GPTR;
           =4 } SI_GENERIC_PTR;
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 // Crossware
           =4 // http://www.crossware.com
           =4 
           =4 #elif defined _XC51_VER
           =4 # define SBIT(name, addr, bit)  _sfrbit  name = (addr+bit)
           =4 # define SFR(name, addr)        _sfr     name = addr
           =4 # define SFR16(name, addr)      _sfrword name = addr
           =4 # define SFR16E(name, fulladdr) /* not supported */
           =4 # define SFR32(name, fulladdr)  /* not supported */
           =4 # define SFR32E(name, fulladdr) /* not supported */
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 // Wickenh盲user
           =4 // http://www.wickenhaeuser.de
           =4 
           =4 #elif defined __UC__
           =4 # define SBIT(name, addr, bit)  unsigned char bit  name @ (addr+bit)
           =4 # define SFR(name, addr)        near unsigned char name @ addr
           =4 # define SFR16(name, addr)      /* not supported */
           =4 # define SFR16E(name, fulladdr) /* not supported */
           =4 # define SFR32(name, fulladdr)  /* not supported */
           =4 # define SFR32E(name, fulladdr) /* not supported */
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 // Default
           =4 // Unknown compiler
           =4 
           =4 #else
           =4 # warning unrecognized compiler
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 67  

           =4 # define SBIT(name, addr, bit)  volatile bool           name
           =4 # define SFR(name, addr)        volatile unsigned char  name
           =4 # define SFRX(name, addr)       volatile unsigned char  name
           =4 # define SFR16(name, addr)      volatile unsigned short name
           =4 # define SFR16E(name, fulladdr) volatile unsigned short name
           =4 # define SFR32(name, fulladdr)  volatile unsigned long  name
           =4 # define SFR32E(name, fulladdr) volatile unsigned long  name
           =4 
           =4 #endif
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 // Header File PreProcessor Directive
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 #endif                                 // #define COMPILER_DEFS_H
 804      =4  
 805      =4  //-----------------------------------------------------------------------------
 806      =4  // End Of File
 807      =4  //-----------------------------------------------------------------------------
   5      =3  #include "C8051F580_defs.h"
   1      =4  //-----------------------------------------------------------------------------
   2      =4  // C8051F580_defs.h
   3      =4  //-----------------------------------------------------------------------------
   4      =4  // Copyright 2008, Silicon Laboratories, Inc.
   5      =4  // http://www.silabs.com
   6      =4  //
   7      =4  // Program Description:
   8      =4  //
   9      =4  // Register/bit definitions for the C8051F58x family.
  10      =4  // **Important Note**: The compiler_defs.h header file should be included
  11      =4  // before including this header file.
  12      =4  //
  13      =4  // Target:         C8051F580/1/2/3/4/5/6/7,8/9-F590/1
  14      =4  // Tool chain:     Generic
  15      =4  // Command Line:   None
  16      =4  //
  17      =4  // Release 0.6 - 20 AUG 2012 (TP)
  18      =4  //    -Added #define for _XPAGE to provide support for SDCC memory paging
  19      =4  //     (pdata)
  20      =4  //
  21      =4  // Release 0.5 - 10 SEP 2011 (GP)
  22      =4  //    - Fixed SFR16 definition for CAN0IF2MC
  23      =4  //
  24      =4  // Release 0.4 - 08 OCT 2010 (TP)
  25      =4  //    - Fixed bit definitions for SCON0
  26      =4  //
  27      =4  // Release 0.3 - 01 APR 2009 (GP)
  28      =4  //    - Added SN0-SN3
  29      =4  //
  30      =4  // Release 0.2 - 29 JUL 2008 (ADT)
  31      =4  //    - Added Timer 4 bit definitions
  32      =4  //
  33      =4  // Release 0.1 - 09 JUL 2008 (GP)
  34      =4  //    - Initial Revision
  35      =4  //
  36      =4  //-----------------------------------------------------------------------------
  37      =4  // Header File Preprocessor Directive
  38      =4  //-----------------------------------------------------------------------------
  39      =4  
  40      =4  #ifndef C8051F580_DEFS_H
           =4 #define C8051F580_DEFS_H
           =4 
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 68  

           =4 //-----------------------------------------------------------------------------
           =4 // Page 0, Page 1 and Page F Registers
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 SFR (P0, 0x80);                        // Port 0 Latch
           =4 SFR (SP, 0x81);                        // Stack Pointer
           =4 SFR (DPL, 0x82);                       // Data Pointer Low
           =4 SFR (DPH, 0x83);                       // Data Pointer High
           =4 SFR (SFR0CN, 0x84);                    // SFR Page Control
           =4 SFR (SFRNEXT, 0x85);                   // SFR stack next page
           =4 SFR (SFRLAST, 0x86);                   // SFR stack last page
           =4 SFR (PCON, 0x87);                      // Power Control
           =4 SFR (TCON, 0x88);                      // Timer/Counter Control
           =4 SFR (TMOD, 0x89);                      // Timer/Counter Mode
           =4 SFR (TL0, 0x8A);                       // Timer/Counter 0 Low
           =4 SFR (TL1, 0x8B);                       // Timer/Counter 1 Low
           =4 SFR (TH0, 0x8C);                       // Timer/Counter 0 High
           =4 SFR (TH1, 0x8D);                       // Timer/Counter 1 High
           =4 SFR (CKCON, 0x8E);                     // Clock Control
           =4 SFR (PSCTL, 0x8F);                     // Program Store R/W Control
           =4 SFR (CLKSEL, 0x8F);                    // System clock select
           =4 SFR (P1, 0x90);                        // Port 1 Latch
           =4 SFR (TMR3CN, 0x91);                    // Timer/Counter 3 Control
           =4 SFR (TMR5CN, 0x91);                    // Timer/Counter 5 Control
           =4 SFR (TMR3RLL, 0x92);                   // Timer/Counter 3 Reload Low
           =4 SFR (TMR5CAPL, 0x92);                  // Timer/Counter 5 Capture Low
           =4 SFR (TMR3RLH, 0x93);                   // Timer/Counter 3 Reload High
           =4 SFR (TMR5CAPH, 0x93);                  // Timer/Counter 5 Capture High
           =4 SFR (TMR3L, 0x94);                     // Timer/Counter 3 Low
           =4 SFR (TMR5L, 0x94);                     // Timer/Counter 5 Low
           =4 SFR (TMR3H, 0x95);                     // Timer/Counter 3 High
           =4 SFR (TMR5H, 0x95);                     // Timer/Counter 5 High
           =4 SFR (TMR5CF, 0x96);                    // Timer/Counter 5 Configuration
           =4 SFR (CLKMUL, 0x97);                    // Clock Multiplier
           =4 SFR (SCON0, 0x98);                     // UART0 Control
           =4 SFR (SCON1, 0x98);                     // UART1 Control
           =4 SFR (SBUF0, 0x99);                     // UART0 Data Buffer
           =4 SFR (SBUF1, 0x99);                     // UART1 Data Buffer
           =4 SFR (CPT0CN, 0x9A);                    // Comparator 0 Control
           =4 SFR (CPT2CN, 0x9A);                    // Comparator 2 Control
           =4 SFR (CPT0MD, 0x9B);                    // Comparator 0 Mode
           =4 SFR (CPT2MD, 0x9B);                    // Comparator 2 Mode
           =4 SFR (CPT0MX, 0x9C);                    // Comparator 0 Mux
           =4 SFR (CPT2MX, 0x9C);                    // Comparator 2 Mux
           =4 SFR (CPT1CN, 0x9D);                    // Comparator 1 Control
           =4 SFR (CPT1MD, 0x9E);                    // Comparator 0 Mode
           =4 SFR (OSCIFIN, 0x9E);                   // Internal Oscillator Fine Control
           =4 SFR (CPT1MX, 0x9F);                    // Comparator 1 Mux
           =4 SFR (OSCXCN, 0x9F);                    // External Oscillator Control
           =4 SFR (P2, 0xA0);                        // Port 2 Latch
           =4 SFR (SPI0CFG, 0xA1);                   // SPI0 Configuration
           =4 SFR (OSCICN, 0xA1);                    // Internal Oscillator Control
           =4 SFR (SPI0CKR, 0xA2);                   // SPI0 Clock rate control
           =4 SFR (OSCICRS, 0xA2);                   // Internal Oscillator Coarse Control
           =4 SFR (SPI0DAT, 0xA3);                   // SPI0 Data Buffer
           =4 SFR (P0MDOUT, 0xA4);                   // Port 0 Output Mode
           =4 SFR (P1MDOUT, 0xA5);                   // Port 1 Output Mode
           =4 SFR (P2MDOUT, 0xA6);                   // Port 2 Output Mode
           =4 SFR (SFRPAGE, 0xA7);                   // SFR Page Select
           =4 SFR (IE, 0xA8);                        // Interrupt Enable
           =4 SFR (SMOD0, 0xA9);                     // Serial Port 0 Control
           =4 SFR (EMI0CN, 0xAA);                    // EMIF Control
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 69  

           =4 SFR (EMI0TC, 0xAA);                    // EMIF Timing control
           =4 SFR (SBCON0, 0xAB);                    // UART0 Baud Rate Generator Control
           =4 SFR (SBRLL0, 0xAC);                    // UART0 Baud Rate Generator Low
           =4 SFR (SBRLH0, 0xAD);                    // UART0 Baud Rate Generator High
           =4 SFR (P3MAT, 0xAE);                     // Port 3 Match
           =4 SFR (P3MDOUT, 0xAE);                   // Port 3 Mode
           =4 SFR (P3MASK, 0xAF);                    // Port 3 Mask
           =4 SFR (P4MDOUT, 0xAF);                   // Port 4 Mode
           =4 SFR (P3, 0xB0);                        // Port 3 Latch
           =4 SFR (P2MAT, 0xB1);                     // Port 2 Match
           =4 SFR (P2MASK, 0xB2);                    // Port 2 Mask
           =4 SFR (EMI0CF, 0xB2);                    // EMIF Configuration
           =4 SFR (P4, 0xB5);                        // Port 4 Latch
           =4 SFR (FLSCL, 0xB6);                     // Flash Scale
           =4 SFR (FLKEY, 0xB7);                     // Flash access limit
           =4 SFR (IP, 0xB8);                        // Interrupt Priority
           =4 SFR (SMB0ADR, 0xB9);                   // SMBus0 Slave address
           =4 SFR (ADC0TK, 0xBA);                    // ADC0 Tracking Mode Select
           =4 SFR (SMB0ADM, 0xBA);                   // SMBus0 Address Mask
           =4 SFR (ADC0MX, 0xBB);                    // AMUX0 Channel select
           =4 SFR (ADC0CF, 0xBC);                    // AMUX0 Channel configuration
           =4 SFR (ADC0L, 0xBD);                     // ADC0 Data Low
           =4 SFR (ADC0H, 0xBE);                     // ADC0 Data High
           =4 SFR (SMB0CN, 0xC0);                    // SMBus0 Control
           =4 SFR (SMB0CF, 0xC1);                    // SMBus0 Configuration
           =4 SFR (SMB0DAT, 0xC2);                   // SMBus0 Data
           =4 SFR (ADC0GTL, 0xC3);                   // ADC0 Greater-Than Compare Low
           =4 SFR (ADC0GTH, 0xC4);                   // ADC0 Greater-Than Compare High
           =4 SFR (ADC0LTL, 0xC5);                   // ADC0 Less-Than Compare Word Low
           =4 SFR (ADC0LTH, 0xC6);                   // ADC0 Less-Than Compare Word High
           =4 SFR (XBR3, 0xC6);                      // Port I/O Crossbar Control 3
           =4 SFR (XBR2, 0xC7);                      // Port I/O Crossbar Control 2
           =4 SFR (TMR2CN, 0xC8);                    // Timer/Counter 2 Control
           =4 SFR (TMR4CN, 0xC8);                    // Timer/Counter 4 Control
           =4 SFR (REG0CN, 0xC9);                    // Regulator Control
           =4 SFR (LIN0CF, 0xC9);                    // LIN 0 Configuration
           =4 SFR (TMR4CF, 0xC9);                    // Timer/Counter 4 Configuration
           =4 SFR (TMR2RLL, 0xCA);                   // Timer/Counter 2 Reload Low
           =4 SFR (TMR4CAPL, 0xCA);                  // Timer/Counter 4 Capture Low
           =4 SFR (TMR2RLH, 0xCB);                   // Timer/Counter 2 Reload High
           =4 SFR (TMR4CAPH, 0xCB);                  // Timer/Counter 4 Capture High
           =4 SFR (TMR2L, 0xCC);                     // Timer/Counter 2 Low
           =4 SFR (TMR4L, 0xCC);                     // Timer/Counter 4 Low
           =4 SFR (TMR2H, 0xCD);                     // Timer/Counter 2 High
           =4 SFR (TMR4H, 0xCD);                     // Timer/Counter 4 High
           =4 SFR (PCA0CPL5, 0xCE);                  // PCA0 Capture 5 Low
           =4 SFR (PCA1CPL11, 0xCE);                 // PCA1 Capture 11 Low
           =4 SFR (PCA0CPH5, 0xCF);                  // PCA0 Capture 5 High
           =4 SFR (PCA1CPH11, 0xCF);                 // PCA1 Capture 11 High
           =4 SFR (PSW, 0xD0);                       // Program Status Word
           =4 SFR (REF0CN, 0xD1);                    // Voltage Reference Control
           =4 SFR (LIN0DAT, 0xD2);                   // LIN0 Data
           =4 SFR (LIN0ADR, 0xD3);                   // LIN0 Address
           =4 SFR (P0SKIP, 0xD4);                    // Port 0 Skip
           =4 SFR (P1SKIP, 0xD5);                    // Port 1 Skip
           =4 SFR (P2SKIP, 0xD6);                    // Port 2 Skip
           =4 SFR (P3SKIP, 0xD7);                    // Port 3 Skip
           =4 SFR (PCA0CN, 0xD8);                    // PCA0 Control
           =4 SFR (PCA1CN, 0xD8);                    // PCA1 Control
           =4 SFR (PCA0MD, 0xD9);                    // PCA0 Mode
           =4 SFR (PCA1MD, 0xD9);                    // PCA1 Mode
           =4 SFR (PCA0PWM, 0xD9);                   // PCA0 PWM Control
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 70  

           =4 SFR (PCA0CPM0, 0xDA);                  // PCA0 Module 0 Mode
           =4 SFR (PCA1CPM6, 0xDA);                  // PCA1 Module 6 Mode
           =4 SFR (PCA1PWM, 0xDA);                   // PCA1 PWM Control
           =4 SFR (PCA0CPM1, 0xDB);                  // PCA0 Module 1  Mode
           =4 SFR (PCA1CPM7, 0xDB);                  // PCA1 Module 7  Mode
           =4 SFR (PCA0CPM2, 0xDC);                  // PCA0 Module 2  Mode
           =4 SFR (PCA1CPM8, 0xDC);                  // PCA1 Module 8  Mode
           =4 SFR (PCA0CPM3, 0xDD);                  // PCA0 Module 3  Mode
           =4 SFR (PCA1CPM9, 0xDD);                  // PCA1 Module 9  Mode
           =4 SFR (PCA0CPM4, 0xDE);                  // PCA0 Module 4  Mode
           =4 SFR (PCA1CPM10, 0xDE);                  // PCA1 Module 10 Mode
           =4 SFR (PCA0CPM5, 0xDF);                  // PCA0 Module 5  Mode
           =4 SFR (PCA1CPM11, 0xDF);                  // PCA1 Module 11 Mode
           =4 SFR (ACC, 0xE0);                       // Accumulator
           =4 SFR (XBR0, 0xE1);                      // Port I/O Crossbar Control 0
           =4 SFR (XBR1, 0xE2);                      // Port I/O Crossbar Control 1
           =4 SFR (CCH0CN, 0xE3);                    // Cache control
           =4 SFR (IT01CF, 0xE4);                    // INT0/INT1 Configuration
           =4 SFR (EIE1, 0xE6);                      // Extended Interrupt Enable 2
           =4 SFR (EIE2, 0xE7);                      // Extended Interrupt Enable 2
           =4 SFR (ADC0CN, 0xE8);                    // ADC0 Control
           =4 SFR (PCA0CPL1, 0xE9);                  // PCA0 Capture 1 Low
           =4 SFR (PCA1CPL1, 0xE9);                  // PCA1 Capture 7 Low
           =4 SFR (PCA0CPH1, 0xEA);                  // PCA0 Capture 1 High
           =4 SFR (PCA1CPH1, 0xEA);                  // PCA1 Capture 7 High
           =4 SFR (PCA0CPL2, 0xEB);                  // PCA0 Capture 2 Low
           =4 SFR (PCA1CPL2, 0xEB);                  // PCA1 Capture 8 Low
           =4 SFR (PCA0CPH2, 0xEC);                  // PCA0 Capture 2 High
           =4 SFR (PCA1CPH2, 0xEC);                  // PCA1 Capture 8 High
           =4 SFR (PCA0CPL3, 0xED);                  // PCA0 Capture 3 Low
           =4 SFR (PCA1CPL3, 0xED);                  // PCA1 Capture 9 Low
           =4 SFR (PCA0CPH3, 0xEE);                  // PCA0 Capture 3 High
           =4 SFR (PCA1CPH3, 0xEE);                  // PCA1 Capture 9 High
           =4 SFR (RSTSRC, 0xEF);                    // Reset Source Configuration/Status
           =4 SFR (B, 0xF0);                         // B Register
           =4 SFR (P0MAT, 0xF1);                     // Port 0 Match
           =4 SFR (P0MDIN, 0xF1);                    // Port 0 Input Mode
           =4 SFR (P0MASK, 0xF2);                    // Port 0 Mask
           =4 SFR (P1MDIN, 0xF2);                    // Port 1 Input Mode
           =4 SFR (P1MAT, 0xF3);                     // Port 1 Match
           =4 SFR (P2MDIN, 0xF3);                    // Port 2 Input Mode
           =4 SFR (P1MASK, 0xF4);                    // Port 1 Mask
           =4 SFR (P3MDIN, 0xF4);                    // Port 3 Input Mode
           =4 SFR (PSBANK, 0xF5);                    // Program Space Bank Select
           =4 SFR (EIP1, 0xF6);                      // External Interrupt Priority 1
           =4 SFR (EIP2, 0xF7);                      // External Interrupt Priority 2
           =4 SFR (SPI0CN, 0xF8);                    // SPI0 Control
           =4 SFR (PCA0L, 0xF9);                     // PCA0 Counter Low
           =4 SFR (PCA1L, 0xF9);                     // PCA1 Counter Low
           =4 SFR (SN0, 0xF9);                       // Serial Number 0
           =4 SFR (PCA0H, 0xFA);                     // PCA0 Counter High
           =4 SFR (PCA1H, 0xFA);                     // PCA1 Counter High
           =4 SFR (SN1, 0xFA);                       // Serial Number 1
           =4 SFR (PCA0CPL0, 0xFB);                  // PCA0 Capture 0 Low
           =4 SFR (PCA1CPL6, 0xFB);                  // PCA1 Capture 6 Low
           =4 SFR (SN2, 0xFB);                       // Serial Number 2
           =4 SFR (PCA0CPH0, 0xFC);                  // PCA0 Capture 0 High
           =4 SFR (PCA1CPH6, 0xFC);                  // PCA1 Capture 6 High
           =4 SFR (SN3, 0xFC);                       // Serial Number 3
           =4 SFR (PCA0CPL4, 0xFD);                  // PCA0 Capture 4 Low
           =4 SFR (PCA1CPL10, 0xFD);                 // PCA1 Capture 10 Low
           =4 SFR (PCA0CPH4, 0xFE);                  // PCA0 Capture 4 High
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 71  

           =4 SFR (PCA1CPH10, 0xFE);                 // PCA1 Capture 10 High
           =4 SFR (VDM0CN, 0xFF);                    // VDD Monitor Control
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 // Page C (CAN0) Registers
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 SFR (CAN0CFG, 0x92);                   // CAN0 Clock Configuration
           =4 SFR (CAN0STAT, 0x94);                  // Status Register Low Byte
           =4 SFR (CAN0ERRL, 0x96);                  // Error Counter Low Byte
           =4 SFR (CAN0ERRH, 0x97);                  // Error Counter High Byte
           =4 SFR (CAN0BTL, 0x9A);                   // Bit Timing Register Low Byte
           =4 SFR (CAN0BTH, 0x9B);                   // Bit Timing Register High Byte
           =4 SFR (CAN0IIDL, 0x9C);                  // Interrupt Register Low Byte
           =4 SFR (CAN0IIDH, 0x9D);                  // Interrupt Register High Byte
           =4 SFR (CAN0TST, 0x9E);                   // Test Register Low Byte
           =4 SFR (CAN0BRPE, 0xA1);                  // BRP Extension Register Low Byte
           =4 SFR (CAN0TR1L, 0xA2);                  // Transmission Request 1 Low Byte
           =4 SFR (CAN0TR1H, 0xA3);                  // Transmission Request 1 High Byte
           =4 SFR (CAN0TR2L, 0xA4);                  // Transmission Request 2 Low Byte
           =4 SFR (CAN0TR2H, 0xA5);                  // Transmission Request 2 High Byte
           =4 SFR (CAN0ND1L, 0xAA);                  // New Data 1 Low Byte
           =4 SFR (CAN0ND1H, 0xAB);                  // New Data 1 High Byte
           =4 SFR (CAN0ND2L, 0xAC);                  // New Data 2 Low Byte
           =4 SFR (CAN0ND2H, 0xAD);                  // New Data 2 High Byte
           =4 SFR (CAN0IP1L, 0xAE);                  // Interrupt Pending 1 Low Byte
           =4 SFR (CAN0IP1H, 0xAF);                  // Interrupt Pending 1 High Byte
           =4 SFR (CAN0IP2L, 0xB2);                  // Interrupt Pending 2 Low Byte
           =4 SFR (CAN0IP2H, 0xB3);                  // Interrupt Pending 2 High Byte
           =4 SFR (CAN0MV1L, 0xBA);                  // Message Valid 1 Low Byte
           =4 SFR (CAN0MV1H, 0xBB);                  // Message Valid 1 High Byte
           =4 SFR (CAN0MV2L, 0xBC);                  // Message Valid 2 Low Byte
           =4 SFR (CAN0MV2H, 0xBD);                  // Message Valid 2 High Byte
           =4 SFR (CAN0IF1CRL, 0xBE);                // IF1 Command Request Low Byte
           =4 SFR (CAN0IF1CRH, 0xBF);                // IF1 Command Request High Byte
           =4 SFR (CAN0CN, 0xC0);                    // CAN Control Register Low Byte
           =4 SFR (CAN0IF1CML, 0xC2);                // IF1 Command Mask Low Byte
           =4 SFR (CAN0IF1CMH, 0xC3);                // IF1 Command Mask High Byte
           =4 SFR (CAN0IF1M1L, 0xC4);                // IF1 Mask 1 Low Byte
           =4 SFR (CAN0IF1M1H, 0xC5);                // IF1 Mask 1 High Byte
           =4 SFR (CAN0IF1M2L, 0xC6);                // IF1 Mask 2 Low Byte
           =4 SFR (CAN0IF1M2H, 0xC7);                // IF1 Mask 2 High Byte
           =4 SFR (CAN0IF1A1L, 0xCA);                // IF1 Arbitration 1 Low Byte
           =4 SFR (CAN0IF1A1H, 0xCB);                // IF1 Arbitration 1 High Byte
           =4 SFR (CAN0IF1A2L, 0xCC);                // IF1 Arbitration 2 Low Byte
           =4 SFR (CAN0IF1A2H, 0xCD);                // IF1 Arbitration 2 High Byte
           =4 SFR (CAN0IF2MCL, 0xCE);                // IF2 Message Control Low Byte
           =4 SFR (CAN0IF2MCH, 0xCF);                // IF2 Message Control High Byte
           =4 SFR (CAN0IF1MCL, 0xD2);                // IF1 Message Control Low Byte
           =4 SFR (CAN0IF1MCH, 0xD3);                // IF1 Message Control High Byte
           =4 SFR (CAN0IF1DA1L, 0xD4);               // IF1 Data A 1 Low Byte
           =4 SFR (CAN0IF1DA1H, 0xD5);               // IF1 Data A 1 High Byte
           =4 SFR (CAN0IF1DA2L, 0xD6);               // IF1 Data A 2 Low Byte
           =4 SFR (CAN0IF1DA2H, 0xD7);               // IF1 Data A 2 High Byte
           =4 SFR (CAN0IF1DB1L, 0xDA);               // IF1 Data B 1 Low Byte
           =4 SFR (CAN0IF1DB1H, 0xDB);               // IF1 Data B 1 High Byte
           =4 SFR (CAN0IF1DB2L, 0xDC);               // IF1 Data B 2 Low Byte
           =4 SFR (CAN0IF1DB2H, 0xDD);               // IF1 Data B 2 High Byte
           =4 SFR (CAN0IF2CRL, 0xDE);                // IF2 Command Request Low Byte
           =4 SFR (CAN0IF2CRH, 0xDF);                // IF2 Command Request High Byte
           =4 SFR (CAN0IF2CML, 0xE2);                // IF2 Command Mask Low Byte
           =4 SFR (CAN0IF2CMH, 0xE3);                // IF2 Command Mask High Byte
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 72  

           =4 SFR (CAN0IF2M1L, 0xEA);                // IF2 Mask 1 Low Byte
           =4 SFR (CAN0IF2M1H, 0xEB);                // IF2 Mask 1 High Byte
           =4 SFR (CAN0IF2M2L, 0xEC);                // IF2 Mask 2 Low Byte
           =4 SFR (CAN0IF2M2H, 0xED);                // IF2 Mask 2 High Byte
           =4 SFR (CAN0IF2A1L, 0xEE);                // IF2 Arbitration 1 Low Byte
           =4 SFR (CAN0IF2A1H, 0xEF);                // IF2 Arbitration 1 High Byte
           =4 SFR (CAN0IF2A2L, 0xF2);                // IF2 Arbitration 2 Low Byte
           =4 SFR (CAN0IF2A2H, 0xF3);                // IF2 Arbitration 2 High Byte
           =4 SFR (CAN0IF2DA1L, 0xF6);               // IF2 Data A 1 Low Byte
           =4 SFR (CAN0IF2DA1H, 0xF7);               // IF2 Data A 1 High Byte
           =4 SFR (CAN0IF2DA2L, 0xFA);               // IF2 Data A 2 Low Byte
           =4 SFR (CAN0IF2DA2H, 0xFB);               // IF2 Data A 2 High Byte
           =4 SFR (CAN0IF2DB1L, 0xFC);               // IF2 Data B 1 Low Byte
           =4 SFR (CAN0IF2DB1H, 0xFD);               // IF2 Data B 1 High Byte
           =4 SFR (CAN0IF2DB2L, 0xFE);               // IF2 Data B 2 Low Byte
           =4 SFR (CAN0IF2DB2H, 0xFF);               // IF2 Data B 2 High Byte
           =4 
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 // 16-bit Register Definitions (might not be supported by all compilers)
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 SFR16 (DP, 0x82);                      // Data Pointer
           =4 SFR16 (TMR3RL, 0x92);                  // Timer 3 Reload
           =4 SFR16 (TMR5CAP, 0x92);                 // Timer 5 Capture
           =4 SFR16 (TMR3, 0x94);                    // Timer 3 Capture / Reload
           =4 SFR16 (TMR5, 0x94);                    // Timer 5
           =4 SFR16 (SBRL0, 0xAC);                   // UART0 Reload
           =4 SFR16 (ADC0, 0xBD);                    // ADC0 data
           =4 SFR16 (ADC0GT, 0xC3);                  // ADC0 Greater Than Window
           =4 SFR16 (ADC0LT, 0xC5);                  // ADC0 Less Than Window
           =4 SFR16 (TMR2RL, 0xCA);                  // Timer 2 Reload
           =4 SFR16 (TMR4CAP, 0xCA);                 // Timer 4 Capture
           =4 SFR16 (TMR2, 0xCC);                    // Timer 2 Capture / Reload
           =4 SFR16 (TMR4, 0xCC);                    // Timer 4
           =4 SFR16 (PCA0CP5, 0xCE);                 // PCA0 Module 5 Capture
           =4 SFR16 (PCA1CP11, 0xCE);                // PCA1 Module 11 Capture
           =4 SFR16 (PCA0CP1, 0xE9);                 // PCA0 Module 1 Capture
           =4 SFR16 (PCA1CP7, 0xE9);                 // PCA1 Module 7 Capture
           =4 SFR16 (PCA0CP2, 0xEB);                 // PCA0 Module 2 Capture
           =4 SFR16 (PCA1CP8, 0xEB);                 // PCA1 Module 8 Capture
           =4 SFR16 (PCA0CP3, 0xED);                 // PCA0 Module 3 Capture
           =4 SFR16 (PCA1CP9, 0xED);                 // PCA1 Module 9 Capture
           =4 SFR16 (PCA0, 0xF9);                    // PCA0 Counter
           =4 SFR16 (PCA1, 0xF9);                    // PCA1 Counter
           =4 SFR16 (PCA0CP0, 0xFB);                 // PCA0 Module 0 Capture
           =4 SFR16 (PCA1CP6, 0xFB);                 // PCA1 Module 6 Capture
           =4 SFR16 (PCA0CP4, 0xFD);                 // PCA0 Module 4 Capture
           =4 SFR16 (PCA1CP10, 0xFD);                 // PCA1 Module 10 Capture
           =4 
           =4 SFR16 (CAN0ERR, 0x96);                 // Error Counter
           =4 SFR16 (CAN0BT, 0x9A);                  // Bit Timing Register
           =4 SFR16 (CAN0IID, 0x9C);                 // Interrupt Register
           =4 SFR16 (CAN0TR1, 0xA2);                 // Transmission Request 1
           =4 SFR16 (CAN0TR2, 0xA4);                 // Transmission Request 2
           =4 SFR16 (CAN0ND1, 0xAA);                 // New Data 1
           =4 SFR16 (CAN0ND2, 0xAC);                 // New Data 2
           =4 SFR16 (CAN0IP1, 0xAE);                 // Interrupt Pending 1
           =4 SFR16 (CAN0IP2, 0xB2);                 // Interrupt Pending 2
           =4 SFR16 (CAN0MV1, 0xBA);                 // Message Valid 1
           =4 SFR16 (CAN0MV2, 0xBC);                 // Message Valid 2
           =4 SFR16 (CAN0IF1CR, 0xBE);               // IF1 Command Request
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 73  

           =4 SFR16 (CAN0IF1CM, 0xC2);               // IF1 Command Mask
           =4 SFR16 (CAN0IF1M1, 0xC4);               // IF1 Mask 1
           =4 SFR16 (CAN0IF1M2, 0xC6);               // IF1 Mask 2
           =4 SFR16 (CAN0IF1A1, 0xCA);               // IF1 Arbitration 1
           =4 SFR16 (CAN0IF1A2, 0xCC);               // IF1 Arbitration 2
           =4 SFR16 (CAN0IF1MC, 0xD2);               // IF1 Message Control
           =4 SFR16 (CAN0IF1DA1, 0xD4);              // IF1 Data A 1
           =4 SFR16 (CAN0IF1DA2, 0xD6);              // IF1 Data A 2
           =4 SFR16 (CAN0IF1DB1, 0xDA);              // IF1 Data B 1
           =4 SFR16 (CAN0IF1DB2, 0xDC);              // IF1 Data B 2
           =4 SFR16 (CAN0IF2CR, 0xDE);               // IF2 Command Request
           =4 SFR16 (CAN0IF2CM, 0xE2);               // IF2 Command Mask
           =4 SFR16 (CAN0IF2M1, 0xEA);               // IF2 Mask 1
           =4 SFR16 (CAN0IF2M2, 0xEC);               // IF2 Mask 2
           =4 SFR16 (CAN0IF2A1, 0xEE);               // IF2 Arbitration 1
           =4 SFR16 (CAN0IF2A2, 0xF2);               // IF2 Arbitration 2
           =4 SFR16 (CAN0IF2MC, 0xCE);               // IF2 Message Control
           =4 SFR16 (CAN0IF2DA1, 0xF6);              // IF2 Data A 1
           =4 SFR16 (CAN0IF2DA2, 0xFA);              // IF2 Data A 2
           =4 SFR16 (CAN0IF2DB1, 0xFC);              // IF2 Data B 1
           =4 SFR16 (CAN0IF2DB2, 0xFE);              // IF2 Data B 2
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 // LIN0 Indirect Registers
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 #define  LIN0DT1   0x00                // LIN0 Data Byte 1
           =4 #define  LIN0DT2   0x01                // LIN0 Data Byte 2
           =4 #define  LIN0DT3   0x02                // LIN0 Data Byte 3
           =4 #define  LIN0DT4   0x03                // LIN0 Data Byte 4
           =4 #define  LIN0DT5   0x04                // LIN0 Data Byte 5
           =4 #define  LIN0DT6   0x05                // LIN0 Data Byte 6
           =4 #define  LIN0DT7   0x06                // LIN0 Data Byte 7
           =4 #define  LIN0DT8   0x07                // LIN0 Data Byte 8
           =4 #define  LIN0CTRL  0x08                // LIN0 Control
           =4 #define  LIN0ST    0x09                // LIN0 Status
           =4 #define  LIN0ERR   0x0A                // LIN0 Error
           =4 #define  LIN0SIZE  0x0B                // LIN0 Message Size
           =4 #define  LIN0DIV   0x0C                // LIN0 Divider
           =4 #define  LIN0MUL   0x0D                // LIN0 Multiplier
           =4 #define  LIN0ID    0x0E                // LIN0 Identifier
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 // Address Definitions for Bit-addressable Registers
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 #define SFR_P0       0x80
           =4 #define SFR_TCON     0x88
           =4 #define SFR_P1       0x90
           =4 #define SFR_SCON0    0x98
           =4 #define SFR_SCON1    0x98
           =4 #define SFR_P2       0xA0
           =4 #define SFR_IE       0xA8
           =4 #define SFR_P3       0xB0
           =4 #define SFR_IP       0xB8
           =4 #define SFR_SMB0CN   0xC0
           =4 #define SFR_TMR2CN   0xC8
           =4 #define SFR_TMR4CN   0xC8
           =4 #define SFR_PSW      0xD0
           =4 #define SFR_PCA0CN   0xD8
           =4 #define SFR_PCA1CN   0xD8
           =4 #define SFR_ACC      0xE0
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 74  

           =4 #define SFR_ADC0CN   0xE8
           =4 #define SFR_B        0xF0
           =4 #define SFR_SPI0CN   0xF8
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 // Bit Definitions
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 // TCON 0x88
           =4 SBIT (TF1, SFR_TCON, 7);               // Timer 1 Overflow Flag
           =4 SBIT (TR1, SFR_TCON, 6);               // Timer 1 On/Off Control
           =4 SBIT (TF0, SFR_TCON, 5);               // Timer 0 Overflow Flag
           =4 SBIT (TR0, SFR_TCON, 4);               // Timer 0 On/Off Control
           =4 SBIT (IE1, SFR_TCON, 3);               // Ext. Interrupt 1 Edge Flag
           =4 SBIT (IT1, SFR_TCON, 2);               // Ext. Interrupt 1 Type
           =4 SBIT (IE0, SFR_TCON, 1);               // Ext. Interrupt 0 Edge Flag
           =4 SBIT (IT0, SFR_TCON, 0);               // Ext. Interrupt 0 Type
           =4 
           =4 // SCON0 0x98
           =4 SBIT (OVR0, SFR_SCON0, 7);             // UART0 Receive FIFO Overrun Flag
           =4 SBIT (PERR0, SFR_SCON0, 6);            // UART0 Parity Error Flag
           =4 SBIT (THRE0, SFR_SCON0, 5);            // UART0 Transmit Register Empty Flag
           =4 SBIT (REN0, SFR_SCON0, 4);             // UART0 RX Enable
           =4 SBIT (TBX0, SFR_SCON0, 3);             // UART0 Extra Transmission Bit
           =4 SBIT (RBX0, SFR_SCON0, 2);             // UART0 Extra Receive Bit
           =4 SBIT (TI0, SFR_SCON0, 1);              // UART0 TX Interrupt Flag
           =4 SBIT (RI0, SFR_SCON0, 0);              // UART0 RX Interrupt Flag
           =4 
           =4 // SCON1 0x98
           =4 SBIT (S1MODE, SFR_SCON1, 7);           // UART1 Mode 0
           =4                                        // Bit 6 UNUSED
           =4 SBIT (MCE1, SFR_SCON1, 5);             // UART1 Multiprocessor enable
           =4 SBIT (REN1, SFR_SCON1, 4);             // UART1 RX Enable
           =4 SBIT (TB81, SFR_SCON1, 3);             // UART1 TX Bit 8
           =4 SBIT (RB81, SFR_SCON1, 2);             // UART1 RX Bit 8
           =4 SBIT (TI1, SFR_SCON1, 1);              // UART1 TX Interrupt Flag
           =4 SBIT (RI1, SFR_SCON1, 0);              // UART1 RX Interrupt Flag
           =4 
           =4 // IE 0xA8
           =4 SBIT (EA, SFR_IE, 7);                  // Global Interrupt Enable
           =4 SBIT (ESPI0, SFR_IE, 6);               // SPI0 Interrupt Enable
           =4 SBIT (ET2, SFR_IE, 5);                 // Timer 2 Interrupt Enable
           =4 SBIT (ES0, SFR_IE, 4);                 // UART0 Interrupt Enable
           =4 SBIT (ET1, SFR_IE, 3);                 // Timer 1 Interrupt Enable
           =4 SBIT (EX1, SFR_IE, 2);                 // External Interrupt 1 Enable
           =4 SBIT (ET0, SFR_IE, 1);                 // Timer 0 Interrupt Enable
           =4 SBIT (EX0, SFR_IE, 0);                 // External Interrupt 0 Enable
           =4 
           =4 // IP 0xB8
           =4                                        // Bit 7 unused
           =4 SBIT (PSPI0, SFR_IP, 6);               // SPI0 Interrupt Priority
           =4 SBIT (PT2, SFR_IP, 5);                 // Timer 2 Priority
           =4 SBIT (PS0, SFR_IP, 4);                 // UART0 Priority
           =4 SBIT (PS, SFR_IP, 4);                  // UART0 Priority
           =4 SBIT (PT1, SFR_IP, 3);                 // Timer 1 Priority
           =4 SBIT (PX1, SFR_IP, 2);                 // External Interrupt 1 Priority
           =4 SBIT (PT0, SFR_IP, 1);                 // Timer 0 Priority
           =4 SBIT (PX0, SFR_IP, 0);                 // External Interrupt 0 Priority
           =4 
           =4 // SMB0CN 0xC0
           =4 SBIT (MASTER, SFR_SMB0CN, 7);          // SMBus0 Master/Slave Indicator
           =4 SBIT (TXMODE, SFR_SMB0CN, 6);          // SMBus0 Transmit Mode Indicator
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 75  

           =4 SBIT (STA, SFR_SMB0CN, 5);             // SMBus0 Start Flag
           =4 SBIT (STO, SFR_SMB0CN, 4);             // SMBus0 Stop Flag
           =4 SBIT (ACKRQ, SFR_SMB0CN, 3);           // SMBus0 Acknowledge Request
           =4 SBIT (ARBLOST, SFR_SMB0CN, 2);         // SMBus0 Arbitration Lost Indicator
           =4 SBIT (ACK, SFR_SMB0CN, 1);             // SMBus0 Acknowledge
           =4 SBIT (SI, SFR_SMB0CN, 0);              // SMBus0 Interrupt Flag
           =4 
           =4 // TMR2CN 0xC8
           =4 SBIT (TF2H, SFR_TMR2CN, 7);            // Timer 2 High-Byte Overflow Flag
           =4 SBIT (TF2L, SFR_TMR2CN, 6);            // Timer 2 Low-Byte  Overflow Flag
           =4 SBIT (TF2LEN, SFR_TMR2CN, 5);          // Timer 2 Low-Byte Flag Enable
           =4 SBIT (TF2CEN, SFR_TMR2CN, 4);          // Timer 2 Capture Enable
           =4 SBIT (T2SPLIT, SFR_TMR2CN, 3);         // Timer 2 Split-Mode Enable
           =4 SBIT (TR2, SFR_TMR2CN, 2);             // Timer 2 Run Enable
           =4 SBIT (T2RCLK, SFR_TMR2CN, 1);          // Timer 2 Xclk/Rclk Select
           =4 SBIT (T2XCLK, SFR_TMR2CN, 0);          // Timer 2 Clk/8 Clock Source
           =4 
           =4 // TMR4CN 0xC8
           =4 SBIT (TF4, SFR_TMR4CN, 7);             // Timer 4 Overflow/Underflow Flag
           =4 SBIT (EXF4, SFR_TMR4CN, 6);            // Timer 4 External Flag
           =4                                        // Bit 5 unused
           =4                                        // Bit 4 unused
           =4 SBIT (EXE4, SFR_TMR4CN, 3);            // Timer 4 External Enable
           =4 SBIT (TR4, SFR_TMR4CN, 2);             // Timer 4 Run Enable
           =4 SBIT (CT4, SFR_TMR4CN, 1);             // Timer 4 Counter/Timer Select
           =4 SBIT (CPRL4, SFR_TMR4CN, 0);           // Timer 4 Capture/Reload Select
           =4 
           =4 // PSW 0xD0
           =4 SBIT (CY, SFR_PSW, 7);                 // Carry Flag
           =4 SBIT (AC, SFR_PSW, 6);                 // Auxiliary Carry Flag
           =4 SBIT (F0, SFR_PSW, 5);                 // User Flag 0
           =4 SBIT (RS1, SFR_PSW, 4);                // Register Bank Select 1
           =4 SBIT (RS0, SFR_PSW, 3);                // Register Bank Select 0
           =4 SBIT (OV, SFR_PSW, 2);                 // Overflow Flag
           =4 SBIT (F1, SFR_PSW, 1);                 // User Flag 1
           =4 SBIT (P, SFR_PSW, 0);                  // Accumulator Parity Flag
           =4 
           =4 // PCA0CN 0xD8
           =4 SBIT (CF, SFR_PCA0CN, 7);              // PCA0 Counter Overflow Flag
           =4 SBIT (CR, SFR_PCA0CN, 6);              // PCA0 Counter Run Control Bit
           =4 SBIT (CCF5, SFR_PCA0CN, 5);            // PCA0 Module 5 Interrupt Flag
           =4 SBIT (CCF4, SFR_PCA0CN, 4);            // PCA0 Module 4 Interrupt Flag
           =4 SBIT (CCF3, SFR_PCA0CN, 3);            // PCA0 Module 3 Interrupt Flag
           =4 SBIT (CCF2, SFR_PCA0CN, 2);            // PCA0 Module 2 Interrupt Flag
           =4 SBIT (CCF1, SFR_PCA0CN, 1);            // PCA0 Module 1 Interrupt Flag
           =4 SBIT (CCF0, SFR_PCA0CN, 0);            // PCA0 Module 0 Interrupt Flag
           =4 
           =4 // PCA1CN 0xD8
           =4 SBIT (CF1, SFR_PCA1CN, 7);             // PCA1 Counter Overflow Flag
           =4 SBIT (CR1, SFR_PCA1CN, 6);             // PCA1 Counter Run Control Bit
           =4 SBIT (CCF11, SFR_PCA1CN, 5);           // PCA1 Module 11 Interrupt Flag
           =4 SBIT (CCF10, SFR_PCA1CN, 4);           // PCA1 Module 10 Interrupt Flag
           =4 SBIT (CCF9, SFR_PCA1CN, 3);            // PCA1 Module 9 Interrupt Flag
           =4 SBIT (CCF8, SFR_PCA1CN, 2);            // PCA1 Module 8 Interrupt Flag
           =4 SBIT (CCF7, SFR_PCA1CN, 1);            // PCA1 Module 7 Interrupt Flag
           =4 SBIT (CCF6, SFR_PCA1CN, 0);            // PCA1 Module 6 Interrupt Flag
           =4 
           =4 // ADC0CN 0xE8
           =4 SBIT (AD0EN, SFR_ADC0CN, 7);           // ADC0 Enable
           =4 SBIT (BURSTEN, SFR_ADC0CN, 6);         // ADC0 Burst Enable
           =4 SBIT (AD0INT, SFR_ADC0CN, 5);          // ADC0 EOC Interrupt Flag
           =4 SBIT (AD0BUSY, SFR_ADC0CN, 4);         // ADC0 Busy Flag
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 76  

           =4 SBIT (AD0WINT, SFR_ADC0CN, 3);         // ADC0 Window Compare Interrupt Flag
           =4 SBIT (AD0LJST, SFR_ADC0CN, 2);         // ADC0 Left Justified
           =4 SBIT (AD0CM1, SFR_ADC0CN, 1);          // ADC0 Start Of Conversion Mode Bit 1
           =4 SBIT (AD0CM0, SFR_ADC0CN, 0);          // ADC0 Start Of Conversion Mode Bit 0
           =4 
           =4 // SPI0CN 0xF8
           =4 SBIT (SPIF, SFR_SPI0CN, 7);            // SPI0 Interrupt Flag
           =4 SBIT (WCOL, SFR_SPI0CN, 6);            // SPI0 Write Collision Flag
           =4 SBIT (MODF, SFR_SPI0CN, 5);            // SPI0 Mode Fault Flag
           =4 SBIT (RXOVRN, SFR_SPI0CN, 4);          // SPI0 RX Overrun Flag
           =4 SBIT (NSSMD1, SFR_SPI0CN, 3);          // SPI0 Slave Select Mode 1
           =4 SBIT (NSSMD0, SFR_SPI0CN, 2);          // SPI0 Slave Select Mode 0
           =4 SBIT (TXBMT, SFR_SPI0CN, 1);           // SPI0 TX Buffer Empty Flag
           =4 SBIT (SPIEN, SFR_SPI0CN, 0);           // SPI0 Enable
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 // Interrupt Priorities
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 #define INTERRUPT_INT0             0   // External Interrupt 0
           =4 #define INTERRUPT_TIMER0           1   // Timer 0 Overflow
           =4 #define INTERRUPT_INT1             2   // External Interrupt 1
           =4 #define INTERRUPT_TIMER1           3   // Timer 1 Overflow
           =4 #define INTERRUPT_UART0            4   // UART0
           =4 #define INTERRUPT_TIMER2           5   // Timer 2 Overflow
           =4 #define INTERRUPT_SPI0             6   // SPI0
           =4 #define INTERRUPT_SMBUS0           7   // SMBus0 Interface
           =4 #define INTERRUPT_ADC0_WINDOW      8   // ADC0 Window Comparison
           =4 #define INTERRUPT_ADC0_EOC         9   // ADC0 End Of Conversion
           =4 #define INTERRUPT_PCA0            10   // PCA0 Peripheral
           =4 #define INTERRUPT_COMPARATOR0     11   // Comparator 0 Comparison
           =4 #define INTERRUPT_COMPARATOR1     12   // Comparator 1 Comparison
           =4 #define INTERRUPT_TIMER3          13   // Timer 3 Overflow
           =4 #define INTERRUPT_LIN0            14   // LIN Bus Interrupt
           =4 #define INTERRUPT_VREG            15   // Voltage Regulator
           =4 #define INTERRUPT_CAN0            16   // CAN Bus Interrupt
           =4 #define INTERRUPT_PORT_MATCH      17   // Port Match
           =4 #define INTERRUPT_UART1           18   // UART1
           =4 #define INTERRUPT_PCA1            19   // PCA1 Peripheral
           =4 #define INTERRUPT_COMPARATOR2     20   // Comparator 2 Comparison
           =4 #define INTERRUPT_TIMER4          21   // Timer 4 Overflow
           =4 #define INTERRUPT_TIMER5          22   // Timer 5 Overflow
           =4 
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 // SFR Page Definitions
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 #define  CONFIG_PAGE       0x0F        // System and Port Configuration Page
           =4 #define  ACTIVE_PAGE       0x00        // Active Use Page
           =4 #define  ACTIVE2_PAGE      0x10        // Active Use Page 2
           =4 #define  CAN0_PAGE         0x0C        // CAN0 Registers
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 // SDCC PDATA External Memory Paging Support
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 #if defined SDCC
           =4 
           =4 SFR(_XPAGE, 0xAA); // Point to the EMI0CN register
           =4 
           =4 #endif
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 77  

           =4 
           =4 //-----------------------------------------------------------------------------
           =4 // Header File PreProcessor Directive
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 #endif                                 // #define C8051F580_DEFS_H
 607      =4  
 608      =4  //-----------------------------------------------------------------------------
 609      =4  // End Of File
 610      =4  //-----------------------------------------------------------------------------
   6      =3  /*****************************************************************************/
   7      =3  void initDeviceF580(void);
   8      =3  #endif
 145      =2  #endif
 146      =2  
 147      =2  #include "delay.h"
   1      =3  #ifndef __DELAY_H__
   2      =3  #define __DELAY_H__
   3      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
           =2 #include "i2c0.h"
           =2 #include "i2c1.h"
           =2 #include "i2c2.h"
           =2 #include "i2c3.h"
           =2 #include "i2c4.h"
           =2 #include "i2c5.h"
           =2 #include "i2c6.h"
           =2 #include "eprom.h"
           =2 #include "mcp47x6.h"
           =2 #include "inPca9554.h"
           =2 #include "outPca9554.h"
           =2 /*****************************************************************************/
           =2 #include "Modbus.h"
           =2 #include "ModbusPort.h"
           =2 /*****************************************************************************/
           =2 #include "sPlc.h"
           =2 #include "sPlcLaser.h"
           =2 //#include "pidFuzzy.h"
           =2 /*****************************************************************************/
           =2 //#include "AppMath.h"
           =2 //#include "chipAdc.h"
           =2 //#include "ad5621.h"
           =2 //#include "chipBeem.h"
           =2 
           =2 /*****************************************************************************/
           =2 #endif
   4      =3  #ifndef __DELAY_H__
   4      =3  #define __DELAY_H__
   4      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   5      =3  /*****************************************************************************/
   6      =3  void delayMs(uint8_t ms) reentrant;
   7      =3  void delayUs(uint8_t us) reentrant;
   8      =3  void hwDelayInit(uint8_t reload_h, uint8_t reload_l);
   9      =3  void hwDelay(uint8_t control, uint8_t reload_h, uint8_t reload_l);
  10      =3  /*****************************************************************************/
  11      =3  #endif
  12      =3  
   1      =3  #ifndef __I2C0_H__
   2      =3  #define __I2C0_H__
   3      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 78  

   4      =3  #ifndef __I2C0_H__
   4      =3  #define __I2C0_H__
   4      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   5      =3  /*****************************************************************************/
   6      =3  
   7      =3  /*****************************************************************************/
   8      =3  void iic0Init(void);
   9      =3  void iic0Start(void);
  10      =3  void iic0Stop(void);
  11      =3  uint8_t iic0WaitAck(void);
  12      =3  void iic0Ack(void);
  13      =3  void iic0NAck(void);
  14      =3  void iic0SendByte(uint8_t txd);
  15      =3  uint8_t iic0ReadByte(uint8_t ack);
  16      =3  
  17      =3  #endif
  18      =3  
  19      =3  
   1      =3  #ifndef __I2C1_H__
   2      =3  #define __I2C1_H__
   3      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   4      =3  #ifndef __I2C1_H__
   4      =3  #define __I2C1_H__
   4      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   5      =3  /*****************************************************************************/
   6      =3  
   7      =3  /*****************************************************************************/
   8      =3  void iic1Init(void);
   9      =3  void iic1Start(void);
  10      =3  void iic1Stop(void);
  11      =3  uint8_t iic1WaitAck(void);
  12      =3  void iic1Ack(void);
  13      =3  void iic1NAck(void);
  14      =3  void iic1SendByte(uint8_t txd);
  15      =3  uint8_t iic1ReadByte(uint8_t ack);
  16      =3  
  17      =3  #endif
  18      =3  
  19      =3  
   1      =3  #ifndef __I2C2_H__
   2      =3  #define __I2C2_H__
   3      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   4      =3  #ifndef __I2C2_H__
   4      =3  #define __I2C2_H__
   4      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   5      =3  /*****************************************************************************/
   6      =3  
   7      =3  /*****************************************************************************/
   8      =3  void iic2Init(void);
   9      =3  void iic2Start(void);
  10      =3  void iic2Stop(void);
  11      =3  uint8_t iic2WaitAck(void);
  12      =3  void iic2Ack(void);
  13      =3  void iic2NAck(void);
  14      =3  void iic2SendByte(uint8_t txd);
  15      =3  uint8_t iic2ReadByte(uint8_t ack);
  16      =3  
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 79  

  17      =3  #endif
  18      =3  
  19      =3  
   1      =3  #ifndef __I2C3_H__
   2      =3  #define __I2C3_H__
   3      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   4      =3  #ifndef __I2C3_H__
   4      =3  #define __I2C3_H__
   4      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   5      =3  /*****************************************************************************/
   6      =3  
   7      =3  /*****************************************************************************/
   8      =3  void iic3Init(void);
   9      =3  void iic3Start(void);
  10      =3  void iic3Stop(void);
  11      =3  uint8_t iic3WaitAck(void);
  12      =3  void iic3Ack(void);
  13      =3  void iic3NAck(void);
  14      =3  void iic3SendByte(uint8_t txd);
  15      =3  uint8_t iic3ReadByte(uint8_t ack);
  16      =3  
  17      =3  #endif
  18      =3  
  19      =3  
   1      =3  #ifndef __I2C4_H__
   2      =3  #define __I2C4_H__
   3      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   4      =3  #ifndef __I2C4_H__
   4      =3  #define __I2C4_H__
   4      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   5      =3  /*****************************************************************************/
   6      =3  
   7      =3  /*****************************************************************************/
   8      =3  void iic4Init(void);
   9      =3  void iic4Start(void);
  10      =3  void iic4Stop(void);
  11      =3  uint8_t iic4WaitAck(void);
  12      =3  void iic4Ack(void);
  13      =3  void iic4NAck(void);
  14      =3  void iic4SendByte(uint8_t txd);
  15      =3  uint8_t iic4ReadByte(uint8_t ack);
  16      =3  
  17      =3  #endif
  18      =3  
  19      =3  
   1      =3  #ifndef __I2C5_H__
   2      =3  #define __I2C5_H__
   3      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   4      =3  #ifndef __I2C5_H__
   4      =3  #define __I2C5_H__
   4      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   5      =3  /*****************************************************************************/
   6      =3  
   7      =3  /*****************************************************************************/
   8      =3  void iic5Init(void);
   9      =3  void iic5Start(void);
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 80  

  10      =3  void iic5Stop(void);
  11      =3  uint8_t iic5WaitAck(void);
  12      =3  void iic5Ack(void);
  13      =3  void iic5NAck(void);
  14      =3  void iic5SendByte(uint8_t txd);
  15      =3  uint8_t iic5ReadByte(uint8_t ack);
  16      =3  
  17      =3  #endif
  18      =3  
  19      =3  
   1      =3  #ifndef __I2C6_H__
   2      =3  #define __I2C6_H__
   3      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   4      =3  #ifndef __I2C6_H__
   4      =3  #define __I2C6_H__
   4      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   5      =3  /*****************************************************************************/
   6      =3  
   7      =3  /*****************************************************************************/
   8      =3  void iic6Init(void);
   9      =3  void iic6Start(void);
  10      =3  void iic6Stop(void);
  11      =3  uint8_t iic6WaitAck(void);
  12      =3  void iic6Ack(void);
  13      =3  void iic6NAck(void);
  14      =3  void iic6SendByte(uint8_t txd);
  15      =3  uint8_t iic6ReadByte(uint8_t ack);
  16      =3  
  17      =3  #endif
  18      =3  
  19      =3  
   1      =3  #ifndef __EPROM_H__
   2      =3  #define __EPROM_H__
   3      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   4      =3  #ifndef __EPROM_H__
   4      =3  #define __EPROM_H__
   4      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   5      =3  /*****************************************************************************/
   6      =3  /*****************************************************************************/
   7      =3  void epromInit(void);
   8      =3  uint8_t epromReadOneByte(uint16_t ReadAddr);
   9      =3  void epromWriteOneByte(uint16_t WriteAddr, uint8_t DataToWrite);
  10      =3  void epromWriteLenByte(uint16_t WriteAddr, uint32_t DataToWrite, uint8_t Len);
  11      =3  uint32_t epromReadLenByte(uint16_t ReadAddr, uint8_t Len);
  12      =3  void epromRead(uint16_t ReadAddr,uint8_t *pBuffer,uint16_t NumToRead);
  13      =3  void epromWrite(uint16_t WriteAddr, uint8_t *pBuffer, uint16_t NumToWrite);
  14      =3  void epromTest(void);
  15      =3  #endif
   1      =3  #ifndef __MCP47X6_H__
   2      =3  #define __MCP47X6_H__
   3      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   4      =3  #ifndef __MCP47X6_H__
   4      =3  #define __MCP47X6_H__
   4      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   5      =3  /*****************************************************************************/
   6      =3  uint8_t mcp47x6Init(void);
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 81  

   7      =3  void mcp47x6Write(uint8_t channel, uint16_t dat);
   8      =3  #endif
   9      =3          
  10      =3  
  11      =3  
  12      =3  
  13      =3  
  14      =3  
  15      =3  
  16      =3  
  17      =3  
  18      =3  
  19      =3  
  20      =3  
   1      =3  #ifndef __INPCA9554_H__
   2      =3  #define __INPCA9554_H__
   3      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   4      =3  #ifndef __INPCA9554_H__
   4      =3  #define __INPCA9554_H__
   4      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   5      =3  /*****************************************************************************/
   6      =3  void inPca9554Init(void);
   7      =3  uint8_t inPca9554Read(void);
   8      =3  void inPca9554Write(uint8_t wdata);
   9      =3  
  10      =3  #endif
   1      =3  #ifndef __OUTPCA9554_H__
   2      =3  #define __OUTPCA9554_H__
   3      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   4      =3  #ifndef __OUTPCA9554_H__
   4      =3  #define __OUTPCA9554_H__
   4      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   5      =3  /*****************************************************************************/
   6      =3  void outPca9554Init(void);
   7      =3  uint8_t outPca9554Read(void);
   8      =3  void outPca9554Write(uint8_t wdata);
   9      =3  
  10      =3  #endif
   1      =3  #ifndef __MODBUS__H__
   2      =3  #define __MODBUS__H__
   3      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   4      =3  #ifndef __MODBUS__H__
   4      =3  #define __MODBUS__H__
   4      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   5      =3  /*****************************************************************************/
   6      =3  extern volatile uint16_t modbusTimerValue;
   7      =3  extern volatile uint8_t modbusReceiveCounter;// Collected data number
   8      =3  extern xdata volatile uint8_t modbusReceiveBuffer[CONFIG_MB_RTU_SLAVE_BUFFER_SIZE];
   9      =3  /*****************************************************************************/
  10      =3  extern void initModbus(uint8_t modbusSlaveAddress, uint32_t bd);
  11      =3  extern void modbusPorcess(void);
  12      =3  #endif
   1      =3  #ifndef __MODBUSPORT__H__
   2      =3  #define __MODBUSPORT__H__
   3      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 82  

   4      =3  #ifndef __MODBUSPORT__H__
   4      =3  #define __MODBUSPORT__H__
   4      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   5      =3  /*****************************************************************************/
   6      =3  extern void modBusUartInitialise(uint32_t baudrate);
   7      =3  extern void modBusTimerInitialise(void);
   8      =3  extern void modBusUartPutch(uint8_t c);
   9      =3  extern uint8_t modBusUartString(uint8_t *s, uint16_t Length);
  10      =3  extern void receiveInterrupt(uint8_t Data);
  11      =3  /*****************************************************************************/
  12      =3  #endif
           =1 /*****************************************************************************/
           =1 //线圈 保持 16 * 16 = 256BIT
           =1 #define MR_START                                                0
           =1 #define MR_END                                                  15
           =1 //线圈寄存器 非保持 16 * 16 = 256BIT
           =1 #define R_START                                                 16
           =1 #define R_END                                                   31
           =1 //数据寄存器 保持 128
           =1 #define DM_START                                                32
           =1 #define DM_END                                                  159
           =1 //数据寄存器 非保持 128个字
           =1 #define EM_START                                                160
           =1 #define EM_END                                                  287
           =1 //延时线圈
           =1 #define T_1MS_START                                             288//16个1mS
           =1 #define T_1MS_END                                               303
           =1 #define T_10MS_START                                    304//16个10mS
           =1 #define T_10MS_END                                              319
           =1 #define T_100MS_START                                   320//16个100mS
           =1 #define T_100MS_END                                             335
           =1 //延时计时器 
           =1 #define TD_1MS_START                                    336//16个1mS
           =1 #define TD_1MS_END                                              351
           =1 #define TD_10MS_START                                   352//16个10mS
           =1 #define TD_10MS_END                                             367
           =1 #define TD_100MS_START                                  368//16个100mS
           =1 #define TD_100MS_END                                    383
           =1 //计数器
           =1 #define C_START                                                 384//16个计数器
           =1 #define C_END                                                   399//
           =1 //输入位寄存器 16 * 16 = 256个
           =1 #define X_START                                                 400//
           =1 #define X_END                                                   415// 
           =1 //输出位寄存器 16 * 16 = 256个
           =1 #define Y_START                                                 416// 
           =1 #define Y_END                                                   431//
           =1 //特殊寄存器 64个字
           =1 #define SPREG_START                                             432//
           =1 #define SPREG_END                                               495//
           =1 //特殊线圈      16 * 16 = 256个
           =1 #define SPCOIL_START                                    496
           =1 #define SPCOIL_END                                              511
           =1 /*****************************************************************************/
           =1 #define CONFIG_NVRAM_SIZE                               (SPCOIL_END + 1)
           =1 /*****************************************************************************/
           =1 #define SPREG_ADC_0                                             (SPREG_START + 0)
           =1 #define SPREG_ADC_1                                             (SPREG_START + 1)
           =1 #define SPREG_ADC_2                                             (SPREG_START + 2)
           =1 #define SPREG_ADC_3                                             (SPREG_START + 3)
           =1 #define SPREG_DAC_0                                             (SPREG_START + 4)
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 83  

           =1 #define SPREG_DAC_1                                             (SPREG_START + 5)
           =1 #define SPREG_DAC_2                                             (SPREG_START + 6)
           =1 #define SPREG_DAC_3                                             (SPREG_START + 7)
           =1 
           =1 #define SPCOIL_ON                                               0//长通线圈
           =1 #define SPCOIL_PS1MS                                    1//1mS间隔 50%占空比脉冲
           =1 #define SPCOIL_PS10MS                                   2//10mS
           =1 #define SPCOIL_PS100MS                                  3//100mS
           =1 /*****************************************************************************/
           =1 #define SP_EM_MODBUS_SLAVE_ERR                  300
           =1 #define SP_R_ON                                                 800//上电ON
           =1 #define SP_R_TICK_1MS                                   801//
           =1 #define SP_R_TICK_10MS                                  802//
           =1 #define SP_R_TICK_100MS                                 803//
           =1 #define SP_R_TICK_1S                                    804//
           =1 /*****************************************************************************/
           =1 extern uint16_t ModbusSlaveAsciiOverTimeCounter;//Modbus Slave通信超时计时器
           =1 extern xdata int16_t NVRAM0[CONFIG_NVRAM_SIZE];//掉电保持寄存器 当前
           =1 extern xdata int16_t NVRAM1[CONFIG_NVRAM_SIZE];//掉电保持寄存器 上一次
           =1 /*****************************************************************************/
           =1 void wdtDisable(void);//看门狗屏蔽
           =1 
           =1 void sPlcInit(void);//软逻辑初始化
           =1 void sPlcProcessStart(void);//sPLC轮询起始
           =1 void sPlcProcessEnd(void);//sPLC轮询结束
           =1 /*****************************************************************************/
           =1 void assertCoilAddress(uint16_t adr);
           =1 void assertRegisterAddress(uint16_t adr);
           =1 /*****************************************************************************/
           =1 void nvramUpdata(void);
           =1 void clearDM(void);
           =1 void clearEM(void);
           =1 void clearR(void);
           =1 void clearT(void);
           =1 void clearTD(void);
           =1 void clearC(void);
           =1 void nvramLoad(void);
           =1 void nvramSave(void);
           =1 void nvramUpdata(void);
           =1 /*****************************************************************************/
           =1 int16_t ADD(int16_t A, int16_t B);//加法指令
           =1 void SET(uint16_t A);//置位
           =1 void RESET(uint16_t A);//复位
           =1 void FLIP(uint16_t A);//翻转
           =1 uint8_t LD(uint16_t A);//载入
           =1 uint8_t LDP(uint16_t A);//脉冲上升沿
           =1 uint8_t LDN(uint16_t A);//脉冲下降沿
           =1 //void T100US(uint8_t A, uint8_t start, uint16_t value);
           =1 void T1MS(uint8_t A, uint8_t start, uint16_t value);//1mS延时器启动
           =1 void T10MS(uint8_t A, uint8_t start, uint16_t value);//10mS延时器启动
           =1 void T100MS(uint8_t A, uint8_t start, uint16_t value);//100mS延时器启动
           =1 void UPDAC(uint16_t dat);//立即更新DAC输出
           =1 void REBOOT(void);//SPLC复位指令
           =1 /*****************************************************************************/
           =1 void chipDacInit(void);
           =1 void chipAdcInit(void);
           =1 void sPlcInit(void);
           =1 void refreshInput(void);
           =1 void refreshOutput(void);
           =1 void refreshDac(void);
           =1 /*****************************************************************************/
           =1 #endif
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 84  

 163      =2  #ifndef __APPCONFIG_H__
 163      =2  #define __APPCONFIG_H__
 163      =2  /*****************************************************************************/
 163      =2  #define CONFIG_SYSCLK                       (22118400L)
 163      =2  #ifdef C8051F020
 163      =2  #define SAR_CLK                                                 2000000L//ADC0时钟 <2.5MHz
 163      =2  #endif
 163      =2  #define CONFIG_DEBUG                        0//调试功能
 163      =2  #define CONFIG_USING_WDT                                        0//使能看门狗
 163      =2  #define CONFIG_USING_RESET                                      0//使能PLC复位MCU功能
 163      =2  #define CONFIG_LADDER_SECTORS_START                     64//指令起始地址
 163      =2  #define CONFIG_LADDER_SECTORS_END                       128//指令结束地址
 163      =2  #define CONFIG_LASERTIMER_OVERFLOW_US           1000L//定时器周期 1mS
 163      =2  #define CONFIG_VERSION                                          0x0001
 163      =2  #define CONFIG_CHECK_CODE                                       0x5A7E
 163      =2  
 163      =2  /*****************************************************************************/
 163      =2  #define CONFIG_UART0_BAUDRATE                           57600//串口波特率
 163      =2  #define CONFIG_UART0_PARITY                                     NONE
 163      =2  #define CONFIG_UART0_STOPBIT                            1
 163      =2  #define CONFIG_UART0_DATABIT                            8
 163      =2  
 163      =2  #define CONFIG_UART1_BAUDRATE                           115200//串口波特率
 163      =2  #define CONFIG_UART1_PARITY                                     NONE
 163      =2  #define CONFIG_UART1_STOPBIT                            1
 163      =2  #define CONFIG_UART1_DATABIT                            8
 163      =2  /*****************************************************************************/
 163      =2  #define CONFIG_I2C0_FREQ                                        (100000L)               
 163      =2  #define CONFIG_I2C1_FREQ                                        (100000L)
 163      =2  #define CONFIG_I2C2_FREQ                                        (100000L)
 163      =2  #define CONFIG_I2C3_FREQ                                        (100000L)
 163      =2  #define CONFIG_I2C4_FREQ                                        (100000L)
 163      =2  /*****************************************************************************/
 163      =2  #define CONFIG_EPROM_SIZE                                       CONFIG_AT24C64_SIZE
 163      =2  #define CONFIG_AT24C02_SIZE                             256
 163      =2  #define CONFIG_AT24C04_SIZE                             512
 163      =2  #define CONFIG_AT24C08_SIZE                             1024
 163      =2  #define CONFIG_AT24C16_SIZE                             2048
 163      =2  #define CONFIG_AT24C32_SIZE                             4096
 163      =2  #define CONFIG_AT24C64_SIZE                                     8192
 163      =2  #define CONFIG_AT24C128_SIZE                            16384
 163      =2  #define CONFIG_AT24C256_SIZE                            32768
 163      =2  #define CONFIG_EPROM_ADDRESS                            0x50
 163      =2  #define CONFIG_EPROM_FRAM                                       0//铁电存储体无写入等待
 163      =2  #define CONFIG_EPROM_FREQ                                       1//
 163      =2  /*****************************************************************************/
 163      =2  #define CONFIG_USE_IPID                                         1//使能IPID温度控制
 163      =2  /*****************************************************************************/
 163      =2  #define CONFIG_USE_HWVER_SHOW                           1//使能固件版本显示
 163      =2  #define CONFIG_USE_MPD1_SHOW                            1//使能MPD1测量显示
 163      =2  #define CONFIG_USE_MPD2_SHOW                            1//使能MPD2测量显示
 163      =2  #define CONFIG_USE_FBS1                                         1//使能FBS1检测
 163      =2  #define CONFIG_USE_FBS2                                         1//使能FBS2检测
 163      =2  #define CONFIG_USE_LASER_TEMP                           1//使能激光器温度显示
 163      =2  #define CONFIG_USE_RADIATOR_TEMP                        1//使能散热器温度显示
 163      =2  #define CONFIG_USE_ENVI_TEMP                            1//使能环境温度显示
 163      =2  #define CONFIG_USE_IPID_UPDATE                          1//使能IPID参数更新功能
 163      =2  #define CONFIG_USE_IPID_OUTSHOW                         1//使能IPID输出显示
 163      =2  /*****************************************************************************/
 163      =2  //SPLC设置
 163      =2  #define CONFIG_SPLC_IO_INPUT_NUM                        16//硬件输入点数
 163      =2  #define CONFIG_SPLC_IO_OUTPUT_NUM                       16//硬件输出点数
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 85  

 163      =2  #define CONFIG_SOFTPLC_HWTIME                           1000L//1mS
 163      =2  #define CONFIG_INPUT_FILTER_TIME                        3//输入数字滤波扫描周期 1mS * N
 163      =2  #define CONFIG_IPID_RUN_CYCLE                           40//IPID运行周期 默认 40 * 100mS
 163      =2  #define CONFIG_IPID_PWM_CYCLE                           20//IPID输出周期 默认 20 * 100mS
 163      =2  /*****************************************************************************/
 163      =2  #define CONFIG_SPLC_USING_WDT                           0//看门狗启用
 163      =2  /*****************************************************************************/
 163      =2  #define CONFIG_SPLC_USING_IO_INPUT                      1//输入IO刷新启用
 163      =2  /*****************************************************************************/
 163      =2  #define CONFIG_SPLC_USING_IO_OUTPUT                     1//输出IO刷新启用
 163      =2  /*****************************************************************************/
 163      =2  #define CONFIG_SPLC_USING_EPROM                         0//EPROM掉电存储启用
 163      =2  /*****************************************************************************/
 163      =2  #define CONFIG_SPLC_USING_ADC                           0//使能ADC模块
 163      =2  #define CONFIG_SPLC_ADC_FILTER_TAP                      48//ADC位移滤波次数
 163      =2  #define CONFIG_SPLC_ADC_CHANNLE                         9//ADC通道数
 163      =2  #define CONFIG_SPLC_ADC_TEMP_SENSOR_GAIN    3330L// Temp Sensor Gain in (uV / degC)
 163      =2  #define CONFIG_SPLC_ADC_TEMP_SENSOR_OFFSET  856L// Temp Sensor Offset in mV
 163      =2  #define CONFIG_SPLC_ADC_INTERNAL_VREF           2200L// ADC Voltage Reference (mV)
 163      =2  #define CONFIG_SPLC_ADC_AMBIENT             25L// Ambient temp in deg C
 163      =2  /*****************************************************************************/
 163      =2  #define CONFIG_SPLC_USING_DAC                           1//是能DAC模块
 163      =2  /*****************************************************************************/
 163      =2  #define CONFIG_SPLC_USING_MB_RTU_SLAVE          1//是能MODBUS RTU从站
 163      =2  #define CONFIG_MB_RTU_SLAVE_TIMER                       1000L//1000uS
 163      =2  #define CONFIG_MB_RTU_SLAVE_ADDRESS                     0x01//从设备地址
 163      =2  #define CONFIG_MB_RTU_SLAVE_BUFFER_SIZE         256//发送接收缓冲区
 163      =2  #define CONFIG_MB_RTU_SLAVE_TIMEOUT                     100//接收通讯超时 10mS
 163      =2  #define CONFIG_MB_RTU_SLAVE_IO_DELAY            1//RX TX切换延时
 163      =2  /*****************************************************************************/
 163      =2  
 163      =2  /*****************************************************************************/
 163      =2  #define ID_ONLY_1_CHANNEL                                       4321
 163      =2  #define ID_ONLY_2_CHANNEL                                       8765
 163      =2  #define ID_BOTH_CHANNEL                                         9431
 163      =2  #define ID_LASER_MODE_CW                                        7631
 163      =2  #define ID_LASER_MODE_SP                                        8934
 163      =2  #define ID_LASER_MODE_MP                                        2453
 163      =2  #define ID_LASER_MODE_GP                                        3876
 163      =2  /*****************************************************************************/
 163      =2  #define FBS1_IN_PORT                                            3
 163      =2  #define FBS2_IN_PORT                                            2
 163      =2  #define COOLON_OUT_PORT                                         (1 * 8 + 3)
 163      =2  /*****************************************************************************/
 163      =2  //PID FUZZY 模糊PID配置
 163      =2  #define CONFIG_TECOUT_CYCLE                                     4000//PID输出转PWM周期
 163      =2  /*****************************************************************************/
 163      =2  /*****************************************************************************/
 163      =2  #define DISABLE_MODBUS_SERIAL_INTERRUPT         ES0 = 0;
 163      =2  #define ENABLE_MODBUS_SERIAL_INTERRUPT          ES0 = 1;
 163      =2  #define DISABLE_INTERRUPT                                       EA = 0;
 163      =2  #define ENABLE_INTERRUPT                                        EA = 1;
 163      =2  /*****************************************************************************/
 163      =2  #include "stdint.h"
 163      =2  #include "stdbool.h"
 163      =2  #include "endian.h"
 163      =2  #include "si_toolchain.h"
 163      =2  #include "compiler_defs.h"
 163      =2  #ifdef C8051F020
 163      =2  #include "C8051F020_defs.h"
 163      =2  #endif
 163      =2  #ifdef C8051F340
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 86  

 163      =2  #include "C8051F340_defs.h"
 163      =2  #endif
 163      =2  #ifdef C8051F580
 163      =2  #include "C8051F580_defs.h"
 163      =2  #endif
 163      =2  /*****************************************************************************/
 163      =2  #include <stdio.h>
 163      =2  #include <stdlib.h> 
 163      =2  #include <string.h>
 163      =2  #include <INTRINS.H>
 163      =2  #include <ctype.h>
 163      =2  #include <LIMITS.H>
 163      =2  #include <math.h>
 163      =2  #include "crc32.h"
 163      =2  /*****************************************************************************/
 163      =2  #ifdef C8051F020
 163      =2  #include "InitDeviceF020.h"
 163      =2  #endif
 163      =2  #ifdef C8051F580
 163      =2  #include "InitDeviceF580.h"
 163      =2  #endif
 163      =2  
 163      =2  #include "delay.h"
 163      =2  #include "i2c0.h"
 163      =2  #include "i2c1.h"
 163      =2  #include "i2c2.h"
 163      =2  #include "i2c3.h"
 163      =2  #include "i2c4.h"
 163      =2  #include "i2c5.h"
 163      =2  #include "i2c6.h"
 163      =2  #include "eprom.h"
 163      =2  #include "mcp47x6.h"
 163      =2  #include "inPca9554.h"
 163      =2  #include "outPca9554.h"
 163      =2  /*****************************************************************************/
 163      =2  #include "Modbus.h"
 163      =2  #include "ModbusPort.h"
 163      =2  /*****************************************************************************/
 163      =2  #include "sPlc.h"
 164      =2  #include "sPlcLaser.h"
   1      =3  #ifndef __SPLCLASER_H__
   2      =3  #define __SPLCLASER_H__
   3      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
           =2 //#include "pidFuzzy.h"
           =2 /*****************************************************************************/
           =2 //#include "AppMath.h"
           =2 //#include "chipAdc.h"
           =2 //#include "ad5621.h"
           =2 //#include "chipBeem.h"
           =2 
           =2 /*****************************************************************************/
           =2 #endif
   4      =3  #ifndef __SPLCLASER_H__
   4      =3  #define __SPLCLASER_H__
   4      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   5      =3  /*****************************************************************************/
   6      =3  #define MCP47X6_LASER_CHANNEL_CH1                                       0
   7      =3  #define MCP47X6_LASER_CHANNEL_CH2                                       1
   8      =3  #define LASER_MODE_CW                                                           0//连续模式
   9      =3  #define LASER_MODE_SP                                                           1//单脉冲模式
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 87  

  10      =3  #define LASER_MODE_MP                                                           2//多脉冲模式
  11      =3  #define LASER_MODE_GP                                                           3//群脉冲模式
  12      =3  
  13      =3  //R 线圈定义
  14      =3  #define R_KEY_MCU_RESET                                                         0//MCU复位请求
  15      =3  #define R_KEY_MCU_ERROR_CLEAR                                           1//MCU错误清除
  16      =3  #define R_KEY_LASER_START                                                       2//激光发射按键
  17      =3  #define R_KEY_LASER_STOP                                                        3//激光停止按键
  18      =3  #define R_KEY_LASER_READY                                                       4//准备按键
  19      =3  #define R_KEY_LASER_SELECT_CH1                                          5//激光选择CH1按键
  20      =3  #define R_KEY_LASER_SELECT_CH2                                          6//激光选择CH2按键
  21      =3  #define R_KEY_LASER_SELECT_BOTH                                         7//激光旋转CH1+CH2按键
  22      =3  #define R_KEY_INFO_RESET                                                        8//激光发射信息复位按键
  23      =3  #define R_KEY_PARA_SAVE                                                         9//参数储存按键
  24      =3  #define R_LASER_MODE_CW                                                         10//激光模式连续按键
  25      =3  #define R_LASER_MODE_PULSE                                                      11//激光模式脉冲连续按键
  26      =3  #define R_LASER_MODE_GP                                                         12//激光模式可编程脉冲按键
  27      =3  #define R_FLAG_COOLING                                                          13//冷却指示
  28      =3  #define R_FLAG_LASER_EMITING                                            14//激光发射指示
  29      =3  #define R_FLAG_LASER_EMIT_OVER                                          15//激光发射完毕
  30      =3  #define R_FLAG_LASER_TIGGER                                                     16//激光发射触发
  31      =3  #define R_FLAG_READY                                                            17//准备状态
  32      =3  #define R_FLAG_STANDBY                                                          18//待机状态
  33      =3  #define R_FLAG_FIBER_MECH_DETECT                                        19//光纤机械传感器
  34      =3  #define R_FLAG_FIBER_NFC_DETECT                                         20//光纤NFC传感器
  35      =3  #define R_FLAG_OPENCASE_DETECT                                          21//开箱检测
  36      =3  #define R_FLAG_WIRE_FOOTSWITCH                                          22//有线脚踏状态
  37      =3  #define R_FLAG_WIRELESS_FOOTSWITCH                                      23//无线脚踏状态
  38      =3  #define R_FLAG_MCU_HEART                                                        24//MCU心跳
  39      =3  #define R_FLAG_BEEM                                                                     25//蜂鸣器状态
  40      =3  //MR 线圈定义
  41      =3  #define MR_FIBER_MECH_DETECT_IGNORE                                     0//光纤探测机械忽略
  42      =3  #define MR_FIBER_NFC_DETCET_IGNORE                                      1//光纤探测NFC忽略
  43      =3  #define MR_OPENCASE_DETECT_IGNORE                                       2//开箱检测忽略
  44      =3  #define MR_AIM_ENABLE                                                           3//指示激光使能                                                 
  45      =3  #define MR_BEEM_ENABLE                                                          4//蜂鸣器使能
  46      =3  //EM 寄存器定义
  47      =3  #define EM_MCU_CHECKCODE                                                        0//MCU校验码
  48      =3  #define EM_MCU_HW_VER                                                           1//MCU硬件版本
  49      =3  #define EM_MCU_FW_VER                                                           2//MCU软件版本
  50      =3  #define EM_STEP_NUM                                                                     3//激光发射步骤号码
  51      =3  #define EM_LASER_POSWIDTH                                                       4//激光正脉宽
  52      =3  #define EM_LASER_NEGWIDTH                                                       5//激光负脉宽
  53      =3  #define EM_LASER_GROUP_SPACE                                            6//分组间隔//激光群脉冲间隔
  54      =3  #define EM_LASER_GROUP_NUM                                                      7//分组脉冲数//激光群脉冲个数
  55      =3  #define EM_LASER_POWER_CH1                                                      8//激光通道1功率设置
  56      =3  #define EM_LASER_POWER_CH2                                                      9//激光通道2功率设置
  57      =3  #define EM_LASER_POWER_TOTAL                                            10//激光总功率显示
  58      =3  #define EM_LASER_POWER_RATIO                                            11//激光功率比例显示
  59      =3  #define EM_LASER_RELEASE_ENERY                                          13//激光发射能量显示
  60      =3  #define EM_LASER_RELEASE_TIME                                           14//激光发射时间显示
  61      =3  #define EM_LASER_CURRENT_CH1                                            15//激光器电流0
  62      =3  #define EM_LASER_CURRENT_CH2                                            16//激光器电流1
  63      =3  #define EM_LASER_PD_CH1                                                         17//激光器反馈0
  64      =3  #define EM_LASER_PD_CH2                                                         18//激光器反馈1
  65      =3  #define EM_LASER_MODE                                                           19//激光发射模式
  66      =3  #define EM_LASER_SELECT_CHANNLE                                         20//激光通道选择
  67      =3  #define EM_LASER_TEMPERATURE                                            21//激光器温度
  68      =3  #define EM_LASER_TMATE                                                          22//计时器匹配值
  69      =3  #define EM_LASER_PMATE                                                          23//脉冲个数匹配值
  70      =3  #define EM_LASER_SMATE                                                          24//脉冲个数溢出值
  71      =3  #define EM_LASER_TOVERFLOW                                                      25//计时器溢出值
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 88  

  72      =3  #define EM_LASER_TCOUNTER                                                       26//计时器计数值
  73      =3  #define EM_LASER_PCOUNTER                                                       27//脉冲个数计数值
  74      =3  #define EM_LASER_SCOUNTER                                                       28//脉冲间隔计数值
  75      =3  #define EM_FAN_GET_SPEED_0                                                      29//风扇0转速读取
  76      =3  #define EM_FAN_GET_SPEED_1                                                      30//风扇1转速读取
  77      =3  #define EM_FAN_GET_SPEED_2                                                      31//风扇2转速读取
  78      =3  #define EM_DRIVER_TEMPERATURE                                           32//驱动器温度
  79      =3  #define EM_MCHIP_TEMPERATURE                                            33//板卡温度
  80      =3  //DM 寄存器定义
  81      =3  #define DM_PID_REF_TEMP//冷却温度设定
  82      =3  #define DM_PID_ON_TIME//PID输出开通时间
  83      =3  #define DM_PID_OFF_TIME//PID输出关闭时间
  84      =3  #define DM_PID_COEF_KP//PID系数比例KP
  85      =3  #define DM_PID_COEF_TI//PID系数积分时间TI
  86      =3  #define DM_PID_COEF_TD//PID系数微分时间TD
  87      =3  #define DM_FAN_SET_SPEED_0//风扇0转速设置
  88      =3  #define DM_FAN_SET_SPEED_1//风扇1转速设置
  89      =3  #define DM_FAN_SET_SPEED_2//风扇2转速设置
  90      =3  #define DM_SET_AIM_BRIGHT//指示激光亮度
  91      =3  #define DM_SET_BEEM_VOLUME//蜂鸣器音量
  92      =3  #define DM_SET_LCD_BRIGHT//液晶屏亮度
  93      =3  #define DM_LASER_PROTECT_HTEMP//激光器高温保护
  94      =3  #define DM_LASER_PROTCET_LTEMP//激光器低温保护
  95      =3  #define DM_DRIVE_PROTECT_HTEMP_//驱动器高温保护
  96      =3  #define DM_DRIVE_PROTECT_LTEMP//驱动器低温保护
  97      =3  #define DM_MCHIP_PROTECT_HTEMP//芯片高温保护
  98      =3  #define DM_MCHIP_PROTECT_LTEMP//芯片低温保护
  99      =3  
 100      =3  #endif
   2          /*****************************************************************************/                 
   3          /*****************************************************************************/
   4          xdata int16_t NVRAM0[CONFIG_NVRAM_SIZE];//掉电保持寄存器 当前
   5          xdata int16_t NVRAM1[CONFIG_NVRAM_SIZE];//掉电保持寄存器 上一次
   6          static data uint8_t TimerCounter_1mS = 0;
   7          static data uint8_t TimerCounter_10mS = 0;
   8          static data uint8_t Timer0_L, Timer0_H;
   9          /*****************************************************************************/
  10          typedef struct{//ADC滤波器
  11                  uint16_t dat[CONFIG_SPLC_ADC_FILTER_TAP];
  12                  uint16_t out;
  13                  uint8_t wIndex;//写入指针
  14          }adcTempDat_t;
  15          
  16          static pdata int8_t inputFilter[CONFIG_SPLC_IO_INPUT_NUM];//IO输入滤波器缓冲区
  17          static xdata adcTempDat_t adcTempDat[CONFIG_SPLC_ADC_CHANNLE];
  18          uint8_t adcSelect;//ADC通道选择
  19          static void refreshAdcData(adcTempDat_t *s , uint16_t dat);
  20          void adcProcess(void);
  21          static void initAdcData(adcTempDat_t *s);
  22          static void chipDacInit(void);
  23          static void chipAdcInit(void);
  24          /******************************************************************************/
  25          
  26          static void adcProcess(void){//循环采集ADC
  27   1              uint16_t result = 0;
  28   1      #ifdef C8051F020
                      while(!AD0INT);
              #endif
  31   1              result = (uint16_t)(ADC0H << 8) + (uint16_t)(ADC0L);
  32   1              refreshAdcData(&adcTempDat[adcSelect], result);
  33   1              NVRAM0[SPREG_ADC_0 + adcSelect] = adcTempDat[adcSelect].out;
  34   1              if(adcSelect < (CONFIG_SPLC_ADC_CHANNLE - 1)){
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 89  

  35   2                      adcSelect ++;
  36   2              }
  37   1              else{
  38   2                      adcSelect = 0;
  39   2              }
  40   1              switch(adcSelect){
  41   2                      case 0:{
  42   3                              //AMX0SL = 0x00;
  43   3                              break;
  44   3                      }
  45   2                      case 1:{
  46   3                              //AMX0SL = 0x01;
  47   3                              break;
  48   3                      }
  49   2                      case 2:{
  50   3                              //AMX0SL = 0x02;
  51   3                              break;
  52   3                      }
  53   2                      case 3:{
  54   3                              //AMX0SL = 0x03;
  55   3                              break;
  56   3                      }
  57   2                      case 4:{
  58   3                              //AMX0SL = 0x04;
  59   3                              break;
  60   3                      }
  61   2                      default:{
  62   3                              break;
  63   3                      }
  64   2              }
  65   1              AD0INT = 0;
  66   1              AD0BUSY = 1;//AD0BUSY写入1
  67   1      }
  68          static void initAdcData(adcTempDat_t *s){//初始化ADC滤波器
  69   1              uint8_t i;
  70   1              for(i = 0;i < CONFIG_SPLC_ADC_FILTER_TAP; i++){
  71   2                      s->dat[i] = 0x0;
  72   2              }
  73   1              s->out = 0;
  74   1              s->wIndex = 0;
  75   1      }
  76          static void refreshAdcData(adcTempDat_t *s , uint16_t dat){//更新ADC采集值
  77   1              uint8_t i;
  78   1              uint16_t temp;
  79   1              uint32_t sum;
  80   1              s->dat[s->wIndex] = dat;
  81   1              s->wIndex ++;
  82   1              if(s->wIndex >= CONFIG_SPLC_ADC_FILTER_TAP){
  83   2                      s->wIndex = 0;
  84   2              }
  85   1              sum = 0;
  86   1              for(i = 0;i < CONFIG_SPLC_ADC_FILTER_TAP;i ++){
  87   2                      sum += s->dat[i];
  88   2              }
  89   1              temp = (uint16_t)(sum / (uint32_t)CONFIG_SPLC_ADC_FILTER_TAP);
  90   1              s->out = temp;
  91   1      }
  92          void assertCoilAddress(uint16_t adr){//检查线圈地址
  93   1              if(adr > (SPREG_END * 16))
  94   1                      while(1);
  95   1      }
  96          void assertRegisterAddress(uint16_t adr){//检查寄存器地址
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 90  

  97   1              if(adr >= SPREG_END)
  98   1                      while(1);
  99   1      }
 100          void clearDM(void){//清除DM寄存器
 101   1              uint16_t i;
 102   1              for(i = 0;i <= DM_END;i ++)
 103   1              {
 104   2                      NVRAM0[i] = 0x0;
 105   2                      NVRAM1[i] = 0x0;
 106   2              }
 107   1      }
 108          void clearMR(void){//清除MR寄存器
 109   1              uint16_t i;
 110   1              for(i = MR_START;i <= MR_END;i ++)
 111   1              {
 112   2                      NVRAM0[i] = 0x0;
 113   2                      NVRAM1[i] = 0x0;
 114   2              }
 115   1      }
 116          void clearEM(void){//清除EM寄存器
 117   1              uint16_t i;
 118   1              for(i = EM_START;i <= EM_END;i ++)
 119   1              {
 120   2                      NVRAM0[i] = 0x0;
 121   2                      NVRAM1[i] = 0x0;
 122   2              }
 123   1      }
 124          void clearR(void){//清除R寄存器
 125   1              uint16_t i;
 126   1              for(i = R_START;i <= R_END;i ++)
 127   1              {
 128   2                      NVRAM0[i] = 0x0;
 129   2                      NVRAM1[i] = 0x0;
 130   2              }
 131   1      }
 132          void clearT(void){//清除T寄存器
 133   1              uint16_t i;
 134   1              for(i = T_1MS_START;i <= T_1MS_END;i ++)
 135   1              {
 136   2                      NVRAM0[i] = 0x0;
 137   2                      NVRAM1[i] = 0x0;
 138   2              }
 139   1              for(i = T_10MS_START;i <= T_10MS_END;i ++)
 140   1              {
 141   2                      NVRAM0[i] = 0x0;
 142   2                      NVRAM1[i] = 0x0;
 143   2              }
 144   1              for(i = T_100MS_START;i <= T_100MS_END;i ++)
 145   1              {
 146   2                      NVRAM0[i] = 0x0;
 147   2                      NVRAM1[i] = 0x0;
 148   2              }
 149   1      }
 150          void clearTD(void){//清除TD寄存器
 151   1              uint16_t i;
 152   1              for(i = TD_1MS_START;i <= TD_1MS_END;i ++)
 153   1              {
 154   2                      NVRAM0[i] = 0x0;
 155   2                      NVRAM1[i] = 0x0;
 156   2              }
 157   1              for(i = TD_10MS_START;i <= TD_10MS_END;i ++)
 158   1              {
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 91  

 159   2                      NVRAM0[i] = 0x0;
 160   2                      NVRAM1[i] = 0x0;
 161   2              }
 162   1              for(i = TD_100MS_START;i <= TD_100MS_END;i ++)
 163   1              {
 164   2                      NVRAM0[i] = 0x0;
 165   2                      NVRAM1[i] = 0x0;
 166   2              }
 167   1      }
 168          void clearC(void){//清除C寄存器
 169   1              uint16_t i;
 170   1              for(i = C_START;i <= C_END;i ++){
 171   2                      NVRAM0[i] = 0x0;
 172   2                      NVRAM1[i] = 0x0;
 173   2              }
 174   1      }
 175          void clearX(void){//清除X寄存器
 176   1              uint16_t i;
 177   1              for(i = X_START;i <= X_END;i ++){
 178   2                      NVRAM0[i] = 0x0;
 179   2                      NVRAM1[i] = 0x0;
 180   2              }
 181   1      }
 182          void clearY(void){//清除Y寄存器
 183   1              uint16_t i;
 184   1              for(i = Y_START;i <= Y_END;i ++){
 185   2                      NVRAM0[i] = 0x0;
 186   2                      NVRAM1[i] = 0x0;
 187   2              }
 188   1      }
 189          void clearSPREG(void){
 190   1              uint16_t i;
 191   1              for(i = SPREG_START;i <= SPREG_END;i ++){
 192   2                      NVRAM0[i] = 0x0;
 193   2                      NVRAM1[i] = 0x0;
 194   2              }
 195   1      }
 196          void clearSPCOIL(){
 197   1              uint16_t i;
 198   1              for(i = SPCOIL_START;i <= SPCOIL_END;i ++){
 199   2                      NVRAM0[i] = 0x0;
 200   2                      NVRAM1[i] = 0x0;
 201   2              }
 202   1      }
 203          static void nvramLoad(void){//从EPROM中载入NVRAM
 204   1              memset(NVRAM0, 0x0, (CONFIG_NVRAM_SIZE * 2));//初始化NVRAM
 205   1              epromRead(0, (uint8_t*)NVRAM0, (CONFIG_NVRAM_SIZE * 2));//从EPROM中恢复MR
 206   1              clearEM();
 207   1              clearR();
 208   1              clearT();
 209   1              clearTD();
 210   1              clearC();
 211   1              clearX();
 212   1              clearY();
 213   1              clearSPREG();
 214   1              clearSPCOIL();
 215   1              memcpy(NVRAM1, NVRAM0, CONFIG_NVRAM_SIZE);
 216   1      }
 217          static void nvramSave(void){//强制将NVRAM存入EPROM
 218   1              DISABLE_INTERRUPT//关闭中断
 219   1              epromWrite(0x0, (uint8_t*)NVRAM0, ((MR_END + 1) * 2));
 220   1              ENABLE_INTERRUPT
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 92  

 221   1      }
 222          static void nvramUpdata(void){//更新NVRAM->EPROM
 223   1              uint8_t *sp0, *sp1;
 224   1              uint16_t i;
 225   1              sp0 = (uint8_t*)(NVRAM0 + (MR_START * 2));
 226   1              sp1 = (uint8_t*)(NVRAM1 + (MR_START * 2));
 227   1              for(i = MR_START;i < ((MR_END + 1) * 2);i ++){//储存MR
 228   2                      if(*(sp0 + i) != *(sp1 + i)){
 229   3                              epromWriteOneByte(i, *(sp0 + i));
 230   3                      }
 231   2              }
 232   1              sp0 = (uint8_t*)(NVRAM0 + (DM_START * 2));
 233   1              sp1 = (uint8_t*)(NVRAM1 + (DM_START * 2));
 234   1              for(i = DM_START;i < ((DM_END + 1) * 2);i ++){//储存DM
 235   2                      if(*(sp0 + i) != *(sp1 + i)){
 236   3                              epromWriteOneByte(i, *(sp0 + i));
 237   3                      }
 238   2              }
 239   1              memcpy(NVRAM1, NVRAM0, (CONFIG_NVRAM_SIZE * 2));
 240   1      }
 241          int16_t ADD(int16_t A, int16_t B){//加法指令
 242   1              int32_t tmp;
 243   1              tmp = (int32_t)A + (int32_t)B;
 244   1              if(tmp >= INT_MAX)
 245   1                      tmp = INT_MAX;
 246   1              if(tmp <= INT_MIN)
 247   1                      tmp = INT_MIN;
 248   1              return (int16_t)tmp;
 249   1      }
 250          void SET(uint16_t A){//置位
 251   1              assertCoilAddress(A);//检查地址范围
 252   1              NVRAM0[(A / 16)] |= 1 << (A % 16);
 253   1      }
 254          void RESET(uint16_t A){//置零
 255   1              assertCoilAddress(A);//检查地址范围
 256   1              NVRAM0[(A / 16)] &= ~(1 << (A % 16));
 257   1      }
 258          void FLIP(uint16_t A){//翻转
 259   1              uint16_t temp;
 260   1              assertCoilAddress(A);//检查地址范围
 261   1              temp= NVRAM0[(A / 16)] & (1 << (A % 16));
 262   1              if(temp)
 263   1                      RESET(A);
 264   1              else
 265   1                      SET(A);
 266   1      }
 267          uint8_t LD(uint16_t A){//载入
 268   1              assertCoilAddress(A);//检查地址范围
 269   1              return (uint8_t)(NVRAM0[(A / 16)] >> NVRAM0[(A % 16)]);
 270   1      }
 271          uint8_t LDP(uint16_t A){//脉冲上升沿
 272   1              uint8_t temp0, temp1;
 273   1              assertCoilAddress(A);//检查地址范围
 274   1              temp0 = (uint8_t)(NVRAM0[(A / 16)] >> NVRAM0[(A % 16)]);
 275   1              temp1 = (uint8_t)(NVRAM1[(A / 16)] >> NVRAM1[(A % 16)]);
 276   1              if(temp0 && !temp1)
 277   1                      return 1;
 278   1              else
 279   1                      return 0;
 280   1      }
 281          uint8_t LDN(uint16_t A){//脉冲下降沿
 282   1              uint8_t temp0, temp1;
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 93  

 283   1              assertCoilAddress(A);
 284   1              temp0 = (uint8_t)(NVRAM0[(A / 16)] >> NVRAM0[(A % 16)]);
 285   1              temp1 = (uint8_t)(NVRAM1[(A / 16)] >> NVRAM1[(A % 16)]);
 286   1              if(!temp0 && temp1)
 287   1                      return 1;
 288   1              else
 289   1                      return 0;
 290   1      }
 291          void T1MS(uint8_t A, uint8_t start, uint16_t value){//1MS延时器
 292   1      #if CONFIG_DEBUG
                      if(A > (TD_1MS_END - TD_1MS_START + 1))
                              printf("T1MS:%d Over Num\n", A);
              #endif
 296   1              if(start){
 297   2                      if(NVRAM0[(TD_1MS_START + A)] >= value){
 298   3                              NVRAM0[(T_1MS_START + (A / 16))] |= 1 << (A % 16);
 299   3                      }
 300   2                      else{
 301   3                              NVRAM0[(T_1MS_START + (A / 16))] &= ~(1 << (A % 16));
 302   3                      }
 303   2                              
 304   2              }
 305   1              else{
 306   2                      NVRAM0[(T_1MS_START + (A / 16))] &= ~(1 << (A % 16));
 307   2                      NVRAM0[(TD_1MS_START + A)] = 0x0;
 308   2              }       
 309   1      }
 310          void T10MS(uint8_t A, uint8_t start, uint16_t value){//10MS延时器
 311   1      #if CONFIG_DEBUG
                      if(A > (TD_10MS_END - TD_10MS_START + 1))
                              printf("T10MS:%d Over Num\n", A);
              #endif
 315   1              if(start){
 316   2                      if(NVRAM0[(TD_10MS_START + A)] >= value){
 317   3                              NVRAM0[(T_10MS_START + (A / 16))] |= 1 << (A % 16);
 318   3                      }
 319   2                      else{
 320   3                              NVRAM0[(T_10MS_START + (A / 16))] &= ~(1 << (A % 16));
 321   3                      }
 322   2              }
 323   1              else{
 324   2                      NVRAM0[(T_10MS_START + (A / 16))] &= ~(1 << (A % 16));
 325   2                      NVRAM0[(TD_10MS_START + A)] = 0x0;
 326   2              }       
 327   1      }
 328          void T100MS(uint8_t A, uint8_t start, uint16_t value){//100MS延时器
 329   1      #if CONFIG_DEBUG
                      if(A > (TD_100MS_END - TD_100MS_START + 1))
                              printf("T100MS:%d Over Num\n", A);
              #endif
 333   1              if(start){
 334   2                      if(NVRAM0[(TD_100MS_START + A)] >= value){
 335   3                              NVRAM0[(T_100MS_START + (A / 16))] |= 1 << (A % 16);
 336   3                      }
 337   2                      else{
 338   3                              NVRAM0[(T_100MS_START + (A / 16))] &= ~(1 << (A % 16));
 339   3                      }       
 340   2              }
 341   1              else{
 342   2                      NVRAM0[(T_100MS_START + (A / 16))] &= ~(1 << (A % 16));
 343   2                      NVRAM0[(TD_100MS_START + A)] = 0x0;
 344   2              }
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 94  

 345   1      }
 346          
 347          int16_t TNTC(int16_t dat){//CODE转换为NTC测量温度温度
 348   1              uint16_t temp;
 349   1              fp32_t ftemp;
 350   1              if(dat >= CONFIG_SPLC_ADC_INTERNAL_VREF) dat = CONFIG_SPLC_ADC_INTERNAL_VREF;//限制输入最大值
 351   1              if(dat < 0) dat = 0;
 352   1              
 353   1              temp = (int16_t)(CONFIG_SPLC_ADC_INTERNAL_VREF * dat / 4096);//单位mV
 354   1              temp = 10000 * 5000 / (5000 - temp);//电源5V 分压电阻10K
 355   1              
 356   1              ftemp = ((1.0 / 3477)*log((fp32_t)(temp) / 10000)) + (1 / (25+273.0));//limo R25=10740,B=3450    uniquemode
             - 3988
 357   1              ftemp = ( 1.0 / ftemp ) - 273.0;
 358   1              if(ftemp >= 100) ftemp = 100;
 359   1              if(ftemp <= -100) ftemp = -100;
 360   1              return (int16_t)(ftemp * 10);
 361   1      }
 362          int16_t TENV(int16_t dat){//CODE转换为环境温度
 363   1              uint16_t temp;
 364   1              temp = (int16_t)(CONFIG_SPLC_ADC_INTERNAL_VREF * dat / 4096);//单位mV
 365   1              temp = (int16_t)((temp - CONFIG_SPLC_ADC_TEMP_SENSOR_OFFSET) * 1000 / CONFIG_SPLC_ADC_TEMP_SENSOR_GAIN);
 366   1              return temp;
 367   1      }
 368          void UPDAC(uint16_t dat){//立即更新DAC输出
 369   1              switch(dat){
 370   2                      case 0:{
 371   3                              mcp47x6Write(0, NVRAM0[SPREG_START + SPREG_DAC_0]);
 372   3                              break;
 373   3                      }
 374   2                      case 1:{
 375   3                              mcp47x6Write(1, NVRAM0[SPREG_START + SPREG_DAC_1]);
 376   3                              break;
 377   3                      }
 378   2                      case 2:{
 379   3                              mcp47x6Write(2, NVRAM0[SPREG_START + SPREG_DAC_2]);
 380   3                              break;
 381   3                      }
 382   2                      case 3:{
 383   3                              mcp47x6Write(3, NVRAM0[SPREG_START + SPREG_DAC_3]);
 384   3                              break;
 385   3                      }
 386   2                      default:break;
 387   2              }
 388   1      }
 389          void REBOOT(void){//MCU复位
 390   1      #ifdef C8051F580        
 391   1              uint8_t SFRPAGE_save;
 392   1      #endif
 393   1      #ifdef C8051F020
                      RSTSRC |= (1 << 1);//Forces a Power-On Reset. /RST is driven low.
              #endif
 396   1      #ifdef C8051F580
 397   1              SFRPAGE_save = SFRPAGE;
 398   1              SFRPAGE = ACTIVE_PAGE;
 399   1              RSTSRC |= (1 << 1);//Forces a Power-On Reset. /RST is driven low.
 400   1              SFRPAGE = SFRPAGE_save;
 401   1      #endif
 402   1              
 403   1      }
 404          static void wdtInit(void){//看门狗初始化
 405   1      #ifdef C8051F020
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 95  

                      WDTCN = 0;//47mS
              #endif
 408   1      }
 409          static void wdtEnable(void){//使能看门狗
 410   1      #ifdef C8051F020
                      WDTCN = 0xA5;
              #endif
 413   1      #ifdef C8051F580
 414   1      #endif
 415   1      }
 416          void wdtDisable(void){//关闭看门狗(未锁定)
 417   1              uint8_t flagEA;
 418   1              flagEA = EA;
 419   1              EA = 0;
 420   1      #ifdef C8051F020
                      WDTCN = 0xDE;
                  WDTCN = 0xAD;
              #endif
 424   1      #ifdef C8051F020
              #endif
 426   1              EA = flagEA;
 427   1      
 428   1      }
 429          static void wdtFeed(void){//喂狗
 430   1      #ifdef C8051F020
                      WDTCN = 0xA5;
              #endif
 433   1      }
 434          
 435          static void pcaInit(void){//硬件PCA初始化
 436   1      #ifdef C8051F020
              
              #endif
 439   1      #ifdef C8051F580
 440   1      //F580 CEX6,7,8 PWM OUT
 441   1      //F680 CEX9,10,11 PULSE IN
 442   1      #endif
 443   1      }
 444          
 445          static void timer0Init(void){//硬件sTimer计时器初始化
 446   1              data uint16_t temp;
 447   1              TimerCounter_1mS = 0;
 448   1              TimerCounter_10mS = 0;
 449   1      #ifdef C8051F020
                      temp = (uint16_t)(65536 - (CONFIG_SYSCLK / 12 /CONFIG_SOFTPLC_HWTIME));
                      Timer0_L = temp & 0xFF;
                      Timer0_H = (temp >> 8) & 0xFF;
                      TH0 = Timer0_H;// Init T0 High register
                      TL0 = Timer0_L;// Init T0 Low register
                      CKCON &= ~(1 << 3);//SYSCLK / 12        
                      TMOD &= 0xF0;
                      TMOD |= (1 << 0);// T0 in 16-bit mode
                      ET0 = 1;// T0 interrupt enabled
                      TR0 = 1;// T0 ON
              #endif
 461   1      }
*** WARNING C280 IN LINE 446 OF MainApp\sPlc.c: 'temp': unreferenced local variable
 462          static void timer0Isr(void) interrupt INTERRUPT_TIMER0{//硬件sTimer计时器中断 1mS
 463   1              uint16_t i;
 464   1              TF0 = 0;
 465   1              TR0 = 0;
 466   1              TH0 = Timer0_H;
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 96  

 467   1              TL0 = Timer0_L;
 468   1              TR0 = 1;
 469   1              if((NVRAM0[(SPCOIL_START + (SPCOIL_PS1MS / 16))] >> (SPCOIL_PS1MS % 16)) & 0x01){//ON
 470   2                      NVRAM0[(SPCOIL_START + (SPCOIL_PS1MS / 16))] &= ~(uint16_t)(1 << (SPCOIL_PS1MS % 16));
 471   2              }
 472   1              else{//OFF
 473   2                      NVRAM0[(SPCOIL_START + (SPCOIL_PS1MS / 16))] |= (uint16_t)(1 << (SPCOIL_PS1MS % 16));
 474   2              }
 475   1              
 476   1              for(i = TD_1MS_START;i <= TD_1MS_END;i ++){//1mS计时
 477   2                      if(NVRAM0[i] < SHRT_MAX){
 478   3                              NVRAM0[i] ++;
 479   3                      }
 480   2              }
 481   1              if(TimerCounter_1mS >= 10){//10mS计算
 482   2                      if((NVRAM0[(SPCOIL_START + (SPCOIL_PS10MS / 16))] >> (SPCOIL_PS10MS % 16)) & 0x01){//ON
 483   3                              NVRAM0[(SPCOIL_START + (SPCOIL_PS10MS / 16))] &= ~(uint16_t)(1 << (SPCOIL_PS10MS % 16));
 484   3                      }
 485   2                      else{//OFF
 486   3                              NVRAM0[(SPCOIL_START + (SPCOIL_PS10MS / 16))] |= (uint16_t)(1 << (SPCOIL_PS10MS % 16));
 487   3                      }
 488   2                      for(i = TD_10MS_START;i <= TD_10MS_END;i ++){
 489   3                              if(NVRAM0[i] < SHRT_MAX){
 490   4                                      NVRAM0[i] ++;
 491   4                              }
 492   3                      }
 493   2                      TimerCounter_10mS ++;
 494   2                      TimerCounter_1mS = 0;
 495   2              }
 496   1              if(TimerCounter_10mS >= 10){//100ms计算
 497   2                      if((NVRAM0[(SPCOIL_START + (SPCOIL_PS100MS / 16))] >> (SPCOIL_PS100MS % 16)) & 0x01){//ON
 498   3                              NVRAM0[(SPCOIL_START + (SPCOIL_PS100MS / 16))] &= ~(uint16_t)(1 << (SPCOIL_PS100MS % 16));
 499   3                      }
 500   2                      else{//OFF
 501   3                              NVRAM0[(SPCOIL_START + (SPCOIL_PS100MS / 16))] |= (uint16_t)(1 << (SPCOIL_PS100MS % 16));
 502   3                      }
 503   2                      for(i = TD_100MS_START;i < TD_100MS_END;i ++){
 504   3                              if(NVRAM0[i] < SHRT_MAX){
 505   4                                      NVRAM0[i] ++;
 506   4                              }
 507   3                      }
 508   2                      TimerCounter_10mS = 0;
 509   2              }
 510   1      #if CONFIG_SPLC_USING_ADC == 1
                      adcProcess();//ADC扫描
              #endif
 513   1              TimerCounter_1mS ++;
 514   1      }
 515          
 516          static void inputInit(void){
 517   1              memset(inputFilter, 0x0, CONFIG_SPLC_IO_INPUT_NUM);
 518   1      #ifdef C8051F020
              #endif
 520   1      #ifdef C8051F580
 521   1      #endif
 522   1      }
 523          static void outputInit(void){
 524   1      #ifdef C8051F020
                      
              #endif
 527   1      #ifdef C8051F580
 528   1              
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 97  

 529   1      #endif
 530   1      }
 531          static void inputRefresh(void){//获取输入IO
 532   1              uint8_t ctemp0,ctemp1, i;
 533   1              ctemp0 = 0;
 534   1              ctemp0 = 0;
 535   1      #ifdef C8051F020
                      //P4,P5输入
                      ctemp0 = P4;
                      ctemp1 = P5;
              #endif
 540   1      #ifdef C8051F580
 541   1              ctemp0 = inPca9554Read() ;
 542   1      #endif
 543   1              for(i = 0;i < 8;i ++){//X0-X7
 544   2                      if((ctemp0 >> i) & 0x01){
 545   3                              if(inputFilter[i] < CONFIG_INPUT_FILTER_TIME){
 546   4                                      inputFilter[i] ++;
 547   4                              }
 548   3                              else{
 549   4                                      NVRAM0[X_START] |= (int16_t)(1 << i);
 550   4                              }
 551   3                      }
 552   2                      else{
 553   3                              if(inputFilter[i] > (CONFIG_INPUT_FILTER_TIME * -1)){
 554   4                                      inputFilter[i] --;
 555   4                              }
 556   3                              else{
 557   4                                      NVRAM0[X_START] &= ~(uint16_t)(1 << i);
 558   4                              }
 559   3                      }
 560   2              }
 561   1              for(i = 8;i < 16;i ++){//X8-X15
 562   2                      if((ctemp1 >> (i - 8)) & 0x01){
 563   3                              if(inputFilter[i] < CONFIG_INPUT_FILTER_TIME){
 564   4                                      inputFilter[i] ++;
 565   4                              }
 566   3                              else{
 567   4                                      NVRAM0[X_START] |= (int16_t)(1 << i);
 568   4                              }
 569   3                      }
 570   2                      else{
 571   3                              if(inputFilter[i] > (CONFIG_INPUT_FILTER_TIME * -1)){
 572   4                                      inputFilter[i] --;
 573   4                              }
 574   3                              else{
 575   4                                      NVRAM0[X_START] &= ~(uint16_t)(1 << i);
 576   4                              }
 577   3                      }
 578   2              }
 579   1      }
 580          static void outputRefresh(void){//设置输出IO
 581   1      #ifdef C8051F020
                      //P6,P7输出IO
                      P6 = (NVRAM0[Y_START] & 0x00FF);
                      P7 = ((NVRAM0[Y_START] >> 8) & 0x00FF);
              #endif
 586   1      #ifdef C8051F580
 587   1              outPca9554Write(NVRAM0[Y_START]);
 588   1      #endif
 589   1      }
 590          static void chipAdcInit(void){//ADC模块初始化
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 98  

 591   1              uint8_t i;
 592   1      #ifdef C8051F020
                      ADC0CN = 0x0;//软件触发
                      ADC0CN |= (1 << 6);//AD0TM = 1 启用跟踪
                      ADC0CN |= (1 << 7);//AD0EN = 1 
                      ADC0CF = 0x0;
                      ADC0CF |= (CONFIG_SYSCLK / SAR_CLK) << 3;     // ADC conversion clock = 2.5MHz
                      AMX0CF = 0x00;                      // AIN inputs are single-ended (default)
                      AMX0SL = 0x00;                      // Select AIN0.1 pin as ADC mux input
                      AD0INT = 0;
                      AD0BUSY = 1;//AD0BUSY写入1
              #endif
 603   1              adcSelect = 0;
 604   1              for(i = 0;i <= CONFIG_SPLC_ADC_CHANNLE;i ++){
 605   2                      initAdcData(&adcTempDat[i]);
 606   2              }
 607   1      }
 608          void sPlcInit(void){//软逻辑初始化
 609   1              wdtInit();//看门狗使能
 610   1              wdtDisable();//屏蔽看门狗
 611   1              
 612   1      #if CONFIG_SPLC_USING_EPROM == 1
                      nvramLoad();//上电恢复NVRAM
              #endif
 615   1              
 616   1      #if CONFIG_SPLC_USING_ADC == 1
                      chipAdcInit();//初始化ADC模块
              #endif
 619   1              
 620   1      #if CONFIG_SPLC_USING_DAC == 1
 621   1              chipDacInit();//初始化DAC模块
 622   1      #endif
 623   1              
 624   1      #if CONFIG_SPLC_USING_MB_RTU_SLAVE == 1
 625   1              initModbus(CONFIG_MB_RTU_SLAVE_ADDRESS, CONFIG_UART0_BAUDRATE);
 626   1      #endif
 627   1              timer0Init();//初始化硬件计时器模块
 628   1              NVRAM0[(SPCOIL_START + (SPCOIL_ON / 16))] |= (uint16_t)(1 << (SPCOIL_ON % 16));
 629   1      }
 630          static void refreshDac(void){//刷新DAC
 631   1      #ifdef C8051F020
                      if(DAC0 != NVRAM0[SPREG_DAC_0]){
                              DAC0 = NVRAM0[SPREG_DAC_0];
                      }
                      if(DAC1 != NVRAM0[SPREG_DAC_1]){
                              DAC1 = NVRAM0[SPREG_DAC_1];
                      }
              #endif
 639   1      }
 640          static void chipDacInit(void){//初始化DAC
 641   1      #ifdef C8051F020
                      DAC0CN = 0x0;
                      DAC0CN |= (1 << 7);
                      DAC0 = 0;
                      DAC1 = 0;
              #endif
 647   1      }
 648          void sPlcProcessStart(void){//sPLC轮询起始
 649   1      #if CONFIG_SPLC_USING_MB_RTU_SLAVE == 1
 650   1              modbusPorcess();//处理MODBUS
 651   1      #endif
 652   1      #if CONFIG_SPLC_USING_IO_INPUT == 1
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 99  

 653   1              inputRefresh();//读取X口输入
 654   1      #endif
 655   1      #if CONFIG_SPLC_USING_WDT == 1
                      wdtFeed();
              #endif
 658   1      }
 659          void sPlcProcessEnd(void){//sPLC轮询结束
 660   1      #if CONFIG_SPLC_USING_WDT == 1
                      wdtFeed();//喂狗
              #endif
 663   1      #if CONFIG_SPLC_USING_IO_OUTPUT == 1
 664   1              outputRefresh();//更新Y口输出
 665   1      #endif
 666   1      #if CONFIG_SPLC_USING_DAC
 667   1              refreshDac();//更新DAC输出
 668   1      #endif
 669   1      #if CONFIG_SPLC_USING_EPROM == 1
                      nvramUpdata();//更新NVRAM
              #endif
 672   1      }
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 100 

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION adcProcess (BEGIN)
                                           ; SOURCE LINE # 26
                                           ; SOURCE LINE # 27
;---- Variable 'result' assigned to Register 'R4/R5' ----
0000 E4                CLR     A
0001 FC                MOV     R4,A
                                           ; SOURCE LINE # 31
0002 AFBE              MOV     R7,ADC0H
0004 EF                MOV     A,R7
0005 FE                MOV     R6,A
0006 ADBD              MOV     R5,ADC0L
0008 E4                CLR     A
0009 2D                ADD     A,R5
000A FD                MOV     R5,A
000B EC                MOV     A,R4
000C 3E                ADDC    A,R6
000D FC                MOV     R4,A
                                           ; SOURCE LINE # 32
000E E500        R     MOV     A,adcSelect
0010 75F063            MOV     B,#063H
0013 A4                MUL     AB
0014 2400        R     ADD     A,#LOW adcTempDat
0016 F9                MOV     R1,A
0017 7400        R     MOV     A,#HIGH adcTempDat
0019 35F0              ADDC    A,B
001B FA                MOV     R2,A
001C 7B01              MOV     R3,#01H
001E 120000      R     LCALL   _refreshAdcData
                                           ; SOURCE LINE # 33
0021 75F063            MOV     B,#063H
0024 E500        R     MOV     A,adcSelect
0026 A4                MUL     AB
0027 2400        R     ADD     A,#LOW adcTempDat+060H
0029 F582              MOV     DPL,A
002B E5F0              MOV     A,B
002D 3400        R     ADDC    A,#HIGH adcTempDat+060H
002F F583              MOV     DPH,A
0031 E0                MOVX    A,@DPTR
0032 FC                MOV     R4,A
0033 A3                INC     DPTR
0034 E0                MOVX    A,@DPTR
0035 FD                MOV     R5,A
0036 E500        R     MOV     A,adcSelect
0038 25E0              ADD     A,ACC
003A FF                MOV     R7,A
003B E4                CLR     A
003C 33                RLC     A
003D FE                MOV     R6,A
003E 7400        R     MOV     A,#LOW NVRAM0+0360H
0040 2F                ADD     A,R7
0041 F582              MOV     DPL,A
0043 7400        R     MOV     A,#HIGH NVRAM0+0360H
0045 3E                ADDC    A,R6
0046 F583              MOV     DPH,A
0048 EC                MOV     A,R4
0049 F0                MOVX    @DPTR,A
004A A3                INC     DPTR
004B ED                MOV     A,R5
004C F0                MOVX    @DPTR,A
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 101 

                                           ; SOURCE LINE # 34
004D E500        R     MOV     A,adcSelect
004F C3                CLR     C
0050 9408              SUBB    A,#08H
0052 5004              JNC     ?C0001
                                           ; SOURCE LINE # 35
0054 0500        R     INC     adcSelect
                                           ; SOURCE LINE # 36
0056 8003              SJMP    ?C0003
0058         ?C0001:
                                           ; SOURCE LINE # 37
                                           ; SOURCE LINE # 38
0058 E4                CLR     A
0059 F500        R     MOV     adcSelect,A
                                           ; SOURCE LINE # 39
005B         ?C0002:
                                           ; SOURCE LINE # 40
                                           ; SOURCE LINE # 41
                                           ; SOURCE LINE # 43
                                           ; SOURCE LINE # 44
                                           ; SOURCE LINE # 45
                                           ; SOURCE LINE # 47
                                           ; SOURCE LINE # 48
                                           ; SOURCE LINE # 49
                                           ; SOURCE LINE # 51
                                           ; SOURCE LINE # 52
                                           ; SOURCE LINE # 53
                                           ; SOURCE LINE # 55
                                           ; SOURCE LINE # 56
                                           ; SOURCE LINE # 57
                                           ; SOURCE LINE # 59
                                           ; SOURCE LINE # 60
                                           ; SOURCE LINE # 61
                                           ; SOURCE LINE # 62
                                           ; SOURCE LINE # 63
                                           ; SOURCE LINE # 64
005B         ?C0003:
                                           ; SOURCE LINE # 65
005B C2ED              CLR     AD0INT
                                           ; SOURCE LINE # 66
005D D2EC              SETB    AD0BUSY
                                           ; SOURCE LINE # 67
005F 22                RET     
             ; FUNCTION adcProcess (END)

             ; FUNCTION _initAdcData (BEGIN)
                                           ; SOURCE LINE # 68
0000 8B00        R     MOV     s,R3
0002 8A00        R     MOV     s+01H,R2
0004 8900        R     MOV     s+02H,R1
                                           ; SOURCE LINE # 70
;---- Variable 'i' assigned to Register 'R7' ----
0006 E4                CLR     A
0007 FF                MOV     R7,A
0008         ?C0011:
                                           ; SOURCE LINE # 71
0008 AB00        R     MOV     R3,s
000A AA00        R     MOV     R2,s+01H
000C A900        R     MOV     R1,s+02H
000E 75F002            MOV     B,#02H
0011 EF                MOV     A,R7
0012 A4                MUL     AB
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 102 

0013 F582              MOV     DPL,A
0015 85F083            MOV     DPH,B
0018 E4                CLR     A
0019 F5F0              MOV     B,A
001B 120000      E     LCALL   ?C?ISTOPTR
                                           ; SOURCE LINE # 72
001E 0F                INC     R7
001F BF30E6            CJNE    R7,#030H,?C0011
0022         ?C0012:
                                           ; SOURCE LINE # 73
0022 AB00        R     MOV     R3,s
0024 AA00        R     MOV     R2,s+01H
0026 A900        R     MOV     R1,s+02H
0028 900060            MOV     DPTR,#060H
002B E4                CLR     A
002C F5F0              MOV     B,A
002E 120000      E     LCALL   ?C?ISTOPTR
                                           ; SOURCE LINE # 74
0031 900062            MOV     DPTR,#062H
0034 E4                CLR     A
0035 020000      E     LJMP    ?C?CSTOPTR
             ; FUNCTION _initAdcData (END)

             ; FUNCTION _refreshAdcData (BEGIN)
                                           ; SOURCE LINE # 76
0000 8B00        R     MOV     s,R3
0002 8A00        R     MOV     s+01H,R2
0004 8900        R     MOV     s+02H,R1
;---- Variable 'dat' assigned to Register 'R4/R5' ----
                                           ; SOURCE LINE # 80
0006 900062            MOV     DPTR,#062H
0009 120000      E     LCALL   ?C?CLDOPTR
000C 75F002            MOV     B,#02H
000F A4                MUL     AB
0010 F582              MOV     DPL,A
0012 85F083            MOV     DPH,B
0015 EC                MOV     A,R4
0016 8DF0              MOV     B,R5
0018 120000      E     LCALL   ?C?ISTOPTR
                                           ; SOURCE LINE # 81
001B AB00        R     MOV     R3,s
001D AA00        R     MOV     R2,s+01H
001F A900        R     MOV     R1,s+02H
0021 900062            MOV     DPTR,#062H
0024 7401              MOV     A,#01H
0026 120000      E     LCALL   ?C?CILDOPTR
                                           ; SOURCE LINE # 82
0029 900062            MOV     DPTR,#062H
002C 120000      E     LCALL   ?C?CLDOPTR
002F C3                CLR     C
0030 9430              SUBB    A,#030H
0032 400D              JC      ?C0015
                                           ; SOURCE LINE # 83
0034 AB00        R     MOV     R3,s
0036 AA00        R     MOV     R2,s+01H
0038 A900        R     MOV     R1,s+02H
003A 900062            MOV     DPTR,#062H
003D E4                CLR     A
003E 120000      E     LCALL   ?C?CSTOPTR
                                           ; SOURCE LINE # 84
0041         ?C0015:
                                           ; SOURCE LINE # 85
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 103 

0041 E4                CLR     A
0042 F500        R     MOV     sum+03H,A
0044 F500        R     MOV     sum+02H,A
0046 F500        R     MOV     sum+01H,A
0048 F500        R     MOV     sum,A
                                           ; SOURCE LINE # 86
004A F500        R     MOV     i,A
004C         ?C0016:
                                           ; SOURCE LINE # 87
004C AB00        R     MOV     R3,s
004E AA00        R     MOV     R2,s+01H
0050 A900        R     MOV     R1,s+02H
0052 75F002            MOV     B,#02H
0055 E500        R     MOV     A,i
0057 A4                MUL     AB
0058 F582              MOV     DPL,A
005A 85F083            MOV     DPH,B
005D 120000      E     LCALL   ?C?ILDOPTR
0060 FF                MOV     R7,A
0061 AEF0              MOV     R6,B
0063 E4                CLR     A
0064 FC                MOV     R4,A
0065 FD                MOV     R5,A
0066 E500        R     MOV     A,sum+03H
0068 2F                ADD     A,R7
0069 F500        R     MOV     sum+03H,A
006B E500        R     MOV     A,sum+02H
006D 3E                ADDC    A,R6
006E F500        R     MOV     sum+02H,A
0070 ED                MOV     A,R5
0071 3500        R     ADDC    A,sum+01H
0073 F500        R     MOV     sum+01H,A
0075 EC                MOV     A,R4
0076 3500        R     ADDC    A,sum
0078 F500        R     MOV     sum,A
                                           ; SOURCE LINE # 88
007A 0500        R     INC     i
007C E500        R     MOV     A,i
007E B430CB            CJNE    A,#030H,?C0016
0081         ?C0017:
                                           ; SOURCE LINE # 89
0081 E4                CLR     A
0082 7B30              MOV     R3,#030H
0084 FA                MOV     R2,A
0085 F9                MOV     R1,A
0086 F8                MOV     R0,A
0087 AF00        R     MOV     R7,sum+03H
0089 AE00        R     MOV     R6,sum+02H
008B AD00        R     MOV     R5,sum+01H
008D AC00        R     MOV     R4,sum
008F 120000      E     LCALL   ?C?ULDIV
;---- Variable 'temp' assigned to Register 'R6/R7' ----
                                           ; SOURCE LINE # 90
0092 AB00        R     MOV     R3,s
0094 AA00        R     MOV     R2,s+01H
0096 A900        R     MOV     R1,s+02H
0098 900060            MOV     DPTR,#060H
009B EE                MOV     A,R6
009C 8FF0              MOV     B,R7
009E 020000      E     LJMP    ?C?ISTOPTR
             ; FUNCTION _refreshAdcData (END)

C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 104 

             ; FUNCTION L?0272 (BEGIN)
0000         L?0273:
0000 AD07              MOV     R5,AR7
0002 AC06              MOV     R4,AR6
             ; FUNCTION _assertCoilAddress (BEGIN)
                                           ; SOURCE LINE # 92
;---- Variable 'adr' assigned to Register 'R6/R7' ----
                                           ; SOURCE LINE # 93
0004 D3                SETB    C
0005 EF                MOV     A,R7
0006 94F0              SUBB    A,#0F0H
0008 EE                MOV     A,R6
0009 941E              SUBB    A,#01EH
000B 4002              JC      ?C0023
000D         ?C0021:
                                           ; SOURCE LINE # 94
000D 80FE              SJMP    ?C0021
                                           ; SOURCE LINE # 95
000F         ?C0023:
000F 22                RET     
             ; FUNCTION _assertCoilAddress (END)

             ; FUNCTION _assertRegisterAddress (BEGIN)
                                           ; SOURCE LINE # 96
;---- Variable 'adr' assigned to Register 'R6/R7' ----
                                           ; SOURCE LINE # 97
0000 C3                CLR     C
0001 EF                MOV     A,R7
0002 94EF              SUBB    A,#0EFH
0004 EE                MOV     A,R6
0005 9401              SUBB    A,#01H
0007 4002              JC      ?C0027
0009         ?C0025:
                                           ; SOURCE LINE # 98
0009 80FE              SJMP    ?C0025
                                           ; SOURCE LINE # 99
000B         ?C0027:
000B 22                RET     
             ; FUNCTION _assertRegisterAddress (END)

             ; FUNCTION clearDM (BEGIN)
                                           ; SOURCE LINE # 100
                                           ; SOURCE LINE # 102
;---- Variable 'i' assigned to Register 'R4/R5' ----
0000 E4                CLR     A
0001 FD                MOV     R5,A
0002 FC                MOV     R4,A
0003         ?C0028:
                                           ; SOURCE LINE # 103
                                           ; SOURCE LINE # 104
0003 ED                MOV     A,R5
0004 25E0              ADD     A,ACC
0006 FF                MOV     R7,A
0007 EC                MOV     A,R4
0008 33                RLC     A
0009 FE                MOV     R6,A
000A 7400        R     MOV     A,#LOW NVRAM0
000C 2F                ADD     A,R7
000D F582              MOV     DPL,A
000F 7400        R     MOV     A,#HIGH NVRAM0
0011 3E                ADDC    A,R6
0012 F583              MOV     DPH,A
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 105 

0014 E4                CLR     A
0015 F0                MOVX    @DPTR,A
0016 A3                INC     DPTR
0017 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 105
0018 7400        R     MOV     A,#LOW NVRAM1
001A 2F                ADD     A,R7
001B F582              MOV     DPL,A
001D 7400        R     MOV     A,#HIGH NVRAM1
001F 3E                ADDC    A,R6
0020 F583              MOV     DPH,A
0022 E4                CLR     A
0023 F0                MOVX    @DPTR,A
0024 A3                INC     DPTR
0025 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 106
0026 0D                INC     R5
0027 BD0001            CJNE    R5,#00H,?C0197
002A 0C                INC     R4
002B         ?C0197:
002B ED                MOV     A,R5
002C 64A0              XRL     A,#0A0H
002E 4C                ORL     A,R4
002F 70D2              JNZ     ?C0028
                                           ; SOURCE LINE # 107
0031         ?C0031:
0031 22                RET     
             ; FUNCTION clearDM (END)

             ; FUNCTION clearMR (BEGIN)
                                           ; SOURCE LINE # 108
                                           ; SOURCE LINE # 110
;---- Variable 'i' assigned to Register 'R4/R5' ----
0000 E4                CLR     A
0001 FD                MOV     R5,A
0002 FC                MOV     R4,A
0003         ?C0032:
                                           ; SOURCE LINE # 111
                                           ; SOURCE LINE # 112
0003 ED                MOV     A,R5
0004 25E0              ADD     A,ACC
0006 FF                MOV     R7,A
0007 EC                MOV     A,R4
0008 33                RLC     A
0009 FE                MOV     R6,A
000A 7400        R     MOV     A,#LOW NVRAM0
000C 2F                ADD     A,R7
000D F582              MOV     DPL,A
000F 7400        R     MOV     A,#HIGH NVRAM0
0011 3E                ADDC    A,R6
0012 F583              MOV     DPH,A
0014 E4                CLR     A
0015 F0                MOVX    @DPTR,A
0016 A3                INC     DPTR
0017 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 113
0018 7400        R     MOV     A,#LOW NVRAM1
001A 2F                ADD     A,R7
001B F582              MOV     DPL,A
001D 7400        R     MOV     A,#HIGH NVRAM1
001F 3E                ADDC    A,R6
0020 F583              MOV     DPH,A
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 106 

0022 E4                CLR     A
0023 F0                MOVX    @DPTR,A
0024 A3                INC     DPTR
0025 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 114
0026 0D                INC     R5
0027 BD0001            CJNE    R5,#00H,?C0198
002A 0C                INC     R4
002B         ?C0198:
002B ED                MOV     A,R5
002C 6410              XRL     A,#010H
002E 4C                ORL     A,R4
002F 70D2              JNZ     ?C0032
                                           ; SOURCE LINE # 115
0031         ?C0035:
0031 22                RET     
             ; FUNCTION clearMR (END)

             ; FUNCTION clearEM (BEGIN)
                                           ; SOURCE LINE # 116
                                           ; SOURCE LINE # 118
;---- Variable 'i' assigned to Register 'R4/R5' ----
0000 7DA0              MOV     R5,#0A0H
0002 7C00              MOV     R4,#00H
0004         ?C0036:
                                           ; SOURCE LINE # 119
                                           ; SOURCE LINE # 120
0004 ED                MOV     A,R5
0005 25E0              ADD     A,ACC
0007 FF                MOV     R7,A
0008 EC                MOV     A,R4
0009 33                RLC     A
000A FE                MOV     R6,A
000B 7400        R     MOV     A,#LOW NVRAM0
000D 2F                ADD     A,R7
000E F582              MOV     DPL,A
0010 7400        R     MOV     A,#HIGH NVRAM0
0012 3E                ADDC    A,R6
0013 F583              MOV     DPH,A
0015 E4                CLR     A
0016 F0                MOVX    @DPTR,A
0017 A3                INC     DPTR
0018 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 121
0019 7400        R     MOV     A,#LOW NVRAM1
001B 2F                ADD     A,R7
001C F582              MOV     DPL,A
001E 7400        R     MOV     A,#HIGH NVRAM1
0020 3E                ADDC    A,R6
0021 F583              MOV     DPH,A
0023 E4                CLR     A
0024 F0                MOVX    @DPTR,A
0025 A3                INC     DPTR
0026 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 122
0027 0D                INC     R5
0028 BD0001            CJNE    R5,#00H,?C0199
002B 0C                INC     R4
002C         ?C0199:
002C BC01D5            CJNE    R4,#01H,?C0036
002F BD20D2            CJNE    R5,#020H,?C0036
                                           ; SOURCE LINE # 123
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 107 

0032         ?C0039:
0032 22                RET     
             ; FUNCTION clearEM (END)

             ; FUNCTION clearR (BEGIN)
                                           ; SOURCE LINE # 124
                                           ; SOURCE LINE # 126
;---- Variable 'i' assigned to Register 'R4/R5' ----
0000 7D10              MOV     R5,#010H
0002 7C00              MOV     R4,#00H
0004         ?C0040:
                                           ; SOURCE LINE # 127
                                           ; SOURCE LINE # 128
0004 ED                MOV     A,R5
0005 25E0              ADD     A,ACC
0007 FF                MOV     R7,A
0008 EC                MOV     A,R4
0009 33                RLC     A
000A FE                MOV     R6,A
000B 7400        R     MOV     A,#LOW NVRAM0
000D 2F                ADD     A,R7
000E F582              MOV     DPL,A
0010 7400        R     MOV     A,#HIGH NVRAM0
0012 3E                ADDC    A,R6
0013 F583              MOV     DPH,A
0015 E4                CLR     A
0016 F0                MOVX    @DPTR,A
0017 A3                INC     DPTR
0018 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 129
0019 7400        R     MOV     A,#LOW NVRAM1
001B 2F                ADD     A,R7
001C F582              MOV     DPL,A
001E 7400        R     MOV     A,#HIGH NVRAM1
0020 3E                ADDC    A,R6
0021 F583              MOV     DPH,A
0023 E4                CLR     A
0024 F0                MOVX    @DPTR,A
0025 A3                INC     DPTR
0026 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 130
0027 0D                INC     R5
0028 BD0001            CJNE    R5,#00H,?C0200
002B 0C                INC     R4
002C         ?C0200:
002C ED                MOV     A,R5
002D 6420              XRL     A,#020H
002F 4C                ORL     A,R4
0030 70D2              JNZ     ?C0040
                                           ; SOURCE LINE # 131
0032         ?C0043:
0032 22                RET     
             ; FUNCTION clearR (END)

             ; FUNCTION clearT (BEGIN)
                                           ; SOURCE LINE # 132
                                           ; SOURCE LINE # 134
;---- Variable 'i' assigned to Register 'R4/R5' ----
0000 7D20              MOV     R5,#020H
0002 7C01              MOV     R4,#01H
0004         ?C0044:
                                           ; SOURCE LINE # 135
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 108 

                                           ; SOURCE LINE # 136
0004 ED                MOV     A,R5
0005 25E0              ADD     A,ACC
0007 FF                MOV     R7,A
0008 EC                MOV     A,R4
0009 33                RLC     A
000A FE                MOV     R6,A
000B 7400        R     MOV     A,#LOW NVRAM0
000D 2F                ADD     A,R7
000E F582              MOV     DPL,A
0010 7400        R     MOV     A,#HIGH NVRAM0
0012 3E                ADDC    A,R6
0013 F583              MOV     DPH,A
0015 E4                CLR     A
0016 F0                MOVX    @DPTR,A
0017 A3                INC     DPTR
0018 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 137
0019 7400        R     MOV     A,#LOW NVRAM1
001B 2F                ADD     A,R7
001C F582              MOV     DPL,A
001E 7400        R     MOV     A,#HIGH NVRAM1
0020 3E                ADDC    A,R6
0021 F583              MOV     DPH,A
0023 E4                CLR     A
0024 F0                MOVX    @DPTR,A
0025 A3                INC     DPTR
0026 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 138
0027 0D                INC     R5
0028 BD0001            CJNE    R5,#00H,?C0201
002B 0C                INC     R4
002C         ?C0201:
002C BC01D5            CJNE    R4,#01H,?C0044
002F BD30D2            CJNE    R5,#030H,?C0044
0032         ?C0045:
                                           ; SOURCE LINE # 139
0032 7C01              MOV     R4,#01H
0034 7D30              MOV     R5,#030H
0036         ?C0047:
                                           ; SOURCE LINE # 140
                                           ; SOURCE LINE # 141
0036 ED                MOV     A,R5
0037 25E0              ADD     A,ACC
0039 FF                MOV     R7,A
003A EC                MOV     A,R4
003B 33                RLC     A
003C FE                MOV     R6,A
003D 7400        R     MOV     A,#LOW NVRAM0
003F 2F                ADD     A,R7
0040 F582              MOV     DPL,A
0042 7400        R     MOV     A,#HIGH NVRAM0
0044 3E                ADDC    A,R6
0045 F583              MOV     DPH,A
0047 E4                CLR     A
0048 F0                MOVX    @DPTR,A
0049 A3                INC     DPTR
004A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 142
004B 7400        R     MOV     A,#LOW NVRAM1
004D 2F                ADD     A,R7
004E F582              MOV     DPL,A
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 109 

0050 7400        R     MOV     A,#HIGH NVRAM1
0052 3E                ADDC    A,R6
0053 F583              MOV     DPH,A
0055 E4                CLR     A
0056 F0                MOVX    @DPTR,A
0057 A3                INC     DPTR
0058 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 143
0059 0D                INC     R5
005A BD0001            CJNE    R5,#00H,?C0202
005D 0C                INC     R4
005E         ?C0202:
005E BC01D5            CJNE    R4,#01H,?C0047
0061 BD40D2            CJNE    R5,#040H,?C0047
0064         ?C0048:
                                           ; SOURCE LINE # 144
0064 7C01              MOV     R4,#01H
0066 7D40              MOV     R5,#040H
0068         ?C0050:
                                           ; SOURCE LINE # 145
                                           ; SOURCE LINE # 146
0068 ED                MOV     A,R5
0069 25E0              ADD     A,ACC
006B FF                MOV     R7,A
006C EC                MOV     A,R4
006D 33                RLC     A
006E FE                MOV     R6,A
006F 7400        R     MOV     A,#LOW NVRAM0
0071 2F                ADD     A,R7
0072 F582              MOV     DPL,A
0074 7400        R     MOV     A,#HIGH NVRAM0
0076 3E                ADDC    A,R6
0077 F583              MOV     DPH,A
0079 E4                CLR     A
007A F0                MOVX    @DPTR,A
007B A3                INC     DPTR
007C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 147
007D 7400        R     MOV     A,#LOW NVRAM1
007F 2F                ADD     A,R7
0080 F582              MOV     DPL,A
0082 7400        R     MOV     A,#HIGH NVRAM1
0084 3E                ADDC    A,R6
0085 F583              MOV     DPH,A
0087 E4                CLR     A
0088 F0                MOVX    @DPTR,A
0089 A3                INC     DPTR
008A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 148
008B 0D                INC     R5
008C BD0001            CJNE    R5,#00H,?C0203
008F 0C                INC     R4
0090         ?C0203:
0090 BC01D5            CJNE    R4,#01H,?C0050
0093 BD50D2            CJNE    R5,#050H,?C0050
                                           ; SOURCE LINE # 149
0096         ?C0053:
0096 22                RET     
             ; FUNCTION clearT (END)

             ; FUNCTION clearTD (BEGIN)
                                           ; SOURCE LINE # 150
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 110 

                                           ; SOURCE LINE # 152
;---- Variable 'i' assigned to Register 'R4/R5' ----
0000 7D50              MOV     R5,#050H
0002 7C01              MOV     R4,#01H
0004         ?C0054:
                                           ; SOURCE LINE # 153
                                           ; SOURCE LINE # 154
0004 ED                MOV     A,R5
0005 25E0              ADD     A,ACC
0007 FF                MOV     R7,A
0008 EC                MOV     A,R4
0009 33                RLC     A
000A FE                MOV     R6,A
000B 7400        R     MOV     A,#LOW NVRAM0
000D 2F                ADD     A,R7
000E F582              MOV     DPL,A
0010 7400        R     MOV     A,#HIGH NVRAM0
0012 3E                ADDC    A,R6
0013 F583              MOV     DPH,A
0015 E4                CLR     A
0016 F0                MOVX    @DPTR,A
0017 A3                INC     DPTR
0018 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 155
0019 7400        R     MOV     A,#LOW NVRAM1
001B 2F                ADD     A,R7
001C F582              MOV     DPL,A
001E 7400        R     MOV     A,#HIGH NVRAM1
0020 3E                ADDC    A,R6
0021 F583              MOV     DPH,A
0023 E4                CLR     A
0024 F0                MOVX    @DPTR,A
0025 A3                INC     DPTR
0026 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 156
0027 0D                INC     R5
0028 BD0001            CJNE    R5,#00H,?C0204
002B 0C                INC     R4
002C         ?C0204:
002C BC01D5            CJNE    R4,#01H,?C0054
002F BD60D2            CJNE    R5,#060H,?C0054
0032         ?C0055:
                                           ; SOURCE LINE # 157
0032 7C01              MOV     R4,#01H
0034 7D60              MOV     R5,#060H
0036         ?C0057:
                                           ; SOURCE LINE # 158
                                           ; SOURCE LINE # 159
0036 ED                MOV     A,R5
0037 25E0              ADD     A,ACC
0039 FF                MOV     R7,A
003A EC                MOV     A,R4
003B 33                RLC     A
003C FE                MOV     R6,A
003D 7400        R     MOV     A,#LOW NVRAM0
003F 2F                ADD     A,R7
0040 F582              MOV     DPL,A
0042 7400        R     MOV     A,#HIGH NVRAM0
0044 3E                ADDC    A,R6
0045 F583              MOV     DPH,A
0047 E4                CLR     A
0048 F0                MOVX    @DPTR,A
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 111 

0049 A3                INC     DPTR
004A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 160
004B 7400        R     MOV     A,#LOW NVRAM1
004D 2F                ADD     A,R7
004E F582              MOV     DPL,A
0050 7400        R     MOV     A,#HIGH NVRAM1
0052 3E                ADDC    A,R6
0053 F583              MOV     DPH,A
0055 E4                CLR     A
0056 F0                MOVX    @DPTR,A
0057 A3                INC     DPTR
0058 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 161
0059 0D                INC     R5
005A BD0001            CJNE    R5,#00H,?C0205
005D 0C                INC     R4
005E         ?C0205:
005E BC01D5            CJNE    R4,#01H,?C0057
0061 BD70D2            CJNE    R5,#070H,?C0057
0064         ?C0058:
                                           ; SOURCE LINE # 162
0064 7C01              MOV     R4,#01H
0066 7D70              MOV     R5,#070H
0068         ?C0060:
                                           ; SOURCE LINE # 163
                                           ; SOURCE LINE # 164
0068 ED                MOV     A,R5
0069 25E0              ADD     A,ACC
006B FF                MOV     R7,A
006C EC                MOV     A,R4
006D 33                RLC     A
006E FE                MOV     R6,A
006F 7400        R     MOV     A,#LOW NVRAM0
0071 2F                ADD     A,R7
0072 F582              MOV     DPL,A
0074 7400        R     MOV     A,#HIGH NVRAM0
0076 3E                ADDC    A,R6
0077 F583              MOV     DPH,A
0079 E4                CLR     A
007A F0                MOVX    @DPTR,A
007B A3                INC     DPTR
007C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 165
007D 7400        R     MOV     A,#LOW NVRAM1
007F 2F                ADD     A,R7
0080 F582              MOV     DPL,A
0082 7400        R     MOV     A,#HIGH NVRAM1
0084 3E                ADDC    A,R6
0085 F583              MOV     DPH,A
0087 E4                CLR     A
0088 F0                MOVX    @DPTR,A
0089 A3                INC     DPTR
008A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 166
008B 0D                INC     R5
008C BD0001            CJNE    R5,#00H,?C0206
008F 0C                INC     R4
0090         ?C0206:
0090 BC01D5            CJNE    R4,#01H,?C0060
0093 BD80D2            CJNE    R5,#080H,?C0060
                                           ; SOURCE LINE # 167
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 112 

0096         ?C0063:
0096 22                RET     
             ; FUNCTION clearTD (END)

             ; FUNCTION clearC (BEGIN)
                                           ; SOURCE LINE # 168
                                           ; SOURCE LINE # 170
;---- Variable 'i' assigned to Register 'R4/R5' ----
0000 7D80              MOV     R5,#080H
0002 7C01              MOV     R4,#01H
0004         ?C0064:
                                           ; SOURCE LINE # 171
0004 ED                MOV     A,R5
0005 25E0              ADD     A,ACC
0007 FF                MOV     R7,A
0008 EC                MOV     A,R4
0009 33                RLC     A
000A FE                MOV     R6,A
000B 7400        R     MOV     A,#LOW NVRAM0
000D 2F                ADD     A,R7
000E F582              MOV     DPL,A
0010 7400        R     MOV     A,#HIGH NVRAM0
0012 3E                ADDC    A,R6
0013 F583              MOV     DPH,A
0015 E4                CLR     A
0016 F0                MOVX    @DPTR,A
0017 A3                INC     DPTR
0018 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 172
0019 7400        R     MOV     A,#LOW NVRAM1
001B 2F                ADD     A,R7
001C F582              MOV     DPL,A
001E 7400        R     MOV     A,#HIGH NVRAM1
0020 3E                ADDC    A,R6
0021 F583              MOV     DPH,A
0023 E4                CLR     A
0024 F0                MOVX    @DPTR,A
0025 A3                INC     DPTR
0026 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 173
0027 0D                INC     R5
0028 BD0001            CJNE    R5,#00H,?C0207
002B 0C                INC     R4
002C         ?C0207:
002C BC01D5            CJNE    R4,#01H,?C0064
002F BD90D2            CJNE    R5,#090H,?C0064
                                           ; SOURCE LINE # 174
0032         ?C0067:
0032 22                RET     
             ; FUNCTION clearC (END)

             ; FUNCTION clearX (BEGIN)
                                           ; SOURCE LINE # 175
                                           ; SOURCE LINE # 177
;---- Variable 'i' assigned to Register 'R4/R5' ----
0000 7D90              MOV     R5,#090H
0002 7C01              MOV     R4,#01H
0004         ?C0068:
                                           ; SOURCE LINE # 178
0004 ED                MOV     A,R5
0005 25E0              ADD     A,ACC
0007 FF                MOV     R7,A
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 113 

0008 EC                MOV     A,R4
0009 33                RLC     A
000A FE                MOV     R6,A
000B 7400        R     MOV     A,#LOW NVRAM0
000D 2F                ADD     A,R7
000E F582              MOV     DPL,A
0010 7400        R     MOV     A,#HIGH NVRAM0
0012 3E                ADDC    A,R6
0013 F583              MOV     DPH,A
0015 E4                CLR     A
0016 F0                MOVX    @DPTR,A
0017 A3                INC     DPTR
0018 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 179
0019 7400        R     MOV     A,#LOW NVRAM1
001B 2F                ADD     A,R7
001C F582              MOV     DPL,A
001E 7400        R     MOV     A,#HIGH NVRAM1
0020 3E                ADDC    A,R6
0021 F583              MOV     DPH,A
0023 E4                CLR     A
0024 F0                MOVX    @DPTR,A
0025 A3                INC     DPTR
0026 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 180
0027 0D                INC     R5
0028 BD0001            CJNE    R5,#00H,?C0208
002B 0C                INC     R4
002C         ?C0208:
002C BC01D5            CJNE    R4,#01H,?C0068
002F BDA0D2            CJNE    R5,#0A0H,?C0068
                                           ; SOURCE LINE # 181
0032         ?C0071:
0032 22                RET     
             ; FUNCTION clearX (END)

             ; FUNCTION clearY (BEGIN)
                                           ; SOURCE LINE # 182
                                           ; SOURCE LINE # 184
;---- Variable 'i' assigned to Register 'R4/R5' ----
0000 7DA0              MOV     R5,#0A0H
0002 7C01              MOV     R4,#01H
0004         ?C0072:
                                           ; SOURCE LINE # 185
0004 ED                MOV     A,R5
0005 25E0              ADD     A,ACC
0007 FF                MOV     R7,A
0008 EC                MOV     A,R4
0009 33                RLC     A
000A FE                MOV     R6,A
000B 7400        R     MOV     A,#LOW NVRAM0
000D 2F                ADD     A,R7
000E F582              MOV     DPL,A
0010 7400        R     MOV     A,#HIGH NVRAM0
0012 3E                ADDC    A,R6
0013 F583              MOV     DPH,A
0015 E4                CLR     A
0016 F0                MOVX    @DPTR,A
0017 A3                INC     DPTR
0018 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 186
0019 7400        R     MOV     A,#LOW NVRAM1
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 114 

001B 2F                ADD     A,R7
001C F582              MOV     DPL,A
001E 7400        R     MOV     A,#HIGH NVRAM1
0020 3E                ADDC    A,R6
0021 F583              MOV     DPH,A
0023 E4                CLR     A
0024 F0                MOVX    @DPTR,A
0025 A3                INC     DPTR
0026 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 187
0027 0D                INC     R5
0028 BD0001            CJNE    R5,#00H,?C0209
002B 0C                INC     R4
002C         ?C0209:
002C BC01D5            CJNE    R4,#01H,?C0072
002F BDB0D2            CJNE    R5,#0B0H,?C0072
                                           ; SOURCE LINE # 188
0032         ?C0075:
0032 22                RET     
             ; FUNCTION clearY (END)

             ; FUNCTION clearSPREG (BEGIN)
                                           ; SOURCE LINE # 189
                                           ; SOURCE LINE # 191
;---- Variable 'i' assigned to Register 'R4/R5' ----
0000 7DB0              MOV     R5,#0B0H
0002 7C01              MOV     R4,#01H
0004         ?C0076:
                                           ; SOURCE LINE # 192
0004 ED                MOV     A,R5
0005 25E0              ADD     A,ACC
0007 FF                MOV     R7,A
0008 EC                MOV     A,R4
0009 33                RLC     A
000A FE                MOV     R6,A
000B 7400        R     MOV     A,#LOW NVRAM0
000D 2F                ADD     A,R7
000E F582              MOV     DPL,A
0010 7400        R     MOV     A,#HIGH NVRAM0
0012 3E                ADDC    A,R6
0013 F583              MOV     DPH,A
0015 E4                CLR     A
0016 F0                MOVX    @DPTR,A
0017 A3                INC     DPTR
0018 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 193
0019 7400        R     MOV     A,#LOW NVRAM1
001B 2F                ADD     A,R7
001C F582              MOV     DPL,A
001E 7400        R     MOV     A,#HIGH NVRAM1
0020 3E                ADDC    A,R6
0021 F583              MOV     DPH,A
0023 E4                CLR     A
0024 F0                MOVX    @DPTR,A
0025 A3                INC     DPTR
0026 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 194
0027 0D                INC     R5
0028 BD0001            CJNE    R5,#00H,?C0210
002B 0C                INC     R4
002C         ?C0210:
002C BC01D5            CJNE    R4,#01H,?C0076
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 115 

002F BDF0D2            CJNE    R5,#0F0H,?C0076
                                           ; SOURCE LINE # 195
0032         ?C0079:
0032 22                RET     
             ; FUNCTION clearSPREG (END)

             ; FUNCTION clearSPCOIL (BEGIN)
                                           ; SOURCE LINE # 196
                                           ; SOURCE LINE # 198
;---- Variable 'i' assigned to Register 'R4/R5' ----
0000 7DF0              MOV     R5,#0F0H
0002 7C01              MOV     R4,#01H
0004         ?C0080:
                                           ; SOURCE LINE # 199
0004 ED                MOV     A,R5
0005 25E0              ADD     A,ACC
0007 FF                MOV     R7,A
0008 EC                MOV     A,R4
0009 33                RLC     A
000A FE                MOV     R6,A
000B 7400        R     MOV     A,#LOW NVRAM0
000D 2F                ADD     A,R7
000E F582              MOV     DPL,A
0010 7400        R     MOV     A,#HIGH NVRAM0
0012 3E                ADDC    A,R6
0013 F583              MOV     DPH,A
0015 E4                CLR     A
0016 F0                MOVX    @DPTR,A
0017 A3                INC     DPTR
0018 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 200
0019 7400        R     MOV     A,#LOW NVRAM1
001B 2F                ADD     A,R7
001C F582              MOV     DPL,A
001E 7400        R     MOV     A,#HIGH NVRAM1
0020 3E                ADDC    A,R6
0021 F583              MOV     DPH,A
0023 E4                CLR     A
0024 F0                MOVX    @DPTR,A
0025 A3                INC     DPTR
0026 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 201
0027 0D                INC     R5
0028 BD0001            CJNE    R5,#00H,?C0211
002B 0C                INC     R4
002C         ?C0211:
002C E4                CLR     A
002D B505D4            CJNE    A,AR5,?C0080
0030 EC                MOV     A,R4
0031 B402D0            CJNE    A,#02H,?C0080
                                           ; SOURCE LINE # 202
0034         ?C0083:
0034 22                RET     
             ; FUNCTION clearSPCOIL (END)

             ; FUNCTION nvramLoad (BEGIN)
                                           ; SOURCE LINE # 203
                                           ; SOURCE LINE # 204
0000 7E04              MOV     R6,#04H
0002 7F00              MOV     R7,#00H
0004 7D00              MOV     R5,#00H
0006 7B01              MOV     R3,#01H
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 116 

0008 7A00        R     MOV     R2,#HIGH NVRAM0
000A 7900        R     MOV     R1,#LOW NVRAM0
000C 120000      E     LCALL   ?C?MEMSET
                                           ; SOURCE LINE # 205
000F 7B01              MOV     R3,#01H
0011 7A00        R     MOV     R2,#HIGH NVRAM0
0013 7900        R     MOV     R1,#LOW NVRAM0
0015 750004      E     MOV     ?_epromRead?BYTE+05H,#04H
0018 750000      E     MOV     ?_epromRead?BYTE+06H,#00H
001B E4                CLR     A
001C FF                MOV     R7,A
001D FE                MOV     R6,A
001E 120000      E     LCALL   _epromRead
                                           ; SOURCE LINE # 206
0021 120000      R     LCALL   clearEM
                                           ; SOURCE LINE # 207
0024 120000      R     LCALL   clearR
                                           ; SOURCE LINE # 208
0027 120000      R     LCALL   clearT
                                           ; SOURCE LINE # 209
002A 120000      R     LCALL   clearTD
                                           ; SOURCE LINE # 210
002D 120000      R     LCALL   clearC
                                           ; SOURCE LINE # 211
0030 120000      R     LCALL   clearX
                                           ; SOURCE LINE # 212
0033 120000      R     LCALL   clearY
                                           ; SOURCE LINE # 213
0036 120000      R     LCALL   clearSPREG
                                           ; SOURCE LINE # 214
0039 120000      R     LCALL   clearSPCOIL
                                           ; SOURCE LINE # 215
003C 7800        R     MOV     R0,#LOW NVRAM1
003E 7C00        R     MOV     R4,#HIGH NVRAM1
0040 7D01              MOV     R5,#01H
0042 7B01              MOV     R3,#01H
0044 7A00        R     MOV     R2,#HIGH NVRAM0
0046 7900        R     MOV     R1,#LOW NVRAM0
0048 7E02              MOV     R6,#02H
004A 7F00              MOV     R7,#00H
004C 020000      E     LJMP    ?C?COPY
             ; FUNCTION nvramLoad (END)

             ; FUNCTION nvramSave (BEGIN)
                                           ; SOURCE LINE # 217
                                           ; SOURCE LINE # 218
0000 C2AF              CLR     EA
                                           ; SOURCE LINE # 219
0002 7B01              MOV     R3,#01H
0004 7A00        R     MOV     R2,#HIGH NVRAM0
0006 7900        R     MOV     R1,#LOW NVRAM0
0008 750000      E     MOV     ?_epromWrite?BYTE+05H,#00H
000B 750020      E     MOV     ?_epromWrite?BYTE+06H,#020H
000E E4                CLR     A
000F FF                MOV     R7,A
0010 FE                MOV     R6,A
0011 120000      E     LCALL   _epromWrite
                                           ; SOURCE LINE # 220
0014 D2AF              SETB    EA
                                           ; SOURCE LINE # 221
0016 22                RET     
             ; FUNCTION nvramSave (END)
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 117 


             ; FUNCTION nvramUpdata (BEGIN)
                                           ; SOURCE LINE # 222
                                           ; SOURCE LINE # 225
0000 750001      R     MOV     sp0,#01H
0003 750000      R     MOV     sp0+01H,#HIGH NVRAM0
0006 750000      R     MOV     sp0+02H,#LOW NVRAM0
                                           ; SOURCE LINE # 226
0009 750001      R     MOV     sp1,#01H
000C 750000      R     MOV     sp1+01H,#HIGH NVRAM1
000F 750000      R     MOV     sp1+02H,#LOW NVRAM1
                                           ; SOURCE LINE # 227
0012 E4                CLR     A
0013 F500        R     MOV     i,A
0015 F500        R     MOV     i+01H,A
0017         ?C0086:
                                           ; SOURCE LINE # 228
0017 AB00        R     MOV     R3,sp1
0019 AA00        R     MOV     R2,sp1+01H
001B A900        R     MOV     R1,sp1+02H
001D 850082      R     MOV     DPL,i+01H
0020 850083      R     MOV     DPH,i
0023 120000      E     LCALL   ?C?CLDOPTR
0026 FF                MOV     R7,A
0027 AB00        R     MOV     R3,sp0
0029 AA00        R     MOV     R2,sp0+01H
002B A900        R     MOV     R1,sp0+02H
002D 850082      R     MOV     DPL,i+01H
0030 850083      R     MOV     DPH,i
0033 120000      E     LCALL   ?C?CLDOPTR
0036 FD                MOV     R5,A
0037 6F                XRL     A,R7
0038 6007              JZ      ?C0088
                                           ; SOURCE LINE # 229
003A AF00        R     MOV     R7,i+01H
003C AE00        R     MOV     R6,i
003E 120000      E     LCALL   _epromWriteOneByte
                                           ; SOURCE LINE # 230
                                           ; SOURCE LINE # 231
0041         ?C0088:
0041 0500        R     INC     i+01H
0043 E500        R     MOV     A,i+01H
0045 7002              JNZ     ?C0213
0047 0500        R     INC     i
0049         ?C0213:
0049 C3                CLR     C
004A 9420              SUBB    A,#020H
004C E500        R     MOV     A,i
004E 9400              SUBB    A,#00H
0050 40C5              JC      ?C0086
0052         ?C0087:
                                           ; SOURCE LINE # 232
0052 750001      R     MOV     sp0,#01H
0055 750000      R     MOV     sp0+01H,#HIGH NVRAM0+080H
0058 750000      R     MOV     sp0+02H,#LOW NVRAM0+080H
                                           ; SOURCE LINE # 233
005B 750001      R     MOV     sp1,#01H
005E 750000      R     MOV     sp1+01H,#HIGH NVRAM1+080H
0061 750000      R     MOV     sp1+02H,#LOW NVRAM1+080H
                                           ; SOURCE LINE # 234
0064 750000      R     MOV     i,#00H
0067 750020      R     MOV     i+01H,#020H
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 118 

006A         ?C0090:
                                           ; SOURCE LINE # 235
006A AB00        R     MOV     R3,sp1
006C AA00        R     MOV     R2,sp1+01H
006E A900        R     MOV     R1,sp1+02H
0070 850082      R     MOV     DPL,i+01H
0073 850083      R     MOV     DPH,i
0076 120000      E     LCALL   ?C?CLDOPTR
0079 FF                MOV     R7,A
007A AB00        R     MOV     R3,sp0
007C AA00        R     MOV     R2,sp0+01H
007E A900        R     MOV     R1,sp0+02H
0080 850082      R     MOV     DPL,i+01H
0083 850083      R     MOV     DPH,i
0086 120000      E     LCALL   ?C?CLDOPTR
0089 FD                MOV     R5,A
008A 6F                XRL     A,R7
008B 6007              JZ      ?C0092
                                           ; SOURCE LINE # 236
008D AF00        R     MOV     R7,i+01H
008F AE00        R     MOV     R6,i
0091 120000      E     LCALL   _epromWriteOneByte
                                           ; SOURCE LINE # 237
                                           ; SOURCE LINE # 238
0094         ?C0092:
0094 0500        R     INC     i+01H
0096 E500        R     MOV     A,i+01H
0098 7002              JNZ     ?C0214
009A 0500        R     INC     i
009C         ?C0214:
009C C3                CLR     C
009D 9440              SUBB    A,#040H
009F E500        R     MOV     A,i
00A1 9401              SUBB    A,#01H
00A3 40C5              JC      ?C0090
00A5         ?C0091:
                                           ; SOURCE LINE # 239
00A5 7800        R     MOV     R0,#LOW NVRAM1
00A7 7C00        R     MOV     R4,#HIGH NVRAM1
00A9 7D01              MOV     R5,#01H
00AB 7B01              MOV     R3,#01H
00AD 7A00        R     MOV     R2,#HIGH NVRAM0
00AF 7900        R     MOV     R1,#LOW NVRAM0
00B1 7E04              MOV     R6,#04H
00B3 7F00              MOV     R7,#00H
00B5 020000      E     LJMP    ?C?COPY
             ; FUNCTION nvramUpdata (END)

             ; FUNCTION _ADD (BEGIN)
                                           ; SOURCE LINE # 241
;---- Variable 'B' assigned to Register 'R4/R5' ----
;---- Variable 'A' assigned to Register 'R2/R3' ----
0000 AB07              MOV     R3,AR7
0002 AA06              MOV     R2,AR6
                                           ; SOURCE LINE # 243
0004 AE04              MOV     R6,AR4
0006 AF05              MOV     R7,AR5
0008 EE                MOV     A,R6
0009 33                RLC     A
000A 95E0              SUBB    A,ACC
000C FD                MOV     R5,A
000D FC                MOV     R4,A
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 119 

000E C006              PUSH    AR6
0010 C007              PUSH    AR7
0012 EA                MOV     A,R2
0013 33                RLC     A
0014 95E0              SUBB    A,ACC
0016 F9                MOV     R1,A
0017 F8                MOV     R0,A
0018 D007              POP     AR7
001A D006              POP     AR6
001C EB                MOV     A,R3
001D 2F                ADD     A,R7
001E F500        R     MOV     tmp+03H,A
0020 EA                MOV     A,R2
0021 3E                ADDC    A,R6
0022 F500        R     MOV     tmp+02H,A
0024 E9                MOV     A,R1
0025 3D                ADDC    A,R5
0026 F500        R     MOV     tmp+01H,A
0028 E8                MOV     A,R0
0029 3C                ADDC    A,R4
002A F500        R     MOV     tmp,A
                                           ; SOURCE LINE # 244
002C E4                CLR     A
002D 7FFF              MOV     R7,#0FFH
002F 7E7F              MOV     R6,#07FH
0031 FD                MOV     R5,A
0032 FC                MOV     R4,A
0033 AB00        R     MOV     R3,tmp+03H
0035 AA00        R     MOV     R2,tmp+02H
0037 A900        R     MOV     R1,tmp+01H
0039 A800        R     MOV     R0,tmp
003B C3                CLR     C
003C 120000      E     LCALL   ?C?SLCMP
003F 400B              JC      ?C0095
                                           ; SOURCE LINE # 245
0041 E4                CLR     A
0042 7500FF      R     MOV     tmp+03H,#0FFH
0045 75007F      R     MOV     tmp+02H,#07FH
0048 F500        R     MOV     tmp+01H,A
004A F500        R     MOV     tmp,A
004C         ?C0095:
                                           ; SOURCE LINE # 246
004C 7F00              MOV     R7,#00H
004E 7E80              MOV     R6,#080H
0050 7DFF              MOV     R5,#0FFH
0052 7CFF              MOV     R4,#0FFH
0054 AB00        R     MOV     R3,tmp+03H
0056 AA00        R     MOV     R2,tmp+02H
0058 A900        R     MOV     R1,tmp+01H
005A A800        R     MOV     R0,tmp
005C D3                SETB    C
005D 120000      E     LCALL   ?C?SLCMP
0060 500C              JNC     ?C0096
                                           ; SOURCE LINE # 247
0062 750000      R     MOV     tmp+03H,#00H
0065 750080      R     MOV     tmp+02H,#080H
0068 7500FF      R     MOV     tmp+01H,#0FFH
006B 7500FF      R     MOV     tmp,#0FFH
006E         ?C0096:
                                           ; SOURCE LINE # 248
006E AE00        R     MOV     R6,tmp+02H
0070 AF00        R     MOV     R7,tmp+03H
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 120 

                                           ; SOURCE LINE # 249
0072         ?C0097:
0072 22                RET     
             ; FUNCTION _ADD (END)

             ; FUNCTION _SET (BEGIN)
                                           ; SOURCE LINE # 250
0000 8E00        R     MOV     A,R6
0002 8F00        R     MOV     A+01H,R7
                                           ; SOURCE LINE # 251
0004 120000      R     LCALL   _assertCoilAddress
                                           ; SOURCE LINE # 252
0007 E500        R     MOV     A,A
0009 C4                SWAP    A
000A F8                MOV     R0,A
000B 54F0              ANL     A,#0F0H
000D C8                XCH     A,R0
000E 68                XRL     A,R0
000F FE                MOV     R6,A
0010 E500        R     MOV     A,A+01H
0012 C4                SWAP    A
0013 540F              ANL     A,#0FH
0015 48                ORL     A,R0
0016 25E0              ADD     A,ACC
0018 FF                MOV     R7,A
0019 EE                MOV     A,R6
001A 33                RLC     A
001B FE                MOV     R6,A
001C 7400        R     MOV     A,#LOW NVRAM0
001E 2F                ADD     A,R7
001F F582              MOV     DPL,A
0021 7400        R     MOV     A,#HIGH NVRAM0
0023 3E                ADDC    A,R6
0024 F583              MOV     DPH,A
0026 C083              PUSH    DPH
0028 C082              PUSH    DPL
002A E0                MOVX    A,@DPTR
002B FC                MOV     R4,A
002C A3                INC     DPTR
002D E0                MOVX    A,@DPTR
002E FD                MOV     R5,A
002F E500        R     MOV     A,A+01H
0031 540F              ANL     A,#0FH
0033 FF                MOV     R7,A
0034 7401              MOV     A,#01H
0036 7E00              MOV     R6,#00H
0038 A807              MOV     R0,AR7
003A 08                INC     R0
003B 8005              SJMP    ?C0216
003D         ?C0215:
003D C3                CLR     C
003E 33                RLC     A
003F CE                XCH     A,R6
0040 33                RLC     A
0041 CE                XCH     A,R6
0042         ?C0216:
0042 D8F9              DJNZ    R0,?C0215
0044 FF                MOV     R7,A
0045 EC                MOV     A,R4
0046 4E                ORL     A,R6
0047 FE                MOV     R6,A
0048 ED                MOV     A,R5
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 121 

0049 4F                ORL     A,R7
004A FF                MOV     R7,A
004B D082              POP     DPL
004D D083              POP     DPH
004F EE                MOV     A,R6
0050 F0                MOVX    @DPTR,A
0051 A3                INC     DPTR
0052 EF                MOV     A,R7
0053 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 253
0054 22                RET     
             ; FUNCTION _SET (END)

             ; FUNCTION _RESET (BEGIN)
                                           ; SOURCE LINE # 254
0000 8E00        R     MOV     A,R6
0002 8F00        R     MOV     A+01H,R7
                                           ; SOURCE LINE # 255
0004 120000      R     LCALL   _assertCoilAddress
                                           ; SOURCE LINE # 256
0007 E500        R     MOV     A,A
0009 C4                SWAP    A
000A F8                MOV     R0,A
000B 54F0              ANL     A,#0F0H
000D C8                XCH     A,R0
000E 68                XRL     A,R0
000F FE                MOV     R6,A
0010 E500        R     MOV     A,A+01H
0012 C4                SWAP    A
0013 540F              ANL     A,#0FH
0015 48                ORL     A,R0
0016 25E0              ADD     A,ACC
0018 FF                MOV     R7,A
0019 EE                MOV     A,R6
001A 33                RLC     A
001B FE                MOV     R6,A
001C 7400        R     MOV     A,#LOW NVRAM0
001E 2F                ADD     A,R7
001F F582              MOV     DPL,A
0021 7400        R     MOV     A,#HIGH NVRAM0
0023 3E                ADDC    A,R6
0024 F583              MOV     DPH,A
0026 C083              PUSH    DPH
0028 C082              PUSH    DPL
002A E0                MOVX    A,@DPTR
002B FC                MOV     R4,A
002C A3                INC     DPTR
002D E0                MOVX    A,@DPTR
002E FD                MOV     R5,A
002F E500        R     MOV     A,A+01H
0031 540F              ANL     A,#0FH
0033 FF                MOV     R7,A
0034 7401              MOV     A,#01H
0036 7E00              MOV     R6,#00H
0038 A807              MOV     R0,AR7
003A 08                INC     R0
003B 8005              SJMP    ?C0218
003D         ?C0217:
003D C3                CLR     C
003E 33                RLC     A
003F CE                XCH     A,R6
0040 33                RLC     A
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 122 

0041 CE                XCH     A,R6
0042         ?C0218:
0042 D8F9              DJNZ    R0,?C0217
0044 F4                CPL     A
0045 FF                MOV     R7,A
0046 EE                MOV     A,R6
0047 F4                CPL     A
0048 5C                ANL     A,R4
0049 FE                MOV     R6,A
004A ED                MOV     A,R5
004B 5F                ANL     A,R7
004C FF                MOV     R7,A
004D D082              POP     DPL
004F D083              POP     DPH
0051 EE                MOV     A,R6
0052 F0                MOVX    @DPTR,A
0053 A3                INC     DPTR
0054 EF                MOV     A,R7
0055 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 257
0056 22                RET     
             ; FUNCTION _RESET (END)

             ; FUNCTION _FLIP (BEGIN)
                                           ; SOURCE LINE # 258
;---- Variable 'A' assigned to Register 'R4/R5' ----
                                           ; SOURCE LINE # 260
0000 120000      R     LCALL   L?0272
                                           ; SOURCE LINE # 261
0003 EC                MOV     A,R4
0004 C4                SWAP    A
0005 F8                MOV     R0,A
0006 54F0              ANL     A,#0F0H
0008 C8                XCH     A,R0
0009 68                XRL     A,R0
000A FE                MOV     R6,A
000B ED                MOV     A,R5
000C C4                SWAP    A
000D 540F              ANL     A,#0FH
000F 48                ORL     A,R0
0010 25E0              ADD     A,ACC
0012 FF                MOV     R7,A
0013 EE                MOV     A,R6
0014 33                RLC     A
0015 FE                MOV     R6,A
0016 7400        R     MOV     A,#LOW NVRAM0
0018 2F                ADD     A,R7
0019 F582              MOV     DPL,A
001B 7400        R     MOV     A,#HIGH NVRAM0
001D 3E                ADDC    A,R6
001E F583              MOV     DPH,A
0020 E0                MOVX    A,@DPTR
0021 FA                MOV     R2,A
0022 A3                INC     DPTR
0023 E0                MOVX    A,@DPTR
0024 FB                MOV     R3,A
0025 ED                MOV     A,R5
0026 540F              ANL     A,#0FH
0028 FF                MOV     R7,A
0029 7401              MOV     A,#01H
002B 7E00              MOV     R6,#00H
002D A807              MOV     R0,AR7
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 123 

002F 08                INC     R0
0030 8005              SJMP    ?C0220
0032         ?C0219:
0032 C3                CLR     C
0033 33                RLC     A
0034 CE                XCH     A,R6
0035 33                RLC     A
0036 CE                XCH     A,R6
0037         ?C0220:
0037 D8F9              DJNZ    R0,?C0219
0039 FF                MOV     R7,A
003A EA                MOV     A,R2
003B 5E                ANL     A,R6
003C FE                MOV     R6,A
003D EB                MOV     A,R3
003E 5F                ANL     A,R7
;---- Variable 'temp' assigned to Register 'R6/R7' ----
                                           ; SOURCE LINE # 262
003F 4E                ORL     A,R6
0040 AF05              MOV     R7,AR5
0042 AE04              MOV     R6,AR4
0044 6003              JZ      ?C0100
                                           ; SOURCE LINE # 263
0046 020000      R     LJMP    _RESET
0049         ?C0100:
                                           ; SOURCE LINE # 265
0049 120000      R     LCALL   _SET
                                           ; SOURCE LINE # 266
004C         ?C0102:
004C 22                RET     
             ; FUNCTION _FLIP (END)

             ; FUNCTION _LD (BEGIN)
                                           ; SOURCE LINE # 267
;---- Variable 'A' assigned to Register 'R4/R5' ----
                                           ; SOURCE LINE # 268
0000 120000      R     LCALL   L?0272
                                           ; SOURCE LINE # 269
0003 ED                MOV     A,R5
0004 540F              ANL     A,#0FH
0006 25E0              ADD     A,ACC
0008 FF                MOV     R7,A
0009 E4                CLR     A
000A 33                RLC     A
000B FE                MOV     R6,A
000C 7400        R     MOV     A,#LOW NVRAM0
000E 2F                ADD     A,R7
000F F582              MOV     DPL,A
0011 7400        R     MOV     A,#HIGH NVRAM0
0013 3E                ADDC    A,R6
0014 F583              MOV     DPH,A
0016 A3                INC     DPTR
0017 E0                MOVX    A,@DPTR
0018 FB                MOV     R3,A
0019 EC                MOV     A,R4
001A C4                SWAP    A
001B F8                MOV     R0,A
001C 54F0              ANL     A,#0F0H
001E C8                XCH     A,R0
001F 68                XRL     A,R0
0020 FE                MOV     R6,A
0021 ED                MOV     A,R5
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 124 

0022 C4                SWAP    A
0023 540F              ANL     A,#0FH
0025 48                ORL     A,R0
0026 25E0              ADD     A,ACC
0028 FF                MOV     R7,A
0029 EE                MOV     A,R6
002A 33                RLC     A
002B FE                MOV     R6,A
002C 7400        R     MOV     A,#LOW NVRAM0
002E 2F                ADD     A,R7
002F F582              MOV     DPL,A
0031 7400        R     MOV     A,#HIGH NVRAM0
0033 3E                ADDC    A,R6
0034 F583              MOV     DPH,A
0036 E0                MOVX    A,@DPTR
0037 FE                MOV     R6,A
0038 A3                INC     DPTR
0039 E0                MOVX    A,@DPTR
003A A803              MOV     R0,AR3
003C 08                INC     R0
003D 8006              SJMP    ?C0222
003F         ?C0221:
003F CE                XCH     A,R6
0040 A2E7              MOV     C,ACC.7
0042 13                RRC     A
0043 CE                XCH     A,R6
0044 13                RRC     A
0045         ?C0222:
0045 D8F8              DJNZ    R0,?C0221
0047 FF                MOV     R7,A
                                           ; SOURCE LINE # 270
0048         ?C0103:
0048 22                RET     
             ; FUNCTION _LD (END)

             ; FUNCTION _LDP (BEGIN)
                                           ; SOURCE LINE # 271
;---- Variable 'A' assigned to Register 'R4/R5' ----
                                           ; SOURCE LINE # 273
0000 120000      R     LCALL   L?0273
                                           ; SOURCE LINE # 274
0003 ED                MOV     A,R5
0004 540F              ANL     A,#0FH
0006 25E0              ADD     A,ACC
0008 FF                MOV     R7,A
0009 E4                CLR     A
000A 33                RLC     A
000B FE                MOV     R6,A
000C 7400        R     MOV     A,#LOW NVRAM0
000E 2F                ADD     A,R7
000F F582              MOV     DPL,A
0011 7400        R     MOV     A,#HIGH NVRAM0
0013 3E                ADDC    A,R6
0014 F583              MOV     DPH,A
0016 A3                INC     DPTR
0017 E0                MOVX    A,@DPTR
0018 FB                MOV     R3,A
0019 EC                MOV     A,R4
001A C4                SWAP    A
001B F8                MOV     R0,A
001C 54F0              ANL     A,#0F0H
001E C8                XCH     A,R0
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 125 

001F 68                XRL     A,R0
0020 FE                MOV     R6,A
0021 ED                MOV     A,R5
0022 C4                SWAP    A
0023 540F              ANL     A,#0FH
0025 48                ORL     A,R0
0026 25E0              ADD     A,ACC
0028 FF                MOV     R7,A
0029 EE                MOV     A,R6
002A 33                RLC     A
002B FE                MOV     R6,A
002C 7400        R     MOV     A,#LOW NVRAM0
002E 2F                ADD     A,R7
002F F582              MOV     DPL,A
0031 7400        R     MOV     A,#HIGH NVRAM0
0033 3E                ADDC    A,R6
0034 F583              MOV     DPH,A
0036 E0                MOVX    A,@DPTR
0037 FE                MOV     R6,A
0038 A3                INC     DPTR
0039 E0                MOVX    A,@DPTR
003A A803              MOV     R0,AR3
003C 08                INC     R0
003D 8006              SJMP    ?C0224
003F         ?C0223:
003F CE                XCH     A,R6
0040 A2E7              MOV     C,ACC.7
0042 13                RRC     A
0043 CE                XCH     A,R6
0044 13                RRC     A
0045         ?C0224:
0045 D8F8              DJNZ    R0,?C0223
;---- Variable 'temp0' assigned to Register 'R3' ----
0047 FB                MOV     R3,A
                                           ; SOURCE LINE # 275
0048 ED                MOV     A,R5
0049 540F              ANL     A,#0FH
004B 25E0              ADD     A,ACC
004D FF                MOV     R7,A
004E E4                CLR     A
004F 33                RLC     A
0050 FE                MOV     R6,A
0051 7400        R     MOV     A,#LOW NVRAM1
0053 2F                ADD     A,R7
0054 F582              MOV     DPL,A
0056 7400        R     MOV     A,#HIGH NVRAM1
0058 3E                ADDC    A,R6
0059 F583              MOV     DPH,A
005B A3                INC     DPTR
005C E0                MOVX    A,@DPTR
005D FA                MOV     R2,A
005E EC                MOV     A,R4
005F C4                SWAP    A
0060 F8                MOV     R0,A
0061 54F0              ANL     A,#0F0H
0063 C8                XCH     A,R0
0064 68                XRL     A,R0
0065 FE                MOV     R6,A
0066 ED                MOV     A,R5
0067 C4                SWAP    A
0068 540F              ANL     A,#0FH
006A 48                ORL     A,R0
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 126 

006B 25E0              ADD     A,ACC
006D FF                MOV     R7,A
006E EE                MOV     A,R6
006F 33                RLC     A
0070 FE                MOV     R6,A
0071 7400        R     MOV     A,#LOW NVRAM1
0073 2F                ADD     A,R7
0074 F582              MOV     DPL,A
0076 7400        R     MOV     A,#HIGH NVRAM1
0078 3E                ADDC    A,R6
0079 F583              MOV     DPH,A
007B E0                MOVX    A,@DPTR
007C FE                MOV     R6,A
007D A3                INC     DPTR
007E E0                MOVX    A,@DPTR
007F A802              MOV     R0,AR2
0081 08                INC     R0
0082 8006              SJMP    ?C0226
0084         ?C0225:
0084 CE                XCH     A,R6
0085 A2E7              MOV     C,ACC.7
0087 13                RRC     A
0088 CE                XCH     A,R6
0089 13                RRC     A
008A         ?C0226:
008A D8F8              DJNZ    R0,?C0225
008C FF                MOV     R7,A
;---- Variable 'temp1' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 276
008D EB                MOV     A,R3
008E 6006              JZ      ?C0104
0090 EF                MOV     A,R7
0091 7003              JNZ     ?C0104
                                           ; SOURCE LINE # 277
0093 7F01              MOV     R7,#01H
0095 22                RET     
0096         ?C0104:
                                           ; SOURCE LINE # 279
0096 7F00              MOV     R7,#00H
                                           ; SOURCE LINE # 280
0098         ?C0105:
0098 22                RET     
             ; FUNCTION _LDP (END)

             ; FUNCTION _LDN (BEGIN)
                                           ; SOURCE LINE # 281
;---- Variable 'A' assigned to Register 'R4/R5' ----
                                           ; SOURCE LINE # 283
0000 120000      R     LCALL   L?0273
                                           ; SOURCE LINE # 284
0003 ED                MOV     A,R5
0004 540F              ANL     A,#0FH
0006 25E0              ADD     A,ACC
0008 FF                MOV     R7,A
0009 E4                CLR     A
000A 33                RLC     A
000B FE                MOV     R6,A
000C 7400        R     MOV     A,#LOW NVRAM0
000E 2F                ADD     A,R7
000F F582              MOV     DPL,A
0011 7400        R     MOV     A,#HIGH NVRAM0
0013 3E                ADDC    A,R6
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 127 

0014 F583              MOV     DPH,A
0016 A3                INC     DPTR
0017 E0                MOVX    A,@DPTR
0018 FB                MOV     R3,A
0019 EC                MOV     A,R4
001A C4                SWAP    A
001B F8                MOV     R0,A
001C 54F0              ANL     A,#0F0H
001E C8                XCH     A,R0
001F 68                XRL     A,R0
0020 FE                MOV     R6,A
0021 ED                MOV     A,R5
0022 C4                SWAP    A
0023 540F              ANL     A,#0FH
0025 48                ORL     A,R0
0026 25E0              ADD     A,ACC
0028 FF                MOV     R7,A
0029 EE                MOV     A,R6
002A 33                RLC     A
002B FE                MOV     R6,A
002C 7400        R     MOV     A,#LOW NVRAM0
002E 2F                ADD     A,R7
002F F582              MOV     DPL,A
0031 7400        R     MOV     A,#HIGH NVRAM0
0033 3E                ADDC    A,R6
0034 F583              MOV     DPH,A
0036 E0                MOVX    A,@DPTR
0037 FE                MOV     R6,A
0038 A3                INC     DPTR
0039 E0                MOVX    A,@DPTR
003A A803              MOV     R0,AR3
003C 08                INC     R0
003D 8006              SJMP    ?C0228
003F         ?C0227:
003F CE                XCH     A,R6
0040 A2E7              MOV     C,ACC.7
0042 13                RRC     A
0043 CE                XCH     A,R6
0044 13                RRC     A
0045         ?C0228:
0045 D8F8              DJNZ    R0,?C0227
;---- Variable 'temp0' assigned to Register 'R3' ----
0047 FB                MOV     R3,A
                                           ; SOURCE LINE # 285
0048 ED                MOV     A,R5
0049 540F              ANL     A,#0FH
004B 25E0              ADD     A,ACC
004D FF                MOV     R7,A
004E E4                CLR     A
004F 33                RLC     A
0050 FE                MOV     R6,A
0051 7400        R     MOV     A,#LOW NVRAM1
0053 2F                ADD     A,R7
0054 F582              MOV     DPL,A
0056 7400        R     MOV     A,#HIGH NVRAM1
0058 3E                ADDC    A,R6
0059 F583              MOV     DPH,A
005B A3                INC     DPTR
005C E0                MOVX    A,@DPTR
005D FA                MOV     R2,A
005E EC                MOV     A,R4
005F C4                SWAP    A
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 128 

0060 F8                MOV     R0,A
0061 54F0              ANL     A,#0F0H
0063 C8                XCH     A,R0
0064 68                XRL     A,R0
0065 FE                MOV     R6,A
0066 ED                MOV     A,R5
0067 C4                SWAP    A
0068 540F              ANL     A,#0FH
006A 48                ORL     A,R0
006B 25E0              ADD     A,ACC
006D FF                MOV     R7,A
006E EE                MOV     A,R6
006F 33                RLC     A
0070 FE                MOV     R6,A
0071 7400        R     MOV     A,#LOW NVRAM1
0073 2F                ADD     A,R7
0074 F582              MOV     DPL,A
0076 7400        R     MOV     A,#HIGH NVRAM1
0078 3E                ADDC    A,R6
0079 F583              MOV     DPH,A
007B E0                MOVX    A,@DPTR
007C FE                MOV     R6,A
007D A3                INC     DPTR
007E E0                MOVX    A,@DPTR
007F A802              MOV     R0,AR2
0081 08                INC     R0
0082 8006              SJMP    ?C0230
0084         ?C0229:
0084 CE                XCH     A,R6
0085 A2E7              MOV     C,ACC.7
0087 13                RRC     A
0088 CE                XCH     A,R6
0089 13                RRC     A
008A         ?C0230:
008A D8F8              DJNZ    R0,?C0229
008C FF                MOV     R7,A
;---- Variable 'temp1' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 286
008D EB                MOV     A,R3
008E 7006              JNZ     ?C0107
0090 EF                MOV     A,R7
0091 6003              JZ      ?C0107
                                           ; SOURCE LINE # 287
0093 7F01              MOV     R7,#01H
0095 22                RET     
0096         ?C0107:
                                           ; SOURCE LINE # 289
0096 7F00              MOV     R7,#00H
                                           ; SOURCE LINE # 290
0098         ?C0108:
0098 22                RET     
             ; FUNCTION _LDN (END)

             ; FUNCTION _T1MS (BEGIN)
                                           ; SOURCE LINE # 291
0000 8F00        R     MOV     A,R7
;---- Variable 'value' assigned to Register 'R2/R3' ----
;---- Variable 'start' assigned to Register 'R5' ----
                                           ; SOURCE LINE # 296
0002 ED                MOV     A,R5
0003 7003              JNZ     $ + 5H
0005 020000      R     LJMP    ?C0110
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 129 

                                           ; SOURCE LINE # 297
0008 EF                MOV     A,R7
0009 25E0              ADD     A,ACC
000B FF                MOV     R7,A
000C E4                CLR     A
000D 33                RLC     A
000E FE                MOV     R6,A
000F 7400        R     MOV     A,#LOW NVRAM0+02A0H
0011 2F                ADD     A,R7
0012 F582              MOV     DPL,A
0014 7400        R     MOV     A,#HIGH NVRAM0+02A0H
0016 3E                ADDC    A,R6
0017 F583              MOV     DPH,A
0019 E0                MOVX    A,@DPTR
001A FE                MOV     R6,A
001B A3                INC     DPTR
001C E0                MOVX    A,@DPTR
001D C3                CLR     C
001E 9B                SUBB    A,R3
001F EE                MOV     A,R6
0020 9A                SUBB    A,R2
0021 4037              JC      ?C0111
                                           ; SOURCE LINE # 298
0023 E500        R     MOV     A,A
0025 C4                SWAP    A
0026 540F              ANL     A,#0FH
0028 25E0              ADD     A,ACC
002A FF                MOV     R7,A
002B E4                CLR     A
002C 33                RLC     A
002D FE                MOV     R6,A
002E 7400        R     MOV     A,#LOW NVRAM0+0240H
0030 2F                ADD     A,R7
0031 F582              MOV     DPL,A
0033 7400        R     MOV     A,#HIGH NVRAM0+0240H
0035 3E                ADDC    A,R6
0036 F583              MOV     DPH,A
0038 C083              PUSH    DPH
003A C082              PUSH    DPL
003C E500        R     MOV     A,A
003E 540F              ANL     A,#0FH
0040 FF                MOV     R7,A
0041 7401              MOV     A,#01H
0043 7E00              MOV     R6,#00H
0045 A807              MOV     R0,AR7
0047 08                INC     R0
0048 8005              SJMP    ?C0232
004A         ?C0231:
004A C3                CLR     C
004B 33                RLC     A
004C CE                XCH     A,R6
004D 33                RLC     A
004E CE                XCH     A,R6
004F         ?C0232:
004F D8F9              DJNZ    R0,?C0231
0051 FF                MOV     R7,A
0052 E0                MOVX    A,@DPTR
0053 4E                ORL     A,R6
0054 FE                MOV     R6,A
0055 A3                INC     DPTR
0056 E0                MOVX    A,@DPTR
0057 4F                ORL     A,R7
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 130 

                                           ; SOURCE LINE # 299
0058 8039              SJMP    ?C0266
005A         ?C0111:
                                           ; SOURCE LINE # 300
                                           ; SOURCE LINE # 301
005A E500        R     MOV     A,A
005C C4                SWAP    A
005D 540F              ANL     A,#0FH
005F 25E0              ADD     A,ACC
0061 FF                MOV     R7,A
0062 E4                CLR     A
0063 33                RLC     A
0064 FE                MOV     R6,A
0065 7400        R     MOV     A,#LOW NVRAM0+0240H
0067 2F                ADD     A,R7
0068 F582              MOV     DPL,A
006A 7400        R     MOV     A,#HIGH NVRAM0+0240H
006C 3E                ADDC    A,R6
006D F583              MOV     DPH,A
006F C083              PUSH    DPH
0071 C082              PUSH    DPL
0073 E500        R     MOV     A,A
0075 540F              ANL     A,#0FH
0077 FF                MOV     R7,A
0078 7401              MOV     A,#01H
007A 7E00              MOV     R6,#00H
007C A807              MOV     R0,AR7
007E 08                INC     R0
007F 8005              SJMP    ?C0234
0081         ?C0233:
0081 C3                CLR     C
0082 33                RLC     A
0083 CE                XCH     A,R6
0084 33                RLC     A
0085 CE                XCH     A,R6
0086         ?C0234:
0086 D8F9              DJNZ    R0,?C0233
0088 F4                CPL     A
0089 FF                MOV     R7,A
008A EE                MOV     A,R6
008B F4                CPL     A
008C FE                MOV     R6,A
008D E0                MOVX    A,@DPTR
008E 5E                ANL     A,R6
008F FE                MOV     R6,A
0090 A3                INC     DPTR
0091 E0                MOVX    A,@DPTR
0092 5F                ANL     A,R7
0093         ?C0266:
0093 FF                MOV     R7,A
0094 D082              POP     DPL
0096 D083              POP     DPH
0098 EE                MOV     A,R6
0099 F0                MOVX    @DPTR,A
009A A3                INC     DPTR
009B EF                MOV     A,R7
009C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 302
                                           ; SOURCE LINE # 304
009D 22                RET     
009E         ?C0110:
                                           ; SOURCE LINE # 305
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 131 

                                           ; SOURCE LINE # 306
009E E500        R     MOV     A,A
00A0 C4                SWAP    A
00A1 540F              ANL     A,#0FH
00A3 25E0              ADD     A,ACC
00A5 FF                MOV     R7,A
00A6 E4                CLR     A
00A7 33                RLC     A
00A8 FE                MOV     R6,A
00A9 7400        R     MOV     A,#LOW NVRAM0+0240H
00AB 2F                ADD     A,R7
00AC F582              MOV     DPL,A
00AE 7400        R     MOV     A,#HIGH NVRAM0+0240H
00B0 3E                ADDC    A,R6
00B1 F583              MOV     DPH,A
00B3 C083              PUSH    DPH
00B5 C082              PUSH    DPL
00B7 E500        R     MOV     A,A
00B9 540F              ANL     A,#0FH
00BB FF                MOV     R7,A
00BC 7401              MOV     A,#01H
00BE 7E00              MOV     R6,#00H
00C0 A807              MOV     R0,AR7
00C2 08                INC     R0
00C3 8005              SJMP    ?C0236
00C5         ?C0235:
00C5 C3                CLR     C
00C6 33                RLC     A
00C7 CE                XCH     A,R6
00C8 33                RLC     A
00C9 CE                XCH     A,R6
00CA         ?C0236:
00CA D8F9              DJNZ    R0,?C0235
00CC F4                CPL     A
00CD FF                MOV     R7,A
00CE EE                MOV     A,R6
00CF F4                CPL     A
00D0 FE                MOV     R6,A
00D1 E0                MOVX    A,@DPTR
00D2 5E                ANL     A,R6
00D3 FE                MOV     R6,A
00D4 A3                INC     DPTR
00D5 E0                MOVX    A,@DPTR
00D6 5F                ANL     A,R7
00D7 FF                MOV     R7,A
00D8 D082              POP     DPL
00DA D083              POP     DPH
00DC EE                MOV     A,R6
00DD F0                MOVX    @DPTR,A
00DE A3                INC     DPTR
00DF EF                MOV     A,R7
00E0 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 307
00E1 E500        R     MOV     A,A
00E3 25E0              ADD     A,ACC
00E5 FF                MOV     R7,A
00E6 E4                CLR     A
00E7 33                RLC     A
00E8 FE                MOV     R6,A
00E9 7400        R     MOV     A,#LOW NVRAM0+02A0H
00EB 2F                ADD     A,R7
00EC F582              MOV     DPL,A
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 132 

00EE 7400        R     MOV     A,#HIGH NVRAM0+02A0H
00F0 3E                ADDC    A,R6
00F1 F583              MOV     DPH,A
00F3 E4                CLR     A
00F4 F0                MOVX    @DPTR,A
00F5 A3                INC     DPTR
00F6 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 308
                                           ; SOURCE LINE # 309
00F7         ?C0114:
00F7 22                RET     
             ; FUNCTION _T1MS (END)

             ; FUNCTION _T10MS (BEGIN)
                                           ; SOURCE LINE # 310
0000 8F00        R     MOV     A,R7
;---- Variable 'value' assigned to Register 'R2/R3' ----
;---- Variable 'start' assigned to Register 'R5' ----
                                           ; SOURCE LINE # 315
0002 ED                MOV     A,R5
0003 7003              JNZ     $ + 5H
0005 020000      R     LJMP    ?C0115
                                           ; SOURCE LINE # 316
0008 EF                MOV     A,R7
0009 25E0              ADD     A,ACC
000B FF                MOV     R7,A
000C E4                CLR     A
000D 33                RLC     A
000E FE                MOV     R6,A
000F 7400        R     MOV     A,#LOW NVRAM0+02C0H
0011 2F                ADD     A,R7
0012 F582              MOV     DPL,A
0014 7400        R     MOV     A,#HIGH NVRAM0+02C0H
0016 3E                ADDC    A,R6
0017 F583              MOV     DPH,A
0019 E0                MOVX    A,@DPTR
001A FE                MOV     R6,A
001B A3                INC     DPTR
001C E0                MOVX    A,@DPTR
001D C3                CLR     C
001E 9B                SUBB    A,R3
001F EE                MOV     A,R6
0020 9A                SUBB    A,R2
0021 4037              JC      ?C0116
                                           ; SOURCE LINE # 317
0023 E500        R     MOV     A,A
0025 C4                SWAP    A
0026 540F              ANL     A,#0FH
0028 25E0              ADD     A,ACC
002A FF                MOV     R7,A
002B E4                CLR     A
002C 33                RLC     A
002D FE                MOV     R6,A
002E 7400        R     MOV     A,#LOW NVRAM0+0260H
0030 2F                ADD     A,R7
0031 F582              MOV     DPL,A
0033 7400        R     MOV     A,#HIGH NVRAM0+0260H
0035 3E                ADDC    A,R6
0036 F583              MOV     DPH,A
0038 C083              PUSH    DPH
003A C082              PUSH    DPL
003C E500        R     MOV     A,A
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 133 

003E 540F              ANL     A,#0FH
0040 FF                MOV     R7,A
0041 7401              MOV     A,#01H
0043 7E00              MOV     R6,#00H
0045 A807              MOV     R0,AR7
0047 08                INC     R0
0048 8005              SJMP    ?C0238
004A         ?C0237:
004A C3                CLR     C
004B 33                RLC     A
004C CE                XCH     A,R6
004D 33                RLC     A
004E CE                XCH     A,R6
004F         ?C0238:
004F D8F9              DJNZ    R0,?C0237
0051 FF                MOV     R7,A
0052 E0                MOVX    A,@DPTR
0053 4E                ORL     A,R6
0054 FE                MOV     R6,A
0055 A3                INC     DPTR
0056 E0                MOVX    A,@DPTR
0057 4F                ORL     A,R7
                                           ; SOURCE LINE # 318
0058 8039              SJMP    ?C0267
005A         ?C0116:
                                           ; SOURCE LINE # 319
                                           ; SOURCE LINE # 320
005A E500        R     MOV     A,A
005C C4                SWAP    A
005D 540F              ANL     A,#0FH
005F 25E0              ADD     A,ACC
0061 FF                MOV     R7,A
0062 E4                CLR     A
0063 33                RLC     A
0064 FE                MOV     R6,A
0065 7400        R     MOV     A,#LOW NVRAM0+0260H
0067 2F                ADD     A,R7
0068 F582              MOV     DPL,A
006A 7400        R     MOV     A,#HIGH NVRAM0+0260H
006C 3E                ADDC    A,R6
006D F583              MOV     DPH,A
006F C083              PUSH    DPH
0071 C082              PUSH    DPL
0073 E500        R     MOV     A,A
0075 540F              ANL     A,#0FH
0077 FF                MOV     R7,A
0078 7401              MOV     A,#01H
007A 7E00              MOV     R6,#00H
007C A807              MOV     R0,AR7
007E 08                INC     R0
007F 8005              SJMP    ?C0240
0081         ?C0239:
0081 C3                CLR     C
0082 33                RLC     A
0083 CE                XCH     A,R6
0084 33                RLC     A
0085 CE                XCH     A,R6
0086         ?C0240:
0086 D8F9              DJNZ    R0,?C0239
0088 F4                CPL     A
0089 FF                MOV     R7,A
008A EE                MOV     A,R6
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 134 

008B F4                CPL     A
008C FE                MOV     R6,A
008D E0                MOVX    A,@DPTR
008E 5E                ANL     A,R6
008F FE                MOV     R6,A
0090 A3                INC     DPTR
0091 E0                MOVX    A,@DPTR
0092 5F                ANL     A,R7
0093         ?C0267:
0093 FF                MOV     R7,A
0094 D082              POP     DPL
0096 D083              POP     DPH
0098 EE                MOV     A,R6
0099 F0                MOVX    @DPTR,A
009A A3                INC     DPTR
009B EF                MOV     A,R7
009C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 321
                                           ; SOURCE LINE # 322
009D 22                RET     
009E         ?C0115:
                                           ; SOURCE LINE # 323
                                           ; SOURCE LINE # 324
009E E500        R     MOV     A,A
00A0 C4                SWAP    A
00A1 540F              ANL     A,#0FH
00A3 25E0              ADD     A,ACC
00A5 FF                MOV     R7,A
00A6 E4                CLR     A
00A7 33                RLC     A
00A8 FE                MOV     R6,A
00A9 7400        R     MOV     A,#LOW NVRAM0+0260H
00AB 2F                ADD     A,R7
00AC F582              MOV     DPL,A
00AE 7400        R     MOV     A,#HIGH NVRAM0+0260H
00B0 3E                ADDC    A,R6
00B1 F583              MOV     DPH,A
00B3 C083              PUSH    DPH
00B5 C082              PUSH    DPL
00B7 E500        R     MOV     A,A
00B9 540F              ANL     A,#0FH
00BB FF                MOV     R7,A
00BC 7401              MOV     A,#01H
00BE 7E00              MOV     R6,#00H
00C0 A807              MOV     R0,AR7
00C2 08                INC     R0
00C3 8005              SJMP    ?C0242
00C5         ?C0241:
00C5 C3                CLR     C
00C6 33                RLC     A
00C7 CE                XCH     A,R6
00C8 33                RLC     A
00C9 CE                XCH     A,R6
00CA         ?C0242:
00CA D8F9              DJNZ    R0,?C0241
00CC F4                CPL     A
00CD FF                MOV     R7,A
00CE EE                MOV     A,R6
00CF F4                CPL     A
00D0 FE                MOV     R6,A
00D1 E0                MOVX    A,@DPTR
00D2 5E                ANL     A,R6
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 135 

00D3 FE                MOV     R6,A
00D4 A3                INC     DPTR
00D5 E0                MOVX    A,@DPTR
00D6 5F                ANL     A,R7
00D7 FF                MOV     R7,A
00D8 D082              POP     DPL
00DA D083              POP     DPH
00DC EE                MOV     A,R6
00DD F0                MOVX    @DPTR,A
00DE A3                INC     DPTR
00DF EF                MOV     A,R7
00E0 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 325
00E1 E500        R     MOV     A,A
00E3 25E0              ADD     A,ACC
00E5 FF                MOV     R7,A
00E6 E4                CLR     A
00E7 33                RLC     A
00E8 FE                MOV     R6,A
00E9 7400        R     MOV     A,#LOW NVRAM0+02C0H
00EB 2F                ADD     A,R7
00EC F582              MOV     DPL,A
00EE 7400        R     MOV     A,#HIGH NVRAM0+02C0H
00F0 3E                ADDC    A,R6
00F1 F583              MOV     DPH,A
00F3 E4                CLR     A
00F4 F0                MOVX    @DPTR,A
00F5 A3                INC     DPTR
00F6 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 326
                                           ; SOURCE LINE # 327
00F7         ?C0119:
00F7 22                RET     
             ; FUNCTION _T10MS (END)

             ; FUNCTION _T100MS (BEGIN)
                                           ; SOURCE LINE # 328
0000 8F00        R     MOV     A,R7
;---- Variable 'value' assigned to Register 'R2/R3' ----
;---- Variable 'start' assigned to Register 'R5' ----
                                           ; SOURCE LINE # 333
0002 ED                MOV     A,R5
0003 7003              JNZ     $ + 5H
0005 020000      R     LJMP    ?C0120
                                           ; SOURCE LINE # 334
0008 EF                MOV     A,R7
0009 25E0              ADD     A,ACC
000B FF                MOV     R7,A
000C E4                CLR     A
000D 33                RLC     A
000E FE                MOV     R6,A
000F 7400        R     MOV     A,#LOW NVRAM0+02E0H
0011 2F                ADD     A,R7
0012 F582              MOV     DPL,A
0014 7400        R     MOV     A,#HIGH NVRAM0+02E0H
0016 3E                ADDC    A,R6
0017 F583              MOV     DPH,A
0019 E0                MOVX    A,@DPTR
001A FE                MOV     R6,A
001B A3                INC     DPTR
001C E0                MOVX    A,@DPTR
001D C3                CLR     C
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 136 

001E 9B                SUBB    A,R3
001F EE                MOV     A,R6
0020 9A                SUBB    A,R2
0021 4037              JC      ?C0121
                                           ; SOURCE LINE # 335
0023 E500        R     MOV     A,A
0025 C4                SWAP    A
0026 540F              ANL     A,#0FH
0028 25E0              ADD     A,ACC
002A FF                MOV     R7,A
002B E4                CLR     A
002C 33                RLC     A
002D FE                MOV     R6,A
002E 7400        R     MOV     A,#LOW NVRAM0+0280H
0030 2F                ADD     A,R7
0031 F582              MOV     DPL,A
0033 7400        R     MOV     A,#HIGH NVRAM0+0280H
0035 3E                ADDC    A,R6
0036 F583              MOV     DPH,A
0038 C083              PUSH    DPH
003A C082              PUSH    DPL
003C E500        R     MOV     A,A
003E 540F              ANL     A,#0FH
0040 FF                MOV     R7,A
0041 7401              MOV     A,#01H
0043 7E00              MOV     R6,#00H
0045 A807              MOV     R0,AR7
0047 08                INC     R0
0048 8005              SJMP    ?C0244
004A         ?C0243:
004A C3                CLR     C
004B 33                RLC     A
004C CE                XCH     A,R6
004D 33                RLC     A
004E CE                XCH     A,R6
004F         ?C0244:
004F D8F9              DJNZ    R0,?C0243
0051 FF                MOV     R7,A
0052 E0                MOVX    A,@DPTR
0053 4E                ORL     A,R6
0054 FE                MOV     R6,A
0055 A3                INC     DPTR
0056 E0                MOVX    A,@DPTR
0057 4F                ORL     A,R7
                                           ; SOURCE LINE # 336
0058 8039              SJMP    ?C0268
005A         ?C0121:
                                           ; SOURCE LINE # 337
                                           ; SOURCE LINE # 338
005A E500        R     MOV     A,A
005C C4                SWAP    A
005D 540F              ANL     A,#0FH
005F 25E0              ADD     A,ACC
0061 FF                MOV     R7,A
0062 E4                CLR     A
0063 33                RLC     A
0064 FE                MOV     R6,A
0065 7400        R     MOV     A,#LOW NVRAM0+0280H
0067 2F                ADD     A,R7
0068 F582              MOV     DPL,A
006A 7400        R     MOV     A,#HIGH NVRAM0+0280H
006C 3E                ADDC    A,R6
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 137 

006D F583              MOV     DPH,A
006F C083              PUSH    DPH
0071 C082              PUSH    DPL
0073 E500        R     MOV     A,A
0075 540F              ANL     A,#0FH
0077 FF                MOV     R7,A
0078 7401              MOV     A,#01H
007A 7E00              MOV     R6,#00H
007C A807              MOV     R0,AR7
007E 08                INC     R0
007F 8005              SJMP    ?C0246
0081         ?C0245:
0081 C3                CLR     C
0082 33                RLC     A
0083 CE                XCH     A,R6
0084 33                RLC     A
0085 CE                XCH     A,R6
0086         ?C0246:
0086 D8F9              DJNZ    R0,?C0245
0088 F4                CPL     A
0089 FF                MOV     R7,A
008A EE                MOV     A,R6
008B F4                CPL     A
008C FE                MOV     R6,A
008D E0                MOVX    A,@DPTR
008E 5E                ANL     A,R6
008F FE                MOV     R6,A
0090 A3                INC     DPTR
0091 E0                MOVX    A,@DPTR
0092 5F                ANL     A,R7
0093         ?C0268:
0093 FF                MOV     R7,A
0094 D082              POP     DPL
0096 D083              POP     DPH
0098 EE                MOV     A,R6
0099 F0                MOVX    @DPTR,A
009A A3                INC     DPTR
009B EF                MOV     A,R7
009C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 339
                                           ; SOURCE LINE # 340
009D 22                RET     
009E         ?C0120:
                                           ; SOURCE LINE # 341
                                           ; SOURCE LINE # 342
009E E500        R     MOV     A,A
00A0 C4                SWAP    A
00A1 540F              ANL     A,#0FH
00A3 25E0              ADD     A,ACC
00A5 FF                MOV     R7,A
00A6 E4                CLR     A
00A7 33                RLC     A
00A8 FE                MOV     R6,A
00A9 7400        R     MOV     A,#LOW NVRAM0+0280H
00AB 2F                ADD     A,R7
00AC F582              MOV     DPL,A
00AE 7400        R     MOV     A,#HIGH NVRAM0+0280H
00B0 3E                ADDC    A,R6
00B1 F583              MOV     DPH,A
00B3 C083              PUSH    DPH
00B5 C082              PUSH    DPL
00B7 E500        R     MOV     A,A
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 138 

00B9 540F              ANL     A,#0FH
00BB FF                MOV     R7,A
00BC 7401              MOV     A,#01H
00BE 7E00              MOV     R6,#00H
00C0 A807              MOV     R0,AR7
00C2 08                INC     R0
00C3 8005              SJMP    ?C0248
00C5         ?C0247:
00C5 C3                CLR     C
00C6 33                RLC     A
00C7 CE                XCH     A,R6
00C8 33                RLC     A
00C9 CE                XCH     A,R6
00CA         ?C0248:
00CA D8F9              DJNZ    R0,?C0247
00CC F4                CPL     A
00CD FF                MOV     R7,A
00CE EE                MOV     A,R6
00CF F4                CPL     A
00D0 FE                MOV     R6,A
00D1 E0                MOVX    A,@DPTR
00D2 5E                ANL     A,R6
00D3 FE                MOV     R6,A
00D4 A3                INC     DPTR
00D5 E0                MOVX    A,@DPTR
00D6 5F                ANL     A,R7
00D7 FF                MOV     R7,A
00D8 D082              POP     DPL
00DA D083              POP     DPH
00DC EE                MOV     A,R6
00DD F0                MOVX    @DPTR,A
00DE A3                INC     DPTR
00DF EF                MOV     A,R7
00E0 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 343
00E1 E500        R     MOV     A,A
00E3 25E0              ADD     A,ACC
00E5 FF                MOV     R7,A
00E6 E4                CLR     A
00E7 33                RLC     A
00E8 FE                MOV     R6,A
00E9 7400        R     MOV     A,#LOW NVRAM0+02E0H
00EB 2F                ADD     A,R7
00EC F582              MOV     DPL,A
00EE 7400        R     MOV     A,#HIGH NVRAM0+02E0H
00F0 3E                ADDC    A,R6
00F1 F583              MOV     DPH,A
00F3 E4                CLR     A
00F4 F0                MOVX    @DPTR,A
00F5 A3                INC     DPTR
00F6 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 344
                                           ; SOURCE LINE # 345
00F7         ?C0124:
00F7 22                RET     
             ; FUNCTION _T100MS (END)

             ; FUNCTION _TNTC (BEGIN)
                                           ; SOURCE LINE # 347
;---- Variable 'dat' assigned to Register 'DPTR' ----
0000 8F82              MOV     DPL,R7
0002 8E83              MOV     DPH,R6
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 139 

                                           ; SOURCE LINE # 350
0004 EE                MOV     A,R6
0005 33                RLC     A
0006 95E0              SUBB    A,ACC
0008 FD                MOV     R5,A
0009 FC                MOV     R4,A
000A E4                CLR     A
000B 7B98              MOV     R3,#098H
000D 7A08              MOV     R2,#08H
000F F9                MOV     R1,A
0010 F8                MOV     R0,A
0011 D3                SETB    C
0012 120000      E     LCALL   ?C?SLCMP
0015 5003              JNC     ?C0125
0017 900898            MOV     DPTR,#0898H
001A         ?C0125:
                                           ; SOURCE LINE # 351
001A C3                CLR     C
001B E583              MOV     A,DPH
001D 6480              XRL     A,#080H
001F 9480              SUBB    A,#080H
0021 5005              JNC     ?C0126
0023 E4                CLR     A
0024 F583              MOV     DPH,A
0026 F582              MOV     DPL,A
0028         ?C0126:
                                           ; SOURCE LINE # 353
0028 AE83              MOV     R6,DPH
002A AF82              MOV     R7,DPL
002C EE                MOV     A,R6
002D 33                RLC     A
002E 95E0              SUBB    A,ACC
0030 FD                MOV     R5,A
0031 FC                MOV     R4,A
0032 E4                CLR     A
0033 7B98              MOV     R3,#098H
0035 7A08              MOV     R2,#08H
0037 F9                MOV     R1,A
0038 F8                MOV     R0,A
0039 120000      E     LCALL   ?C?LMUL
003C E4                CLR     A
003D FB                MOV     R3,A
003E 7A10              MOV     R2,#010H
0040 F9                MOV     R1,A
0041 F8                MOV     R0,A
0042 120000      E     LCALL   ?C?SLDIV
;---- Variable 'temp' assigned to Register 'R6/R7' ----
                                           ; SOURCE LINE # 354
0045 C3                CLR     C
0046 7488              MOV     A,#088H
0048 9F                SUBB    A,R7
0049 FD                MOV     R5,A
004A 7413              MOV     A,#013H
004C 9E                SUBB    A,R6
004D FC                MOV     R4,A
004E 7EF0              MOV     R6,#0F0H
0050 7F80              MOV     R7,#080H
0052 120000      E     LCALL   ?C?UIDIV
                                           ; SOURCE LINE # 356
0055 AD07              MOV     R5,AR7
0057 AC06              MOV     R4,AR6
0059 E4                CLR     A
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 140 

005A 120000      E     LCALL   ?C?FCASTI
005D 7B00              MOV     R3,#00H
005F 7A40              MOV     R2,#040H
0061 791C              MOV     R1,#01CH
0063 7846              MOV     R0,#046H
0065 120000      E     LCALL   ?C?FPDIV
0068 120000      E     LCALL   _log
006B 7B97              MOV     R3,#097H
006D 7AC9              MOV     R2,#0C9H
006F 7996              MOV     R1,#096H
0071 7839              MOV     R0,#039H
0073 120000      E     LCALL   ?C?FPMUL
0076 7B62              MOV     R3,#062H
0078 7AEB              MOV     R2,#0EBH
007A 795B              MOV     R1,#05BH
007C 783B              MOV     R0,#03BH
007E 120000      E     LCALL   ?C?FPADD
0081 8F00        R     MOV     ftemp+03H,R7
0083 8E00        R     MOV     ftemp+02H,R6
0085 8D00        R     MOV     ftemp+01H,R5
0087 8C00        R     MOV     ftemp,R4
                                           ; SOURCE LINE # 357
0089 AB00        R     MOV     R3,ftemp+03H
008B AA00        R     MOV     R2,ftemp+02H
008D A900        R     MOV     R1,ftemp+01H
008F A800        R     MOV     R0,ftemp
0091 E4                CLR     A
0092 FF                MOV     R7,A
0093 FE                MOV     R6,A
0094 7D80              MOV     R5,#080H
0096 7C3F              MOV     R4,#03FH
0098 120000      E     LCALL   ?C?FPDIV
009B 7B00              MOV     R3,#00H
009D 7A80              MOV     R2,#080H
009F 7988              MOV     R1,#088H
00A1 78C3              MOV     R0,#0C3H
00A3 120000      E     LCALL   ?C?FPADD
00A6 8F00        R     MOV     ftemp+03H,R7
00A8 8E00        R     MOV     ftemp+02H,R6
00AA 8D00        R     MOV     ftemp+01H,R5
00AC 8C00        R     MOV     ftemp,R4
                                           ; SOURCE LINE # 358
00AE E4                CLR     A
00AF FF                MOV     R7,A
00B0 FE                MOV     R6,A
00B1 7DC8              MOV     R5,#0C8H
00B3 7C42              MOV     R4,#042H
00B5 AB00        R     MOV     R3,ftemp+03H
00B7 AA00        R     MOV     R2,ftemp+02H
00B9 A900        R     MOV     R1,ftemp+01H
00BB A800        R     MOV     R0,ftemp
00BD 120000      E     LCALL   ?C?FPCMP3
00C0 400B              JC      ?C0127
00C2 E4                CLR     A
00C3 F500        R     MOV     ftemp+03H,A
00C5 F500        R     MOV     ftemp+02H,A
00C7 7500C8      R     MOV     ftemp+01H,#0C8H
00CA 750042      R     MOV     ftemp,#042H
00CD         ?C0127:
                                           ; SOURCE LINE # 359
00CD E4                CLR     A
00CE FF                MOV     R7,A
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 141 

00CF FE                MOV     R6,A
00D0 7DC8              MOV     R5,#0C8H
00D2 7CC2              MOV     R4,#0C2H
00D4 AB00        R     MOV     R3,ftemp+03H
00D6 AA00        R     MOV     R2,ftemp+02H
00D8 A900        R     MOV     R1,ftemp+01H
00DA A800        R     MOV     R0,ftemp
00DC 120000      E     LCALL   ?C?FPCMP3
00DF 6002              JZ      $ + 4H
00E1 500B              JNC     ?C0128
00E3 E4                CLR     A
00E4 F500        R     MOV     ftemp+03H,A
00E6 F500        R     MOV     ftemp+02H,A
00E8 7500C8      R     MOV     ftemp+01H,#0C8H
00EB 7500C2      R     MOV     ftemp,#0C2H
00EE         ?C0128:
                                           ; SOURCE LINE # 360
00EE E4                CLR     A
00EF FF                MOV     R7,A
00F0 FE                MOV     R6,A
00F1 7D20              MOV     R5,#020H
00F3 7C41              MOV     R4,#041H
00F5 AB00        R     MOV     R3,ftemp+03H
00F7 AA00        R     MOV     R2,ftemp+02H
00F9 A900        R     MOV     R1,ftemp+01H
00FB A800        R     MOV     R0,ftemp
00FD 120000      E     LCALL   ?C?FPMUL
0100 120000      E     LCALL   ?C?CASTF
                                           ; SOURCE LINE # 361
0103         ?C0129:
0103 22                RET     
             ; FUNCTION _TNTC (END)

             ; FUNCTION _TENV (BEGIN)
                                           ; SOURCE LINE # 362
;---- Variable 'dat' assigned to Register 'R6/R7' ----
                                           ; SOURCE LINE # 364
0000 EE                MOV     A,R6
0001 33                RLC     A
0002 95E0              SUBB    A,ACC
0004 FD                MOV     R5,A
0005 FC                MOV     R4,A
0006 E4                CLR     A
0007 7B98              MOV     R3,#098H
0009 7A08              MOV     R2,#08H
000B F9                MOV     R1,A
000C F8                MOV     R0,A
000D 120000      E     LCALL   ?C?LMUL
0010 E4                CLR     A
0011 FB                MOV     R3,A
0012 7A10              MOV     R2,#010H
0014 F9                MOV     R1,A
0015 F8                MOV     R0,A
0016 120000      E     LCALL   ?C?SLDIV
;---- Variable 'temp' assigned to Register 'R6/R7' ----
                                           ; SOURCE LINE # 365
0019 EF                MOV     A,R7
001A 24A8              ADD     A,#0A8H
001C FF                MOV     R7,A
001D EE                MOV     A,R6
001E 34FC              ADDC    A,#0FCH
0020 FE                MOV     R6,A
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 142 

0021 E4                CLR     A
0022 34FF              ADDC    A,#0FFH
0024 FD                MOV     R5,A
0025 E4                CLR     A
0026 34FF              ADDC    A,#0FFH
0028 FC                MOV     R4,A
0029 E4                CLR     A
002A 7BE8              MOV     R3,#0E8H
002C 7A03              MOV     R2,#03H
002E F9                MOV     R1,A
002F F8                MOV     R0,A
0030 120000      E     LCALL   ?C?LMUL
0033 E4                CLR     A
0034 7B02              MOV     R3,#02H
0036 7A0D              MOV     R2,#0DH
0038 F9                MOV     R1,A
0039 F8                MOV     R0,A
003A 120000      E     LCALL   ?C?SLDIV
                                           ; SOURCE LINE # 366
                                           ; SOURCE LINE # 367
003D         ?C0130:
003D 22                RET     
             ; FUNCTION _TENV (END)

             ; FUNCTION _UPDAC (BEGIN)
                                           ; SOURCE LINE # 368
;---- Variable 'dat' assigned to Register 'R6/R7' ----
                                           ; SOURCE LINE # 369
0000 EE                MOV     A,R6
0001 703F              JNZ     ?C0137
0003 EF                MOV     A,R7
0004 14                DEC     A
0005 6016              JZ      ?C0133
0007 14                DEC     A
0008 601F              JZ      ?C0134
000A 14                DEC     A
000B 6028              JZ      ?C0135
000D 2403              ADD     A,#03H
000F 7031              JNZ     ?C0137
                                           ; SOURCE LINE # 370
0011         ?C0132:
                                           ; SOURCE LINE # 371
0011 900000      R     MOV     DPTR,#NVRAM0+06C8H
0014 E0                MOVX    A,@DPTR
0015 FC                MOV     R4,A
0016 A3                INC     DPTR
0017 E0                MOVX    A,@DPTR
0018 FD                MOV     R5,A
0019 E4                CLR     A
001A FF                MOV     R7,A
                                           ; SOURCE LINE # 372
001B 8022              SJMP    ?C0271
                                           ; SOURCE LINE # 373
                                           ; SOURCE LINE # 374
001D         ?C0133:
                                           ; SOURCE LINE # 375
001D 900000      R     MOV     DPTR,#NVRAM0+06CAH
0020 E0                MOVX    A,@DPTR
0021 FC                MOV     R4,A
0022 A3                INC     DPTR
0023 E0                MOVX    A,@DPTR
0024 FD                MOV     R5,A
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 143 

0025 7F01              MOV     R7,#01H
0027         ?C0269:
                                           ; SOURCE LINE # 376
0027 8016              SJMP    ?C0271
                                           ; SOURCE LINE # 377
                                           ; SOURCE LINE # 378
0029         ?C0134:
                                           ; SOURCE LINE # 379
0029 900000      R     MOV     DPTR,#NVRAM0+06CCH
002C E0                MOVX    A,@DPTR
002D FC                MOV     R4,A
002E A3                INC     DPTR
002F E0                MOVX    A,@DPTR
0030 FD                MOV     R5,A
0031 7F02              MOV     R7,#02H
0033         ?C0270:
                                           ; SOURCE LINE # 380
0033 800A              SJMP    ?C0271
                                           ; SOURCE LINE # 381
                                           ; SOURCE LINE # 382
0035         ?C0135:
                                           ; SOURCE LINE # 383
0035 900000      R     MOV     DPTR,#NVRAM0+06CEH
0038 E0                MOVX    A,@DPTR
0039 FC                MOV     R4,A
003A A3                INC     DPTR
003B E0                MOVX    A,@DPTR
003C FD                MOV     R5,A
003D 7F03              MOV     R7,#03H
003F         ?C0271:
003F 120000      E     LCALL   _mcp47x6Write
                                           ; SOURCE LINE # 384
                                           ; SOURCE LINE # 385
                                           ; SOURCE LINE # 386
                                           ; SOURCE LINE # 387
                                           ; SOURCE LINE # 388
0042         ?C0137:
0042 22                RET     
             ; FUNCTION _UPDAC (END)

             ; FUNCTION REBOOT (BEGIN)
                                           ; SOURCE LINE # 389
                                           ; SOURCE LINE # 397
;---- Variable 'SFRPAGE_save' assigned to Register 'R7' ----
0000 AFA7              MOV     R7,SFRPAGE
                                           ; SOURCE LINE # 398
0002 E4                CLR     A
0003 F5A7              MOV     SFRPAGE,A
                                           ; SOURCE LINE # 399
0005 43EF02            ORL     RSTSRC,#02H
                                           ; SOURCE LINE # 400
0008 8FA7              MOV     SFRPAGE,R7
                                           ; SOURCE LINE # 403
000A 22                RET     
             ; FUNCTION REBOOT (END)

             ; FUNCTION wdtInit (BEGIN)
                                           ; SOURCE LINE # 404
                                           ; SOURCE LINE # 408
0000 22                RET     
             ; FUNCTION wdtInit (END)

C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 144 

             ; FUNCTION wdtEnable (BEGIN)
                                           ; SOURCE LINE # 409
                                           ; SOURCE LINE # 415
0000 22                RET     
             ; FUNCTION wdtEnable (END)

             ; FUNCTION wdtDisable (BEGIN)
                                           ; SOURCE LINE # 416
                                           ; SOURCE LINE # 418
0000 A2AF              MOV     C,EA
0002 E4                CLR     A
0003 33                RLC     A
;---- Variable 'flagEA' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 419
0004 C2AF              CLR     EA
                                           ; SOURCE LINE # 426
0006 24FF              ADD     A,#0FFH
0008 92AF              MOV     EA,C
                                           ; SOURCE LINE # 428
000A 22                RET     
             ; FUNCTION wdtDisable (END)

             ; FUNCTION wdtFeed (BEGIN)
                                           ; SOURCE LINE # 429
                                           ; SOURCE LINE # 433
0000 22                RET     
             ; FUNCTION wdtFeed (END)

             ; FUNCTION pcaInit (BEGIN)
                                           ; SOURCE LINE # 435
                                           ; SOURCE LINE # 443
0000 22                RET     
             ; FUNCTION pcaInit (END)

             ; FUNCTION timer0Init (BEGIN)
                                           ; SOURCE LINE # 445
                                           ; SOURCE LINE # 447
0000 E4                CLR     A
0001 F500        R     MOV     TimerCounter_1mS,A
                                           ; SOURCE LINE # 448
0003 F500        R     MOV     TimerCounter_10mS,A
                                           ; SOURCE LINE # 461
0005 22                RET     
             ; FUNCTION timer0Init (END)

             ; FUNCTION timer0Isr (BEGIN)
0000 C0E0              PUSH    ACC
0002 C0F0              PUSH    B
0004 C083              PUSH    DPH
0006 C082              PUSH    DPL
0008 C0D0              PUSH    PSW
000A 75D000            MOV     PSW,#00H
000D C000              PUSH    AR0
000F C002              PUSH    AR2
0011 C004              PUSH    AR4
0013 C005              PUSH    AR5
0015 C006              PUSH    AR6
0017 C007              PUSH    AR7
                                           ; SOURCE LINE # 462
                                           ; SOURCE LINE # 464
0019 C28D              CLR     TF0
                                           ; SOURCE LINE # 465
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 145 

001B C28C              CLR     TR0
                                           ; SOURCE LINE # 466
001D 85008C      R     MOV     TH0,Timer0_H
                                           ; SOURCE LINE # 467
0020 85008A      R     MOV     TL0,Timer0_L
                                           ; SOURCE LINE # 468
0023 D28C              SETB    TR0
                                           ; SOURCE LINE # 469
0025 900000      R     MOV     DPTR,#NVRAM0+03E0H
0028 E0                MOVX    A,@DPTR
0029 A2E7              MOV     C,ACC.7
002B 13                RRC     A
002C A3                INC     DPTR
002D E0                MOVX    A,@DPTR
002E 13                RRC     A
002F 30E006            JNB     ACC.0,?C0145
                                           ; SOURCE LINE # 470
0032 E0                MOVX    A,@DPTR
0033 54FD              ANL     A,#0FDH
0035 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 471
0036 8007              SJMP    ?C0146
0038         ?C0145:
                                           ; SOURCE LINE # 472
                                           ; SOURCE LINE # 473
0038 900000      R     MOV     DPTR,#NVRAM0+03E1H
003B E0                MOVX    A,@DPTR
003C 4402              ORL     A,#02H
003E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 474
003F         ?C0146:
                                           ; SOURCE LINE # 476
;---- Variable 'i' assigned to Register 'R4/R5' ----
003F 7D50              MOV     R5,#050H
0041 7C01              MOV     R4,#01H
0043         ?C0147:
                                           ; SOURCE LINE # 477
0043 ED                MOV     A,R5
0044 25E0              ADD     A,ACC
0046 FF                MOV     R7,A
0047 EC                MOV     A,R4
0048 33                RLC     A
0049 FE                MOV     R6,A
004A 7400        R     MOV     A,#LOW NVRAM0
004C 2F                ADD     A,R7
004D F582              MOV     DPL,A
004F 7400        R     MOV     A,#HIGH NVRAM0
0051 3E                ADDC    A,R6
0052 F583              MOV     DPH,A
0054 E0                MOVX    A,@DPTR
0055 FA                MOV     R2,A
0056 A3                INC     DPTR
0057 E0                MOVX    A,@DPTR
0058 C3                CLR     C
0059 94FF              SUBB    A,#0FFH
005B EA                MOV     A,R2
005C 6480              XRL     A,#080H
005E 94FF              SUBB    A,#0FFH
0060 5011              JNC     ?C0149
                                           ; SOURCE LINE # 478
0062 7400        R     MOV     A,#LOW NVRAM0
0064 2F                ADD     A,R7
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 146 

0065 F582              MOV     DPL,A
0067 7400        R     MOV     A,#HIGH NVRAM0
0069 3E                ADDC    A,R6
006A F583              MOV     DPH,A
006C E4                CLR     A
006D 75F001            MOV     B,#01H
0070 120000      E     LCALL   ?C?IILDX
                                           ; SOURCE LINE # 479
                                           ; SOURCE LINE # 480
0073         ?C0149:
0073 0D                INC     R5
0074 BD0001            CJNE    R5,#00H,?C0249
0077 0C                INC     R4
0078         ?C0249:
0078 BC01C8            CJNE    R4,#01H,?C0147
007B BD60C5            CJNE    R5,#060H,?C0147
007E         ?C0148:
                                           ; SOURCE LINE # 481
007E E500        R     MOV     A,TimerCounter_1mS
0080 C3                CLR     C
0081 940A              SUBB    A,#0AH
0083 4065              JC      ?C0151
                                           ; SOURCE LINE # 482
0085 900000      R     MOV     DPTR,#NVRAM0+03E0H
0088 E0                MOVX    A,@DPTR
0089 FE                MOV     R6,A
008A A3                INC     DPTR
008B E0                MOVX    A,@DPTR
008C 7802              MOV     R0,#02H
008E         ?C0250:
008E CE                XCH     A,R6
008F A2E7              MOV     C,ACC.7
0091 13                RRC     A
0092 CE                XCH     A,R6
0093 13                RRC     A
0094 D8F8              DJNZ    R0,?C0250
0096 900000      R     MOV     DPTR,#NVRAM0+03E1H
0099 30E006            JNB     ACC.0,?C0152
                                           ; SOURCE LINE # 483
009C E0                MOVX    A,@DPTR
009D 54FB              ANL     A,#0FBH
009F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 484
00A0 8004              SJMP    ?C0153
00A2         ?C0152:
                                           ; SOURCE LINE # 485
                                           ; SOURCE LINE # 486
00A2 E0                MOVX    A,@DPTR
00A3 4404              ORL     A,#04H
00A5 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 487
00A6         ?C0153:
                                           ; SOURCE LINE # 488
00A6 7C01              MOV     R4,#01H
00A8 7D60              MOV     R5,#060H
00AA         ?C0154:
                                           ; SOURCE LINE # 489
00AA ED                MOV     A,R5
00AB 25E0              ADD     A,ACC
00AD FF                MOV     R7,A
00AE EC                MOV     A,R4
00AF 33                RLC     A
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 147 

00B0 FE                MOV     R6,A
00B1 7400        R     MOV     A,#LOW NVRAM0
00B3 2F                ADD     A,R7
00B4 F582              MOV     DPL,A
00B6 7400        R     MOV     A,#HIGH NVRAM0
00B8 3E                ADDC    A,R6
00B9 F583              MOV     DPH,A
00BB E0                MOVX    A,@DPTR
00BC FA                MOV     R2,A
00BD A3                INC     DPTR
00BE E0                MOVX    A,@DPTR
00BF C3                CLR     C
00C0 94FF              SUBB    A,#0FFH
00C2 EA                MOV     A,R2
00C3 6480              XRL     A,#080H
00C5 94FF              SUBB    A,#0FFH
00C7 5011              JNC     ?C0156
                                           ; SOURCE LINE # 490
00C9 7400        R     MOV     A,#LOW NVRAM0
00CB 2F                ADD     A,R7
00CC F582              MOV     DPL,A
00CE 7400        R     MOV     A,#HIGH NVRAM0
00D0 3E                ADDC    A,R6
00D1 F583              MOV     DPH,A
00D3 E4                CLR     A
00D4 75F001            MOV     B,#01H
00D7 120000      E     LCALL   ?C?IILDX
                                           ; SOURCE LINE # 491
                                           ; SOURCE LINE # 492
00DA         ?C0156:
00DA 0D                INC     R5
00DB BD0001            CJNE    R5,#00H,?C0251
00DE 0C                INC     R4
00DF         ?C0251:
00DF BC01C8            CJNE    R4,#01H,?C0154
00E2 BD70C5            CJNE    R5,#070H,?C0154
00E5         ?C0155:
                                           ; SOURCE LINE # 493
00E5 0500        R     INC     TimerCounter_10mS
                                           ; SOURCE LINE # 494
00E7 750000      R     MOV     TimerCounter_1mS,#00H
                                           ; SOURCE LINE # 495
00EA         ?C0151:
                                           ; SOURCE LINE # 496
00EA E500        R     MOV     A,TimerCounter_10mS
00EC C3                CLR     C
00ED 940A              SUBB    A,#0AH
00EF 4063              JC      ?C0158
                                           ; SOURCE LINE # 497
00F1 900000      R     MOV     DPTR,#NVRAM0+03E0H
00F4 E0                MOVX    A,@DPTR
00F5 FE                MOV     R6,A
00F6 A3                INC     DPTR
00F7 E0                MOVX    A,@DPTR
00F8 7803              MOV     R0,#03H
00FA         ?C0252:
00FA CE                XCH     A,R6
00FB A2E7              MOV     C,ACC.7
00FD 13                RRC     A
00FE CE                XCH     A,R6
00FF 13                RRC     A
0100 D8F8              DJNZ    R0,?C0252
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 148 

0102 900000      R     MOV     DPTR,#NVRAM0+03E1H
0105 30E006            JNB     ACC.0,?C0159
                                           ; SOURCE LINE # 498
0108 E0                MOVX    A,@DPTR
0109 54F7              ANL     A,#0F7H
010B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 499
010C 8004              SJMP    ?C0160
010E         ?C0159:
                                           ; SOURCE LINE # 500
                                           ; SOURCE LINE # 501
010E E0                MOVX    A,@DPTR
010F 4408              ORL     A,#08H
0111 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 502
0112         ?C0160:
                                           ; SOURCE LINE # 503
0112 7C01              MOV     R4,#01H
0114 7D70              MOV     R5,#070H
0116         ?C0161:
                                           ; SOURCE LINE # 504
0116 ED                MOV     A,R5
0117 25E0              ADD     A,ACC
0119 FF                MOV     R7,A
011A EC                MOV     A,R4
011B 33                RLC     A
011C FE                MOV     R6,A
011D 7400        R     MOV     A,#LOW NVRAM0
011F 2F                ADD     A,R7
0120 F582              MOV     DPL,A
0122 7400        R     MOV     A,#HIGH NVRAM0
0124 3E                ADDC    A,R6
0125 F583              MOV     DPH,A
0127 E0                MOVX    A,@DPTR
0128 FA                MOV     R2,A
0129 A3                INC     DPTR
012A E0                MOVX    A,@DPTR
012B C3                CLR     C
012C 94FF              SUBB    A,#0FFH
012E EA                MOV     A,R2
012F 6480              XRL     A,#080H
0131 94FF              SUBB    A,#0FFH
0133 5011              JNC     ?C0163
                                           ; SOURCE LINE # 505
0135 7400        R     MOV     A,#LOW NVRAM0
0137 2F                ADD     A,R7
0138 F582              MOV     DPL,A
013A 7400        R     MOV     A,#HIGH NVRAM0
013C 3E                ADDC    A,R6
013D F583              MOV     DPH,A
013F E4                CLR     A
0140 75F001            MOV     B,#01H
0143 120000      E     LCALL   ?C?IILDX
                                           ; SOURCE LINE # 506
                                           ; SOURCE LINE # 507
0146         ?C0163:
0146 0D                INC     R5
0147 BD0001            CJNE    R5,#00H,?C0253
014A 0C                INC     R4
014B         ?C0253:
014B BC01C8            CJNE    R4,#01H,?C0161
014E BD7FC5            CJNE    R5,#07FH,?C0161
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 149 

0151         ?C0162:
                                           ; SOURCE LINE # 508
0151 750000      R     MOV     TimerCounter_10mS,#00H
                                           ; SOURCE LINE # 509
0154         ?C0158:
                                           ; SOURCE LINE # 513
0154 0500        R     INC     TimerCounter_1mS
                                           ; SOURCE LINE # 514
0156 D007              POP     AR7
0158 D006              POP     AR6
015A D005              POP     AR5
015C D004              POP     AR4
015E D002              POP     AR2
0160 D000              POP     AR0
0162 D0D0              POP     PSW
0164 D082              POP     DPL
0166 D083              POP     DPH
0168 D0F0              POP     B
016A D0E0              POP     ACC
016C 32                RETI    
             ; FUNCTION timer0Isr (END)

             ; FUNCTION inputInit (BEGIN)
                                           ; SOURCE LINE # 516
                                           ; SOURCE LINE # 517
0000 7E00              MOV     R6,#00H
0002 7F10              MOV     R7,#010H
0004 7D00              MOV     R5,#00H
0006 7BFE              MOV     R3,#0FEH
0008 7A00        R     MOV     R2,#HIGH inputFilter
000A 7900        R     MOV     R1,#LOW inputFilter
000C 020000      E     LJMP    ?C?MEMSET
             ; FUNCTION inputInit (END)

             ; FUNCTION outputInit (BEGIN)
                                           ; SOURCE LINE # 523
                                           ; SOURCE LINE # 530
0000 22                RET     
             ; FUNCTION outputInit (END)

             ; FUNCTION inputRefresh (BEGIN)
                                           ; SOURCE LINE # 531
                                           ; SOURCE LINE # 533
;---- Variable 'ctemp0' assigned to Register 'R5' ----
0000 E4                CLR     A
0001 FD                MOV     R5,A
                                           ; SOURCE LINE # 534
                                           ; SOURCE LINE # 541
0002 120000      E     LCALL   inPca9554Read
0005 AD07              MOV     R5,AR7
                                           ; SOURCE LINE # 543
;---- Variable 'i' assigned to Register 'R4' ----
0007 E4                CLR     A
0008 FC                MOV     R4,A
0009         ?C0168:
                                           ; SOURCE LINE # 544
0009 ED                MOV     A,R5
000A A804              MOV     R0,AR4
000C 08                INC     R0
000D 8002              SJMP    ?C0255
000F         ?C0254:
000F C3                CLR     C
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 150 

0010 13                RRC     A
0011         ?C0255:
0011 D8FC              DJNZ    R0,?C0254
0013 30E032            JNB     ACC.0,?C0171
                                           ; SOURCE LINE # 545
0016 7400        R     MOV     A,#LOW inputFilter
0018 2C                ADD     A,R4
0019 F8                MOV     R0,A
001A E2                MOVX    A,@R0
001B C3                CLR     C
001C 6480              XRL     A,#080H
001E 9483              SUBB    A,#083H
0020 5009              JNC     ?C0172
                                           ; SOURCE LINE # 546
0022 7400        R     MOV     A,#LOW inputFilter
0024 2C                ADD     A,R4
0025 F8                MOV     R0,A
0026 E2                MOVX    A,@R0
0027 04                INC     A
0028 F2                MOVX    @R0,A
                                           ; SOURCE LINE # 547
0029 8051              SJMP    ?C0170
002B         ?C0172:
                                           ; SOURCE LINE # 548
                                           ; SOURCE LINE # 549
002B 7401              MOV     A,#01H
002D 7E00              MOV     R6,#00H
002F A804              MOV     R0,AR4
0031 08                INC     R0
0032 8005              SJMP    ?C0257
0034         ?C0256:
0034 C3                CLR     C
0035 33                RLC     A
0036 CE                XCH     A,R6
0037 33                RLC     A
0038 CE                XCH     A,R6
0039         ?C0257:
0039 D8F9              DJNZ    R0,?C0256
003B FF                MOV     R7,A
003C 900000      R     MOV     DPTR,#NVRAM0+0320H
003F E0                MOVX    A,@DPTR
0040 4E                ORL     A,R6
0041 F0                MOVX    @DPTR,A
0042 A3                INC     DPTR
0043 E0                MOVX    A,@DPTR
0044 4F                ORL     A,R7
0045 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 550
                                           ; SOURCE LINE # 551
0046 8034              SJMP    ?C0170
0048         ?C0171:
                                           ; SOURCE LINE # 552
                                           ; SOURCE LINE # 553
0048 7400        R     MOV     A,#LOW inputFilter
004A 2C                ADD     A,R4
004B F8                MOV     R0,A
004C E2                MOVX    A,@R0
004D D3                SETB    C
004E 6480              XRL     A,#080H
0050 947D              SUBB    A,#07DH
0052 4009              JC      ?C0175
                                           ; SOURCE LINE # 554
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 151 

0054 7400        R     MOV     A,#LOW inputFilter
0056 2C                ADD     A,R4
0057 F8                MOV     R0,A
0058 E2                MOVX    A,@R0
0059 14                DEC     A
005A F2                MOVX    @R0,A
                                           ; SOURCE LINE # 555
005B 801F              SJMP    ?C0170
005D         ?C0175:
                                           ; SOURCE LINE # 556
                                           ; SOURCE LINE # 557
005D 7401              MOV     A,#01H
005F 7E00              MOV     R6,#00H
0061 A804              MOV     R0,AR4
0063 08                INC     R0
0064 8005              SJMP    ?C0259
0066         ?C0258:
0066 C3                CLR     C
0067 33                RLC     A
0068 CE                XCH     A,R6
0069 33                RLC     A
006A CE                XCH     A,R6
006B         ?C0259:
006B D8F9              DJNZ    R0,?C0258
006D F4                CPL     A
006E FF                MOV     R7,A
006F EE                MOV     A,R6
0070 F4                CPL     A
0071 FE                MOV     R6,A
0072 900000      R     MOV     DPTR,#NVRAM0+0320H
0075 E0                MOVX    A,@DPTR
0076 5E                ANL     A,R6
0077 F0                MOVX    @DPTR,A
0078 A3                INC     DPTR
0079 E0                MOVX    A,@DPTR
007A 5F                ANL     A,R7
007B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 558
                                           ; SOURCE LINE # 559
                                           ; SOURCE LINE # 560
007C         ?C0170:
007C 0C                INC     R4
007D EC                MOV     A,R4
007E 6408              XRL     A,#08H
0080 7087              JNZ     ?C0168
0082         ?C0169:
                                           ; SOURCE LINE # 561
0082 7C08              MOV     R4,#08H
0084         ?C0177:
                                           ; SOURCE LINE # 562
0084 EC                MOV     A,R4
0085 24F8              ADD     A,#0F8H
0087 FF                MOV     R7,A
0088 E500        R     MOV     A,ctemp1
008A A807              MOV     R0,AR7
008C 08                INC     R0
008D 8002              SJMP    ?C0261
008F         ?C0260:
008F C3                CLR     C
0090 13                RRC     A
0091         ?C0261:
0091 D8FC              DJNZ    R0,?C0260
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 152 

0093 30E032            JNB     ACC.0,?C0180
                                           ; SOURCE LINE # 563
0096 7400        R     MOV     A,#LOW inputFilter
0098 2C                ADD     A,R4
0099 F8                MOV     R0,A
009A E2                MOVX    A,@R0
009B C3                CLR     C
009C 6480              XRL     A,#080H
009E 9483              SUBB    A,#083H
00A0 5009              JNC     ?C0181
                                           ; SOURCE LINE # 564
00A2 7400        R     MOV     A,#LOW inputFilter
00A4 2C                ADD     A,R4
00A5 F8                MOV     R0,A
00A6 E2                MOVX    A,@R0
00A7 04                INC     A
00A8 F2                MOVX    @R0,A
                                           ; SOURCE LINE # 565
00A9 8051              SJMP    ?C0179
00AB         ?C0181:
                                           ; SOURCE LINE # 566
                                           ; SOURCE LINE # 567
00AB 7401              MOV     A,#01H
00AD 7E00              MOV     R6,#00H
00AF A804              MOV     R0,AR4
00B1 08                INC     R0
00B2 8005              SJMP    ?C0263
00B4         ?C0262:
00B4 C3                CLR     C
00B5 33                RLC     A
00B6 CE                XCH     A,R6
00B7 33                RLC     A
00B8 CE                XCH     A,R6
00B9         ?C0263:
00B9 D8F9              DJNZ    R0,?C0262
00BB FF                MOV     R7,A
00BC 900000      R     MOV     DPTR,#NVRAM0+0320H
00BF E0                MOVX    A,@DPTR
00C0 4E                ORL     A,R6
00C1 F0                MOVX    @DPTR,A
00C2 A3                INC     DPTR
00C3 E0                MOVX    A,@DPTR
00C4 4F                ORL     A,R7
00C5 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 568
                                           ; SOURCE LINE # 569
00C6 8034              SJMP    ?C0179
00C8         ?C0180:
                                           ; SOURCE LINE # 570
                                           ; SOURCE LINE # 571
00C8 7400        R     MOV     A,#LOW inputFilter
00CA 2C                ADD     A,R4
00CB F8                MOV     R0,A
00CC E2                MOVX    A,@R0
00CD D3                SETB    C
00CE 6480              XRL     A,#080H
00D0 947D              SUBB    A,#07DH
00D2 4009              JC      ?C0184
                                           ; SOURCE LINE # 572
00D4 7400        R     MOV     A,#LOW inputFilter
00D6 2C                ADD     A,R4
00D7 F8                MOV     R0,A
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 153 

00D8 E2                MOVX    A,@R0
00D9 14                DEC     A
00DA F2                MOVX    @R0,A
                                           ; SOURCE LINE # 573
00DB 801F              SJMP    ?C0179
00DD         ?C0184:
                                           ; SOURCE LINE # 574
                                           ; SOURCE LINE # 575
00DD 7401              MOV     A,#01H
00DF 7E00              MOV     R6,#00H
00E1 A804              MOV     R0,AR4
00E3 08                INC     R0
00E4 8005              SJMP    ?C0265
00E6         ?C0264:
00E6 C3                CLR     C
00E7 33                RLC     A
00E8 CE                XCH     A,R6
00E9 33                RLC     A
00EA CE                XCH     A,R6
00EB         ?C0265:
00EB D8F9              DJNZ    R0,?C0264
00ED F4                CPL     A
00EE FF                MOV     R7,A
00EF EE                MOV     A,R6
00F0 F4                CPL     A
00F1 FE                MOV     R6,A
00F2 900000      R     MOV     DPTR,#NVRAM0+0320H
00F5 E0                MOVX    A,@DPTR
00F6 5E                ANL     A,R6
00F7 F0                MOVX    @DPTR,A
00F8 A3                INC     DPTR
00F9 E0                MOVX    A,@DPTR
00FA 5F                ANL     A,R7
00FB F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 576
                                           ; SOURCE LINE # 577
                                           ; SOURCE LINE # 578
00FC         ?C0179:
00FC 0C                INC     R4
00FD EC                MOV     A,R4
00FE 6410              XRL     A,#010H
0100 7082              JNZ     ?C0177
                                           ; SOURCE LINE # 579
0102         ?C0186:
0102 22                RET     
             ; FUNCTION inputRefresh (END)

             ; FUNCTION outputRefresh (BEGIN)
                                           ; SOURCE LINE # 580
                                           ; SOURCE LINE # 587
0000 900000      R     MOV     DPTR,#NVRAM0+0340H
0003 A3                INC     DPTR
0004 E0                MOVX    A,@DPTR
0005 FF                MOV     R7,A
0006 020000      E     LJMP    _outPca9554Write
             ; FUNCTION outputRefresh (END)

             ; FUNCTION chipAdcInit (BEGIN)
                                           ; SOURCE LINE # 590
                                           ; SOURCE LINE # 603
0000 E4                CLR     A
0001 F500        R     MOV     adcSelect,A
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 154 

                                           ; SOURCE LINE # 604
0003 F500        R     MOV     i,A
0005         ?C0188:
                                           ; SOURCE LINE # 605
0005 E500        R     MOV     A,i
0007 75F063            MOV     B,#063H
000A A4                MUL     AB
000B 2400        R     ADD     A,#LOW adcTempDat
000D F9                MOV     R1,A
000E 7400        R     MOV     A,#HIGH adcTempDat
0010 35F0              ADDC    A,B
0012 FA                MOV     R2,A
0013 7B01              MOV     R3,#01H
0015 120000      R     LCALL   _initAdcData
                                           ; SOURCE LINE # 606
0018 0500        R     INC     i
001A E500        R     MOV     A,i
001C D3                SETB    C
001D 9409              SUBB    A,#09H
001F 40E4              JC      ?C0188
                                           ; SOURCE LINE # 607
0021         ?C0191:
0021 22                RET     
             ; FUNCTION chipAdcInit (END)

             ; FUNCTION sPlcInit (BEGIN)
                                           ; SOURCE LINE # 608
                                           ; SOURCE LINE # 609
0000 120000      R     LCALL   wdtInit
                                           ; SOURCE LINE # 610
0003 120000      R     LCALL   wdtDisable
                                           ; SOURCE LINE # 621
0006 120000      R     LCALL   chipDacInit
                                           ; SOURCE LINE # 625
0009 E4                CLR     A
000A F500        E     MOV     ?_initModbus?BYTE+04H,A
000C 7500E1      E     MOV     ?_initModbus?BYTE+03H,#0E1H
000F F500        E     MOV     ?_initModbus?BYTE+02H,A
0011 F500        E     MOV     ?_initModbus?BYTE+01H,A
0013 7F01              MOV     R7,#01H
0015 120000      E     LCALL   _initModbus
                                           ; SOURCE LINE # 627
0018 120000      R     LCALL   timer0Init
                                           ; SOURCE LINE # 628
001B 900000      R     MOV     DPTR,#NVRAM0+03E1H
001E E0                MOVX    A,@DPTR
001F 4401              ORL     A,#01H
0021 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 629
0022 22                RET     
             ; FUNCTION sPlcInit (END)

             ; FUNCTION refreshDac (BEGIN)
                                           ; SOURCE LINE # 630
                                           ; SOURCE LINE # 639
0000 22                RET     
             ; FUNCTION refreshDac (END)

             ; FUNCTION chipDacInit (BEGIN)
                                           ; SOURCE LINE # 640
                                           ; SOURCE LINE # 647
0000 22                RET     
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 155 

             ; FUNCTION chipDacInit (END)

             ; FUNCTION sPlcProcessStart (BEGIN)
                                           ; SOURCE LINE # 648
                                           ; SOURCE LINE # 650
0000 120000      E     LCALL   modbusPorcess
                                           ; SOURCE LINE # 653
0003 020000      R     LJMP    inputRefresh
             ; FUNCTION sPlcProcessStart (END)

             ; FUNCTION sPlcProcessEnd (BEGIN)
                                           ; SOURCE LINE # 659
                                           ; SOURCE LINE # 664
0000 120000      R     LCALL   outputRefresh
                                           ; SOURCE LINE # 667
0003 020000      R     LJMP    refreshDac
             ; FUNCTION sPlcProcessEnd (END)

C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 156 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


uint8_t. . . . . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
uint16_t . . . . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
uint32_t . . . . . . . . . . . . . . .  TYPEDEF  -----  U_LONG   -----  4
uint64_t . . . . . . . . . . . . . . .  TYPEDEF  -----  ARRAY    -----  8
int8_t . . . . . . . . . . . . . . . .  TYPEDEF  -----  CHAR     -----  1
int16_t. . . . . . . . . . . . . . . .  TYPEDEF  -----  INT      -----  2
int32_t. . . . . . . . . . . . . . . .  TYPEDEF  -----  LONG     -----  4
int64_t. . . . . . . . . . . . . . . .  TYPEDEF  -----  ARRAY    -----  8
fp32_t . . . . . . . . . . . . . . . .  TYPEDEF  -----  FLOAT    -----  4
fp64_t . . . . . . . . . . . . . . . .  TYPEDEF  -----  FLOAT    -----  4
bool . . . . . . . . . . . . . . . . .  TYPEDEF  -----  BIT      -----  1
false. . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
true . . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
SI_UU16. . . . . . . . . . . . . . . .  * TAG *  -----  UNION    -----  2
  u16. . . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0000H  2
  s16. . . . . . . . . . . . . . . . .  MEMBER   -----  INT      0000H  2
  u8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
  s8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
SI_UU16_t. . . . . . . . . . . . . . .  TYPEDEF  -----  UNION    -----  2
  u16. . . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0000H  2
  s16. . . . . . . . . . . . . . . . .  MEMBER   -----  INT      0000H  2
  u8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
  s8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
SI_UU32. . . . . . . . . . . . . . . .  * TAG *  -----  UNION    -----  4
  u32. . . . . . . . . . . . . . . . .  MEMBER   -----  U_LONG   0000H  4
  s32. . . . . . . . . . . . . . . . .  MEMBER   -----  LONG     0000H  4
  uu16 . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  u16. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  s16. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  u8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  s8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
SI_UU32_t. . . . . . . . . . . . . . .  TYPEDEF  -----  UNION    -----  4
  u32. . . . . . . . . . . . . . . . .  MEMBER   -----  U_LONG   0000H  4
  s32. . . . . . . . . . . . . . . . .  MEMBER   -----  LONG     0000H  4
  uu16 . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  u16. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  s16. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  u8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  s8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
GPTR_t . . . . . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  3
  memtype. . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  address. . . . . . . . . . . . . . .  MEMBER   -----  UNION    0001H  2
SI_GEN_PTR . . . . . . . . . . . . . .  * TAG *  -----  UNION    -----  3
  u8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  3
  gptr . . . . . . . . . . . . . . . .  MEMBER   -----  STRUCT   0000H  3
SI_GEN_PTR_t . . . . . . . . . . . . .  TYPEDEF  -----  UNION    -----  3
  u8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  3
  gptr . . . . . . . . . . . . . . . .  MEMBER   -----  STRUCT   0000H  3
U8 . . . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
U16. . . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
U32. . . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_LONG   -----  4
S8 . . . . . . . . . . . . . . . . . .  TYPEDEF  -----  CHAR     -----  1
S16. . . . . . . . . . . . . . . . . .  TYPEDEF  -----  INT      -----  2
S32. . . . . . . . . . . . . . . . . .  TYPEDEF  -----  LONG     -----  4
UU16 . . . . . . . . . . . . . . . . .  * TAG *  -----  UNION    -----  2
  U16. . . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0000H  2
  S16. . . . . . . . . . . . . . . . .  MEMBER   -----  INT      0000H  2
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 157 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


  U8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
  S8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
UU16 . . . . . . . . . . . . . . . . .  TYPEDEF  -----  UNION    -----  2
  U16. . . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0000H  2
  S16. . . . . . . . . . . . . . . . .  MEMBER   -----  INT      0000H  2
  U8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
  S8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
UU32 . . . . . . . . . . . . . . . . .  * TAG *  -----  UNION    -----  4
  U32. . . . . . . . . . . . . . . . .  MEMBER   -----  U_LONG   0000H  4
  S32. . . . . . . . . . . . . . . . .  MEMBER   -----  LONG     0000H  4
  UU16 . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  U16. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  S16. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  U8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  S8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
UU32 . . . . . . . . . . . . . . . . .  TYPEDEF  -----  UNION    -----  4
  U32. . . . . . . . . . . . . . . . .  MEMBER   -----  U_LONG   0000H  4
  S32. . . . . . . . . . . . . . . . .  MEMBER   -----  LONG     0000H  4
  UU16 . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  U16. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  S16. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  U8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  S8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
SI_GENERIC_PTR . . . . . . . . . . . .  * TAG *  -----  UNION    -----  3
  U8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  3
  GPTR . . . . . . . . . . . . . . . .  MEMBER   -----  STRUCT   0000H  3
SI_GENERIC_PTR . . . . . . . . . . . .  TYPEDEF  -----  UNION    -----  3
  U8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  3
  GPTR . . . . . . . . . . . . . . . .  MEMBER   -----  STRUCT   0000H  3
P0 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0080H  1
SP . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0081H  1
DPL. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0082H  1
DPH. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0083H  1
SFR0CN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0084H  1
SFRNEXT. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0085H  1
SFRLAST. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0086H  1
PCON . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0087H  1
TCON . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0088H  1
TMOD . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0089H  1
TL0. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008AH  1
TL1. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008BH  1
TH0. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008CH  1
TH1. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008DH  1
CKCON. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008EH  1
PSCTL. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008FH  1
CLKSEL . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008FH  1
P1 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0090H  1
TMR3CN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0091H  1
TMR5CN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0091H  1
TMR3RLL. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0092H  1
TMR5CAPL . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0092H  1
TMR3RLH. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0093H  1
TMR5CAPH . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0093H  1
TMR3L. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0094H  1
TMR5L. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0094H  1
TMR3H. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0095H  1
TMR5H. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0095H  1
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 158 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


TMR5CF . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0096H  1
CLKMUL . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0097H  1
SCON0. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0098H  1
SCON1. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0098H  1
SBUF0. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0099H  1
SBUF1. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0099H  1
CPT0CN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   009AH  1
CPT2CN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   009AH  1
CPT0MD . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   009BH  1
CPT2MD . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   009BH  1
CPT0MX . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   009CH  1
CPT2MX . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   009CH  1
CPT1CN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   009DH  1
CPT1MD . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   009EH  1
OSCIFIN. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   009EH  1
CPT1MX . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   009FH  1
OSCXCN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   009FH  1
P2 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A0H  1
SPI0CFG. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A1H  1
OSCICN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A1H  1
SPI0CKR. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A2H  1
OSCICRS. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A2H  1
SPI0DAT. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A3H  1
P0MDOUT. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A4H  1
P1MDOUT. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A5H  1
P2MDOUT. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A6H  1
SFRPAGE. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A7H  1
IE . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A8H  1
SMOD0. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A9H  1
EMI0CN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00AAH  1
EMI0TC . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00AAH  1
SBCON0 . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00ABH  1
SBRLL0 . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00ACH  1
SBRLH0 . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00ADH  1
P3MAT. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00AEH  1
P3MDOUT. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00AEH  1
P3MASK . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00AFH  1
P4MDOUT. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00AFH  1
P3 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B0H  1
P2MAT. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B1H  1
P2MASK . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B2H  1
EMI0CF . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B2H  1
P4 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B5H  1
FLSCL. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B6H  1
FLKEY. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B7H  1
IP . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B8H  1
SMB0ADR. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B9H  1
ADC0TK . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00BAH  1
SMB0ADM. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00BAH  1
ADC0MX . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00BBH  1
ADC0CF . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00BCH  1
ADC0L. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00BDH  1
ADC0H. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00BEH  1
SMB0CN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C0H  1
SMB0CF . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C1H  1
SMB0DAT. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C2H  1
ADC0GTL. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C3H  1
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 159 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


ADC0GTH. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C4H  1
ADC0LTL. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C5H  1
ADC0LTH. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C6H  1
XBR3 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C6H  1
XBR2 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C7H  1
TMR2CN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C8H  1
TMR4CN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C8H  1
REG0CN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C9H  1
LIN0CF . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C9H  1
TMR4CF . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C9H  1
TMR2RLL. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CAH  1
TMR4CAPL . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CAH  1
TMR2RLH. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CBH  1
TMR4CAPH . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CBH  1
TMR2L. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CCH  1
TMR4L. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CCH  1
TMR2H. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CDH  1
TMR4H. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CDH  1
PCA0CPL5 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CEH  1
PCA1CPL11. . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CEH  1
PCA0CPH5 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CFH  1
PCA1CPH11. . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CFH  1
PSW. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D0H  1
REF0CN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D1H  1
LIN0DAT. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D2H  1
LIN0ADR. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D3H  1
P0SKIP . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D4H  1
P1SKIP . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D5H  1
P2SKIP . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D6H  1
P3SKIP . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D7H  1
PCA0CN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D8H  1
PCA1CN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D8H  1
PCA0MD . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D9H  1
PCA1MD . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D9H  1
PCA0PWM. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D9H  1
PCA0CPM0 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DAH  1
PCA1CPM6 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DAH  1
PCA1PWM. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DAH  1
PCA0CPM1 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DBH  1
PCA1CPM7 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DBH  1
PCA0CPM2 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DCH  1
PCA1CPM8 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DCH  1
PCA0CPM3 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DDH  1
PCA1CPM9 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DDH  1
PCA0CPM4 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DEH  1
PCA1CPM10. . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DEH  1
PCA0CPM5 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DFH  1
PCA1CPM11. . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DFH  1
ACC. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E0H  1
XBR0 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E1H  1
XBR1 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E2H  1
CCH0CN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E3H  1
IT01CF . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E4H  1
EIE1 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E6H  1
EIE2 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E7H  1
ADC0CN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E8H  1
PCA0CPL1 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E9H  1
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 160 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


PCA1CPL1 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E9H  1
PCA0CPH1 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00EAH  1
PCA1CPH1 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00EAH  1
PCA0CPL2 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00EBH  1
PCA1CPL2 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00EBH  1
PCA0CPH2 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00ECH  1
PCA1CPH2 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00ECH  1
PCA0CPL3 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00EDH  1
PCA1CPL3 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00EDH  1
PCA0CPH3 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00EEH  1
PCA1CPH3 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00EEH  1
RSTSRC . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00EFH  1
B. . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F0H  1
P0MAT. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F1H  1
P0MDIN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F1H  1
P0MASK . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F2H  1
P1MDIN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F2H  1
P1MAT. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F3H  1
P2MDIN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F3H  1
P1MASK . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F4H  1
P3MDIN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F4H  1
PSBANK . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F5H  1
EIP1 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F6H  1
EIP2 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F7H  1
SPI0CN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F8H  1
PCA0L. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F9H  1
PCA1L. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F9H  1
SN0. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F9H  1
PCA0H. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FAH  1
PCA1H. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FAH  1
SN1. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FAH  1
PCA0CPL0 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FBH  1
PCA1CPL6 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FBH  1
SN2. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FBH  1
PCA0CPH0 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FCH  1
PCA1CPH6 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FCH  1
SN3. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FCH  1
PCA0CPL4 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FDH  1
PCA1CPL10. . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FDH  1
PCA0CPH4 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FEH  1
PCA1CPH10. . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FEH  1
VDM0CN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FFH  1
CAN0CFG. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0092H  1
CAN0STAT . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0094H  1
CAN0ERRL . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0096H  1
CAN0ERRH . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0097H  1
CAN0BTL. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   009AH  1
CAN0BTH. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   009BH  1
CAN0IIDL . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   009CH  1
CAN0IIDH . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   009DH  1
CAN0TST. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   009EH  1
CAN0BRPE . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A1H  1
CAN0TR1L . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A2H  1
CAN0TR1H . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A3H  1
CAN0TR2L . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A4H  1
CAN0TR2H . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A5H  1
CAN0ND1L . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00AAH  1
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 161 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


CAN0ND1H . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00ABH  1
CAN0ND2L . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00ACH  1
CAN0ND2H . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00ADH  1
CAN0IP1L . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00AEH  1
CAN0IP1H . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00AFH  1
CAN0IP2L . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B2H  1
CAN0IP2H . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B3H  1
CAN0MV1L . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00BAH  1
CAN0MV1H . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00BBH  1
CAN0MV2L . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00BCH  1
CAN0MV2H . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00BDH  1
CAN0IF1CRL . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00BEH  1
CAN0IF1CRH . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00BFH  1
CAN0CN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C0H  1
CAN0IF1CML . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C2H  1
CAN0IF1CMH . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C3H  1
CAN0IF1M1L . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C4H  1
CAN0IF1M1H . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C5H  1
CAN0IF1M2L . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C6H  1
CAN0IF1M2H . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C7H  1
CAN0IF1A1L . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CAH  1
CAN0IF1A1H . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CBH  1
CAN0IF1A2L . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CCH  1
CAN0IF1A2H . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CDH  1
CAN0IF2MCL . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CEH  1
CAN0IF2MCH . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CFH  1
CAN0IF1MCL . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D2H  1
CAN0IF1MCH . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D3H  1
CAN0IF1DA1L. . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D4H  1
CAN0IF1DA1H. . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D5H  1
CAN0IF1DA2L. . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D6H  1
CAN0IF1DA2H. . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D7H  1
CAN0IF1DB1L. . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DAH  1
CAN0IF1DB1H. . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DBH  1
CAN0IF1DB2L. . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DCH  1
CAN0IF1DB2H. . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DDH  1
CAN0IF2CRL . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DEH  1
CAN0IF2CRH . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DFH  1
CAN0IF2CML . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E2H  1
CAN0IF2CMH . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E3H  1
CAN0IF2M1L . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00EAH  1
CAN0IF2M1H . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00EBH  1
CAN0IF2M2L . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00ECH  1
CAN0IF2M2H . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00EDH  1
CAN0IF2A1L . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00EEH  1
CAN0IF2A1H . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00EFH  1
CAN0IF2A2L . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F2H  1
CAN0IF2A2H . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F3H  1
CAN0IF2DA1L. . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F6H  1
CAN0IF2DA1H. . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F7H  1
CAN0IF2DA2L. . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FAH  1
CAN0IF2DA2H. . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FBH  1
CAN0IF2DB1L. . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FCH  1
CAN0IF2DB1H. . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FDH  1
CAN0IF2DB2L. . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FEH  1
CAN0IF2DB2H. . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FFH  1
DP . . . . . . . . . . . . . . . . . .  SFR      DATA   U_INT    0082H  2
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 162 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


TMR3RL . . . . . . . . . . . . . . . .  SFR      DATA   U_INT    0092H  2
TMR5CAP. . . . . . . . . . . . . . . .  SFR      DATA   U_INT    0092H  2
TMR3 . . . . . . . . . . . . . . . . .  SFR      DATA   U_INT    0094H  2
TMR5 . . . . . . . . . . . . . . . . .  SFR      DATA   U_INT    0094H  2
SBRL0. . . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00ACH  2
ADC0 . . . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00BDH  2
ADC0GT . . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00C3H  2
ADC0LT . . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00C5H  2
TMR2RL . . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00CAH  2
TMR4CAP. . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00CAH  2
TMR2 . . . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00CCH  2
TMR4 . . . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00CCH  2
PCA0CP5. . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00CEH  2
PCA1CP11 . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00CEH  2
PCA0CP1. . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00E9H  2
PCA1CP7. . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00E9H  2
PCA0CP2. . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00EBH  2
PCA1CP8. . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00EBH  2
PCA0CP3. . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00EDH  2
PCA1CP9. . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00EDH  2
PCA0 . . . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00F9H  2
PCA1 . . . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00F9H  2
PCA0CP0. . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00FBH  2
PCA1CP6. . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00FBH  2
PCA0CP4. . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00FDH  2
PCA1CP10 . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00FDH  2
CAN0ERR. . . . . . . . . . . . . . . .  SFR      DATA   U_INT    0096H  2
CAN0BT . . . . . . . . . . . . . . . .  SFR      DATA   U_INT    009AH  2
CAN0IID. . . . . . . . . . . . . . . .  SFR      DATA   U_INT    009CH  2
CAN0TR1. . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00A2H  2
CAN0TR2. . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00A4H  2
CAN0ND1. . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00AAH  2
CAN0ND2. . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00ACH  2
CAN0IP1. . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00AEH  2
CAN0IP2. . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00B2H  2
CAN0MV1. . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00BAH  2
CAN0MV2. . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00BCH  2
CAN0IF1CR. . . . . . . . . . . . . . .  SFR      DATA   U_INT    00BEH  2
CAN0IF1CM. . . . . . . . . . . . . . .  SFR      DATA   U_INT    00C2H  2
CAN0IF1M1. . . . . . . . . . . . . . .  SFR      DATA   U_INT    00C4H  2
CAN0IF1M2. . . . . . . . . . . . . . .  SFR      DATA   U_INT    00C6H  2
CAN0IF1A1. . . . . . . . . . . . . . .  SFR      DATA   U_INT    00CAH  2
CAN0IF1A2. . . . . . . . . . . . . . .  SFR      DATA   U_INT    00CCH  2
CAN0IF1MC. . . . . . . . . . . . . . .  SFR      DATA   U_INT    00D2H  2
CAN0IF1DA1 . . . . . . . . . . . . . .  SFR      DATA   U_INT    00D4H  2
CAN0IF1DA2 . . . . . . . . . . . . . .  SFR      DATA   U_INT    00D6H  2
CAN0IF1DB1 . . . . . . . . . . . . . .  SFR      DATA   U_INT    00DAH  2
CAN0IF1DB2 . . . . . . . . . . . . . .  SFR      DATA   U_INT    00DCH  2
CAN0IF2CR. . . . . . . . . . . . . . .  SFR      DATA   U_INT    00DEH  2
CAN0IF2CM. . . . . . . . . . . . . . .  SFR      DATA   U_INT    00E2H  2
CAN0IF2M1. . . . . . . . . . . . . . .  SFR      DATA   U_INT    00EAH  2
CAN0IF2M2. . . . . . . . . . . . . . .  SFR      DATA   U_INT    00ECH  2
CAN0IF2A1. . . . . . . . . . . . . . .  SFR      DATA   U_INT    00EEH  2
CAN0IF2A2. . . . . . . . . . . . . . .  SFR      DATA   U_INT    00F2H  2
CAN0IF2MC. . . . . . . . . . . . . . .  SFR      DATA   U_INT    00CEH  2
CAN0IF2DA1 . . . . . . . . . . . . . .  SFR      DATA   U_INT    00F6H  2
CAN0IF2DA2 . . . . . . . . . . . . . .  SFR      DATA   U_INT    00FAH  2
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 163 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


CAN0IF2DB1 . . . . . . . . . . . . . .  SFR      DATA   U_INT    00FCH  2
CAN0IF2DB2 . . . . . . . . . . . . . .  SFR      DATA   U_INT    00FEH  2
TF1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008FH  1
TR1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008EH  1
TF0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008DH  1
TR0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008CH  1
IE1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008BH  1
IT1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008AH  1
IE0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0089H  1
IT0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0088H  1
OVR0 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009FH  1
PERR0. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009EH  1
THRE0. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009DH  1
REN0 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009CH  1
TBX0 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009BH  1
RBX0 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009AH  1
TI0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0099H  1
RI0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0098H  1
S1MODE . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009FH  1
MCE1 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009DH  1
REN1 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009CH  1
TB81 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009BH  1
RB81 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009AH  1
TI1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0099H  1
RI1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0098H  1
EA . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00AFH  1
ESPI0. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00AEH  1
ET2. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00ADH  1
ES0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00ACH  1
ET1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00ABH  1
EX1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00AAH  1
ET0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A9H  1
EX0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A8H  1
PSPI0. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BEH  1
PT2. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BDH  1
PS0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BCH  1
PS . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BCH  1
PT1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BBH  1
PX1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BAH  1
PT0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B9H  1
PX0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B8H  1
MASTER . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C7H  1
TXMODE . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C6H  1
STA. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C5H  1
STO. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C4H  1
ACKRQ. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C3H  1
ARBLOST. . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C2H  1
ACK. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C1H  1
SI . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C0H  1
TF2H . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CFH  1
TF2L . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CEH  1
TF2LEN . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CDH  1
TF2CEN . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CCH  1
T2SPLIT. . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CBH  1
TR2. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CAH  1
T2RCLK . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C9H  1
T2XCLK . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C8H  1
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 164 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


TF4. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CFH  1
EXF4 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CEH  1
EXE4 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CBH  1
TR4. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CAH  1
CT4. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C9H  1
CPRL4. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C8H  1
CY . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D7H  1
AC . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D6H  1
F0 . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D5H  1
RS1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D4H  1
RS0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D3H  1
OV . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D2H  1
F1 . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D1H  1
P. . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D0H  1
CF . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00DFH  1
CR . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00DEH  1
CCF5 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00DDH  1
CCF4 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00DCH  1
CCF3 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00DBH  1
CCF2 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00DAH  1
CCF1 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D9H  1
CCF0 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D8H  1
CF1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00DFH  1
CR1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00DEH  1
CCF11. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00DDH  1
CCF10. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00DCH  1
CCF9 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00DBH  1
CCF8 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00DAH  1
CCF7 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D9H  1
CCF6 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D8H  1
AD0EN. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00EFH  1
BURSTEN. . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00EEH  1
AD0INT . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00EDH  1
AD0BUSY. . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00ECH  1
AD0WINT. . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00EBH  1
AD0LJST. . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00EAH  1
AD0CM1 . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00E9H  1
AD0CM0 . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00E8H  1
SPIF . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00FFH  1
WCOL . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00FEH  1
MODF . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00FDH  1
RXOVRN . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00FCH  1
NSSMD1 . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00FBH  1
NSSMD0 . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00FAH  1
TXBMT. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00F9H  1
SPIEN. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00F8H  1
size_t . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
wchar_t. . . . . . . . . . . . . . . .  TYPEDEF  -----  CHAR     -----  1
_log . . . . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
_epromWriteOneByte . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
_epromRead . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
_epromWrite. . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
_mcp47x6Write. . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
inPca9554Read. . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
_outPca9554Write . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
_initModbus. . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
modbusPorcess. . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 165 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


NVRAM0 . . . . . . . . . . . . . . . .  PUBLIC   XDATA  ARRAY    0000H  1024
NVRAM1 . . . . . . . . . . . . . . . .  PUBLIC   XDATA  ARRAY    0400H  1024
wdtDisable . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  flagEA . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
sPlcInit . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
sPlcProcessStart . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
sPlcProcessEnd . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
_assertCoilAddress . . . . . . . . . .  PUBLIC   CODE   PROC     0004H  -----
  adr. . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0006H  2
_assertRegisterAddress . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  adr. . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0006H  2
nvramUpdata. . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
  sp0. . . . . . . . . . . . . . . . .  AUTO     DATA   PTR      0000H  3
  sp1. . . . . . . . . . . . . . . . .  AUTO     DATA   PTR      0003H  3
  i. . . . . . . . . . . . . . . . . .  AUTO     DATA   U_INT    0006H  2
clearDM. . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  i. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0004H  2
clearEM. . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  i. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0004H  2
clearR . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  i. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0004H  2
clearT . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  i. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0004H  2
clearTD. . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  i. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0004H  2
clearC . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  i. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0004H  2
nvramLoad. . . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
nvramSave. . . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
_ADD . . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  A. . . . . . . . . . . . . . . . . .  * REG *  DATA   INT      0002H  2
  B. . . . . . . . . . . . . . . . . .  * REG *  DATA   INT      0004H  2
  tmp. . . . . . . . . . . . . . . . .  AUTO     DATA   LONG     0000H  4
_SET . . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  A. . . . . . . . . . . . . . . . . .  AUTO     DATA   U_INT    0000H  2
_RESET . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  A. . . . . . . . . . . . . . . . . .  AUTO     DATA   U_INT    0000H  2
_FLIP. . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  A. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0004H  2
  temp . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0006H  2
_LD. . . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  A. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0004H  2
_LDP . . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  A. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0004H  2
  temp0. . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0003H  1
  temp1. . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
_LDN . . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  A. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0004H  2
  temp0. . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0003H  1
  temp1. . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
_T1MS. . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  A. . . . . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0000H  1
  start. . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0005H  1
  value. . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0002H  2
_T10MS . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  A. . . . . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0000H  1
  start. . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0005H  1
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 166 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


  value. . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0002H  2
_T100MS. . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  A. . . . . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0000H  1
  start. . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0005H  1
  value. . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0002H  2
_UPDAC . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  dat. . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0006H  2
REBOOT . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  SFRPAGE_save . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
chipDacInit. . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
chipAdcInit. . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
  i. . . . . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0000H  1
refreshDac . . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
TimerCounter_1mS . . . . . . . . . . .  STATIC   DATA   U_CHAR   0000H  1
TimerCounter_10mS. . . . . . . . . . .  STATIC   DATA   U_CHAR   0001H  1
Timer0_L . . . . . . . . . . . . . . .  STATIC   DATA   U_CHAR   0002H  1
Timer0_H . . . . . . . . . . . . . . .  STATIC   DATA   U_CHAR   0003H  1
adcTempDat_t . . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  99
  dat. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  96
  out. . . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0060H  2
  wIndex . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0062H  1
inputFilter. . . . . . . . . . . . . .  STATIC   PDATA  ARRAY    0000H  16
adcTempDat . . . . . . . . . . . . . .  STATIC   XDATA  ARRAY    0800H  891
adcSelect. . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0004H  1
_refreshAdcData. . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
  s. . . . . . . . . . . . . . . . . .  AUTO     DATA   PTR      0000H  3
  dat. . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0004H  2
  i. . . . . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0003H  1
  temp . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0006H  2
  sum. . . . . . . . . . . . . . . . .  AUTO     DATA   U_LONG   0004H  4
adcProcess . . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
  result . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0004H  2
_initAdcData . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
  s. . . . . . . . . . . . . . . . . .  AUTO     DATA   PTR      0000H  3
  i. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
clearMR. . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  i. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0004H  2
clearX . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  i. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0004H  2
clearY . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  i. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0004H  2
clearSPREG . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  i. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0004H  2
clearSPCOIL. . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  i. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0004H  2
_TNTC. . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  dat. . . . . . . . . . . . . . . . .  * REG *  DATA   INT      0082H  2
  temp . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0006H  2
  ftemp. . . . . . . . . . . . . . . .  AUTO     DATA   FLOAT    0000H  4
_TENV. . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  dat. . . . . . . . . . . . . . . . .  * REG *  DATA   INT      0006H  2
  temp . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0006H  2
wdtInit. . . . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
wdtEnable. . . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
wdtFeed. . . . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
pcaInit. . . . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
timer0Init . . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
C51 COMPILER V9.56.0.0   SPLC                                                              01/04/2019 17:20:16 PAGE 167 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


  temp . . . . . . . . . . . . . . . .  AUTO     DATA   U_INT    0000H  2
timer0Isr. . . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
  i. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0004H  2
inputInit. . . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
outputInit . . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
inputRefresh . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
  ctemp0 . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0005H  1
  ctemp1 . . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0000H  1
  i. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0004H  1
outputRefresh. . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   4031    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   2939    ----
   PDATA SIZE       =     16    ----
   DATA SIZE        =      5      38
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
