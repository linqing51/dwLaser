C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE SPLC
OBJECT MODULE PLACED IN .\Objects\sPlc.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE MainApp\sPlc.c OPTIMIZE(8,SPEED) REGFILE(.\Objects\dwLaser_F020.ORC) BRO
                    -WSE ORDER INCDIR(.\Lib;.\Driver;.\MainApp;.\Modbus) DEFINE(C8051F020) DEBUG OBJECTEXTEND CODE LISTINCLUDE SYMBOLS PRINT(
                    -.\Listings\sPlc.lst) OBJECT(.\Objects\sPlc.obj)

line level    source

   1          #include "sPlc.h"
   1      =1  #ifndef __SPLC_H__
   2      =1  #define __SPLC_H__
   3      =1  /*****************************************************************************/
   4      =1  #include "appConfig.h"
   1      =2  #ifndef __APPCONFIG_H__
   2      =2  #define __APPCONFIG_H__
   3      =2  /*****************************************************************************/
   4      =2  #define DEBUG_LED_ON                                            0
   5      =2  #define DEBUG_LED_OFF                                           1
   6      =2  #define CONFIG_SYSCLK                       (22118400L)
   7      =2  #ifdef C8051F020
   8      =2  #define SAR_CLK                                                 2000000L//ADC0时钟 <2.5MHz
   9      =2  #endif
  10      =2  #define CONFIG_DEBUG                        0//调试功能
  11      =2  /*****************************************************************************/
  12      =2  #define CONFIG_UART0_BAUDRATE                           115200//串口波特率
  13      =2  #define CONFIG_UART0_PARITY                                     NONE
  14      =2  #define CONFIG_UART0_STOPBIT                            1
  15      =2  #define CONFIG_UART0_DATABIT                            8
  16      =2  
  17      =2  #define CONFIG_UART1_BAUDRATE                           9600//串口波特率
  18      =2  #define CONFIG_UART1_PARITY                                     NONE
  19      =2  #define CONFIG_UART1_STOPBIT                            1
  20      =2  #define CONFIG_UART1_DATABIT                            8
  21      =2  /*****************************************************************************/
  22      =2  #define CONFIG_I2C0_FREQ                                        1 
  23      =2  #define CONFIG_I2C_WAITACT_TIME                         250
  24      =2  /*****************************************************************************/
  25      =2  #define CONFIG_EPROM_DEBUG                                      0
  26      =2  #define CONFIG_EPROM_SIZE                                       CONFIG_AT24C64_SIZE
  27      =2  #define CONFIG_AT24C02_SIZE                             256
  28      =2  #define CONFIG_AT24C04_SIZE                             512
  29      =2  #define CONFIG_AT24C08_SIZE                             1024
  30      =2  #define CONFIG_AT24C16_SIZE                             2048
  31      =2  #define CONFIG_AT24C32_SIZE                             4096
  32      =2  #define CONFIG_AT24C64_SIZE                                     8192
  33      =2  #define CONFIG_AT24C128_SIZE                            16384
  34      =2  #define CONFIG_AT24C256_SIZE                            32768
  35      =2  #define CONFIG_EPROM_ADDRESS                            0x50
  36      =2  #define CONFIG_EPROM_FRAM                                       0//铁电存储体无写入等待
  37      =2  #define CONFIG_EPROM_PAGEWRITE                          0//页写入
  38      =2  /*****************************************************************************/
  39      =2  //SPLC设置
  40      =2  #define CONFIG_SPLC_ASSERT                                      0//检查地址范围
  41      =2  #define CONFIG_SPLC_DEV                                         0x0A01//设备号
  42      =2  #define CONFIG_SPLC_CLEAR_CODE                          0xA58E
  43      =2  #define CONFIG_SOFTPLC_HWTIME                           1000L//1mS
  44      =2  #define CONFIG_INPUT_FILTER_TIME                        3//输入数字滤波扫描周期 1mS * N
  45      =2  /*****************************************************************************/
  46      =2  #define CONFIG_SPLC_USING_CLEAR_NVRAM           1//启用清除NVRAM功能
  47      =2  /*****************************************************************************/
  48      =2  #define CONFIG_SPLC_USING_WDT                           1//看门狗启用
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 2   

  49      =2  /*****************************************************************************/
  50      =2  #define CONFIG_SPLC_USING_IO_INPUT                      1//输入IO刷新启用
  51      =2  /*****************************************************************************/
  52      =2  #define CONFIG_SPLC_USING_IO_OUTPUT                     1//输出IO刷新启用
  53      =2  /*****************************************************************************/
  54      =2  #define CONFIG_SPLC_USING_EPROM                         1//EPROM掉电存储启用
  55      =2  /*****************************************************************************/
  56      =2  #define CONFIG_SPLC_USING_UART1                         1//UART1串口启用
  57      =2  #if CONFIG_SPLC_USING_UART1 == 1
  58      =2  #define SPLC_UART1                                                      1
  59      =2  #endif
  60      =2  /*****************************************************************************/
  61      =2  #define CONFIG_SPLC_USING_CADC                          1//使能ADC模块
  62      =2  #define CONFIG_SPLC_ADC_FILTER_TAP                      14//ADC位移滤波次数
  63      =2  #define CONFIG_SPLC_ADC_CHANNLE                         64//ADC通道数
  64      =2  #define CONFIG_SPLC_ADC_TEMP_SENSOR_GAIN    3330L// Temp Sensor Gain in (uV / degC)
  65      =2  #define CONFIG_SPLC_ADC_TEMP_SENSOR_OFFSET  856L// Temp Sensor Offset in mV
  66      =2  #define CONFIG_SPLC_ADC_INTERNAL_VREF           2400L// ADC Voltage Reference (mV)
  67      =2  #define CONFIG_SPLC_ADC_AMBIENT             25L// Ambient temp in deg C
  68      =2  /*****************************************************************************/
  69      =2  #define CONFIG_SPLC_USING_DAC                           1//是能DAC模块
  70      =2  /*****************************************************************************/
  71      =2  #define CONFIG_SPLC_USING_MB_RTU_SLAVE          1//是能MODBUS RTU从站
  72      =2  #define CONFIG_MB_RTU_SLAVE_TIMER                       1000L//1000uS
  73      =2  #define CONFIG_MB_RTU_SLAVE_ADDRESS                     0x01//从设备地址
  74      =2  #define CONFIG_MB_RTU_SLAVE_BUFFER_SIZE         256//发送接收缓冲区
  75      =2  #define CONFIG_MB_RTU_SLAVE_TIMEOUT                     100//接收通讯超时 10mS
  76      =2  #define CONFIG_MB_RTU_SLAVE_IO_DELAY            1//RX TX切换延时
  77      =2  /*****************************************************************************/
  78      =2  /*****************************************************************************/
  79      =2  #define DISABLE_MODBUS_SERIAL_INTERRUPT         ES0 = 0;
  80      =2  #define ENABLE_MODBUS_SERIAL_INTERRUPT          ES0 = 1;
  81      =2  #define DISABLE_INTERRUPT                                       EA = 0;
  82      =2  #define ENABLE_INTERRUPT                                        EA = 1;
  83      =2  /*****************************************************************************/
  84      =2  //指示盒子
  85      =2  #define R_BOX_RED_SENDED                                        (R_START * 16 + 126)
  86      =2  #define R_BOX_GREEN_SENDED                                      (R_START * 16 + 127)
  87      =2  #define BOX_CMD_STX                                                     0x81
  88      =2  #define BOX_CMD_ETX                                                     0x84
  89      =2  #define BOX_SEND_BFADDR                                         (EM_START + 100)//发送缓冲区位置
  90      =2  #define BOX_SEND_LENGTH                                         29//发送数据量
  91      =2  /*****************************************************************************/
  92      =2  #include "stdint.h"
   1      =3  /**************************************************************************//**
   2      =3   * Copyright (c) 2015 by Silicon Laboratories Inc. All rights reserved.
   3      =3   *
   4      =3   * http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   5      =3   *****************************************************************************/
   6      =3  
   7      =3  #ifndef STDINT_H
   8      =3  #define STDINT_H
   9      =3  
  10      =3  #if defined __C51__
  11      =3  
  12      =3  typedef unsigned char uint8_t;
  13      =3  typedef unsigned short uint16_t;
  14      =3  typedef unsigned long uint32_t;
  15      =3  typedef uint32_t uint64_t[2];
  16      =3  
  17      =3  typedef signed char int8_t;
  18      =3  typedef short int16_t;
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 3   

  19      =3  typedef long int32_t;
  20      =3  typedef int32_t int64_t[2];
  21      =3  typedef float fp32_t;
  22      =3  typedef double fp64_t;
  23      =3  
  24      =3  #elif defined __ICC8051__
           =3 
           =3 /* Fixed size types. These are all optional. */
           =3 #ifdef __INT8_T_TYPE__
           =3   typedef __INT8_T_TYPE__   int8_t;
           =3   typedef __UINT8_T_TYPE__ uint8_t;
           =3 #endif /* __INT8_T_TYPE__ */
           =3 
           =3 #ifdef __INT16_T_TYPE__
           =3   typedef __INT16_T_TYPE__   int16_t;
           =3   typedef __UINT16_T_TYPE__ uint16_t;
           =3 #endif /* __INT16_T_TYPE__ */
           =3 
           =3 #ifdef __INT32_T_TYPE__
           =3   typedef __INT32_T_TYPE__   int32_t;
           =3   typedef __UINT32_T_TYPE__ uint32_t;
           =3 #endif /* __INT32_T_TYPE__ */
           =3 
           =3 #ifdef __INT64_T_TYPE__
           =3   #pragma language=save
           =3   #pragma language=extended
           =3   typedef __INT64_T_TYPE__   int64_t;
           =3   typedef __UINT64_T_TYPE__ uint64_t;
           =3   #pragma language=restore
           =3 #endif /* __INT64_T_TYPE__ */
           =3 
           =3 #endif
  51      =3  
  52      =3  #endif
  93      =2  #include "stdbool.h"
   1      =3  /**************************************************************************//**
   2      =3   * Copyright (c) 2015 by Silicon Laboratories Inc. All rights reserved.
   3      =3   *
   4      =3   * http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   5      =3   *****************************************************************************/
   6      =3  
   7      =3  #ifndef STDBOOL_H
   8      =3  #define STDBOOL_H
   9      =3  
  10      =3  #if defined __C51__
  11      =3  
  12      =3  typedef bit bool;
  13      =3  enum{
  14      =3    false = 0,
  15      =3    true = 1,
  16      =3  };
  17      =3  
  18      =3  #elif defined __ICC8051__
           =3 
           =3 #ifndef _SYSTEM_BUILD
           =3   #pragma system_include
           =3 #endif
           =3 
           =3 #ifndef __cplusplus
           =3 
           =3 #define bool _Bool
           =3 #define true 1
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 4   

           =3 #define false 0
           =3 
           =3 #define __bool_true_false_are_defined 1
           =3 
           =3 #endif /* !__cplusplus */
           =3 
           =3 #else  // __SLS_IDE__ : Macros defined to remove syntax errors within Simplicity Studio
           =3 
           =3 typedef bit bool;
           =3 enum{
           =3   false = 0,
           =3   true = 1,
           =3 };
           =3 
           =3 #endif
  43      =3  
  44      =3  #endif //STDBOOL_H
  45      =3  
  94      =2  #include "endian.h"
   1      =3  /**************************************************************************//**
   2      =3   * Copyright (c) 2015 by Silicon Laboratories Inc. All rights reserved.
   3      =3   *
   4      =3   * http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   5      =3   *****************************************************************************/
   6      =3  
   7      =3  #ifndef __ENDIAN_H__
   8      =3  #define __ENDIAN_H__
   9      =3  
  10      =3  #define bswapu16(x) (((x) >> 8) | ((x) << 8))
  11      =3  #define bswapu32(x) (((x) >> 24) | (((x) & 0x00FF0000) >> 8) \
  12      =3                    | (((x) & 0x0000FF00) << 8) | ((x) << 24))
  13      =3  
  14      =3  #define bswap16(x) bswapu16((uint16_t)(x))
  15      =3  #define bswap32(x) bswapu32((uint32_t)(x))
  16      =3  
  17      =3  // Big Endian Compilers
  18      =3  #if ((defined __C51__) || (defined __RC51__) || (defined _CC51))
  19      =3  
  20      =3  #define htobe16(x) (x)
  21      =3  #define htobe32(x) (x)
  22      =3  #define be16toh(x) (x)
  23      =3  #define be32toh(x) (x)
  24      =3  
  25      =3  #define htole16(x) bswap16(x)
  26      =3  #define htole32(x) bswap32(x)
  27      =3  #define le16toh(x) bswap16(x)
  28      =3  #define le32toh(x) bswap32(x)
  29      =3  
  30      =3  #elif ((defined SDCC) || (defined HI_TECH_C) || (defined __ICC8051__))
           =3 
           =3 #define htobe16(x) bswap16(x)
           =3 #define htobe32(x) bswap32(x)
           =3 #define be16toh(x) bswap16(x)
           =3 #define be32toh(x) bswap32(x)
           =3 
           =3 #define htole16(x) (x)
           =3 #define htole32(x) (x)
           =3 #define le16toh(x) (x)
           =3 #define le32toh(x) (x)
           =3 
           =3 #else
           =3 
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 5   

           =3 #define htobe16(x) (x)
           =3 #define htobe32(x) (x)
           =3 #define be16toh(x) (x)
           =3 #define be32toh(x) (x)
           =3 
           =3 #define htole16(x) (x)
           =3 #define htole32(x) (x)
           =3 #define le16toh(x) (x)
           =3 #define le32toh(x) (x)
           =3 
           =3 #endif  // Compiler Definitions
  55      =3  
  56      =3  #endif  // __ENDIAN_H__
  95      =2  #include "si_toolchain.h"
   1      =3  /******************************************************************************
   2      =3   * Copyright (c) 2015 by Silicon Laboratories Inc. All rights reserved.
   3      =3   *
   4      =3   * http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   5      =3   *****************************************************************************/
   6      =3  
   7      =3  #ifndef __SI_TOOLCHAIN_H__
   8      =3  #define __SI_TOOLCHAIN_H__
   9      =3  
  10      =3  #include <stdint.h>
   1      =4  /**************************************************************************//**
   2      =4   * Copyright (c) 2015 by Silicon Laboratories Inc. All rights reserved.
   3      =4   *
   4      =4   * http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   5      =4   *****************************************************************************/
   6      =4  
   7      =4  #ifndef STDINT_H
           =4 #define STDINT_H
           =4 
           =4 #if defined __C51__
           =4 
           =4 typedef unsigned char uint8_t;
           =4 typedef unsigned short uint16_t;
           =4 typedef unsigned long uint32_t;
           =4 typedef uint32_t uint64_t[2];
           =4 
           =4 typedef signed char int8_t;
           =4 typedef short int16_t;
           =4 typedef long int32_t;
           =4 typedef int32_t int64_t[2];
           =4 typedef float fp32_t;
           =4 typedef double fp64_t;
           =4 
           =4 #elif defined __ICC8051__
           =4 
           =4 /* Fixed size types. These are all optional. */
           =4 #ifdef __INT8_T_TYPE__
           =4   typedef __INT8_T_TYPE__   int8_t;
           =4   typedef __UINT8_T_TYPE__ uint8_t;
           =4 #endif /* __INT8_T_TYPE__ */
           =4 
           =4 #ifdef __INT16_T_TYPE__
           =4   typedef __INT16_T_TYPE__   int16_t;
           =4   typedef __UINT16_T_TYPE__ uint16_t;
           =4 #endif /* __INT16_T_TYPE__ */
           =4 
           =4 #ifdef __INT32_T_TYPE__
           =4   typedef __INT32_T_TYPE__   int32_t;
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 6   

           =4   typedef __UINT32_T_TYPE__ uint32_t;
           =4 #endif /* __INT32_T_TYPE__ */
           =4 
           =4 #ifdef __INT64_T_TYPE__
           =4   #pragma language=save
           =4   #pragma language=extended
           =4   typedef __INT64_T_TYPE__   int64_t;
           =4   typedef __UINT64_T_TYPE__ uint64_t;
           =4   #pragma language=restore
           =4 #endif /* __INT64_T_TYPE__ */
           =4 
           =4 #endif
           =4 
           =4 #endif
  11      =3  #include <stdbool.h>
   1      =4  /**************************************************************************//**
   2      =4   * Copyright (c) 2015 by Silicon Laboratories Inc. All rights reserved.
   3      =4   *
   4      =4   * http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   5      =4   *****************************************************************************/
   6      =4  
   7      =4  #ifndef STDBOOL_H
           =4 #define STDBOOL_H
           =4 
           =4 #if defined __C51__
           =4 
           =4 typedef bit bool;
           =4 enum{
           =4   false = 0,
           =4   true = 1,
           =4 };
           =4 
           =4 #elif defined __ICC8051__
           =4 
           =4 #ifndef _SYSTEM_BUILD
           =4   #pragma system_include
           =4 #endif
           =4 
           =4 #ifndef __cplusplus
           =4 
           =4 #define bool _Bool
           =4 #define true 1
           =4 #define false 0
           =4 
           =4 #define __bool_true_false_are_defined 1
           =4 
           =4 #endif /* !__cplusplus */
           =4 
           =4 #else  // __SLS_IDE__ : Macros defined to remove syntax errors within Simplicity Studio
           =4 
           =4 typedef bit bool;
           =4 enum{
           =4   false = 0,
           =4   true = 1,
           =4 };
           =4 
           =4 #endif
           =4 
           =4 #endif //STDBOOL_H
  45      =4  
  12      =3  
  13      =3  /**************************************************************************//**
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 7   

  14      =3   *
  15      =3   * @addtogroup toolchain_group Toolchain Abstraction
  16      =3   *
  17      =3   * @brief Macros for toolchain abstraction.
  18      =3   *
  19      =3   * # Introduction #
  20      =3   *
  21      =3   * This header file contains macros that are used to provide an abstraction
  22      =3   * for toolchain use in source code.  The 8051 compiler requires C-language
  23      =3   * extensions in order to fully use features of the 8051 architecture.  All
  24      =3   * compilers for 8051 implement a set of extensions but use different names
  25      =3   * and ways of implementing those extensions.  This header file provides
  26      =3   * macros that are defined for each supported toolchain and can be used in
  27      =3   * the source code.  This allows the source code to use 8051 extensions and
  28      =3   * remain independent of which toolchain is used for compilation.
  29      =3   *
  30      =3   * ## Variable and Pointer Declarations ##
  31      =3   *
  32      =3   * It is often useful to specify the memory area (or segment) of a variable,
  33      =3   * pointer, or pointer target.  For example, you may wish to place all
  34      =3   * variables in XDATA by default, but for variables used in time-sensitive
  35      =3   * code you use DATA for efficient access.  In this case you declare the
  36      =3   * XDATA variable in the normal C way, but declare the variables to be located
  37      =3   * in the DATA segment using @ref SI_SEGMENT_VARIABLE.
  38      =3   *
  39      =3   * Pointers are more complicated because there are two memory spaces
  40      =3   * associated with a pointer, the pointer target, and the pointer variable
  41      =3   * itself.  When using default memory segment for the pointer location and
  42      =3   * target, then no special macro is needed.  But if you wish to specify the
  43      =3   * pointer variable location, or target memory segment, then you can use one
  44      =3   * of the following macros to do this in a toolchain-independent way.
  45      =3   *
  46      =3   * |Pointer segment|Target segment|Macro                                   |
  47      =3   * |---------------|--------------|----------------------------------------|
  48      =3   * |default        |generic       |None                                    |
  49      =3   * |default        |specific      |@ref SI_VARIABLE_SEGMENT_POINTER        |
  50      =3   * |specific       |generic       |@ref SI_SEGMENT_POINTER                 |
  51      =3   * |specific       |specific      |@ref SI_SEGMENT_VARIABLE_SEGMENT_POINTER|
  52      =3   *
  53      =3   * ## Prior Toolchain Abstraction Header File ##
  54      =3   *
  55      =3   * This file supercedes an earlier header file named `compiler_defs.h`.  We
  56      =3   * are deprecating the use of compiler_defs.h, however it will remain for
  57      =3   * backwards compatibility.  This file was created to normalize macro names,
  58      =3   * remove unused macros, and to provide documentation.
  59      =3   *
  60      =3   * ## Supported Toolchains ##
  61      =3   *
  62      =3   * - Keil/ARM C51
  63      =3   *
  64      =3   * @{
  65      =3   *
  66      =3   *****************************************************************************/
  67      =3  
  68      =3  // Make sure there is a NULL defined if the toolchain does not provide it.
  69      =3  #ifndef NULL
  70      =3  #define NULL ((void *)0)
  71      =3  #endif
  72      =3  
  73      =3  // -------------------------------
  74      =3  // Keil/ARM C51
  75      =3  //
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 8   

  76      =3  #if defined(__C51__)
  77      =3  
  78      =3  /// Used with pointers, declares a generic pointer.  Generic pointers
  79      =3  /// work with any memory space but are inefficient.
  80      =3  #define SI_SEG_GENERIC
  81      =3  
  82      =3  /// Declares a variable to be located in 8051 DATA space.
  83      =3  #define SI_SEG_DATA data
  84      =3  
  85      =3  /// Declares a variable to be located in 8051 IDATA space.
  86      =3  #define SI_SEG_IDATA idata
  87      =3  
  88      =3  /// Declares a variable to be located in 8051 XDATA space.
  89      =3  #define SI_SEG_XDATA xdata
  90      =3  
  91      =3  /// Declares a variable to be located in 8051 PDATA space.
  92      =3  #define SI_SEG_PDATA pdata
  93      =3  
  94      =3  /// Declares a variable to be located in 8051 BDATA (bit-addressable) space.
  95      =3  #define SI_SEG_BDATA bdata
  96      =3  
  97      =3  /// Declares a variable to be located in 8051 CODE space.
  98      =3  #define SI_SEG_CODE code
  99      =3  
 100      =3  /**************************************************************************//**
 101      =3   * Declares a bit variable in a bit-addressable memory space.
 102      =3   *
 103      =3   * @param name The name of the bit variable.
 104      =3   *****************************************************************************/
 105      =3  #define SI_BIT(name) bit name
 106      =3  
 107      =3  /**************************************************************************//**
 108      =3   * Declares a bit variable in a bit-addressable SFR or memory space.
 109      =3   *
 110      =3   * @param name The name of the bit variable.
 111      =3   * @param address The address of the byte containing the bit.
 112      =3   * @param bitnum The bit number (0-7) within the byte.
 113      =3   *
 114      =3   * This cannot be used to make any arbitrary SFR or variable into
 115      =3   * a bit variable.  The underlying memory must support bit-addressability.
 116      =3   *****************************************************************************/
 117      =3  #define SI_SBIT(name, address, bitnum) sbit name = address^bitnum
 118      =3  
 119      =3  /**************************************************************************//**
 120      =3   * Declares an 8-bit special function register (SFR) variable.
 121      =3   *
 122      =3   * @param name The name of the SFR variable.
 123      =3   * @param address The address of the SFR.
 124      =3   *
 125      =3   * This creates a C variable (8-bit) that maps to a physical special function
 126      =3   * register of the 8051.  This cannot be used to make any arbitrary memory
 127      =3   * location into an SFR.  The _address_ must map to a real SFR in the memory
 128      =3   * map.
 129      =3   *****************************************************************************/
 130      =3  #define SI_SFR(name, address) sfr name = address
 131      =3  
 132      =3  /**************************************************************************//**
 133      =3   * Declares a 16-bit special function register (SFR) variable.
 134      =3   *
 135      =3   * @param name The name of the SFR variable.
 136      =3   * @param address The address of the 16-bit SFR.
 137      =3   *
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 9   

 138      =3   * This creates a C variable (16-bit) that maps to a physical special function
 139      =3   * register of the 8051.  This cannot be used to make any arbitrary memory
 140      =3   * location into an SFR.  The _address_ must map to a real 16-bit SFR in the
 141      =3   * memory map.
 142      =3   *****************************************************************************/
 143      =3  #define SI_SFR16(name, address) sfr16 name = address
 144      =3  
 145      =3  #ifndef __SLS_IDE__
 146      =3  /**************************************************************************//**
 147      =3   * Define an interrupt handler function for an interrupt vector.
 148      =3   *
 149      =3   * @param name The name of the interrupt handler function.
 150      =3   * @param vector The interrupt vector number.
 151      =3   *
 152      =3   * This macro defines a function to be an interrupt handler.  The _vector_
 153      =3   * parameter is the 8051 interrupt vector number, not the address.  This
 154      =3   * will cause the compiler to treat the function as the interrupt handler
 155      =3   * and generate the appropriate prolog/epilog code.
 156      =3   *
 157      =3   * @note This macro is used to define the function implementation.  To declare
 158      =3   * the interrupt function prototype, use @ref SI_INTERRUPT_PROTO.
 159      =3   *****************************************************************************/
 160      =3  #define SI_INTERRUPT(name, vector) void name (void) interrupt vector
 161      =3  
 162      =3  /**************************************************************************//**
 163      =3   * Define an interrupt handler function using a specific register bank.
 164      =3   *
 165      =3   * @param name The name of the interrupt handler function.
 166      =3   * @param vector The interrupt vector number.
 167      =3   * @param regnum The register bank number (0-3).
 168      =3   *
 169      =3   * This macro defines a function to be an interrupt handler, using a specific
 170      =3   * register bank for the interrupt code.  The _vector_ parameter is the 8051
 171      =3   * interrupt vector number, not the address.  The _regnum_ parameter is the
 172      =3   * register bank number (0-3) that will be used as general purpose registers
 173      =3   * for the instructions in the compiled code.  Using dedicated register banks
 174      =3   * for interrupt handlers allows the prolog code to just switch banks instead
 175      =3   * of saving and restoring all the general purpose registers.  This can make
 176      =3   * interrupt entry/exit faster but requires dedicating a register bank for
 177      =3   * the interrupt handler.
 178      =3   *
 179      =3   * @note This macro is used to define the function implementation.  To declare
 180      =3   * the interrupt function prototype, use @ref SI_INTERRUPT_PROTO_USING.
 181      =3   *****************************************************************************/
 182      =3  #define SI_INTERRUPT_USING(name, vector, regnum)                             \
 183      =3               void name (void) interrupt vector using regnum
 184      =3  
 185      =3  /**************************************************************************//**
 186      =3   * Declare an interrupt handler prototype for an interrupt vector.
 187      =3   *
 188      =3   * @param name The name of the interrupt handler function.
 189      =3   * @param vector The interrupt vector number.
 190      =3   *
 191      =3   * This macro declares a function prototype for an interrupt handler.  The
 192      =3   * _vector_ parameter is the 8051 interrupt vector number, not the address.
 193      =3   * Declaring the function prototype this way will cause the compiler to
 194      =3   * recognize that the function is an interrupt handler and not a normal C
 195      =3   * function.
 196      =3   *
 197      =3   * @note This macro is used to declare a prototype for the interrupt function.
 198      =3   * To define the interrupt function implementation, use @ref SI_INTERRUPT.
 199      =3   *****************************************************************************/
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 10  

 200      =3  #define SI_INTERRUPT_PROTO(name, vector) void name (void)
 201      =3  
 202      =3  /**************************************************************************//**
 203      =3   * Declare an interrupt handler prototype using a specific register bank.
 204      =3   *
 205      =3   * @param name The name of the interrupt handler function.
 206      =3   * @param vector The interrupt vector number.
 207      =3   * @param regnum The register bank number (0-3).
 208      =3   *
 209      =3   * This macro declares a function prototype for an interrupt handler, for a
 210      =3   * function that uses a specific register bank for the interrupt code.  The
 211      =3   * _vector_ parameter is the 8051 interrupt vector number, not the address.
 212      =3   * The _regnum_ parameter is the register bank number (0-3) that will be used
 213      =3   * as general purpose registers in the function.  Declaring the function
 214      =3   * prototype this way will cause the compiler to recognize that the function
 215      =3   * is an interrupt handler and is not a normal C function.
 216      =3   *
 217      =3   * @note This macro is used to declare a prototype for the interrupt function.
 218      =3   * To define the interrupt function implementation,
 219      =3   * use @ref SI_INTERRUPT_USING.
 220      =3   *****************************************************************************/
 221      =3  #define SI_INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
 222      =3  
 223      =3  /**************************************************************************//**
 224      =3   * Define a function to be reentrant (store local variables on the stack).
 225      =3   *
 226      =3   * @param name The name of the function.
 227      =3   * @param return_type The data type of the function return value
 228      =3   * (void, int, etc).
 229      =3   * @param parameter One C function parameter (or "void") (type and name).
 230      =3   *
 231      =3   * This macro defines a function to be reentrant.
 232      =3   *
 233      =3   * You must specify the _return_type_ which is the type of the function.  It
 234      =3   * can be `void` or any other C type or typedef.  The _parameters_ argument
 235      =3   * is the list of function parameters.  It can be `void` or else it must be
 236      =3   * a parameter data type and name.  It can also be multiple parameters but
 237      =3   * they must be enclosed in parentheses and separated by commas.
 238      =3   *
 239      =3   * __Example__
 240      =3   *
 241      =3   * ~~~~~~~~.c
 242      =3   * // The following is used to implement a function with the following
 243      =3   * // signature...
 244      =3   * uint16_t myFunction(uint8_t parm1, uint8_t parm2);
 245      =3   *
 246      =3   * SI_REENTRANT_FUNCTION(myFunction, uint16_t, (uint8_t parm1, uint8_t parm2))
 247      =3   * {
 248      =3   *   // Function implementation body
 249      =3   * }
 250      =3   * ~~~~~~~~
 251      =3   *
 252      =3   * @note This macro is used to define the function implementation.  To declare
 253      =3   * the function prototype, use @ref SI_REENTRANT_FUNCTION_PROTO.
 254      =3   *****************************************************************************/
 255      =3  #define SI_REENTRANT_FUNCTION(name, return_type, parameter) \
 256      =3    return_type name parameter reentrant
 257      =3  
 258      =3  /**************************************************************************//**
 259      =3   * Declare a function to be reentrant (store local variables on the stack).
 260      =3   *
 261      =3   * @param name The name of the function.
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 11  

 262      =3   * @param return_type The data type of the function return value
 263      =3   * (void, int, etc).
 264      =3   * @param parameter One C function parameter (or "void") (type and name).
 265      =3   *
 266      =3   * This macro declares a function prototype for a C function that is reentrant.
 267      =3   * See the documentation for @ref SI_REENTRANT_FUNCTION for an explanation of
 268      =3   * the macro arguments.  This is an advanced feature.
 269      =3   *
 270      =3   * @note This macro is used to declare a prototype for the function.  To
 271      =3   * define the function implementation, use @ref SI_REENTRANT_FUNCTION.
 272      =3   *****************************************************************************/
 273      =3  #define SI_REENTRANT_FUNCTION_PROTO(name, return_type, parameter) \
 274      =3    return_type name parameter reentrant
 275      =3                 
 276      =3  /**************************************************************************//**
 277      =3   * Define a function to use a specific register bank.
 278      =3   *
 279      =3   * @param name The name of the function.
 280      =3   * @param return_value The data type of the function return value
 281      =3   * (void, int, etc).
 282      =3   * @param parameter One C function parameter (or "void") (type and name).
 283      =3   * @param regnum The register bank number (0-3).
 284      =3   *
 285      =3   * This macro defines a function that uses a specific register bank.  The
 286      =3   * _regnum_ parameter is the register bank number (0-3) that will be used as
 287      =3   * general purpose registers for the instructions in the compiled function
 288      =3   * code.  Using dedicated register banks for a function can reduce the amount
 289      =3   * of registers saving and restoring needed on entry and exit to the
 290      =3   * function.  However, this is an advanced feature and you should not use it
 291      =3   * unless you fully understand how and when to use register banking.
 292      =3   *
 293      =3   * You must specify the _return_value_ which is the type of the function.  It
 294      =3   * can be `void` or any other C type or typedef.  The _parameters_ argument
 295      =3   * is the list of function parameters.  It can be `void` or else it must be
 296      =3   * a parameter data type and name.  It can also be multiple parameters but
 297      =3   * they must be enclosed in parentheses and separated by commas.
 298      =3   *
 299      =3   * __Example__
 300      =3   *
 301      =3   * ~~~~~~~~.c
 302      =3   * // The following is used to implement a function with the following
 303      =3   * // signature, and that uses register bank 3 ...
 304      =3   * uint16_t myFunction(uint8_t parm1, uint8_t parm2);
 305      =3   *
 306      =3   * SI_FUNCTION_USING(myFunction, uint16_t, (uint8_t parm1, uint8_t parm2), 3)
 307      =3   * {
 308      =3   *   // Function implementation body
 309      =3   * }
 310      =3   * ~~~~~~~~
 311      =3   *
 312      =3   * @note This macro is used to define the function implementation.  To declare
 313      =3   * the function prototype, use @ref SI_FUNCTION_PROTO_USING.
 314      =3   *****************************************************************************/
 315      =3  #define SI_FUNCTION_USING(name, return_value, parameter, regnum)              \
 316      =3               return_value name parameter using regnum
 317      =3  
 318      =3  /**************************************************************************//**
 319      =3   * Declare a function that uses a specific register bank.
 320      =3   *
 321      =3   * @param name The name of the function.
 322      =3   * @param return_value The data type of the function return value
 323      =3   * (void, int, etc).
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 12  

 324      =3   * @param parameter One C function parameter (or "void") (type and name).
 325      =3   * @param regnum The register bank number (0-3).
 326      =3   *
 327      =3   * This macro declares a function prototype for a C function that uses a
 328      =3   * specific register its working registers.  See the documentation for
 329      =3   * @ref SI_FUNCTION_USING for an explanation of the macro arguments.  This is
 330      =3   * an advanced feature.
 331      =3   *
 332      =3   * @note This macro is used to declare a prototype for the function.  To
 333      =3   * define the function implementation, use @ref SI_FUNCTION_USING.
 334      =3   *****************************************************************************/
 335      =3  #define SI_FUNCTION_PROTO_USING(name, return_value, parameter, regnum)        \
 336      =3               return_value name parameter
 337      =3  
 338      =3  /**************************************************************************//**
 339      =3   * Declare a variable to be located in a specific memory segment.
 340      =3   *
 341      =3   * @param name The variable name.
 342      =3   * @param vartype The variable data type.* @param memseg The memory segment to use for the variable.
 343      =3   *
 344      =3   * This macro declares a variable to be located in a specific memory area
 345      =3   * (or segment) of the 8051 memory space.  It is only necessary to use this
 346      =3   * macro if you want to force the variable into a specific memory space instead
 347      =3   * of the default memory space used by the compiler.  The segment can be
 348      =3   * one of the following:
 349      =3   *
 350      =3   * - @ref SI_SEG_DATA
 351      =3   * - @ref SI_SEG_IDATA
 352      =3   * - @ref SI_SEG_BDATA
 353      =3   * - @ref SI_SEG_PDATA
 354      =3   * - @ref SI_SEG_XDATA
 355      =3   * - @ref SI_SEG_CODE
 356      =3   *
 357      =3   * __Example__
 358      =3   *
 359      =3   * ~~~~~~~~.c
 360      =3   * // The following macro can be used to create a variable located in
 361      =3   * // XDATA with the following signature:
 362      =3   * uint8_t myVar;
 363      =3   *
 364      =3   * SI_SEGMENT_VARIABLE(myVar, uint8_t, SEG_XDATA);
 365      =3   * ~~~~~~~~
 366      =3   *****************************************************************************/
 367      =3  #define SI_SEGMENT_VARIABLE(name, vartype, memseg) vartype memseg name
 368      =3  
 369      =3  /**************************************************************************//**
 370      =3   * Declare a memory segment specific pointer variable.
 371      =3   *
 372      =3   * @param name The pointer variable name.
 373      =3   * @param vartype The pointer data type.
 374      =3   * @param targseg The target memory segment for the pointer.
 375      =3   *
 376      =3   * This macro declares a pointer that points at a specific memory area
 377      =3   * (or segment).  The memory segment of the pointer variable itself is not
 378      =3   * specified and the default is used.  The segment can be one of the following:
 379      =3   *
 380      =3   * - @ref SI_SEG_DATA
 381      =3   * - @ref SI_SEG_IDATA
 382      =3   * - @ref SI_SEG_BDATA
 383      =3   * - @ref SI_SEG_PDATA
 384      =3   * - @ref SI_SEG_XDATA
 385      =3   * - @ref SI_SEG_CODE
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 13  

 386      =3   *
 387      =3   * __Example__
 388      =3   *
 389      =3   * ~~~~~~~~.c
 390      =3   * // The following macro can be used to create a pointer that points to
 391      =3   * // a location in XDATA with the following signature:
 392      =3   * uint8_t *pVar; // where pVar is pointing at XDATA
 393      =3   *
 394      =3   * SI_VARIABLE_SEGMENT_POINTER(pVar, uint8_t, SEG_XDATA);
 395      =3   * ~~~~~~~~
 396      =3   *****************************************************************************/
 397      =3  #define SI_VARIABLE_SEGMENT_POINTER(name, vartype, targseg)                  \
 398      =3               vartype targseg * name
 399      =3  
 400      =3  /**************************************************************************//**
 401      =3   * Declare a memory segment specific pointer variable, in a specific segment.
 402      =3   *
 403      =3   * @param name The pointer variable name.
 404      =3   * @param vartype The pointer data type.
 405      =3   * @param targseg The target memory segment for the pointer.
 406      =3   * @param memseg The memory segment to use for the pointer variable.
 407      =3   *
 408      =3   * This macro declares a pointer that points at a specific memory area
 409      =3   * (or segment).  The pointer variable itself is also located in a specified
 410      =3   * memory segment by _memseg_.  The arguments _targseg_ and _memseg_ can be
 411      =3   * one of the following:
 412      =3   *
 413      =3   * - @ref SI_SEG_DATA
 414      =3   * - @ref SI_SEG_IDATA
 415      =3   * - @ref SI_SEG_BDATA
 416      =3   * - @ref SI_SEG_PDATA
 417      =3   * - @ref SI_SEG_XDATA
 418      =3   * - @ref SI_SEG_CODE
 419      =3   *
 420      =3   * __Example__
 421      =3   *
 422      =3   * ~~~~~~~~.c
 423      =3   * // The following macro can be used to create a pointer that points to
 424      =3   * // a location in XDATA while the pointer itself is located in DATA, with
 425      =3   * // the following signature:
 426      =3   * uint8_t *pVar; // where pVar is located in DATA and is pointing at XDATA
 427      =3   *
 428      =3   * SI_SEGMENT_VARIABLE_SEGMENT_POINTER(pVar, uint8_t, SEG_XDATA, SEG_DATA);
 429      =3   * ~~~~~~~~
 430      =3   *****************************************************************************/
 431      =3  #define SI_SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targseg, memseg)  \
 432      =3               vartype targseg * memseg name
 433      =3  
 434      =3  /**************************************************************************//**
 435      =3   * Declare a generic pointer variable that is located in a specific segment.
 436      =3   *
 437      =3   * @param name The pointer variable name.
 438      =3   * @param vartype The pointer data type.
 439      =3   * @param memseg The memory segment to use for the pointer variable.
 440      =3   *
 441      =3   * This macro declares a pointer that is a generic pointer.  This means it can
 442      =3   * point at any kind of memory location.  However the pointer variable itself
 443      =3   * is located in a specific memory segment by _memseg_, which can be one of
 444      =3   * the following:
 445      =3   *
 446      =3   * - @ref SI_SEG_DATA
 447      =3   * - @ref SI_SEG_IDATA
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 14  

 448      =3   * - @ref SI_SEG_BDATA
 449      =3   * - @ref SI_SEG_PDATA
 450      =3   * - @ref SI_SEG_XDATA
 451      =3   * - @ref SI_SEG_CODE
 452      =3   *
 453      =3   * __Example__
 454      =3   *
 455      =3   * ~~~~~~~~.c
 456      =3   * // The following macro can be used to create a generic pointer that
 457      =3   * // is located in DATA and points at any memory type, with the
 458      =3   * // following signature:
 459      =3   * uint8_t *pVar; // where pVar is located in DATA and is a generic pointer
 460      =3   *
 461      =3   * SI_SEGMENT_POINTER(pVar, uint8_t, SEG_DATA);
 462      =3   * ~~~~~~~~
 463      =3   *****************************************************************************/
 464      =3  #define SI_SEGMENT_POINTER(name, vartype, memseg) vartype * memseg name
 465      =3  
 466      =3  /**************************************************************************//**
 467      =3   * Declare an uninitialized variable that is located at a specific address.
 468      =3   *
 469      =3   * @param name The variable name.
 470      =3   * @param vartype The variable data type.
 471      =3   * @param memseg The memory segment to use for the variable.
 472      =3   * @param address The memory address of the variable.
 473      =3   *
 474      =3   * This macro allows declaring a variable that can be placed at a specific
 475      =3   * location in memory.  This can only be used for variables that do not need
 476      =3   * initializers.  The _address_ is the memory address within the specified
 477      =3   * segment.  The memory segment, _memseg_, can be one of the following:
 478      =3   *
 479      =3   * - @ref SI_SEG_DATA
 480      =3   * - @ref SI_SEG_IDATA
 481      =3   * - @ref SI_SEG_BDATA
 482      =3   * - @ref SI_SEG_PDATA
 483      =3   * - @ref SI_SEG_XDATA
 484      =3   * - @ref SI_SEG_CODE
 485      =3   *
 486      =3   * __Example__
 487      =3   *
 488      =3   * ~~~~~~~~.c
 489      =3   * // The following declares a variable located at 0x4000 in XDATA with
 490      =3   * // the following signature:
 491      =3   * uint8_t myMemVar;
 492      =3   *
 493      =3   * SI_LOCATED_VARIABLE_NO_INIT(myMemVar, uint8_t, SEG_DATA, 0x4000);
 494      =3   * ~~~~~~~~
 495      =3   *****************************************************************************/
 496      =3  #define SI_LOCATED_VARIABLE_NO_INIT(name, vartype, memseg, address)          \
 497      =3               vartype memseg name _at_ address
 498      =3  
 499      =3  
 500      =3  #else  // __SLS_IDE__ : Macros defined to remove syntax errors within Simplicity Studio
           =3 #define SI_INTERRUPT(name, vector) void name (void)
           =3 #define SI_INTERRUPT_USING(name, vector, regnum) void name (void)
           =3 #define SI_INTERRUPT_PROTO(name, vector) void name (void)
           =3 #define SI_INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
           =3 
           =3 #define SI_REENTRANT_FUNCTION(name, return_value, parameter, regnum) return_value name (parameter)
           =3 #define SI_REENTRANT_FUNCTION_PROTO(name, return_value, parameter, regnum) return_value name (parameter)
           =3 
           =3 #define SI_FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter)
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 15  

           =3 #define SI_FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =3 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =3 
           =3 #define SI_SEGMENT_VARIABLE(name, vartype, locsegment) vartype name
           =3 #define SI_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype * name
           =3 #define SI_SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype * name
           =3 #define SI_SEGMENT_POINTER(name, vartype, locsegment) vartype * name
           =3 #define SI_LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) vartype name
           =3 #endif // __SLS_IDE__
 519      =3  
 520      =3  // The following are used for byte ordering when referring to individual
 521      =3  // bytes within a SI_UU32_t.  B0 is the least significant byte.
 522      =3  #define B0 3 ///< Least significant byte of a 4 byte word
 523      =3  #define B1 2 ///< Byte 1 of a 4-byte word, where byte 0 is LSB
 524      =3  #define B2 1 ///< Byte 2 of a 4-byte word, where byte 0 is LSB
 525      =3  #define B3 0 ///< Most significant byte of a 4-byte word
 526      =3  
 527      =3  #define LSB 1 ///< Index to least significant bit of a 2 byte word
 528      =3  #define MSB 0 ///< Index to most significant bit of a 2 byte word
 529      =3  
 530      =3  /// A union type to make it easier to access individual bytes of a 16-bit
 531      =3  /// word, and to use as signed or unsigned type.
 532      =3  typedef union SI_UU16
 533      =3  {
 534      =3    uint16_t u16;   ///< The two byte value as a 16-bit unsigned integer.
 535      =3    int16_t s16;    ///< The two byte value as a 16-bit signed integer.
 536      =3    uint8_t u8[2];  ///< The two byte value as two unsigned 8-bit integers.
 537      =3    int8_t s8[2];   ///< The two byte value as two signed 8-bit integers.
 538      =3  } SI_UU16_t;
 539      =3  
 540      =3  /// A union type to make it easier to access individual bytes within a
 541      =3  /// 32-bit word, or to access it as variations of 16-bit words, or to
 542      =3  /// use as signed or unsigned type.
 543      =3  typedef union SI_UU32
 544      =3  {
 545      =3    uint32_t u32;       ///< The 4-byte value as a 32-bit unsigned integer.
 546      =3    int32_t s32;        ///< The 4-byte value as a 32-bit signed integer.
 547      =3    SI_UU16_t uu16[2];  ///< The 4-byte value as a SI_UU16_t.
 548      =3    uint16_t u16[2];    ///< The 4-byte value as two unsigned 16-bit integers.
 549      =3    int16_t s16[2];     ///< The 4-byte value as two signed 16-bit integers.
 550      =3    uint8_t u8[4];      ///< The 4-byte value as 4 unsigned 8-bit integers.
 551      =3    int8_t s8[4];       ///< The 4-byte value as 4 signed 8-bit integers.
 552      =3  } SI_UU32_t;
 553      =3  
 554      =3  // Generic pointer memory segment constants.
 555      =3  #define SI_GPTR                   ///< Generic pointer indeterminate type.
 556      =3  #define SI_GPTR_MTYPE_DATA  0x00  ///< Generic pointer for DATA segment.
 557      =3  #define SI_GPTR_MTYPE_IDATA 0x00  ///< Generic pointer for IDATA segment.
 558      =3  #define SI_GPTR_MTYPE_BDATA 0x00  ///< Generic pointer for BDATA segment.
 559      =3  #define SI_GPTR_MTYPE_PDATA 0xFE  ///< Generic pointer for PDATA segment.
 560      =3  #define SI_GPTR_MTYPE_XDATA 0x01  ///< Generic pointer for XDATA segment.
 561      =3  #define SI_GPTR_MTYPE_CODE  0xFF  ///< Generic pointer for CODE segment.
 562      =3  
 563      =3  /// Generic pointer structure containing the type and address.
 564      =3  typedef struct
 565      =3  {
 566      =3    uint8_t memtype;    ///< The type of memory of the generic pointer.
 567      =3    SI_UU16_t address;  ///< The address of the generic pointer.
 568      =3  } GPTR_t;
 569      =3  
 570      =3  /// A union type to allow access to the fields of a generic pointer.
 571      =3  /// A generic pointer has a field indicating the type of memory and an
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 16  

 572      =3  /// address within the memory.
 573      =3  typedef union SI_GEN_PTR
 574      =3  {
 575      =3    uint8_t u8[3];    ///< 3-byte generic pointer as 3 unsigned 8-bit integers.
 576      =3    GPTR_t gptr;      ///< 3-byte generic pointer as pointer structure
 577      =3  } SI_GEN_PTR_t;
 578      =3  
 579      =3  // Declaration of Keil intrinisc
 580      =3  extern void _nop_(void);
 581      =3  /// Macro to insert a no-operation (NOP) instruction.
 582      =3  #define NOP() _nop_()
 583      =3  
 584      =3  // -------------------------------
 585      =3  // GCC for ARM Cortex-M
 586      =3  // Provides support for code that can be compiled for 8 or 32-bit
 587      =3  //
 588      =3  #elif defined (__GNUC__)
           =3 #if defined(__ARMEL__) && ((__ARMEL__ == 1) && ((__ARM_ARCH == 6) || (__ARM_ARCH == 7)))
           =3 
           =3 // these ignore any memory segment directives
           =3 #define SI_SEG_GENERIC
           =3 #define SI_SEG_DATA
           =3 #define SI_SEG_IDATA
           =3 #define SI_SEG_XDATA
           =3 #define SI_SEG_PDATA
           =3 #define SI_SEG_BDATA
           =3 #define SI_SEG_CODE
           =3 
           =3 // the following create a variable of the specified name but ignore the
           =3 // address and bit number.  If the using-code cares about the actual
           =3 // address or bit number, this probably will break it
           =3 #define SI_SBIT(name, address, bitnum) uint8_t name
           =3 #define SI_SFR(name, address) uint8_t name
           =3 #define SI_SFR16(name, address) uint16_t name
           =3 
           =3 // the following create function and variable names of the specified types
           =3 // but the 8051-specific aspects (like memory segment) are ignored
           =3 #define SI_INTERRUPT(name, vector) void name (void)
           =3 #define SI_INTERRUPT_USING(name, vector, regnum) void name (void)
           =3 #define SI_INTERRUPT_PROTO(name, vector) void name (void)
           =3 #define SI_INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
           =3 #define SI_FUNCTION_USING(name, return_value, parameter, regnum)              \
           =3              return_value name (parameter)
           =3 #define SI_FUNCTION_PROTO_USING(name, return_value, parameter, regnum)        \
           =3              return_value name (parameter)
           =3 #define SI_SEGMENT_VARIABLE(name, vartype, memseg) vartype name
           =3 #define SI_VARIABLE_SEGMENT_POINTER(name, vartype, targseg)                  \
           =3              vartype * name
           =3 #define SI_SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targseg, memseg)  \
           =3              vartype * name
           =3 #define SI_SEGMENT_POINTER(name, vartype, memseg) vartype * name
           =3 #define SI_LOCATED_VARIABLE_NO_INIT(name, vartype, memseg, address)          \
           =3              vartype name
           =3 
           =3 #define B0 0
           =3 #define B1 1
           =3 #define B2 2
           =3 #define B3 3
           =3 #define LSB 0
           =3 #define MSB 1
           =3 typedef union SI_UU16
           =3 {
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 17  

           =3   uint16_t u16;
           =3   int16_t s16;
           =3   uint8_t u8[2];
           =3   int8_t s8[2];
           =3 } SI_UU16_t;
           =3 
           =3 typedef union SI_UU32
           =3 {
           =3   uint32_t u32;
           =3   int32_t s32;
           =3   SI_UU16_t uu16[2];
           =3   uint16_t u16[2];
           =3   int16_t s16[2];
           =3   uint8_t u8[4];
           =3   int8_t s8[4];
           =3 } SI_UU32_t;
           =3 
           =3 // Generic pointer stuff is left out because if you are accessing
           =3 // generic pointer fields then it will need to be rewritten for 32-bit
           =3 
           =3 // __NOP should be declared in cmsis header core_cmInstr.h
           =3 extern void __NOP(void);
           =3 /// Macro to insert a no-operation (NOP) instruction.
           =3 #define NOP() __NOP()
           =3 
           =3 #else // ARM_ARCH 6 | 7
           =3 #error unsupported ARM arch
           =3 #endif
           =3 
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 // IAR 8051
           =3 // http://www.iar.com
           =3 #elif defined __ICC8051__
           =3 
           =3 #include <intrinsics.h>
           =3 
           =3 #define SI_BIT(name)              __no_init bool __bit name
           =3 #define SI_SBIT(name, addr, bit)  __bit __no_init volatile bool name @ (addr+bit)
           =3 #define SI_SFR(name, addr)        __sfr __no_init volatile unsigned char name @ addr
           =3 #define SI_SFR16(name, addr)      __sfr __no_init volatile unsigned int  name @ addr
           =3 
           =3 #define SI_SEG_GENERIC __generic
           =3 #define SI_SEG_FAR  __xdata
           =3 #define SI_SEG_DATA __data
           =3 #define SI_SEG_NEAR __data
           =3 #define SI_SEG_IDATA __idata
           =3 #define SI_SEG_XDATA __xdata
           =3 #define SI_SEG_PDATA __pdata
           =3 #define SI_SEG_CODE  __code
           =3 #define SI_SEG_BDATA __bdata
           =3 
           =3 #define _PPTOSTR_(x) #x
           =3 #define _PPARAM_(address) _PPTOSTR_(vector=address * 8 + 3)
           =3 #define _PPARAM2_(regbank) _PPTOSTR_(register_bank=regbank)
           =3 #define SI_INTERRUPT(name, vector) _Pragma(_PPARAM_(vector)) __interrupt void name(void)
           =3 #define SI_INTERRUPT_PROTO(name, vector)  __interrupt void name(void)
           =3 #define SI_INTERRUPT_USING(name, vector, regnum) _Pragma(_PPARAM2_(regnum)) _Pragma(_PPARAM_(vector)) __in
             -terrupt void name(void)
           =3 #define SI_INTERRUPT_PROTO_USING(name, vector, regnum) __interrupt void name(void)
           =3 
           =3 #if (__DATA_MODEL__ == 0) /* TINY */ || \
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 18  

           =3     (__DATA_MODEL__ == 1) /* SMALL */
           =3 #define SI_REENTRANT_FUNCTION(name, return_type, parameter) \
           =3   __idata_reentrant return_type name parameter
           =3 #define SI_REENTRANT_FUNCTION_PROTO(name, return_type, parameter) \
           =3   __idata_reentrant return_type name parameter
           =3 #elif (__DATA_MODEL__ == 2) /* LARGE */ || \
           =3       (__DATA_MODEL__ == 3) /* GENERIC */ || \
           =3       (__DATA_MODEL__ == 4) /* FAR */
           =3 #define SI_REENTRANT_FUNCTION(name, return_type, parameter) \
           =3   __xdata_reentrant return_type name parameter
           =3 #define SI_REENTRANT_FUNCTION_PROTO(name, return_type, parameter) \
           =3   __xdata_reentrant return_type name (parameter)
           =3 #else
           =3 #error "Illegal memory model setting."
           =3 #endif
           =3 
           =3 // Note: IAR does not support functions using different register banks. Register
           =3 //       banks can only be specified in interrupts. If a function is called from
           =3 //       inside an interrupt, it will use the same register bank as the interrupt.
           =3 #define SI_FUNCTION_USING(name, return_value, parameter, regnum)              \
           =3              return_value name parameter
           =3 #define SI_FUNCTION_PROTO_USING(name, return_value, parameter, regnum)        \
           =3              return_value name parameter
           =3 
           =3 #define SI_SEGMENT_VARIABLE(name, vartype, locsegment)  vartype locsegment name
           =3 #define SI_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment  * name
           =3 #define SI_SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * 
             -locsegment name
           =3                
           =3 #define SI_SEGMENT_POINTER(name, vartype, ptrseg) vartype __generic * ptrseg name
           =3 
           =3 #define SI_LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment __no_init vartype name @ add
             -r
           =3 
           =3 #define SI_LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) locsegment __no_init vartype name @ a
             -ddr
           =3 
           =3 // The following are used for byte ordering when referring to individual
           =3 // bytes within a SI_UU32_t.  B0 is the least significant byte.
           =3 #define B0 0 ///< Least significant byte of a 4 byte word
           =3 #define B1 1 ///< Byte 1 of a 4-byte word, where byte 0 is LSB
           =3 #define B2 2 ///< Byte 2 of a 4-byte word, where byte 0 is LSB
           =3 #define B3 3 ///< Most significant byte of a 4-byte word
           =3 
           =3 #define LSB 0 ///< Index to least significant bit of a 2 byte word
           =3 #define MSB 1 ///< Index to most significant bit of a 2 byte word
           =3 
           =3 /// A union type to make it easier to access individual bytes of a 16-bit
           =3 /// word, and to use as signed or unsigned type.
           =3 typedef union SI_UU16
           =3 {
           =3   uint16_t u16;   ///< The two byte value as a 16-bit unsigned integer.
           =3   int16_t s16;    ///< The two byte value as a 16-bit signed integer.
           =3   uint8_t u8[2];  ///< The two byte value as two unsigned 8-bit integers.
           =3   int8_t s8[2];   ///< The two byte value as two signed 8-bit integers.
           =3 } SI_UU16_t;
           =3 
           =3 /// A union type to make it easier to access individual bytes within a
           =3 /// 32-bit word, or to access it as variations of 16-bit words, or to
           =3 /// use as signed or unsigned type.
           =3 typedef union SI_UU32
           =3 {
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 19  

           =3   uint32_t u32;       ///< The 4-byte value as a 32-bit unsigned integer.
           =3   int32_t s32;        ///< The 4-byte value as a 32-bit signed integer.
           =3   SI_UU16_t uu16[2];  ///< The 4-byte value as a SI_UU16_t.
           =3   uint16_t u16[2];    ///< The 4-byte value as two unsigned 16-bit integers.
           =3   int16_t s16[2];     ///< The 4-byte value as two signed 16-bit integers.
           =3   uint8_t u8[4];      ///< The 4-byte value as 4 unsigned 8-bit integers.
           =3   int8_t s8[4];       ///< The 4-byte value as 4 signed 8-bit integers.
           =3 } SI_UU32_t;
           =3 
           =3 // Generic pointer memory segment constants.
           =3 #define SI_GPTR                   ///< Generic pointer indeterminate type.
           =3 #define SI_GPTR_MTYPE_DATA  0x01  ///< Generic pointer for DATA segment.
           =3 #define SI_GPTR_MTYPE_IDATA 0x01  ///< Generic pointer for IDATA segment.
           =3 #define SI_GPTR_MTYPE_BDATA 0x01  ///< Generic pointer for BDATA segment.
           =3 #define SI_GPTR_MTYPE_PDATA 0x00  ///< Generic pointer for PDATA segment.
           =3 #define SI_GPTR_MTYPE_XDATA 0x00  ///< Generic pointer for XDATA segment.
           =3 #define SI_GPTR_MTYPE_CODE  0x80  ///< Generic pointer for CODE segment.
           =3 
           =3 /// Generic pointer structure containing the type and address.
           =3 typedef struct
           =3 {
           =3   SI_UU16_t address;  ///< The address of the generic pointer.
           =3   uint8_t memtype;    ///< The type of memory of the generic pointer.  
           =3 } GPTR_t;
           =3 
           =3 /// A union type to allow access to the fields of a generic pointer.
           =3 /// A generic pointer has a field indicating the type of memory and an
           =3 /// address within the memory.
           =3 typedef union SI_GEN_PTR
           =3 {
           =3   uint8_t u8[3];    ///< 3-byte generic pointer as 3 unsigned 8-bit integers.
           =3   GPTR_t gptr;      ///< 3-byte generic pointer as pointer structure
           =3 } SI_GEN_PTR_t;
           =3 
           =3 /// Macro to insert a no-operation (NOP) instruction.
           =3 #define NOP() __no_operation()
           =3 
           =3 #else // unknown toolchain
           =3 #error Unrecognized toolchain in si_toolchain.h
           =3 #endif
 794      =3  
 795      =3  /** @} */
 796      =3  
 797      =3  #endif
  96      =2  #include "compiler_defs.h"
   1      =3  //-----------------------------------------------------------------------------
   2      =3  // compiler_defs.h
   3      =3  //-----------------------------------------------------------------------------
   4      =3  // Portions of this file are copyright Maarten Brock
   5      =3  // http://sdcc.sourceforge.net
   6      =3  // Portions of this file are Copyright 2014 Silicon Laboratories, Inc.
   7      =3  // http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   8      =3  //
   9      =3  // GNU LGPL boilerplate:
  10      =3  /** This library is free software; you can redistribute it and/or
  11      =3    * modify it under the terms of the GNU Lesser General Public
  12      =3    * License as published by the Free Software Foundation; either
  13      =3    * version 2.1 of the License, or (at your option) any later version.
  14      =3    *
  15      =3    * This library is distributed in the hope that it will be useful,
  16      =3    * but WITHOUT ANY WARRANTY; without even the implied warranty of
  17      =3    * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 20  

  18      =3    * Lesser General Public License for more details.
  19      =3    *
  20      =3    * You should have received a copy of the GNU Lesser General Public
  21      =3    * License along with this library; if not, write to the Free Software
  22      =3    * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  23      =3    *
  24      =3    * In other words, you are welcome to use, share and improve this program.
  25      =3    * You are forbidden to forbid anyone else to use, share and improve
  26      =3    * what you give them. Help stamp out software-hoarding!
  27      =3  **/
  28      =3  // Program Description:
  29      =3  //
  30      =3  // **Important Note**: This header file should be included before including
  31      =3  // a device-specific header file such as C8051F300_defs.h.
  32      =3  //
  33      =3  // Macro definitions to accomodate 8051 compiler differences in specifying
  34      =3  // special function registers and other 8051-specific features such as NOP
  35      =3  // generation, and locating variables in memory-specific segments.  The
  36      =3  // compilers are identified by their unique predefined macros. See also:
  37      =3  // http://predef.sourceforge.net/precomp.html
  38      =3  //
  39      =3  // SBIT and SFR define special bit and special function registers at the given
  40      =3  // address. SFR16 and SFR32 define sfr combinations at adjacent addresses in
  41      =3  // little-endian format. SFR16E and SFR32E define sfr combinations without
  42      =3  // prerequisite byte order or adjacency. None of these multi-byte sfr
  43      =3  // combinations will guarantee the order in which they are accessed when read
  44      =3  // or written.
  45      =3  //
  46      =3  // SFR16X and SFR32X for 16 bit and 32 bit xdata registers are not defined
  47      =3  // to avoid portability issues because of compiler endianness.
  48      =3  //
  49      =3  // Example:
  50      =3  // // my_mcu.c: main 'c' file for my mcu
  51      =3  // #include <compiler_defs.h>  // this file
  52      =3  // #include <C8051xxxx_defs.h> // SFR definitions for specific MCU target
  53      =3  //
  54      =3  // SBIT  (P0_1, 0x80, 1);      // Port 0 pin 1
  55      =3  // SFR   (P0, 0x80);           // Port 0
  56      =3  // SFRX  (CPUCS, 0xE600);      // Cypress FX2 Control and Status register in
  57      =3  //                             // xdata memory at 0xE600
  58      =3  // SFR16 (TMR2, 0xCC);         // Timer 2, lsb at 0xCC, msb at 0xCD
  59      =3  // SFR16E(TMR0, 0x8C8A);       // Timer 0, lsb at 0x8A, msb at 0x8C
  60      =3  // SFR32 (MAC0ACC, 0x93);      // SiLabs C8051F120 32 bits MAC0 Accumulator,
  61      =3  //                             // lsb at 0x93, msb at 0x96
  62      =3  // SFR32E(SUMR, 0xE5E4E3E2);   // TI MSC1210 SUMR 32 bits Summation register,
  63      =3  //                             // lsb at 0xE2, msb at 0xE5
  64      =3  //
  65      =3  // Target:         C8051xxxx
  66      =3  // Tool chain:     Generic
  67      =3  // Command Line:   None
  68      =3  // 
  69      =3  // Release 2.7 - 25 JUN 2014 (JM)
  70      =3  //    -Added SI_GENERIC_PTR struct for accessing generic pointers
  71      =3  //    -Added SI_GPTR_MTYPE_XXXX definitions for determining the memory type
  72      =3  //     pointed at by a generic poitner
  73      =3  // Release 2.6 - 14 DEC 2012 (GO)
  74      =3  //        -Added define for deprecated SDCC keyword 'at'
  75      =3  // Release 2.5 - 12 SEP 2012 (TP)
  76      =3  //    -Added defines for deprecated SDCC keywords bit and code
  77      =3  // Release 2.4 - 27 AUG 2012 (TP)
  78      =3  //    -Added defines for deprecated SDCC keywords interrupt, _asm, and _endasm
  79      =3  // Release 2.3 - 27 MAY 2010 (DM)
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 21  

  80      =3  //    -Removed 'LOCATED_VARIABLE' pragma from Keil because it is not supported
  81      =3  // Release 2.2 - 06 APR 2010 (ES)
  82      =3  //    -Removed 'PATHINCLUDE' pragma from Raisonance section
  83      =3  // Release 2.1 - 16 JUL 2009 (ES)
  84      =3  //    -Added SEGMENT_POINTER macro definitions for SDCC, Keil, and Raisonance
  85      =3  //    -Added LOCATED_VARIABLE_NO_INIT macro definitions for Raisonance
  86      =3  // Release 2.0 - 19 MAY 2009 (ES)
  87      =3  //    -Added LOCATED_VARIABLE_NO_INIT macro definitions for SDCC and Keil
  88      =3  // Release 1.9 - 23 OCT 2008 (ES)
  89      =3  //    -Updated Hi-Tech INTERRUPT and INTERRUPT_USING macro definitions
  90      =3  //    -Added SFR16 macro defintion for Hi-Tech
  91      =3  // Release 1.8 - 31 JUL 2008 (ES)
  92      =3  //    -Added INTERRUPT_USING and FUNCTION_USING macro's
  93      =3  //    -Added macro's for IAR
  94      =3  //    -Corrected Union definitions for Hi-Tech and added SFR16 macro defintion
  95      =3  // Release 1.7 - 11 SEP 2007 (BW)
  96      =3  //    -Added support for Raisonance EVAL 03.03.42 and Tasking Eval 7.2r1
  97      =3  // Release 1.6 - 27 AUG 2007 (BW)
  98      =3  //    -Updated copyright notice per agreement with Maartin Brock
  99      =3  //    -Added SDCC 2.7.0 "compiler.h" bug fixes
 100      =3  //    -Added memory segment defines (SEG_XDATA, for example)
 101      =3  // Release 1.5 - 24 AUG 2007 (BW)
 102      =3  //    -Added support for NOP () macro
 103      =3  //    -Added support for Hi-Tech ver 9.01
 104      =3  // Release 1.4 - 07 AUG 2007 (PKC)
 105      =3  //    -Removed FID and fixed formatting.
 106      =3  // Release 1.3 - 30 SEP 2007 (TP)
 107      =3  //    -Added INTERRUPT_PROTO_USING to properly support ISR context switching
 108      =3  //     under SDCC.
 109      =3  // Release 1.2 - (BW)
 110      =3  //    -Added support for U8,U16,U32,S8,S16,S32,UU16,UU32 data types
 111      =3  // Release 1.1 - (BW)
 112      =3  //    -Added support for INTERRUPT, INTERRUPT_USING, INTERRUPT_PROTO,
 113      =3  //     SEGMENT_VARIABLE, VARIABLE_SEGMENT_POINTER,
 114      =3  //     SEGMENT_VARIABLE_SEGMENT_POINTER, and LOCATED_VARIABLE
 115      =3  // Release 1.0 - 29 SEP 2006 (PKC)
 116      =3  //    -Initial revision
 117      =3  
 118      =3  //-----------------------------------------------------------------------------
 119      =3  // Header File Preprocessor Directive
 120      =3  //-----------------------------------------------------------------------------
 121      =3  
 122      =3  #ifndef COMPILER_DEFS_H
 123      =3  #define COMPILER_DEFS_H
 124      =3  
 125      =3  #include "stdbool.h"
   1      =4  /**************************************************************************//**
   2      =4   * Copyright (c) 2015 by Silicon Laboratories Inc. All rights reserved.
   3      =4   *
   4      =4   * http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   5      =4   *****************************************************************************/
   6      =4  
   7      =4  #ifndef STDBOOL_H
           =4 #define STDBOOL_H
           =4 
           =4 #if defined __C51__
           =4 
           =4 typedef bit bool;
           =4 enum{
           =4   false = 0,
           =4   true = 1,
           =4 };
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 22  

           =4 
           =4 #elif defined __ICC8051__
           =4 
           =4 #ifndef _SYSTEM_BUILD
           =4   #pragma system_include
           =4 #endif
           =4 
           =4 #ifndef __cplusplus
           =4 
           =4 #define bool _Bool
           =4 #define true 1
           =4 #define false 0
           =4 
           =4 #define __bool_true_false_are_defined 1
           =4 
           =4 #endif /* !__cplusplus */
           =4 
           =4 #else  // __SLS_IDE__ : Macros defined to remove syntax errors within Simplicity Studio
           =4 
           =4 typedef bit bool;
           =4 enum{
           =4   false = 0,
           =4   true = 1,
           =4 };
           =4 
           =4 #endif
           =4 
           =4 #endif //STDBOOL_H
  45      =4  
 126      =3  #include "stdint.h"
   1      =4  /**************************************************************************//**
   2      =4   * Copyright (c) 2015 by Silicon Laboratories Inc. All rights reserved.
   3      =4   *
   4      =4   * http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   5      =4   *****************************************************************************/
   6      =4  
   7      =4  #ifndef STDINT_H
           =4 #define STDINT_H
           =4 
           =4 #if defined __C51__
           =4 
           =4 typedef unsigned char uint8_t;
           =4 typedef unsigned short uint16_t;
           =4 typedef unsigned long uint32_t;
           =4 typedef uint32_t uint64_t[2];
           =4 
           =4 typedef signed char int8_t;
           =4 typedef short int16_t;
           =4 typedef long int32_t;
           =4 typedef int32_t int64_t[2];
           =4 typedef float fp32_t;
           =4 typedef double fp64_t;
           =4 
           =4 #elif defined __ICC8051__
           =4 
           =4 /* Fixed size types. These are all optional. */
           =4 #ifdef __INT8_T_TYPE__
           =4   typedef __INT8_T_TYPE__   int8_t;
           =4   typedef __UINT8_T_TYPE__ uint8_t;
           =4 #endif /* __INT8_T_TYPE__ */
           =4 
           =4 #ifdef __INT16_T_TYPE__
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 23  

           =4   typedef __INT16_T_TYPE__   int16_t;
           =4   typedef __UINT16_T_TYPE__ uint16_t;
           =4 #endif /* __INT16_T_TYPE__ */
           =4 
           =4 #ifdef __INT32_T_TYPE__
           =4   typedef __INT32_T_TYPE__   int32_t;
           =4   typedef __UINT32_T_TYPE__ uint32_t;
           =4 #endif /* __INT32_T_TYPE__ */
           =4 
           =4 #ifdef __INT64_T_TYPE__
           =4   #pragma language=save
           =4   #pragma language=extended
           =4   typedef __INT64_T_TYPE__   int64_t;
           =4   typedef __UINT64_T_TYPE__ uint64_t;
           =4   #pragma language=restore
           =4 #endif /* __INT64_T_TYPE__ */
           =4 
           =4 #endif
           =4 
           =4 #endif
 127      =3  
 128      =3  //-----------------------------------------------------------------------------
 129      =3  // Macro definitions
 130      =3  //-----------------------------------------------------------------------------
 131      =3  
 132      =3  //SDK Version
 133      =3  #define SDK_VERSION   2
 134      =3  
 135      =3  #ifndef NULL
           =3 #define NULL ((void*) 0)
           =3 #endif
 138      =3  
 139      =3  
 140      =3  // SDCC - Small Device C Compiler
 141      =3  // http://sdcc.sourceforge.net
 142      =3  
 143      =3  #if defined SDCC
           =3 
           =3 #if (SDCC >= 300)
           =3 
           =3 #define interrupt __interrupt
           =3 #define _asm __asm
           =3 #define _endasm __endasm
           =3 #define bit __bit
           =3 #define code __code
           =3 #define at __at
           =3 
           =3 #endif
           =3 
           =3 # define SEG_GENERIC
           =3 # define SEG_FAR   __xdata
           =3 # define SEG_DATA  __data
           =3 # define SEG_NEAR  __data
           =3 # define SEG_IDATA __idata
           =3 # define SEG_XDATA __xdata
           =3 # define SEG_PDATA __pdata
           =3 # define SEG_CODE  __code
           =3 # define SEG_BDATA __bdata
           =3 
           =3 # define SBIT(name, addr, bit)  __sbit  __at(addr+bit)                  name
           =3 # define SFR(name, addr)        __sfr   __at(addr)                      name
           =3 # define SFRX(name, addr)       xdata volatile unsigned char __at(addr) name
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 24  

           =3 # define SFR16(name, addr)      __sfr16 __at(((addr+1U)<<8) | addr)     name
           =3 # define SFR16E(name, fulladdr) __sfr16 __at(fulladdr)                  name
           =3 # define SFR32(name, addr)      __sfr32 __at(((addr+3UL)<<24) | ((addr+2UL)<<16) | ((addr+1UL)<<8) | addr)
             - name
           =3 # define SFR32E(name, fulladdr) __sfr32 __at(fulladdr)                  name
           =3 
           =3 # define INTERRUPT(name, vector) void name (void) interrupt (vector)
           =3 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt (vector) using (regnum)
           =3 # define INTERRUPT_PROTO(name, vector) void name (void) interrupt (vector)
           =3 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void) interrupt (vector) using (regnum)
           =3 
           =3 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using (regnum
             -)
           =3 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter) using (
             -regnum)
           =3 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =3 
           =3 # define SEGMENT_VARIABLE(name, vartype, locsegment) locsegment vartype name
           =3 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) targsegment vartype * name
           =3 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) targsegment vartype * lo
             -csegment name
           =3 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
           =3 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment at (addr) vartype name = init
           =3 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) locsegment at (addr) vartype name
           =3 
           =3 // used with UU16
           =3 # define LSB 0
           =3 # define MSB 1
           =3 
           =3 // used with UU32 (b0 is least-significant byte)
           =3 # define b0 0
           =3 # define b1 1
           =3 # define b2 2
           =3 # define b3 3
           =3 
           =3 typedef unsigned char U8;
           =3 typedef unsigned int U16;
           =3 typedef unsigned long U32;
           =3 
           =3 typedef signed char S8;
           =3 typedef signed int S16;
           =3 typedef signed long S32;
           =3 
           =3 typedef union UU16
           =3 {
           =3    U16 U16;
           =3    S16 S16;
           =3    U8 U8[2];
           =3    S8 S8[2];
           =3 } UU16;
           =3 
           =3 typedef union UU32
           =3 {
           =3    U32 U32;
           =3    S32 S32;
           =3    UU16 UU16[2];
           =3    U16 U16[2];
           =3    S16 S16[2];
           =3    U8 U8[4];
           =3    S8 S8[4];
           =3 } UU32;
           =3 
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 25  

           =3 // NOP () macro support
           =3 #define NOP() _asm NOP _endasm
           =3 
           =3 // generic pointer memory type specifiers
           =3 #define SI_GPTR
           =3 #define SI_GPTR_MTYPE_DATA       0x40
           =3 #define SI_GPTR_MTYPE_IDATA      0x40
           =3 #define SI_GPTR_MTYPE_BDATA      0x40
           =3 #define SI_GPTR_MTYPE_PDATA      0x60
           =3 #define SI_GPTR_MTYPE_XDATA      0x00
           =3 #define SI_GPTR_MTYPE_CODE       0x80
           =3 
           =3 // generic pointer access struct
           =3 typedef union SI_GENERIC_PTR
           =3 {
           =3     U8 U8[3];
           =3     struct
           =3     {
           =3         UU16 ADDR;
           =3         U8 MTYPE;
           =3     } GPTR;
           =3 } SI_GENERIC_PTR;
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 // Raisonance (must be placed before Keil C51)
           =3 // http://www.raisonance.com
           =3 
           =3 #elif defined __RC51__
           =3 
           =3 //#error Raisonance C51 detected.
           =3 
           =3 # define SEG_GENERIC generic     //SEG_GENERIC only applies to pointers in Raisonance, not variables.
           =3 # define SEG_FAR   xdata
           =3 # define SEG_DATA  data
           =3 # define SEG_NEAR  data
           =3 # define SEG_IDATA idata
           =3 # define SEG_XDATA xdata
           =3 # define SEG_PDATA pdata
           =3 # define SEG_CODE  code
           =3 # define SEG_BDATA bdata
           =3 
           =3 # define SBIT(name, addr, bit)  at (addr+bit) sbit         name
           =3 # define SFR(name, addr)        sfr at addr                name
           =3 # define SFR16(name, addr)      sfr16 at addr              name
           =3 # define SFR16E(name, fulladdr) /* not supported */
           =3 # define SFR32(name, fulladdr)  /* not supported */
           =3 # define SFR32E(name, fulladdr) /* not supported */
           =3 
           =3 # define INTERRUPT(name, vector) void name (void) interrupt vector
           =3 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
           =3 # define INTERRUPT_PROTO(name, vector) void name (void)
           =3 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
           =3 
           =3 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using regnum
           =3 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =3 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =3 
           =3 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =3 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =3 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 26  

           =3 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
           =3 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) at addr locsegment vartype name
           =3 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) at addr locsegment vartype name
           =3 
           =3 
           =3 // used with UU16
           =3 # define LSB 1
           =3 # define MSB 0
           =3 
           =3 // used with UU32 (b0 is least-significant byte)
           =3 # define b0 3
           =3 # define b1 2
           =3 # define b2 1
           =3 # define b3 0
           =3 
           =3 typedef unsigned char U8;
           =3 typedef unsigned int U16;
           =3 typedef unsigned long U32;
           =3 
           =3 typedef signed char S8;
           =3 typedef signed int S16;
           =3 typedef signed long S32;
           =3 
           =3 typedef union UU16
           =3 {
           =3    U16 U16;
           =3    S16 S16;
           =3    U8 U8[2];
           =3    S8 S8[2];
           =3 } UU16;
           =3 
           =3 typedef union UU32
           =3 {
           =3    U32 U32;
           =3    S32 S32;
           =3    UU16 UU16[2];
           =3    U16 U16[2];
           =3    S16 S16[2];
           =3    U8 U8[4];
           =3    S8 S8[4];
           =3 } UU32;
           =3 
           =3 // NOP () macro support -- NOP is opcode 0x00
           =3 #define NOP() asm { 0x00 }
           =3 
           =3 // generic pointer memory type specifiers
           =3 #define SI_GPTR
           =3 #define SI_GPTR_MTYPE_DATA       0x04
           =3 #define SI_GPTR_MTYPE_IDATA      0x01
           =3 #define SI_GPTR_MTYPE_BDATA      0x04
           =3 #define SI_GPTR_MTYPE_PDATA      0x03
           =3 #define SI_GPTR_MTYPE_XDATA      0x02
           =3 #define SI_GPTR_MTYPE_CODE       0x05
           =3 
           =3 // generic pointer access struct
           =3 typedef union SI_GENERIC_PTR
           =3 {
           =3     U8 U8[3];
           =3     struct
           =3     {
           =3         U8 MTYPE;
           =3         UU16 ADDR;
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 27  

           =3     } GPTR;
           =3 } SI_GENERIC_PTR;
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 
           =3 // Keil C51
           =3 // http://www.keil.com
           =3 
           =3 #elif defined __C51__
 360      =3  
 361      =3  //#error Keil C51 detected.
 362      =3  
 363      =3  # define SEG_GENERIC
 364      =3  # define SEG_FAR   xdata
 365      =3  # define SEG_DATA  data
 366      =3  # define SEG_NEAR  data
 367      =3  # define SEG_IDATA idata
 368      =3  # define SEG_XDATA xdata
 369      =3  # define SEG_PDATA pdata
 370      =3  # define SEG_CODE  code
 371      =3  # define SEG_BDATA bdata
 372      =3  
 373      =3  # define SBIT(name, addr, bit)  sbit  name = addr^bit
 374      =3  # define SFR(name, addr)        sfr   name = addr
 375      =3  # define SFR16(name, addr)      sfr16 name = addr
 376      =3  # define SFR16E(name, fulladdr) /* not supported */
 377      =3  # define SFR32(name, fulladdr)  /* not supported */
 378      =3  # define SFR32E(name, fulladdr) /* not supported */
 379      =3  
 380      =3  # ifndef __SLS_IDE__
 381      =3  
 382      =3  # define INTERRUPT(name, vector) void name (void) interrupt vector
 383      =3  # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
 384      =3  # define INTERRUPT_PROTO(name, vector) void name (void)
 385      =3  # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
 386      =3  
 387      =3  # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using regnum
 388      =3  # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter)
 389      =3  // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
 390      =3  
 391      =3  # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
 392      =3  # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
 393      =3  # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
 394      =3  # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
 395      =3  # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) vartype locsegment name _at_ addr
 396      =3  
 397      =3  # else  // __SLS_IDE__
           =3 
           =3 # define INTERRUPT(name, vector) void name (void)
           =3 # define INTERRUPT_USING(name, vector, regnum) void name (void)
           =3 # define INTERRUPT_PROTO(name, vector) void name (void)
           =3 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
           =3 
           =3 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =3 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =3 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =3 
           =3 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype name
           =3 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype * name
           =3 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype * name
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 28  

           =3 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * name
           =3 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) vartype name
           =3 
           =3 # endif // __SLS_IDE__
 415      =3  
 416      =3  // used with UU16
 417      =3  # define LSB 1
 418      =3  # define MSB 0
 419      =3  
 420      =3  // used with UU32 (b0 is least-significant byte)
 421      =3  # define b0 3
 422      =3  # define b1 2
 423      =3  # define b2 1
 424      =3  # define b3 0
 425      =3  
 426      =3  typedef unsigned char U8;
 427      =3  typedef unsigned int U16;
 428      =3  typedef unsigned long U32;
 429      =3  
 430      =3  typedef signed char S8;
 431      =3  typedef signed int S16;
 432      =3  typedef signed long S32;
 433      =3  
 434      =3  typedef union UU16
 435      =3  {
 436      =3     U16 U16;
 437      =3     S16 S16;
 438      =3     U8 U8[2];
 439      =3     S8 S8[2];
 440      =3  } UU16;
 441      =3  
 442      =3  typedef union UU32
 443      =3  {
 444      =3     U32 U32;
 445      =3     S32 S32;
 446      =3     UU16 UU16[2];
 447      =3     U16 U16[2];
 448      =3     S16 S16[2];
 449      =3     U8 U8[4];
 450      =3     S8 S8[4];
 451      =3  } UU32;
 452      =3  
 453      =3  // NOP () macro support
 454      =3  extern void _nop_ (void);
 455      =3  #define NOP() _nop_()
 456      =3  
 457      =3  // generic pointer memory type specifiers
 458      =3  #define SI_GPTR
 459      =3  #define SI_GPTR_MTYPE_DATA      0x00
 460      =3  #define SI_GPTR_MTYPE_IDATA     0x00
 461      =3  #define SI_GPTR_MTYPE_BDATA     0x00
 462      =3  #define SI_GPTR_MTYPE_PDATA     0xFE
 463      =3  #define SI_GPTR_MTYPE_XDATA     0x01
 464      =3  #define SI_GPTR_MTYPE_CODE      0xFF
 465      =3  
 466      =3  // generic pointer access struct
 467      =3  typedef union SI_GENERIC_PTR
 468      =3  {
 469      =3      U8 U8[3];
 470      =3      struct
 471      =3      {
 472      =3          U8 MTYPE;
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 29  

 473      =3          UU16 ADDR;
 474      =3      } GPTR;
 475      =3  } SI_GENERIC_PTR;
 476      =3  
 477      =3  //-----------------------------------------------------------------------------
 478      =3  
 479      =3  // Hi-Tech 8051
 480      =3  // http://www.htsoft.com
 481      =3  
 482      =3  #elif defined HI_TECH_C
           =3 
           =3 # define SEG_GENERIC
           =3 # define SEG_FAR   far
           =3 # define SEG_DATA  data
           =3 # define SEG_NEAR  near
           =3 # define SEG_IDATA idata
           =3 # define SEG_XDATA xdata
           =3 # define SEG_PDATA pdata
           =3 # define SEG_CODE  code
           =3 # define SEG_BDATA bdata
           =3 
           =3 
           =3 # define SBIT(name, addr, thebit) static volatile bit name @ (addr + thebit)
           =3 # define SFR(name, addr)          static volatile unsigned char name @ addr
           =3 # define SFR16(name, addr)        static volatile unsigned int name @ addr
           =3 # define SFR16E(name, fulladdr) /* not supported */
           =3 # define SFR32(name, fulladdr)  /* not supported */
           =3 # define SFR32E(name, fulladdr) /* not supported */
           =3 
           =3 # define INTERRUPT(name, vector)       void name (void) interrupt vector
           =3 # define INTERRUPT_PROTO(name, vector)
           =3 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
           =3 # define INTERRUPT_PROTO_USING(name, vector, regnum)
           =3 
           =3 # define FUNCTION_USING(name, return_value, parameter, regnum) /* not supported */
           =3 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) /* not supported */
           =3 // Note: Hi-Tech does not support functions using different register banks. Register
           =3 //       banks can only be specified in interrupts. If a function is called from
           =3 //       inside an interrupt, it will use the same register bank as the interrupt.
           =3 
           =3 # define SEGMENT_VARIABLE(name, vartype, locsegment) locsegment vartype name
           =3 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) targsegment vartype * name
           =3 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) targsegment vartype * lo
             -csegment name
           =3 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment vartype name @ addr
           =3 
           =3 // used with UU16
           =3 # define LSB 0
           =3 # define MSB 1
           =3 
           =3 // used with UU32 (b0 is least-significant byte)
           =3 # define b0 0
           =3 # define b1 1
           =3 # define b2 2
           =3 # define b3 3
           =3 
           =3 typedef unsigned char U8;
           =3 typedef unsigned int U16;
           =3 typedef unsigned long U32;
           =3 
           =3 typedef signed char S8;
           =3 typedef signed int S16;
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 30  

           =3 typedef signed long S32;
           =3 
           =3 typedef union UU16
           =3 {
           =3    U16 U16;
           =3    S16 S16;
           =3    U8 U8[2];
           =3    S8 S8[2];
           =3 } UU16;
           =3 
           =3 typedef union UU32
           =3 {
           =3    U32 U32;
           =3    S32 S32;
           =3    UU16 UU16[2];
           =3    U16 U16[2];
           =3    S16 S16[2];
           =3    U8 U8[4];
           =3    S8 S8[4];
           =3 } UU32;
           =3 
           =3 // NOP () macro support
           =3 #define NOP() asm(" nop ")
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 // Tasking / Altium
           =3 // http://www.altium.com/tasking
           =3 
           =3 
           =3 #elif defined _CC51
           =3 
           =3 # define SEG_GENERIC
           =3 # define SEG_FAR   _xdat
           =3 # define SEG_DATA  _data
           =3 # define SEG_NEAR  _data
           =3 # define SEG_IDATA _idat
           =3 # define SEG_XDATA _xdat
           =3 # define SEG_PDATA _pdat
           =3 # define SEG_CODE  _rom
           =3 # define SEG_BDATA _bdat
           =3 
           =3 # define SBIT(name, addr, bit)  _sfrbit  name _at(addr+bit)
           =3 # define SFR(name, addr)        _sfrbyte name _at(addr)
           =3 # define SFRX(name, addr)       _xdat volatile unsigned char name _at(addr)
           =3 #if _CC51 > 71
           =3 # define SFR16(name, addr)      _sfrword _little name _at(addr)
           =3 #else
           =3 # define SFR16(name, addr)      /* not supported */
           =3 #endif
           =3 # define SFR16E(name, fulladdr) /* not supported */
           =3 # define SFR32(name, fulladdr)  /* not supported */
           =3 # define SFR32E(name, fulladdr) /* not supported */
           =3 
           =3 # define INTERRUPT(name, vector) _interrupt (vector) void name (void)
           =3 # define INTERRUPT_USING(name, vector, regnum) _interrupt (vector) _using(regnum) void name (void)
           =3 # define INTERRUPT_PROTO(name, vector) _interrupt (vector) void name (void)
           =3 # define INTERRUPT_PROTO_USING(name, vector, regnum) _interrupt (vector) _using(regnum) void name (void)
           =3 
           =3 // When calling FUNCTION_USING in Tasking, the function must be called from an interrupt or Main which
           =3 // is also using the same register bank. If not, the compiler will generate an error.
           =3 # define FUNCTION_USING(name, return_value, parameter, regnum) _using(regnum) return_value name (parameter
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 31  

             -)
           =3 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) _using(regnum) return_value name (par
             -ameter)
           =3 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =3 
           =3 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =3 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =3 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =3 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) vartype locsegment name _at( addr )
           =3 
           =3 // used with UU16
           =3 # define LSB 1
           =3 # define MSB 0
           =3 
           =3 // used with UU32 (b0 is least-significant byte)
           =3 # define b0 3
           =3 # define b1 2
           =3 # define b2 1
           =3 # define b3 0
           =3 
           =3 typedef unsigned char U8;
           =3 typedef unsigned int U16;
           =3 typedef unsigned long U32;
           =3 
           =3 typedef signed char S8;
           =3 typedef signed int S16;
           =3 typedef signed long S32;
           =3 
           =3 typedef union UU16
           =3 {
           =3    U16 U16;
           =3    S16 S16;
           =3    U8 U8[2];
           =3    S8 S8[2];
           =3 } UU16;
           =3 
           =3 typedef union UU32
           =3 {
           =3    U32 U32;
           =3    S32 S32;
           =3    UU16 UU16[2];
           =3    U16 U16[2];
           =3    S16 S16[2];
           =3    U8 U8[4];
           =3    S8 S8[4];
           =3 } UU32;
           =3 
           =3 // NOP () macro support
           =3 extern void _nop (void);
           =3 #define NOP() _nop()
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 
           =3 // IAR 8051
           =3 // http://www.iar.com
           =3 
           =3 #elif defined __ICC8051__
           =3 
           =3 #include <stdbool.h>
           =3 #include <intrinsics.h>
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 32  

           =3 
           =3 # define SBIT(name, addr, bit)  __bit __no_init volatile bool name @ (addr+bit)
           =3 # define SFR(name, addr)        __sfr __no_init volatile unsigned char name @ addr
           =3 # define SFRX(name, addr)       __xdata __no_init volatile unsigned char name @ addr
           =3 # define SFR16(name, addr)      __sfr __no_init volatile unsigned int  name @ addr
           =3 # define SFR16E(name, fulladdr) /* not supported */
           =3 # define SFR32(name, fulladdr) /* not supported */
           =3 # define SFR32E(name, fulladdr) /* not supported */
           =3 
           =3 # define SEG_GENERIC __generic
           =3 # define SEG_FAR  __xdata
           =3 # define SEG_DATA __data
           =3 # define SEG_NEAR __data
           =3 # define SEG_IDATA __idata
           =3 # define SEG_XDATA __xdata
           =3 # define SEG_PDATA __pdata
           =3 # define SEG_CODE  __code
           =3 # define SEG_BDATA __bdata
           =3 
           =3 #define bit bool
           =3 
           =3 # define _PPTOSTR_(x) #x
           =3 # define _PPARAM_(address) _PPTOSTR_(vector=address * 8 + 3)
           =3 # define _PPARAM2_(regbank) _PPTOSTR_(register_bank=regbank)
           =3 # define INTERRUPT(name, vector) _Pragma(_PPARAM_(vector)) __interrupt void name(void)
           =3 # define INTERRUPT_PROTO(name, vector)  __interrupt void name(void)
           =3 # define INTERRUPT_USING(name, vector, regnum) _Pragma(_PPARAM2_(regnum)) _Pragma(_PPARAM_(vector)) __inte
             -rrupt void name(void)
           =3 # define INTERRUPT_PROTO_USING(name, vector, regnum) __interrupt void name(void)
           =3 
           =3 # define FUNCTION_USING(name, return_value, parameter, regnum) /* not supported */
           =3 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) /* not supported */
           =3 // Note: IAR does not support functions using different register banks. Register
           =3 //       banks can only be specified in interrupts. If a function is called from
           =3 //       inside an interrupt, it will use the same register bank as the interrupt.
           =3 
           =3 # define SEGMENT_VARIABLE(name, vartype, locsegment)  locsegment vartype name
           =3 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment  * name
           =3 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =3 
           =3 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment __no_init vartype name @ addr
           =3 
           =3 // used with UU16
           =3 # define LSB 0
           =3 # define MSB 1
           =3 
           =3 // used with UU32 (b0 is least-significant byte)
           =3 # define b0 0
           =3 # define b1 1
           =3 # define b2 2
           =3 # define b3 3
           =3 
           =3 typedef unsigned char U8;
           =3 typedef unsigned int U16;
           =3 typedef unsigned long U32;
           =3 
           =3 typedef signed char S8;
           =3 typedef signed int S16;
           =3 typedef signed long S32;
           =3 
           =3 typedef union UU16
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 33  

           =3 {
           =3    U16 U16;
           =3    S16 S16;
           =3    U8 U8[2];
           =3    S8 S8[2];
           =3 } UU16;
           =3 
           =3 typedef union UU32
           =3 {
           =3    U32 U32;
           =3    S32 S32;
           =3    UU16 UU16[2];
           =3    U16 U16[2];
           =3    S16 S16[2];
           =3    U8 U8[4];
           =3    S8 S8[4];
           =3 } UU32;
           =3 
           =3 
           =3 #define NOP() __no_operation();
           =3 
           =3 // generic pointer memory type specifiers
           =3 #define SI_GPTR
           =3 #define SI_GPTR_MTYPE_DATA       0x01
           =3 #define SI_GPTR_MTYPE_IDATA      0x01
           =3 #define SI_GPTR_MTYPE_BDATA      0x01
           =3 #define SI_GPTR_MTYPE_PDATA      0x00
           =3 #define SI_GPTR_MTYPE_XDATA      0x00
           =3 #define SI_GPTR_MTYPE_CODE       0x80
           =3 
           =3 // generic pointer access struct
           =3 typedef union SI_GENERIC_PTR
           =3 {
           =3     U8 U8[3];
           =3     struct
           =3     {
           =3         UU16 ADDR;
           =3         U8 MTYPE;
           =3     } GPTR;
           =3 } SI_GENERIC_PTR;
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 // Crossware
           =3 // http://www.crossware.com
           =3 
           =3 #elif defined _XC51_VER
           =3 # define SBIT(name, addr, bit)  _sfrbit  name = (addr+bit)
           =3 # define SFR(name, addr)        _sfr     name = addr
           =3 # define SFR16(name, addr)      _sfrword name = addr
           =3 # define SFR16E(name, fulladdr) /* not supported */
           =3 # define SFR32(name, fulladdr)  /* not supported */
           =3 # define SFR32E(name, fulladdr) /* not supported */
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 // Wickenh盲user
           =3 // http://www.wickenhaeuser.de
           =3 
           =3 #elif defined __UC__
           =3 # define SBIT(name, addr, bit)  unsigned char bit  name @ (addr+bit)
           =3 # define SFR(name, addr)        near unsigned char name @ addr
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 34  

           =3 # define SFR16(name, addr)      /* not supported */
           =3 # define SFR16E(name, fulladdr) /* not supported */
           =3 # define SFR32(name, fulladdr)  /* not supported */
           =3 # define SFR32E(name, fulladdr) /* not supported */
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 // Default
           =3 // Unknown compiler
           =3 
           =3 #else
           =3 # warning unrecognized compiler
           =3 # define SBIT(name, addr, bit)  volatile bool           name
           =3 # define SFR(name, addr)        volatile unsigned char  name
           =3 # define SFRX(name, addr)       volatile unsigned char  name
           =3 # define SFR16(name, addr)      volatile unsigned short name
           =3 # define SFR16E(name, fulladdr) volatile unsigned short name
           =3 # define SFR32(name, fulladdr)  volatile unsigned long  name
           =3 # define SFR32E(name, fulladdr) volatile unsigned long  name
           =3 
           =3 #endif
 798      =3  
 799      =3  //-----------------------------------------------------------------------------
 800      =3  // Header File PreProcessor Directive
 801      =3  //-----------------------------------------------------------------------------
 802      =3  
 803      =3  #endif                                 // #define COMPILER_DEFS_H
 804      =3  
 805      =3  //-----------------------------------------------------------------------------
 806      =3  // End Of File
 807      =3  //-----------------------------------------------------------------------------
  97      =2  #include "C8051F020_defs.h"
   1      =3  //-----------------------------------------------------------------------------
   2      =3  // C8051F020_defs.h
   3      =3  //-----------------------------------------------------------------------------
   4      =3  // Copyright 2007, Silicon Laboratories, Inc.
   5      =3  // http://www.silabs.com
   6      =3  //
   7      =3  // Program Description:
   8      =3  //
   9      =3  // Register/bit definitions for the C8051F02x family.
  10      =3  // **Important Note**: The compiler_defs.h header file should be included
  11      =3  // before including this header file.
  12      =3  //
  13      =3  // Target:         C8051F020, 'F021, 'F022, 'F023
  14      =3  // Tool chain:     Generic
  15      =3  // Command Line:   None
  16      =3  //
  17      =3  // Release 1.4 - 20 AUG 2012 (TP)
  18      =3  //    -Added #define for _XPAGE to provide support for SDCC memory paging
  19      =3  //     (pdata)
  20      =3  // Release 1.3 - 07 AUG 2007 (PKC)
  21      =3  //    -Removed #include <compiler_defs.h>. The C source file should include it.
  22      =3  // Release 1.2 - 09 JUL 2007 (PKC)
  23      =3  //    -Reformatted header file to enable portable SFR definitions
  24      =3  
  25      =3  //-----------------------------------------------------------------------------
  26      =3  // Header File Preprocessor Directive
  27      =3  //-----------------------------------------------------------------------------
  28      =3  
  29      =3  #ifndef C8051F020_DEFS_H
  30      =3  #define C8051F020_DEFS_H
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 35  

  31      =3  
  32      =3  //-----------------------------------------------------------------------------
  33      =3  // Byte Registers
  34      =3  //-----------------------------------------------------------------------------
  35      =3  
  36      =3  SFR (P0, 0x80);                        // Port 0 Latch
  37      =3  SFR (SP, 0x81);                        // Stack Pointer
  38      =3  SFR (DPL, 0x82);                       // Data Pointer Low
  39      =3  SFR (DPH, 0x83);                       // Data Pointer High
  40      =3  SFR (P4, 0x84);                        // Port 4 Latch
  41      =3  SFR (P5, 0x85);                        // Port 5 Latch
  42      =3  SFR (P6, 0x86);                        // Port 6 Latch
  43      =3  SFR (PCON, 0x87);                      // Power Control
  44      =3  SFR (TCON, 0x88);                      // Timer/Counter Control
  45      =3  SFR (TMOD, 0x89);                      // Timer/Counter Mode
  46      =3  SFR (TL0, 0x8A);                       // Timer/Counter 0 Low
  47      =3  SFR (TL1, 0x8B);                       // Timer/Counter 1 Low
  48      =3  SFR (TH0, 0x8C);                       // Timer/Counter 0 High
  49      =3  SFR (TH1, 0x8D);                       // Timer/Counter 1 High
  50      =3  SFR (CKCON, 0x8E);                     // Clock Control
  51      =3  SFR (PSCTL, 0x8F);                     // Program Store R/W Control
  52      =3  SFR (P1, 0x90);                        // Port 1 Latch
  53      =3  SFR (TMR3CN, 0x91);                    // Timer/Counter 3 Control
  54      =3  SFR (TMR3RLL, 0x92);                   // Timer/Counter 3 Reload Low
  55      =3  SFR (TMR3RLH, 0x93);                   // Timer/Counter 3 Reload High
  56      =3  SFR (TMR3L, 0x94);                     // Timer/Counter 3 Low
  57      =3  SFR (TMR3H, 0x95);                     // Timer/Counter 3 High
  58      =3  SFR (P7, 0x96);                        // Port 7 Latch
  59      =3  SFR (SCON0, 0x98);                     // Serial Port UART0 Control
  60      =3  SFR (SBUF0, 0x99);                     // Serial Port UART0 Data Buffer
  61      =3  SFR (SPI0CFG, 0x9A);                   // SPI0 Configuration
  62      =3  SFR (SPI0DAT, 0x9B);                   // SPI0 Data
  63      =3  SFR (ADC1, 0x9C);                      // ADC1 Data
  64      =3  SFR (SPI0CKR, 0x9D);                   // SPI0 Clock Rate Control
  65      =3  SFR (CPT0CN, 0x9E);                    // Comparator 0 Control
  66      =3  SFR (CPT1CN, 0x9F);                    // Comparator 1 Control
  67      =3  SFR (P2, 0xA0);                        // Port 2 Latch
  68      =3  SFR (EMI0TC, 0xA1);                    // EMIF Timing Control
  69      =3  SFR (EMI0CF, 0xA3);                    // EMIF Configuration
  70      =3  SFR (P0MDOUT, 0xA4);                   // Port 0 Output Mode Configuration
  71      =3  SFR (P1MDOUT, 0xA5);                   // Port 1 Output Mode Configuration
  72      =3  SFR (P2MDOUT, 0xA6);                   // Port 2 Output Mode Configuration
  73      =3  SFR (P3MDOUT, 0xA7);                   // Port 3 Output Mode Configuration
  74      =3  SFR (IE, 0xA8);                        // Interrupt Enable
  75      =3  SFR (SADDR0, 0xA9);                    // Serial Port UART0 Slave Address
  76      =3  SFR (ADC1CN, 0xAA);                    // ADC1 Control
  77      =3  SFR (ADC1CF, 0xAB);                    // ADC1 Analog Mux Configuration
  78      =3  SFR (AMX1SL, 0xAC);                    // ADC1 Analog Mux Channel Select
  79      =3  SFR (P3IF, 0xAD);                      // Port 3 External Interrupt Flags
  80      =3  SFR (SADEN1, 0xAE);                    // Serial Port UART1 Slave Address Mask
  81      =3  SFR (EMI0CN, 0xAF);                    // EMIF Control
  82      =3  SFR (P3, 0xB0);                        // Port 3 Latch
  83      =3  SFR (OSCXCN, 0xB1);                    // External Oscillator Control
  84      =3  SFR (OSCICN, 0xB2);                    // Internal Oscillator Control
  85      =3  SFR (P74OUT, 0xB5);                    // Ports 4 - 7 Output Mode
  86      =3  SFR (FLSCL, 0xB6);                     // Flash Memory Timing Prescaler
  87      =3  SFR (FLACL, 0xB7);                     // Flash Acess Limit
  88      =3  SFR (IP, 0xB8);                        // Interrupt Priority
  89      =3  SFR (SADEN0, 0xB9);                    // Serial Port UART0 Slave Address Mask
  90      =3  SFR (AMX0CF, 0xBA);                    // ADC0 Mux Configuration
  91      =3  SFR (AMX0SL, 0xBB);                    // ADC0 Mux Channel Selection
  92      =3  SFR (ADC0CF, 0xBC);                    // ADC0 Configuration
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 36  

  93      =3  SFR (P1MDIN, 0xBD);                    // Port 1 Input Mode
  94      =3  SFR (ADC0L, 0xBE);                     // ADC0 Data Low
  95      =3  SFR (ADC0H, 0xBF);                     // ADC0 Data High
  96      =3  SFR (SMB0CN, 0xC0);                    // SMBus0 Control
  97      =3  SFR (SMB0STA, 0xC1);                   // SMBus0 Status
  98      =3  SFR (SMB0DAT, 0xC2);                   // SMBus0 Data
  99      =3  SFR (SMB0ADR, 0xC3);                   // SMBus0 Slave Address
 100      =3  SFR (ADC0GTL, 0xC4);                   // ADC0 Greater-Than Register Low
 101      =3  SFR (ADC0GTH, 0xC5);                   // ADC0 Greater-Than Register High
 102      =3  SFR (ADC0LTL, 0xC6);                   // ADC0 Less-Than Register Low
 103      =3  SFR (ADC0LTH, 0xC7);                   // ADC0 Less-Than Register High
 104      =3  SFR (T2CON, 0xC8);                     // Timer/Counter 2 Control
 105      =3  SFR (T4CON, 0xC9);                     // Timer/Counter 4 Control
 106      =3  SFR (RCAP2L, 0xCA);                    // Timer/Counter 2 Capture Low
 107      =3  SFR (RCAP2H, 0xCB);                    // Timer/Counter 2 Capture High
 108      =3  SFR (TL2, 0xCC);                       // Timer/Counter 2 Low
 109      =3  SFR (TH2, 0xCD);                       // Timer/Counter 2 High
 110      =3  SFR (SMB0CR, 0xCF);                    // SMBus0 Clock Rate
 111      =3  SFR (PSW, 0xD0);                       // Program Status Word
 112      =3  SFR (REF0CN, 0xD1);                    // Voltage Reference 0 Control
 113      =3  SFR (DAC0L, 0xD2);                     // DAC0 Register Low
 114      =3  SFR (DAC0H, 0xD3);                     // DAC0 Register High
 115      =3  SFR (DAC0CN, 0xD4);                    // DAC0 Control
 116      =3  SFR (DAC1L, 0xD5);                     // DAC1 Register Low
 117      =3  SFR (DAC1H, 0xD6);                     // DAC1 Register High
 118      =3  SFR (DAC1CN, 0xD7);                    // DAC1 Control
 119      =3  SFR (PCA0CN, 0xD8);                    // PCA0 Control
 120      =3  SFR (PCA0MD, 0xD9);                    // PCA0 Mode
 121      =3  SFR (PCA0CPM0, 0xDA);                  // PCA0 Module 0 Mode Register
 122      =3  SFR (PCA0CPM1, 0xDB);                  // PCA0 Module 1 Mode Register
 123      =3  SFR (PCA0CPM2, 0xDC);                  // PCA0 Module 2 Mode Register
 124      =3  SFR (PCA0CPM3, 0xDD);                  // PCA0 Module 3 Mode Register
 125      =3  SFR (PCA0CPM4, 0xDE);                  // PCA0 Module 4 Mode Register
 126      =3  SFR (ACC, 0xE0);                       // Accumulator
 127      =3  SFR (XBR0, 0xE1);                      // Port I/O Crossbar Control 0
 128      =3  SFR (XBR1, 0xE2);                      // Port I/O Crossbar Control 1
 129      =3  SFR (XBR2, 0xE3);                      // Port I/O Crossbar Control 2
 130      =3  SFR (RCAP4L, 0xE4);                    // Timer 4 Capture Register Low
 131      =3  SFR (RCAP4H, 0xE5);                    // Timer 4 Capture Register High
 132      =3  SFR (EIE1, 0xE6);                      // External Interrupt Enable 1
 133      =3  SFR (EIE2, 0xE7);                      // External Interrupt Enable 2
 134      =3  SFR (ADC0CN, 0xE8);                    // ADC0 Control
 135      =3  SFR (PCA0L, 0xE9);                     // PCA0 Counter Low
 136      =3  SFR (PCA0CPL0, 0xEA);                  // PCA0 Capture 0 Low
 137      =3  SFR (PCA0CPL1, 0xEB);                  // PCA0 Capture 1 Low
 138      =3  SFR (PCA0CPL2, 0xEC);                  // PCA0 Capture 2 Low
 139      =3  SFR (PCA0CPL3, 0xED);                  // PCA0 Capture 3 Low
 140      =3  SFR (PCA0CPL4, 0xEE);                  // PCA0 Capture 4 Low
 141      =3  SFR (RSTSRC, 0xEF);                    // Reset Source Configuration/Status
 142      =3  SFR (B, 0xF0);                         // B Register
 143      =3  SFR (SCON1, 0xF1);                     // Serial Port UART1 Control
 144      =3  SFR (SBUF1, 0xF2);                     // Serail Port UART1 Data
 145      =3  SFR (SADDR1, 0xF3);                    // Serail Port UART1 Slave Address
 146      =3  SFR (TL4, 0xF4);                       // Timer/Counter 4 Low
 147      =3  SFR (TH4, 0xF5);                       // Timer/Counter 4 High
 148      =3  SFR (EIP1, 0xF6);                      // External Interrupt Priority 1
 149      =3  SFR (EIP2, 0xF7);                      // External Interrupt Priority 2
 150      =3  SFR (SPI0CN, 0xF8);                    // SPI0 Control
 151      =3  SFR (PCA0H, 0xF9);                     // PCA0 Counter High
 152      =3  SFR (PCA0CPH0, 0xFA);                  // PCA0 Capture 0 High
 153      =3  SFR (PCA0CPH1, 0xFB);                  // PCA0 Capture 1 High
 154      =3  SFR (PCA0CPH2, 0xFC);                  // PCA0 Capture 2 High
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 37  

 155      =3  SFR (PCA0CPH3, 0xFD);                  // PCA0 Capture 3 High
 156      =3  SFR (PCA0CPH4, 0xFE);                  // PCA0 Capture 4 High
 157      =3  SFR (WDTCN, 0xFF);                     // Watchdog Timer Control
 158      =3  
 159      =3  //-----------------------------------------------------------------------------
 160      =3  // 16-bit Register Definitions (might not be supported by all compilers)
 161      =3  //-----------------------------------------------------------------------------
 162      =3  
 163      =3  SFR16 (DP, 0x82);                      // Data Pointer
 164      =3  SFR16 (TMR3RL, 0x92);                  // Timer3 Reload Value
 165      =3  SFR16 (TMR3, 0x94);                    // Timer3 Counter
 166      =3  SFR16 (ADC0, 0xBE);                    // ADC0 Data
 167      =3  SFR16 (ADC0GT, 0xC4);                  // ADC0 Greater Than Window
 168      =3  SFR16 (ADC0LT, 0xC6);                  // ADC0 Less Than Window
 169      =3  SFR16 (RCAP2, 0xCA);                   // Timer2 Capture/Reload
 170      =3  SFR16 (T2, 0xCC);                      // Timer2 Counter
 171      =3  SFR16 (TMR2RL, 0xCA);                  // Timer2 Capture/Reload
 172      =3  SFR16 (TMR2, 0xCC);                    // Timer2 Counter
 173      =3  SFR16 (RCAP4, 0xE4);                   // Timer4 Capture/Reload
 174      =3  SFR16 (T4, 0xF4);                      // Timer4 Counter
 175      =3  SFR16 (TMR4RL, 0xE4);                  // Timer4 Capture/Reload
 176      =3  SFR16 (TMR4, 0xF4);                    // Timer4 Counter
 177      =3  SFR16 (DAC0, 0xD2);                    // DAC0 Data
 178      =3  SFR16 (DAC1, 0xD5);                    // DAC1 Data
 179      =3  
 180      =3  //-----------------------------------------------------------------------------
 181      =3  // Address Definitions for bit-addressable SFRs
 182      =3  //-----------------------------------------------------------------------------
 183      =3  
 184      =3  #define SFR_P0       0x80
 185      =3  #define SFR_TCON     0x88
 186      =3  #define SFR_P1       0x90
 187      =3  #define SFR_SCON0    0x98
 188      =3  #define SFR_P2       0xA0
 189      =3  #define SFR_IE       0xA8
 190      =3  #define SFR_P3       0xB0
 191      =3  #define SFR_IP       0xB8
 192      =3  #define SFR_SMB0CN   0xC0
 193      =3  #define SFR_T2CON    0xC8
 194      =3  #define SFR_PSW      0xD0
 195      =3  #define SFR_PCA0CN   0xD8
 196      =3  #define SFR_ACC      0xE0
 197      =3  #define SFR_ADC0CN   0xE8
 198      =3  #define SFR_B        0xF0
 199      =3  #define SFR_SPI0CN   0xF8
 200      =3  
 201      =3  //-----------------------------------------------------------------------------
 202      =3  // Bit Definitions
 203      =3  //-----------------------------------------------------------------------------
 204      =3  
 205      =3  // TCON 0x88
 206      =3  SBIT (TF1, SFR_TCON, 7);               // Timer 1 Overflow Flag
 207      =3  SBIT (TR1, SFR_TCON, 6);               // Timer 1 On/Off Control
 208      =3  SBIT (TF0, SFR_TCON, 5);               // Timer 0 Overflow Flag
 209      =3  SBIT (TR0, SFR_TCON, 4);               // Timer 0 On/Off Control
 210      =3  SBIT (IE1, SFR_TCON, 3);               // Ext. Interrupt 1 Edge Flag
 211      =3  SBIT (IT1, SFR_TCON, 2);               // Ext. Interrupt 1 Type
 212      =3  SBIT (IE0, SFR_TCON, 1);               // Ext. Interrupt 0 Edge Flag
 213      =3  SBIT (IT0, SFR_TCON, 0);               // Ext. Interrupt 0 Type
 214      =3  
 215      =3  // SCON0 0x98
 216      =3  SBIT (SM00, SFR_SCON0, 7);             // Serial Mode Control Bit 0
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 38  

 217      =3  SBIT (SM10, SFR_SCON0, 6);             // Serial Mode Control Bit 1
 218      =3  SBIT (SM20, SFR_SCON0, 5);             // Multiprocessor Communication Enable
 219      =3  SBIT (REN0, SFR_SCON0, 4);             // Receive Enable
 220      =3  SBIT (TB80, SFR_SCON0, 3);             // Transmit Bit 8
 221      =3  SBIT (RB80, SFR_SCON0, 2);             // Receive Bit 8
 222      =3  SBIT (TI0, SFR_SCON0, 1);              // Transmit Interrupt Flag
 223      =3  SBIT (RI0, SFR_SCON0, 0);              // Receive Interrupt Flag
 224      =3  
 225      =3  // IE 0xA8
 226      =3  SBIT (EA, SFR_IE, 7);                  // Global Interrupt Enable
 227      =3  SBIT (IEGF0, SFR_IE, 6);               // General Purpose Flag 0
 228      =3  SBIT (ET2, SFR_IE, 5);                 // Timer 2 Interrupt Enable
 229      =3  SBIT (ES0, SFR_IE, 4);                 // Uart0 Interrupt Enable
 230      =3  SBIT (ET1, SFR_IE, 3);                 // Timer 1 Interrupt Enable
 231      =3  SBIT (EX1, SFR_IE, 2);                 // External Interrupt 1 Enable
 232      =3  SBIT (ET0, SFR_IE, 1);                 // Timer 0 Interrupt Enable
 233      =3  SBIT (EX0, SFR_IE, 0);                 // External Interrupt 0 Enable
 234      =3  
 235      =3  // IP 0xB8
 236      =3                                         // Bit7 UNUSED
 237      =3                                         // Bit6 UNUSED
 238      =3  SBIT (PT2, SFR_IP, 5);                 // Timer 2 Priority
 239      =3  SBIT (PS, SFR_IP, 4);                  // Serial Port Priority
 240      =3  SBIT (PT1, SFR_IP, 3);                 // Timer 1 Priority
 241      =3  SBIT (PX1, SFR_IP, 2);                 // External Interrupt 1 Priority
 242      =3  SBIT (PT0, SFR_IP, 1);                 // Timer 0 Priority
 243      =3  SBIT (PX0, SFR_IP, 0);                 // External Interrupt 0 Priority
 244      =3  
 245      =3  // SMB0CN 0xC0
 246      =3  SBIT (BUSY, SFR_SMB0CN, 7);            // SMBus 0 Busy
 247      =3  SBIT (ENSMB, SFR_SMB0CN, 6);           // SMBus 0 Enable
 248      =3  SBIT (STA, SFR_SMB0CN, 5);             // SMBus 0 Start Flag
 249      =3  SBIT (STO, SFR_SMB0CN, 4);             // SMBus 0 Stop Flag
 250      =3  SBIT (SI, SFR_SMB0CN, 3);              // SMBus 0 Interrupt Pending Flag
 251      =3  SBIT (AA, SFR_SMB0CN, 2);              // SMBus 0 Assert/Acknowledge Flag
 252      =3  SBIT (SMBFTE, SFR_SMB0CN, 1);          // SMBus 0 Free Timer Enable
 253      =3  SBIT (SMBTOE, SFR_SMB0CN, 0);          // SMBus 0 Timeout Enable
 254      =3  
 255      =3  // T2CON 0xC8
 256      =3  SBIT (TF2, SFR_T2CON, 7);              // Timer 2 Overflow Flag
 257      =3  SBIT (EXF2, SFR_T2CON, 6);             // External Flag
 258      =3  SBIT (RCLK0, SFR_T2CON, 5);            // Uart0 Rx Clock Source
 259      =3  SBIT (TCLK0, SFR_T2CON, 4);            // Uart0 Tx Clock Source
 260      =3  SBIT (EXEN2, SFR_T2CON, 3);            // Timer 2 External Enable Flag
 261      =3  SBIT (TR2, SFR_T2CON, 2);              // Timer 2 On/Off Control
 262      =3  SBIT (CT2, SFR_T2CON, 1);              // Timer Or Counter Select
 263      =3  SBIT (CPRL2, SFR_T2CON, 0);            // Capture Or Reload Select
 264      =3  
 265      =3  //  PSW 0xD0
 266      =3  SBIT (CY, SFR_PSW, 7);                 // Carry Flag
 267      =3  SBIT (AC, SFR_PSW, 6);                 // Auxiliary Carry Flag
 268      =3  SBIT (F0, SFR_PSW, 5);                 // User Flag 0
 269      =3  SBIT (RS1, SFR_PSW, 4);                // Register Bank Select 1
 270      =3  SBIT (RS0, SFR_PSW, 3);                // Register Bank Select 0
 271      =3  SBIT (OV, SFR_PSW, 2);                 // Overflow Flag
 272      =3  SBIT (F1, SFR_PSW, 1);                 // User Flag 1
 273      =3  SBIT (P, SFR_PSW, 0);                  // Accumulator Parity Flag
 274      =3  
 275      =3  // PCA0CN 0xD8
 276      =3  SBIT (CF, SFR_PCA0CN, 7);              // PCA 0 Counter Overflow Flag
 277      =3  SBIT (CR, SFR_PCA0CN, 6);              // PCA 0 Counter Run Control Bit
 278      =3                                         // Bit5 UNUSED
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 39  

 279      =3  SBIT (CCF4, SFR_PCA0CN, 4);            // PCA 0 Module 4 Interrupt Flag
 280      =3  SBIT (CCF3, SFR_PCA0CN, 3);            // PCA 0 Module 3 Interrupt Flag
 281      =3  SBIT (CCF2, SFR_PCA0CN, 2);            // PCA 0 Module 2 Interrupt Flag
 282      =3  SBIT (CCF1, SFR_PCA0CN, 1);            // PCA 0 Module 1 Interrupt Flag
 283      =3  SBIT (CCF0, SFR_PCA0CN, 0);            // PCA 0 Module 0 Interrupt Flag
 284      =3  
 285      =3  // ADC0CN 0xE8
 286      =3  SBIT (AD0EN, SFR_ADC0CN, 7);           // ADC 0 Enable
 287      =3  SBIT (AD0TM, SFR_ADC0CN, 6);           // ADC 0 Track Mode
 288      =3  SBIT (AD0INT, SFR_ADC0CN, 5);          // ADC 0 Converision Complete Interrupt Flag
 289      =3  SBIT (AD0BUSY, SFR_ADC0CN, 4);         // ADC 0 Busy Flag
 290      =3  SBIT (AD0CM1, SFR_ADC0CN, 3);          // ADC 0 Start Of Conversion Mode Bit 1
 291      =3  SBIT (AD0CM0, SFR_ADC0CN, 2);          // ADC 0 Start Of Conversion Mode Bit 0
 292      =3  SBIT (AD0WINT, SFR_ADC0CN, 1);         // ADC 0 Window Compare Interrupt Flag
 293      =3  SBIT (AD0LJST, SFR_ADC0CN, 0);         // ADC 0 Right Justify Data Bit
 294      =3  
 295      =3  // SPI0CN 0xF8
 296      =3  SBIT (SPIF, SFR_SPI0CN, 7);            // SPI 0 Interrupt Flag
 297      =3  SBIT (WCOL, SFR_SPI0CN, 6);            // SPI 0 Write Collision Flag
 298      =3  SBIT (MODF, SFR_SPI0CN, 5);            // SPI 0 Mode Fault Flag
 299      =3  SBIT (RXOVRN, SFR_SPI0CN, 4);          // SPI 0 Rx Overrun Flag
 300      =3  SBIT (TXBSY, SFR_SPI0CN, 3);           // SPI 0 Tx Busy Flag
 301      =3  SBIT (SLVSEL, SFR_SPI0CN, 2);          // SPI 0 Slave Select
 302      =3  SBIT (MSTEN, SFR_SPI0CN, 1);           // SPI 0 Master Enable
 303      =3  SBIT (SPIEN, SFR_SPI0CN, 0);           // SPI 0 SPI Enable
 304      =3  
 305      =3  //-----------------------------------------------------------------------------
 306      =3  // Interrupt Priorities
 307      =3  //-----------------------------------------------------------------------------
 308      =3  
 309      =3  #define INTERRUPT_INT0           0     // External Interrupt 0
 310      =3  #define INTERRUPT_TIMER0         1     // Timer0 Overflow
 311      =3  #define INTERRUPT_INT1           2     // External Interrupt 1
 312      =3  #define INTERRUPT_TIMER1         3     // Timer1 Overflow
 313      =3  #define INTERRUPT_UART0          4     // Serial Port UART0
 314      =3  #define INTERRUPT_TIMER2         5     // Timer2 Overflow
 315      =3  #define INTERRUPT_SPI0           6     // SPI0 Interface
 316      =3  #define INTERRUPT_SMBUS0         7     // SMBus0 Interface
 317      =3  #define INTERRUPT_ADC0_WINDOW    8     // ADC0 Window Comparison
 318      =3  #define INTERRUPT_PCA0           9     // PCA0 Peripheral
 319      =3  #define INTERRUPT_COMPARATOR0F   10    // Comparator0 Falling Edge
 320      =3  #define INTERRUPT_COMPARATOR0R   11    // Comparator0 Rising Edge
 321      =3  #define INTERRUPT_COMPARATOR1F   12    // Comparator1 Falling Edge
 322      =3  #define INTERRUPT_COMPARATOR1R   13    // Comparator1 Rising Edge
 323      =3  #define INTERRUPT_TIMER3         14    // Timer3 Overflow
 324      =3  #define INTERRUPT_ADC0_EOC       15    // ADC0 End Of Conversion
 325      =3  #define INTERRUPT_TIMER4         16    // Timer4 Overflow
 326      =3  #define INTERRUPT_ADC1_EOC       17    // ADC1 End Of Conversion
 327      =3  #define INTERRUPT_INT6           18    // External Interrupt 6
 328      =3  #define INTERRUPT_INT7           19    // External Interrupt 7
 329      =3  #define INTERRUPT_UART1          20    // Serial Port UART1
 330      =3  #define INTERRUPT_XTAL_READY     21    // External Crystal Oscillator Ready
 331      =3  
 332      =3  //-----------------------------------------------------------------------------
 333      =3  // SDCC PDATA External Memory Paging Support
 334      =3  //-----------------------------------------------------------------------------
 335      =3  
 336      =3  #if defined SDCC
           =3 
           =3 SFR(_XPAGE, 0xAF); // Point to the EMI0CN register
           =3 
           =3 #endif
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 40  

 341      =3  
 342      =3  //-----------------------------------------------------------------------------
 343      =3  // Header File PreProcessor Directive
 344      =3  //-----------------------------------------------------------------------------
 345      =3  
 346      =3  #endif                                 // #define C8051F020_DEFS_H
 347      =3  
 348      =3  //-----------------------------------------------------------------------------
 349      =3  // End Of File
 350      =3  //-----------------------------------------------------------------------------
  98      =2  /*****************************************************************************/
  99      =2  #include <stdio.h>
   1      =3  /*--------------------------------------------------------------------------
   2      =3  STDIO.H
   3      =3  
   4      =3  Prototypes for standard I/O functions.
   5      =3  Copyright (c) 1988-2002 Keil Elektronik GmbH and Keil Software, Inc.
   6      =3  All rights reserved.
   7      =3  --------------------------------------------------------------------------*/
   8      =3  
   9      =3  #ifndef __STDIO_H__
  10      =3  #define __STDIO_H__
  11      =3  
  12      =3  #ifndef EOF
  13      =3   #define EOF -1
  14      =3  #endif
  15      =3  
  16      =3  #ifndef NULL
           =3  #define NULL ((void *) 0)
           =3 #endif
  19      =3  
  20      =3  #ifndef _SIZE_T
  21      =3   #define _SIZE_T
  22      =3   typedef unsigned int size_t;
  23      =3  #endif
  24      =3  
  25      =3  #pragma SAVE
  26      =3  #pragma REGPARMS
  27      =3  extern char _getkey (void);
  28      =3  extern char getchar (void);
  29      =3  extern char ungetchar (char);
  30      =3  extern char putchar (char);
  31      =3  extern int printf   (const char *, ...);
  32      =3  extern int sprintf  (char *, const char *, ...);
  33      =3  extern int vprintf  (const char *, char *);
  34      =3  extern int vsprintf (char *, const char *, char *);
  35      =3  extern char *gets (char *, int n);
  36      =3  extern int scanf (const char *, ...);
  37      =3  extern int sscanf (char *, const char *, ...);
  38      =3  extern int puts (const char *);
  39      =3  
  40      =3  #pragma RESTORE
  41      =3  
  42      =3  #endif
  43      =3  
 100      =2  #include <stdlib.h> 
   1      =3  /*--------------------------------------------------------------------------
   2      =3  STDLIB.H
   3      =3  
   4      =3  Standard functions.
   5      =3  Copyright (c) 1988-2008 Keil Elektronik GmbH and Keil Software, Inc.
   6      =3  Copyright (c) 2008-2016 ARM Germany GmbH
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 41  

   7      =3  All rights reserved.
   8      =3  --------------------------------------------------------------------------*/
   9      =3  
  10      =3  #ifndef __STDLIB_H__
  11      =3  #define __STDLIB_H__
  12      =3  
  13      =3  #ifndef _SIZE_T
           =3  #define _SIZE_T
           =3  typedef unsigned int size_t;
           =3 #endif
  17      =3  
  18      =3  #ifndef NULL
           =3  #define NULL ((void *)0)
           =3 #endif
  21      =3  
  22      =3  #ifndef _WCHAR_T_DEFINED_
  23      =3  #define _WCHAR_T_DEFINED_
  24      =3  typedef char wchar_t;
  25      =3  #endif
  26      =3  
  27      =3  #if defined (__CX2__)
           =3 #ifndef _DIV_T_DEFINED
           =3 typedef struct _div_t {
           =3         int quot;
           =3         int rem;
           =3 } div_t;
           =3 typedef struct _ldiv_t {
           =3         long quot;
           =3         long rem;
           =3 } ldiv_t;
           =3 #define _DIV_T_DEFINED
           =3 #endif // _DIV_T_DEFINED
           =3 #endif // __CX2__
  40      =3  
  41      =3  #ifndef RAND_MAX
  42      =3   #define RAND_MAX  32767u
  43      =3  #endif
  44      =3  
  45      =3  #if defined (__CX2__)
           =3 #pragma SAVE
           =3 #pragma FUNCTIONS(STATIC)
           =3 /* intrinsic functions are reentrant, but need static attribute */
           =3 extern int    abs  (int   val);
           =3 #pragma RESTORE
           =3 #endif // __CX2__
  52      =3  
  53      =3  #pragma SAVE
  54      =3  #pragma REGPARMS
  55      =3  
  56      =3  extern char   cabs (char  val);
  57      =3  #if !defined (__CX2__)
  58      =3  extern int    abs  (int   val);
  59      =3  #endif // __CX2__
  60      =3  extern long   labs (long  val);
  61      =3  
  62      =3  extern float  atof (const char *s1);
  63      =3  extern long   atol (const char *s1);
  64      =3  extern int    atoi (const char *s1);
  65      =3  extern int    rand (void);
  66      =3  extern void   srand (unsigned int seed);
  67      =3  
  68      =3  #ifdef _DIV_T_DEFINED
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 42  

           =3 extern div_t  __div (int numer, int denom);
           =3 #define div(numer,denom)  __div((numer),(denom));
           =3 extern ldiv_t ldiv (long numer, long denom);
           =3 #endif // _DIV_T_DEFINED
  73      =3  
  74      =3  extern float         strtod  (const char *nptr, char **endptr);
  75      =3  extern long          strtol  (const char *nptr, char **endptr, unsigned char base);
  76      =3  extern unsigned long strtoul (const char *nptr, char **endptr, unsigned char base);
  77      =3  
  78      =3  #define _MALLOC_MEM_    xdata
  79      =3  
  80      =3  extern void init_mempool          (void _MALLOC_MEM_ *p, size_t size);
  81      =3  extern void _MALLOC_MEM_ *malloc  (size_t size);
  82      =3  extern void free                  (void _MALLOC_MEM_ *p);
  83      =3  extern void _MALLOC_MEM_ *realloc (void _MALLOC_MEM_ *p, size_t size);
  84      =3  extern void _MALLOC_MEM_ *calloc  (size_t nmemb, size_t size);
  85      =3  
  86      =3  #if defined (__CX2__)
           =3 extern void abort(void);
           =3 #endif // __CX2__
  89      =3  
  90      =3  #pragma RESTORE
  91      =3  
  92      =3  #endif // __STDLIB_H__
 101      =2  #include <string.h>
   1      =3  /*--------------------------------------------------------------------------
   2      =3  STRING.H
   3      =3  
   4      =3  String functions.
   5      =3  Copyright (c) 1988-2008 Keil Elektronik GmbH and Keil Software, Inc.
   6      =3  Copyright (c) 2008-2016 ARM Germany GmbH
   7      =3  All rights reserved.
   8      =3  --------------------------------------------------------------------------*/
   9      =3  
  10      =3  #ifndef __STRING_H__
  11      =3  #define __STRING_H__
  12      =3  
  13      =3  #ifndef _SIZE_T
           =3  #define _SIZE_T
           =3  typedef unsigned int size_t;
           =3 #endif
  17      =3  
  18      =3  #ifndef NULL
           =3  #define NULL ((void *)0)
           =3 #endif
  21      =3  
  22      =3  #pragma SAVE
  23      =3  #pragma REGPARMS
  24      =3  extern char  *strcat  (char *s1, const char *s2);
  25      =3  extern char  *strncat (char *s1, const char *s2, size_t n);
  26      =3  
  27      =3  extern char   strcmp  (const char *s1, const char *s2);
  28      =3  extern char   strncmp (const char *s1, const char *s2, size_t n);
  29      =3  
  30      =3  extern char  *strcpy  (char *s1, const char *s2);
  31      =3  extern char  *strncpy (char *s1, const char *s2, size_t n);
  32      =3  
  33      =3  extern size_t strlen  (const char *);
  34      =3  
  35      =3  extern char  *strchr  (const char *s, char c);
  36      =3  extern int    strpos  (const char *s, char c);
  37      =3  extern char  *strrchr (const char *s, char c);
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 43  

  38      =3  extern int    strrpos (const char *s, char c);
  39      =3  
  40      =3  extern size_t strspn  (const char *s, const char *set);
  41      =3  extern size_t strcspn (const char *s, const char *set);
  42      =3  extern char  *strpbrk (const char *s, const char *set);
  43      =3  extern char  *strrpbrk(const char *s, const char *set);
  44      =3  extern char  *strstr  (const char *s, const char *sub);
  45      =3  extern char  *strtok  (char *str, const char *set);
  46      =3  
  47      =3  extern char   memcmp  (const void *s1, const void *s2, size_t n);
  48      =3  extern void  *memcpy  (void *s1, const void *s2, size_t n);
  49      =3  extern void  *memchr  (const void *s, char val, size_t n);
  50      =3  extern void  *memccpy (void *s1, const void *s2, char val, size_t n);
  51      =3  extern void  *memmove (void *s1, const void *s2, size_t n);
  52      =3  extern void  *memset  (void *s, char val, size_t n);
  53      =3  #pragma RESTORE
  54      =3  
  55      =3  #endif
 102      =2  #include <INTRINS.H>
   1      =3  /*--------------------------------------------------------------------------
   2      =3  INTRINS.H
   3      =3  
   4      =3  Intrinsic functions for C51.
   5      =3  Copyright (c) 1988-2010 Keil Elektronik GmbH and ARM Germany GmbH
   6      =3  All rights reserved.
   7      =3  --------------------------------------------------------------------------*/
   8      =3  
   9      =3  #ifndef __INTRINS_H__
  10      =3  #define __INTRINS_H__
  11      =3  
  12      =3  #pragma SAVE
  13      =3  
  14      =3  #if defined (__CX2__)
           =3 #pragma FUNCTIONS(STATIC)
           =3 /* intrinsic functions are reentrant, but need static attribute */
           =3 #endif
  18      =3  
  19      =3  extern void          _nop_     (void);
  20      =3  extern bit           _testbit_ (bit);
  21      =3  extern unsigned char _cror_    (unsigned char, unsigned char);
  22      =3  extern unsigned int  _iror_    (unsigned int,  unsigned char);
  23      =3  extern unsigned long _lror_    (unsigned long, unsigned char);
  24      =3  extern unsigned char _crol_    (unsigned char, unsigned char);
  25      =3  extern unsigned int  _irol_    (unsigned int,  unsigned char);
  26      =3  extern unsigned long _lrol_    (unsigned long, unsigned char);
  27      =3  extern unsigned char _chkfloat_(float);
  28      =3  #if defined (__CX2__)
           =3 extern int           abs       (int);
           =3 extern void          _illop_   (void);
           =3 #endif
  32      =3  #if !defined (__CX2__)
  33      =3  extern void          _push_    (unsigned char _sfr);
  34      =3  extern void          _pop_     (unsigned char _sfr);
  35      =3  #endif
  36      =3  
  37      =3  #pragma RESTORE
  38      =3  
  39      =3  #endif
  40      =3  
 103      =2  #include <ctype.h>
   1      =3  /*--------------------------------------------------------------------------
   2      =3  CTYPE.H
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 44  

   3      =3  
   4      =3  Prototypes for character functions.
   5      =3  Copyright (c) 1988-2002 Keil Elektronik GmbH and Keil Software, Inc.
   6      =3  All rights reserved.
   7      =3  --------------------------------------------------------------------------*/
   8      =3  
   9      =3  #ifndef __CTYPE_H__
  10      =3  #define __CTYPE_H__
  11      =3  
  12      =3  #pragma SAVE
  13      =3  #pragma REGPARMS
  14      =3  extern bit isalpha (unsigned char);
  15      =3  extern bit isalnum (unsigned char);
  16      =3  extern bit iscntrl (unsigned char);
  17      =3  extern bit isdigit (unsigned char);
  18      =3  extern bit isgraph (unsigned char);
  19      =3  extern bit isprint (unsigned char);
  20      =3  extern bit ispunct (unsigned char);
  21      =3  extern bit islower (unsigned char);
  22      =3  extern bit isupper (unsigned char);
  23      =3  extern bit isspace (unsigned char);
  24      =3  extern bit isxdigit (unsigned char);
  25      =3  extern unsigned char tolower (unsigned char);
  26      =3  extern unsigned char toupper (unsigned char);
  27      =3  extern unsigned char toint (unsigned char);
  28      =3  
  29      =3  #define _tolower(c) ( (c)-'A'+'a' )
  30      =3  #define _toupper(c) ( (c)-'a'+'A' )
  31      =3  #define toascii(c)  ( (c) & 0x7F )
  32      =3  #pragma RESTORE
  33      =3  
  34      =3  #endif
 104      =2  #include <LIMITS.H>
   1      =3  /*--------------------------------------------------------------------------
   2      =3  LIMITS.H
   3      =3  
   4      =3  ANSI standard include file.
   5      =3  Copyright (c) 1988-2008 Keil Elektronik GmbH and Keil Software, Inc.
   6      =3  Copyright (c) 2009 ARM Germany GmbH
   7      =3  All rights reserved.
   8      =3  --------------------------------------------------------------------------*/
   9      =3  
  10      =3  #ifndef __LIMITS_H__
  11      =3  #define __LIMITS_H__
  12      =3  
  13      =3  #define CHAR_BIT         8              /* Number of bits in any "char" */
  14      =3  #define CHAR_MAX         127            /* Max             "char" value */
  15      =3  #define CHAR_MIN       (-128)           /* Min             "char" value */
  16      =3  #define SCHAR_MAX        127            /* Max "signed"    "char" value */
  17      =3  #define SCHAR_MIN      (-128)           /* Min "signed"    "char" value */
  18      =3  #define UCHAR_MAX        255            /* Max "unsigned"  "char" value */
  19      =3  #define SHRT_MAX         32767          /* Max ("signed") "short" value */
  20      =3  #define SHRT_MIN       (-32767-1)       /* Min ("signed") "short" value */
  21      =3  #define USHRT_MAX        0xFFFF         /* Max "unsigned" "short" value */
  22      =3  #define INT_MAX          32767          /* Max ("signed")   "int" value */
  23      =3  #define INT_MIN        (-32767-1)       /* Min ("signed")   "int" value */
  24      =3  #define UINT_MAX         0xFFFF         /* Max "unsigned"   "int" value */
  25      =3  #define LONG_MAX         2147483647     /* Max ("signed")  "long" value */
  26      =3  #define LONG_MIN   (-2147483647L-1L)    /* Min ("signed")  "long" value */
  27      =3  #define ULONG_MAX        0xFFFFFFFF     /* Max "unsigned"  "long" value */
  28      =3  
  29      =3  #endif
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 45  

 105      =2  #include <math.h>
   1      =3  /*--------------------------------------------------------------------------
   2      =3  MATH.H
   3      =3  
   4      =3  Prototypes for mathematic functions.
   5      =3  Copyright (c) 1988-2008 Keil Elektronik GmbH and Keil Software, Inc.
   6      =3  Copyright (c) 2008-2016 ARM Germany GmbH
   7      =3  All rights reserved.
   8      =3  --------------------------------------------------------------------------*/
   9      =3  
  10      =3  #ifndef __MATH_H__
  11      =3  #define __MATH_H__
  12      =3  
  13      =3  #if defined __CX2__ && (__CX2__ >= 558 || __CX2__ == 556 && __CX2_MINOR__ >= 207)
           =3 #ifndef HUGE_VAL
           =3 #define HUGE_VAL __inf__
           =3 #endif // HUGE_VAL
           =3 
           =3 #ifndef NAN
           =3 #define NAN __nan__
           =3 #endif // NAN
           =3 
           =3 #pragma SAVE
           =3 #pragma FUNCTIONS(STATIC)
           =3 /* intrinsic functions are reentrant, but need static attribute */
           =3 extern int    abs  (int   val);
           =3 #pragma RESTORE
           =3 #endif
  28      =3  
  29      =3  #pragma SAVE
  30      =3  #pragma REGPARMS
  31      =3  #if !defined (__CX2__)
  32      =3  extern char  cabs  (char  val);
  33      =3  extern int    abs  (int   val);
  34      =3  extern long  labs  (long  val);
  35      =3  #endif
  36      =3  
  37      =3  extern float fabs  (float val);
  38      =3  extern float sqrt  (float val);
  39      =3  extern float exp   (float val);
  40      =3  extern float log   (float val);
  41      =3  extern float log10 (float val);
  42      =3  extern float sin   (float val);
  43      =3  extern float cos   (float val);
  44      =3  extern float tan   (float val);
  45      =3  extern float asin  (float val);
  46      =3  extern float acos  (float val);
  47      =3  extern float atan  (float val);
  48      =3  extern float sinh  (float val);
  49      =3  extern float cosh  (float val);
  50      =3  extern float tanh  (float val);
  51      =3  extern float atan2 (float y, float x);
  52      =3  
  53      =3  extern float ceil  (float val);
  54      =3  extern float floor (float val);
  55      =3  extern float modf  (float val, float *n);
  56      =3  extern float fmod  (float x, float y);
  57      =3  extern float pow   (float x, float y);
  58      =3  
  59      =3  #if defined (__CX2__)
           =3 extern float frexp (float val, int *exp);
           =3 extern float ldexp (float val, int exp);
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 46  

           =3 #endif
  63      =3  
  64      =3  #pragma RESTORE
  65      =3  
  66      =3  #endif
 106      =2  #include "crc32.h"
   1      =3  #ifndef __CRC32_H__
   2      =3  #define __CRC32_H__
   3      =3  
   4      =3  //#ifdef __cplusplus
   5      =3  //extern "C" {
   6      =3  //#endif
   7      =3  /*****************************************************************************/
   8      =3  #include "AppConfig.h"
   1      =4  #ifndef __APPCONFIG_H__
           =4 #define __APPCONFIG_H__
           =4 /*****************************************************************************/
           =4 #define DEBUG_LED_ON                                            0
           =4 #define DEBUG_LED_OFF                                           1
           =4 #define CONFIG_SYSCLK                       (22118400L)
           =4 #ifdef C8051F020
           =4 #define SAR_CLK                                                 2000000L//ADC0时钟 <2.5MHz
           =4 #endif
           =4 #define CONFIG_DEBUG                        0//调试功能
           =4 /*****************************************************************************/
           =4 #define CONFIG_UART0_BAUDRATE                           115200//串口波特率
           =4 #define CONFIG_UART0_PARITY                                     NONE
           =4 #define CONFIG_UART0_STOPBIT                            1
           =4 #define CONFIG_UART0_DATABIT                            8
           =4 
           =4 #define CONFIG_UART1_BAUDRATE                           9600//串口波特率
           =4 #define CONFIG_UART1_PARITY                                     NONE
           =4 #define CONFIG_UART1_STOPBIT                            1
           =4 #define CONFIG_UART1_DATABIT                            8
           =4 /*****************************************************************************/
           =4 #define CONFIG_I2C0_FREQ                                        1 
           =4 #define CONFIG_I2C_WAITACT_TIME                         250
           =4 /*****************************************************************************/
           =4 #define CONFIG_EPROM_DEBUG                                      0
           =4 #define CONFIG_EPROM_SIZE                                       CONFIG_AT24C64_SIZE
           =4 #define CONFIG_AT24C02_SIZE                             256
           =4 #define CONFIG_AT24C04_SIZE                             512
           =4 #define CONFIG_AT24C08_SIZE                             1024
           =4 #define CONFIG_AT24C16_SIZE                             2048
           =4 #define CONFIG_AT24C32_SIZE                             4096
           =4 #define CONFIG_AT24C64_SIZE                                     8192
           =4 #define CONFIG_AT24C128_SIZE                            16384
           =4 #define CONFIG_AT24C256_SIZE                            32768
           =4 #define CONFIG_EPROM_ADDRESS                            0x50
           =4 #define CONFIG_EPROM_FRAM                                       0//铁电存储体无写入等待
           =4 #define CONFIG_EPROM_PAGEWRITE                          0//页写入
           =4 /*****************************************************************************/
           =4 //SPLC设置
           =4 #define CONFIG_SPLC_ASSERT                                      0//检查地址范围
           =4 #define CONFIG_SPLC_DEV                                         0x0A01//设备号
           =4 #define CONFIG_SPLC_CLEAR_CODE                          0xA58E
           =4 #define CONFIG_SOFTPLC_HWTIME                           1000L//1mS
           =4 #define CONFIG_INPUT_FILTER_TIME                        3//输入数字滤波扫描周期 1mS * N
           =4 /*****************************************************************************/
           =4 #define CONFIG_SPLC_USING_CLEAR_NVRAM           1//启用清除NVRAM功能
           =4 /*****************************************************************************/
           =4 #define CONFIG_SPLC_USING_WDT                           1//看门狗启用
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 47  

           =4 /*****************************************************************************/
           =4 #define CONFIG_SPLC_USING_IO_INPUT                      1//输入IO刷新启用
           =4 /*****************************************************************************/
           =4 #define CONFIG_SPLC_USING_IO_OUTPUT                     1//输出IO刷新启用
           =4 /*****************************************************************************/
           =4 #define CONFIG_SPLC_USING_EPROM                         1//EPROM掉电存储启用
           =4 /*****************************************************************************/
           =4 #define CONFIG_SPLC_USING_UART1                         1//UART1串口启用
           =4 #if CONFIG_SPLC_USING_UART1 == 1
           =4 #define SPLC_UART1                                                      1
           =4 #endif
           =4 /*****************************************************************************/
           =4 #define CONFIG_SPLC_USING_CADC                          1//使能ADC模块
           =4 #define CONFIG_SPLC_ADC_FILTER_TAP                      14//ADC位移滤波次数
           =4 #define CONFIG_SPLC_ADC_CHANNLE                         64//ADC通道数
           =4 #define CONFIG_SPLC_ADC_TEMP_SENSOR_GAIN    3330L// Temp Sensor Gain in (uV / degC)
           =4 #define CONFIG_SPLC_ADC_TEMP_SENSOR_OFFSET  856L// Temp Sensor Offset in mV
           =4 #define CONFIG_SPLC_ADC_INTERNAL_VREF           2400L// ADC Voltage Reference (mV)
           =4 #define CONFIG_SPLC_ADC_AMBIENT             25L// Ambient temp in deg C
           =4 /*****************************************************************************/
           =4 #define CONFIG_SPLC_USING_DAC                           1//是能DAC模块
           =4 /*****************************************************************************/
           =4 #define CONFIG_SPLC_USING_MB_RTU_SLAVE          1//是能MODBUS RTU从站
           =4 #define CONFIG_MB_RTU_SLAVE_TIMER                       1000L//1000uS
           =4 #define CONFIG_MB_RTU_SLAVE_ADDRESS                     0x01//从设备地址
           =4 #define CONFIG_MB_RTU_SLAVE_BUFFER_SIZE         256//发送接收缓冲区
           =4 #define CONFIG_MB_RTU_SLAVE_TIMEOUT                     100//接收通讯超时 10mS
           =4 #define CONFIG_MB_RTU_SLAVE_IO_DELAY            1//RX TX切换延时
           =4 /*****************************************************************************/
           =4 /*****************************************************************************/
           =4 #define DISABLE_MODBUS_SERIAL_INTERRUPT         ES0 = 0;
           =4 #define ENABLE_MODBUS_SERIAL_INTERRUPT          ES0 = 1;
           =4 #define DISABLE_INTERRUPT                                       EA = 0;
           =4 #define ENABLE_INTERRUPT                                        EA = 1;
           =4 /*****************************************************************************/
           =4 //指示盒子
           =4 #define R_BOX_RED_SENDED                                        (R_START * 16 + 126)
           =4 #define R_BOX_GREEN_SENDED                                      (R_START * 16 + 127)
           =4 #define BOX_CMD_STX                                                     0x81
           =4 #define BOX_CMD_ETX                                                     0x84
           =4 #define BOX_SEND_BFADDR                                         (EM_START + 100)//发送缓冲区位置
           =4 #define BOX_SEND_LENGTH                                         29//发送数据量
           =4 /*****************************************************************************/
           =4 #include "stdint.h"
           =4 #include "stdbool.h"
           =4 #include "endian.h"
           =4 #include "si_toolchain.h"
           =4 #include "compiler_defs.h"
           =4 #include "C8051F020_defs.h"
           =4 /*****************************************************************************/
           =4 #include <stdio.h>
           =4 #include <stdlib.h> 
           =4 #include <string.h>
           =4 #include <INTRINS.H>
           =4 #include <ctype.h>
           =4 #include <LIMITS.H>
           =4 #include <math.h>
           =4 #include "crc32.h"
           =4 /*****************************************************************************/
           =4 #include "InitDeviceF020.h"
           =4 #include "delay.h"
           =4 #include "i2c0.h"
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 48  

           =4 #include "eprom.h"
           =4 #include "dac8568_0.h"
           =4 #include "dac8568_1.h"
           =4 #include "dac8568_2.h"
           =4 #include "dac8568_3.h"
           =4 #if CONFIG_SPLC_USING_UART1 == 1
           =4 #include "sPlcUart.h"
           =4 #endif
           =4 #if CONFIG_SPLC_USING_CADC == 1
           =4 #include "sPlcChipAdc.h"
           =4 #endif
           =4 #if CONFIG_SPLC_USING_DAC == 1
           =4 #include "sPlcDac.h"
           =4 #endif
           =4 /*****************************************************************************/
           =4 #include "Modbus.h"
           =4 #include "ModbusPort.h"
           =4 /*****************************************************************************/
           =4 #include "sPLC.h"
           =4 /*****************************************************************************/
           =4 #endif
   9      =3  /*****************************************************************************/
  10      =3  uint32_t crc32Calculate(uint8_t *buf, uint32_t len);//CRC32 计算数组
  11      =3  uint32_t crc32CalculateAdd(uint8_t dat);//CRC32 计算连续字节
  12      =3  void crc32Clear(void);//清空旧CRC32结果
  13      =3  void crc32SetCrcOld(uint32_t old);
  14      =3  /*****************************************************************************/
  15      =3  //#ifdef __cplusplus
  16      =3  //}
  17      =3  //#endif
  18      =3  #endif
  19      =3  
  20      =3  
  21      =3  
 107      =2  /*****************************************************************************/
 108      =2  #include "InitDeviceF020.h"
   1      =3  #ifndef __INITDEVICEF020_H__
   2      =3  #define __INITDEVICEF020_H__
   3      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
           =2 #include "delay.h"
           =2 #include "i2c0.h"
           =2 #include "eprom.h"
           =2 #include "dac8568_0.h"
           =2 #include "dac8568_1.h"
           =2 #include "dac8568_2.h"
           =2 #include "dac8568_3.h"
           =2 #if CONFIG_SPLC_USING_UART1 == 1
           =2 #include "sPlcUart.h"
           =2 #endif
           =2 #if CONFIG_SPLC_USING_CADC == 1
           =2 #include "sPlcChipAdc.h"
           =2 #endif
           =2 #if CONFIG_SPLC_USING_DAC == 1
           =2 #include "sPlcDac.h"
           =2 #endif
           =2 /*****************************************************************************/
           =2 #include "Modbus.h"
           =2 #include "ModbusPort.h"
           =2 /*****************************************************************************/
           =2 #include "sPLC.h"
           =2 /*****************************************************************************/
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 49  

           =2 #endif
   4      =3  #ifndef __INITDEVICEF020_H__
   4      =3  #define __INITDEVICEF020_H__
   4      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   5      =3  /*****************************************************************************/
   6      =3  void initDeviceF020(void);
   7      =3  #endif
   1      =3  #ifndef __DELAY_H__
   2      =3  #define __DELAY_H__
   3      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   4      =3  #ifndef __DELAY_H__
   4      =3  #define __DELAY_H__
   4      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   5      =3  /*****************************************************************************/
   6      =3  void delayMs(uint8_t ms) reentrant;
   7      =3  void delayUs(uint8_t us) reentrant;
   8      =3  void hwDelayInit(uint8_t reload_h, uint8_t reload_l);
   9      =3  void hwDelay(uint8_t control, uint8_t reload_h, uint8_t reload_l);
  10      =3  /*****************************************************************************/
  11      =3  #endif
  12      =3  
   1      =3  #ifndef __I2C0_H__
   2      =3  #define __I2C0_H__
   3      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   4      =3  #ifndef __I2C0_H__
   4      =3  #define __I2C0_H__
   4      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   5      =3  /*****************************************************************************/
   6      =3  
   7      =3  /*****************************************************************************/
   8      =3  void iic0Init(void);
   9      =3  void iic0Start(void);
  10      =3  void iic0Stop(void);
  11      =3  uint8_t iic0WaitAck(void);
  12      =3  void iic0Ack(void);
  13      =3  void iic0NAck(void);
  14      =3  void iic0SendByte(uint8_t txd);
  15      =3  uint8_t iic0ReadByte(uint8_t ack);
  16      =3  
  17      =3  #endif
  18      =3  
  19      =3  
   1      =3  #ifndef __EPROM_H__
   2      =3  #define __EPROM_H__
   3      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   4      =3  #ifndef __EPROM_H__
   4      =3  #define __EPROM_H__
   4      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   5      =3  /*****************************************************************************/
   6      =3  /*****************************************************************************/
   7      =3  void epromInit(void);
   8      =3  uint8_t epromReadOneByte(uint16_t ReadAddr);
   9      =3  void epromWriteOneByte(uint16_t WriteAddr, uint8_t DataToWrite);
  10      =3  void epromWriteLenByte(uint16_t WriteAddr, uint32_t DataToWrite, uint8_t Len);
  11      =3  uint32_t epromReadLenByte(uint16_t ReadAddr, uint8_t Len);
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 50  

  12      =3  void epromRead(uint16_t ReadAddr,uint8_t *pBuffer,uint16_t NumToRead);
  13      =3  void epromWrite(uint16_t WriteAddr, uint8_t *pBuffer, uint16_t NumToWrite);
  14      =3  uint8_t epromTest(void);
  15      =3  #endif
   1      =3  #include "appConfig.h"
   1      =3  #include "appConfig.h"
   2      =3  /*****************************************************************************/
   3      =3  void dac8568_0_Init(void);
   4      =3  void dac8568_0_Update(uint8_t ch);
   5      =3  void dac8568_0_WriteInputRegister(uint8_t ch, uint16_t dat);
   6      =3  void dac8568_0_WriteDacRegister(uint8_t ch, uint16_t dat);
   7      =3  void dac8568_0_Clear(void);
   8      =3  void dac8568_0_Reset(void);
   1      =3  #include "appConfig.h"
   1      =3  #include "appConfig.h"
   2      =3  /*****************************************************************************/
   3      =3  void dac8568_1_Init(void);
   4      =3  void dac8568_1_Update(uint8_t ch);
   5      =3  void dac8568_1_WriteInputRegister(uint8_t ch, uint16_t dat);
   6      =3  void dac8568_1_WriteDacRegister(uint8_t ch, uint16_t dat);
   7      =3  void dac8568_1_Clear(void);
   8      =3  void dac8568_1_Reset(void);
   1      =3  #include "appConfig.h"
   1      =3  #include "appConfig.h"
   2      =3  /*****************************************************************************/
   3      =3  void dac8568_2_Init(void);
   4      =3  void dac8568_2_Update(uint8_t ch);
   5      =3  void dac8568_2_WriteInputRegister(uint8_t ch, uint16_t dat);
   6      =3  void dac8568_2_WriteDacRegister(uint8_t ch, uint16_t dat);
   7      =3  void dac8568_2_Clear(void);
   8      =3  void dac8568_2_Reset(void);
   1      =3  #include "appConfig.h"
   1      =3  #include "appConfig.h"
   2      =3  /*****************************************************************************/
   3      =3  void dac8568_3_Init(void);
   4      =3  void dac8568_3_Update(uint8_t ch);
   5      =3  void dac8568_3_WriteInputRegister(uint8_t ch, uint16_t dat);
   6      =3  void dac8568_3_WriteDacRegister(uint8_t ch, uint16_t dat);
   7      =3  void dac8568_3_Clear(void);
   8      =3  void dac8568_3_Reset(void);
   1      =3  #ifndef __SPLCUART_H__
   2      =3  #define __SPLCUART_H__
   3      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   4      =3  #ifndef __SPLCUART_H__
   4      =3  #define __SPLCUART_H__
   4      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   5      =3  /*****************************************************************************/
   6      =3  void initUart1(uint32_t baudrate);
   7      =3  void USEND(uint16_t port, uint16_t sendBufAdr, uint16_t length);//串口发送
   8      =3  void URECV(uint16_t port, uint16_t recvBufAdr, uint16_t length);//串口接收
   9      =3  #endif
   1      =3  #ifndef __SPLCCHIPADC_H__
   2      =3  #define __SPLCCHIPADC_H__
   3      =3  #include "appConfig.h"
   3      =3  #ifndef __SPLCCHIPADC_H__
   3      =3  #define __SPLCCHIPADC_H__
   3      =3  #include "appConfig.h"
   4      =3  /*****************************************************************************/
   5      =3  typedef struct{//ADC滤波器
   6      =3          uint16_t dat[CONFIG_SPLC_ADC_FILTER_TAP];
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 51  

   7      =3          uint16_t out;
   8      =3          uint8_t wIndex;//写入指针
   9      =3  }adcTempDat_t;
  10      =3  /*****************************************************************************/
  11      =3  void initChipAdc(void);
  12      =3  void chipAdcProcess(void);
  13      =3  void refreshAdcData(adcTempDat_t *s , uint16_t dat);
  14      =3  #endif
   1      =3  #ifndef __SPLCDAC_H__
   2      =3  #define __SPLCDAC_H__
   3      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   4      =3  #ifndef __SPLCDAC_H__
   4      =3  #define __SPLCDAC_H__
   4      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   5      =3  /*****************************************************************************/
   6      =3  void initChipDac(void);
   7      =3  void refreshDac(void);
   8      =3  void selfTestDac(void);
   9      =3  
  10      =3  #endif
   1      =3  #ifndef __MODBUS__H__
   2      =3  #define __MODBUS__H__
   3      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   4      =3  #ifndef __MODBUS__H__
   4      =3  #define __MODBUS__H__
   4      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   5      =3  /*****************************************************************************/
   6      =3  extern idata volatile uint16_t modbusTimerValue;
   7      =3  extern idata volatile uint8_t modbusReceiveCounter;// Collected data number
   8      =3  extern xdata volatile uint8_t modbusReceiveBuffer[CONFIG_MB_RTU_SLAVE_BUFFER_SIZE];
   9      =3  /*****************************************************************************/
  10      =3  extern void initModbus(uint8_t modbusSlaveAddress, uint32_t bd);
  11      =3  extern void modbusPorcess(void);
  12      =3  #endif
   1      =3  #ifndef __MODBUSPORT__H__
   2      =3  #define __MODBUSPORT__H__
   3      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   4      =3  #ifndef __MODBUSPORT__H__
   4      =3  #define __MODBUSPORT__H__
   4      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   5      =3  /*****************************************************************************/
   6      =3  extern void modBusUartInitialise(uint32_t baudrate);
   7      =3  extern void modBusTimerInitialise(void);
   8      =3  extern void modBusUartPutch(uint8_t c);
   9      =3  extern uint8_t modBusUartString(uint8_t *s, uint16_t Length);
  10      =3  extern void receiveInterrupt(uint8_t Data);
  11      =3  /*****************************************************************************/
  12      =3  #endif
   1      =3  #ifndef __SPLC_H__
           =3 #define __SPLC_H__
           =3 /*****************************************************************************/
           =3 #include "appConfig.h"
           =3 /*****************************************************************************/
           =3 //线圈 保持 8 * 16 = 128BIT
           =3 #define MR_START                                                0
           =3 #define MR_END                                                  3
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 52  

           =3 //线圈寄存器 非保持 8 * 16 = 128BIT
           =3 #define R_START                                                 4
           =3 #define R_END                                                   11
           =3 //数据寄存器 保持 8
           =3 #define DM_START                                                12
           =3 #define DM_END                                                  19
           =3 //数据寄存器 非保持 140个字
           =3 #define EM_START                                                20
           =3 #define EM_END                                                  159
           =3 //延时线圈
           =3 //1MS 1 * 16 = 16BIT
           =3 #define T_1MS_START                                             160
           =3 #define T_1MS_END                                               160
           =3 //10MS 1 * 16 = 16BIT
           =3 #define T_10MS_START                                    161
           =3 #define T_10MS_END                                              161
           =3 //100MS 1 * 16 = 16BIT
           =3 #define T_100MS_START                                   162
           =3 #define T_100MS_END                                             162
           =3 //延时计时器 
           =3 //1MS 16
           =3 #define TD_1MS_START                                    163
           =3 #define TD_1MS_END                                              178
           =3 //10MS 16
           =3 #define TD_10MS_START                                   179
           =3 #define TD_10MS_END                                             194
           =3 //100MS 16
           =3 #define TD_100MS_START                                  195
           =3 #define TD_100MS_END                                    210
           =3 //计数器 1
           =3 #define C_START                                                 211
           =3 #define C_END                                                   211
           =3 //输入位寄存器 1 * 16 = 16个
           =3 #define X_START                                                 212
           =3 #define X_END                                                   212             
           =3 //输出位寄存器 1 * 16 = 16个
           =3 #define Y_START                                                 213
           =3 #define Y_END                                                   213
           =3 //特殊寄存器 24个字
           =3 #define SPREG_START                                             214
           =3 #define SPREG_END                                               237
           =3 //特殊线圈      4 * 16 = 64个
           =3 #define SPCOIL_START                                    238
           =3 #define SPCOIL_END                                              241
           =3 /*****************************************************************************/
           =3 #define EM_ADC_0                                                (EM_START + 0)//ADC0->MLD0
           =3 #define EM_ADC_1                                                (EM_START + 1)//ADC1->MLD1
           =3 #define EM_ADC_2                                                (EM_START + 2)//ADC2->MLD2
           =3 #define EM_ADC_3                                                (EM_START + 3)//ADC3->MLD3
           =3 #define EM_ADC_4                                                (EM_START + 4)//ADC4->MLD4
           =3 #define EM_ADC_5                                                (EM_START + 5)//ADC5->MLD5
           =3 #define EM_ADC_6                                                (EM_START + 6)//ADC6->MLD6
           =3 #define EM_ADC_7                                                (EM_START + 7)//ADC7->MLD7
           =3 #define EM_ADC_8                                                (EM_START + 8)//ADC8->MLD8
           =3 #define EM_ADC_9                                                (EM_START + 9)//ADC9->MLD9
           =3 #define EM_ADC_10                                               (EM_START + 10)//ADC10->MLD10
           =3 #define EM_ADC_11                                               (EM_START + 11)//ADC11->MLD11
           =3 #define EM_ADC_12                                               (EM_START + 12)//ADC12->MLD12
           =3 #define EM_ADC_13                                               (EM_START + 13)//ADC13->MLD13
           =3 #define EM_ADC_14                                               (EM_START + 14)//ADC14->MLD14
           =3 #define EM_ADC_15                                               (EM_START + 15)//ADC15->MLD15
           =3 #define EM_ADC_16                                               (EM_START + 16)//ADC16->MLD16
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 53  

           =3 #define EM_ADC_17                                               (EM_START + 17)//ADC17->MLD17
           =3 #define EM_ADC_18                                               (EM_START + 18)//ADC18->MLD18
           =3 #define EM_ADC_19                                               (EM_START + 19)//ADC19->MLD19
           =3 #define EM_ADC_20                                               (EM_START + 20)//ADC20->MLD20
           =3 #define EM_ADC_21                                               (EM_START + 21)//ADC21->MLD21
           =3 #define EM_ADC_22                                               (EM_START + 22)//ADC22->MLD22
           =3 #define EM_ADC_23                                               (EM_START + 23)//ADC23->MLD23
           =3 #define EM_ADC_24                                               (EM_START + 24)//ADC24->MLD24
           =3 #define EM_ADC_25                                               (EM_START + 25)//ADC25->MLD25
           =3 #define EM_ADC_26                                               (EM_START + 26)//ADC26->MLD26
           =3 #define EM_ADC_27                                               (EM_START + 27)//ADC27->MLD27
           =3 #define EM_ADC_28                                               (EM_START + 28)//ADC28->MLD28
           =3 #define EM_ADC_29                                               (EM_START + 29)//ADC29->MLD29
           =3 #define EM_ADC_30                                               (EM_START + 30)//ADC30->MLD30
           =3 #define EM_ADC_31                                               (EM_START + 31)//ADC31->MLD31
           =3 #define EM_ADC_32                                               (EM_START + 32)//ADC32->MPD0
           =3 #define EM_ADC_33                                               (EM_START + 33)//ADC33->MPD1
           =3 #define EM_ADC_34                                               (EM_START + 34)//ADC34->MPD2
           =3 #define EM_ADC_35                                               (EM_START + 35)//ADC35->MPD3
           =3 #define EM_ADC_36                                               (EM_START + 36)//ADC36->MPD4
           =3 #define EM_ADC_37                                               (EM_START + 37)//ADC37->MPD5
           =3 #define EM_ADC_38                                               (EM_START + 38)//ADC38->MPD6
           =3 #define EM_ADC_39                                               (EM_START + 39)//ADC39->MPD7
           =3 #define EM_ADC_40                                               (EM_START + 40)//ADC40->MPD8
           =3 #define EM_ADC_41                                               (EM_START + 41)//ADC41->MPD9
           =3 #define EM_ADC_42                                               (EM_START + 42)//ADC42->MPD10
           =3 #define EM_ADC_43                                               (EM_START + 43)//ADC42->MPD11
           =3 #define EM_ADC_44                                               (EM_START + 44)//ADC42->MPD12
           =3 #define EM_ADC_45                                               (EM_START + 45)//ADC42->MPD13
           =3 #define EM_ADC_46                                               (EM_START + 46)//ADC42->MPD14
           =3 #define EM_ADC_47                                               (EM_START + 47)//ADC42->MPD15
           =3 #define EM_ADC_48                                               (EM_START + 48)//ADC42->MPD16
           =3 #define EM_ADC_49                                               (EM_START + 49)//ADC42->MPD17
           =3 #define EM_ADC_50                                               (EM_START + 50)//ADC42->MPD18
           =3 #define EM_ADC_51                                               (EM_START + 51)//ADC42->MPD19
           =3 #define EM_ADC_52                                               (EM_START + 52)//ADC42->MPD20
           =3 #define EM_ADC_53                                               (EM_START + 53)//ADC43->MPD21
           =3 #define EM_ADC_54                                               (EM_START + 54)//ADC44->MPD22
           =3 #define EM_ADC_55                                               (EM_START + 55)//ADC45->MPD23
           =3 #define EM_ADC_56                                               (EM_START + 56)//ADC46->MPD24
           =3 #define EM_ADC_57                                               (EM_START + 57)//ADC47->MPD25
           =3 #define EM_ADC_58                                               (EM_START + 58)//ADC48->MPD26
           =3 #define EM_ADC_59                                               (EM_START + 59)//ADC49->MPD27
           =3 #define EM_ADC_60                                               (EM_START + 60)//ADC50->MPD28
           =3 #define EM_ADC_61                                               (EM_START + 61)//ADC50->MPD29
           =3 #define EM_ADC_62                                               (EM_START + 62)//ADC50->MPD30
           =3 #define EM_ADC_63                                               (EM_START + 63)//ADC50->MPD31
           =3 #define EM_DAC_0                                                (EM_START + 64)//DAC0
           =3 #define EM_DAC_1                                                (EM_START + 65)//DAC1
           =3 #define EM_DAC_2                                                (EM_START + 66)//DAC2
           =3 #define EM_DAC_3                                                (EM_START + 67)//DAC3
           =3 #define EM_DAC_4                                                (EM_START + 68)//DAC4
           =3 #define EM_DAC_5                                                (EM_START + 69)//DAC5
           =3 #define EM_DAC_6                                                (EM_START + 70)//DAC6
           =3 #define EM_DAC_7                                                (EM_START + 71)//DAC7
           =3 #define EM_DAC_8                                                (EM_START + 72)//DAC8
           =3 #define EM_DAC_9                                                (EM_START + 73)//DAC9
           =3 #define EM_DAC_10                                               (EM_START + 74)//DAC10
           =3 #define EM_DAC_11                                               (EM_START + 75)//DAC11
           =3 #define EM_DAC_12                                               (EM_START + 76)//DAC12
           =3 #define EM_DAC_13                                               (EM_START + 77)//DAC13
           =3 #define EM_DAC_14                                               (EM_START + 78)//DAC14
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 54  

           =3 #define EM_DAC_15                                               (EM_START + 79)//DAC15
           =3 #define EM_DAC_16                                               (EM_START + 80)//DAC16
           =3 #define EM_DAC_17                                               (EM_START + 81)//DAC17
           =3 #define EM_DAC_18                                               (EM_START + 82)//DAC18
           =3 #define EM_DAC_19                                               (EM_START + 83)//DAC19
           =3 #define EM_DAC_20                                               (EM_START + 84)//DAC20
           =3 #define EM_DAC_21                                               (EM_START + 85)//DAC21
           =3 #define EM_DAC_22                                               (EM_START + 86)//DAC22
           =3 #define EM_DAC_23                                               (EM_START + 87)//DAC23
           =3 #define EM_DAC_24                                               (EM_START + 88)//DAC24
           =3 #define EM_DAC_25                                               (EM_START + 89)//DAC25
           =3 #define EM_DAC_26                                               (EM_START + 90)//DAC26
           =3 #define EM_DAC_27                                               (EM_START + 91)//DAC27
           =3 #define EM_DAC_28                                               (EM_START + 92)//DAC28
           =3 #define EM_DAC_29                                               (EM_START + 93)//DAC29
           =3 #define EM_DAC_30                                               (EM_START + 94)//DAC30
           =3 #define EM_DAC_31                                               (EM_START + 95)//DAC31
           =3 /*****************************************************************************/
           =3 #define CONFIG_NVRAM_SIZE                               (SPCOIL_END + 1)
           =3 /*****************************************************************************/
           =3 #define SPCOIL_ON                                               (SPCOIL_START * 16 + 0)//长通线圈
           =3 #define SPCOIL_START_UP                                 (SPCOIL_START * 16 + 1)//初次上电
           =3 #define SPCOIL_PS1MS                                    (SPCOIL_START * 16 + 2)//1mS间隔 50%占空比脉冲
           =3 #define SPCOIL_PS10MS                                   (SPCOIL_START * 16 + 3)//10mS
           =3 #define SPCOIL_PS100MS                                  (SPCOIL_START * 16 + 4)//100mS  
           =3 #define SPCOIL_PS1000MS                                 (SPCOIL_START * 16 + 5)//1000mS 
           =3 #define SPCOIL_UART0_SEND_BUSY                  (SPCOIL_START * 16 + 10)//UART1发送忙
           =3 #define SPCOIL_UART0_RECV_BUSY                  (SPCOIL_START * 16 + 11)//UART1接收忙
           =3 #define SPCOIL_UART0_SEND_DONE                  (SPCOIL_START * 16 + 12)//发送完成
           =3 #define SPCOIL_UART0_RECV_DONE                  (SPCOIL_START * 16 + 13)//接收完成
           =3 #define SPCOIL_UART1_SEND_BUSY                  (SPCOIL_START * 16 + 14)//UART1发送忙
           =3 #define SPCOIL_UART1_RECV_BUSY                  (SPCOIL_START * 16 + 15)//UART1接收忙
           =3 #define SPCOIL_UART1_SEND_DONE                  (SPCOIL_START * 16 + 16)//发送完成
           =3 #define SPCOIL_UART1_RECV_DONE                  (SPCOIL_START * 16 + 17)//接收完成
           =3 /*****************************************************************************/
           =3 #define SPREG_RUNTIME_L                                 (SPREG_START + 0)//累计运行时间秒 32BIT
           =3 #define SPREG_RUNTIME_H                                 (SPREG_START + 1)//累计运行时间秒 32BIT         
           =3 /*****************************************************************************/
           =3 #define SPREG_UART0_SEND_BUFFER_ADR             (SPREG_START + 4)//UART0 发送缓冲NVRAM地址              
           =3 #define SPREG_UART0_SEND_LENGTH                 (SPREG_START + 5)//UART0 发送数据长度
           =3 #define SPREG_UART0_SEND_NUM                    (SPREG_START + 6)//UART0 已经发送数据长度
           =3 #define SPREG_UART0_RECV_BUFFER_ADR             (SPREG_START + 7)//UART0 接收缓冲NVRAM地址
           =3 #define SPREG_UART0_RECV_LENGTH                 (SPREG_START + 8)//UART0 接收数据长度
           =3 #define SPREG_UART0_RECV_NUM                    (SPREG_START + 9)//UART0 已经接收数据长度
           =3 /*****************************************************************************/
           =3 #define SPREG_UART1_SEND_BUFFER_ADR             (SPREG_START + 10)//UART1 发送缓冲NVRAM地址             
           =3 #define SPREG_UART1_SEND_LENGTH                 (SPREG_START + 11)//UART1 发送数据长度
           =3 #define SPREG_UART1_SEND_NUM                    (SPREG_START + 12)//UART1 已经发送数据长度
           =3 #define SPREG_UART1_RECV_BUFFER_ADR             (SPREG_START + 13)//UART1 接收缓冲NVRAM地址
           =3 #define SPREG_UART1_RECV_LENGTH                 (SPREG_START + 14)//UART1 接收数据长度
           =3 #define SPREG_UART1_RECV_NUM                    (SPREG_START + 15)//UART1 已经接收数据长度
           =3 /*****************************************************************************/
           =3 #define SPREG_CLEAR_NVRAM0                              (SPREG_END)//清除NVRAM后重新启动
           =3 /*****************************************************************************/
           =3 extern xdata int16_t volatile NVRAM0[CONFIG_NVRAM_SIZE];//掉电保持寄存器 当前
           =3 extern xdata int16_t volatile NVRAM1[CONFIG_NVRAM_SIZE];//掉电保持寄存器 上一次
           =3 /*****************************************************************************/
           =3 uint8_t getGlobalInterrupt(void);
           =3 void setLedRun(uint8_t st);
           =3 uint8_t getLedRun(void);
           =3 void setLedEprom(uint8_t st);
           =3 uint8_t getLedEprom(void);
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 55  

           =3 void setLedDac(uint8_t st);
           =3 uint8_t getLedDac(void);
           =3 void setLedError(uint8_t st);
           =3 uint8_t getLedError(void);
           =3 void sPlcInit(void);//软逻辑初始化
           =3 void sPlcProcessStart(void);//sPLC轮询起始
           =3 void sPlcProcessEnd(void);//sPLC轮询结束
           =3 void wdtFeed(void) reentrant;
           =3 void wdtEnable(void) reentrant;
           =3 void wdtDisable(void) reentrant;
           =3 /*****************************************************************************/
           =3 void assertCoilAddress(uint16_t adr) reentrant;
           =3 void assertRegisterAddress(uint16_t adr) reentrant;
           =3 /*****************************************************************************/
           =3 void nvramUpdata(void);
           =3 void clearDM(void);
           =3 void clearEM(void);
           =3 void clearR(void);
           =3 void clearT(void);
           =3 void clearTD(void);
           =3 void clearC(void);
           =3 void nvramLoad(void);
           =3 void nvramSave(void);
           =3 void nvramUpdata(void);
           =3 /*****************************************************************************/
           =3 void REBOOT(void) reentrant;//强制复位
           =3 void SET(uint16_t A) reentrant;//线圈置位
           =3 void RES(uint16_t A) reentrant;//线圈复位
           =3 void FLIP(uint16_t A) reentrant;//翻转
           =3 uint8_t LD(uint16_t A) reentrant;//载入
           =3 uint8_t LDB(uint16_t A) reentrant;//方向载入
           =3 uint8_t LDP(uint16_t A) reentrant;//脉冲上升沿
           =3 uint8_t LDN(uint16_t A) reentrant;//脉冲下降沿
           =3 void T100US(uint8_t A, uint8_t start, uint16_t value);
           =3 void T1MS(uint8_t A, uint8_t start, uint16_t value);
           =3 void T10MS(uint8_t A, uint8_t start, uint16_t value);
           =3 void T100MS(uint8_t A, uint8_t start, uint16_t value);
           =3 void DSUB(uint16_t Sa, uint16_t Sb, uint16_t D);
           =3 /*****************************************************************************/
           =3 void chipDacInit(void);
           =3 void chipAdcInit(void);
           =3 void sPlcInit(void);
           =3 void refreshInput(void);
           =3 void refreshOutput(void);
           =3 void refreshDac(void);
           =3 /*****************************************************************************/
           =3 #endif
   5      =1  /*****************************************************************************/
   6      =1  //线圈 保持 8 * 16 = 128BIT
   7      =1  #define MR_START                                                0
   8      =1  #define MR_END                                                  3
   9      =1  //线圈寄存器 非保持 8 * 16 = 128BIT
  10      =1  #define R_START                                                 4
  11      =1  #define R_END                                                   11
  12      =1  //数据寄存器 保持 8
  13      =1  #define DM_START                                                12
  14      =1  #define DM_END                                                  19
  15      =1  //数据寄存器 非保持 140个字
  16      =1  #define EM_START                                                20
  17      =1  #define EM_END                                                  159
  18      =1  //延时线圈
  19      =1  //1MS 1 * 16 = 16BIT
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 56  

  20      =1  #define T_1MS_START                                             160
  21      =1  #define T_1MS_END                                               160
  22      =1  //10MS 1 * 16 = 16BIT
  23      =1  #define T_10MS_START                                    161
  24      =1  #define T_10MS_END                                              161
  25      =1  //100MS 1 * 16 = 16BIT
  26      =1  #define T_100MS_START                                   162
  27      =1  #define T_100MS_END                                             162
  28      =1  //延时计时器 
  29      =1  //1MS 16
  30      =1  #define TD_1MS_START                                    163
  31      =1  #define TD_1MS_END                                              178
  32      =1  //10MS 16
  33      =1  #define TD_10MS_START                                   179
  34      =1  #define TD_10MS_END                                             194
  35      =1  //100MS 16
  36      =1  #define TD_100MS_START                                  195
  37      =1  #define TD_100MS_END                                    210
  38      =1  //计数器 1
  39      =1  #define C_START                                                 211
  40      =1  #define C_END                                                   211
  41      =1  //输入位寄存器 1 * 16 = 16个
  42      =1  #define X_START                                                 212
  43      =1  #define X_END                                                   212             
  44      =1  //输出位寄存器 1 * 16 = 16个
  45      =1  #define Y_START                                                 213
  46      =1  #define Y_END                                                   213
  47      =1  //特殊寄存器 24个字
  48      =1  #define SPREG_START                                             214
  49      =1  #define SPREG_END                                               237
  50      =1  //特殊线圈      4 * 16 = 64个
  51      =1  #define SPCOIL_START                                    238
  52      =1  #define SPCOIL_END                                              241
  53      =1  /*****************************************************************************/
  54      =1  #define EM_ADC_0                                                (EM_START + 0)//ADC0->MLD0
  55      =1  #define EM_ADC_1                                                (EM_START + 1)//ADC1->MLD1
  56      =1  #define EM_ADC_2                                                (EM_START + 2)//ADC2->MLD2
  57      =1  #define EM_ADC_3                                                (EM_START + 3)//ADC3->MLD3
  58      =1  #define EM_ADC_4                                                (EM_START + 4)//ADC4->MLD4
  59      =1  #define EM_ADC_5                                                (EM_START + 5)//ADC5->MLD5
  60      =1  #define EM_ADC_6                                                (EM_START + 6)//ADC6->MLD6
  61      =1  #define EM_ADC_7                                                (EM_START + 7)//ADC7->MLD7
  62      =1  #define EM_ADC_8                                                (EM_START + 8)//ADC8->MLD8
  63      =1  #define EM_ADC_9                                                (EM_START + 9)//ADC9->MLD9
  64      =1  #define EM_ADC_10                                               (EM_START + 10)//ADC10->MLD10
  65      =1  #define EM_ADC_11                                               (EM_START + 11)//ADC11->MLD11
  66      =1  #define EM_ADC_12                                               (EM_START + 12)//ADC12->MLD12
  67      =1  #define EM_ADC_13                                               (EM_START + 13)//ADC13->MLD13
  68      =1  #define EM_ADC_14                                               (EM_START + 14)//ADC14->MLD14
  69      =1  #define EM_ADC_15                                               (EM_START + 15)//ADC15->MLD15
  70      =1  #define EM_ADC_16                                               (EM_START + 16)//ADC16->MLD16
  71      =1  #define EM_ADC_17                                               (EM_START + 17)//ADC17->MLD17
  72      =1  #define EM_ADC_18                                               (EM_START + 18)//ADC18->MLD18
  73      =1  #define EM_ADC_19                                               (EM_START + 19)//ADC19->MLD19
  74      =1  #define EM_ADC_20                                               (EM_START + 20)//ADC20->MLD20
  75      =1  #define EM_ADC_21                                               (EM_START + 21)//ADC21->MLD21
  76      =1  #define EM_ADC_22                                               (EM_START + 22)//ADC22->MLD22
  77      =1  #define EM_ADC_23                                               (EM_START + 23)//ADC23->MLD23
  78      =1  #define EM_ADC_24                                               (EM_START + 24)//ADC24->MLD24
  79      =1  #define EM_ADC_25                                               (EM_START + 25)//ADC25->MLD25
  80      =1  #define EM_ADC_26                                               (EM_START + 26)//ADC26->MLD26
  81      =1  #define EM_ADC_27                                               (EM_START + 27)//ADC27->MLD27
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 57  

  82      =1  #define EM_ADC_28                                               (EM_START + 28)//ADC28->MLD28
  83      =1  #define EM_ADC_29                                               (EM_START + 29)//ADC29->MLD29
  84      =1  #define EM_ADC_30                                               (EM_START + 30)//ADC30->MLD30
  85      =1  #define EM_ADC_31                                               (EM_START + 31)//ADC31->MLD31
  86      =1  #define EM_ADC_32                                               (EM_START + 32)//ADC32->MPD0
  87      =1  #define EM_ADC_33                                               (EM_START + 33)//ADC33->MPD1
  88      =1  #define EM_ADC_34                                               (EM_START + 34)//ADC34->MPD2
  89      =1  #define EM_ADC_35                                               (EM_START + 35)//ADC35->MPD3
  90      =1  #define EM_ADC_36                                               (EM_START + 36)//ADC36->MPD4
  91      =1  #define EM_ADC_37                                               (EM_START + 37)//ADC37->MPD5
  92      =1  #define EM_ADC_38                                               (EM_START + 38)//ADC38->MPD6
  93      =1  #define EM_ADC_39                                               (EM_START + 39)//ADC39->MPD7
  94      =1  #define EM_ADC_40                                               (EM_START + 40)//ADC40->MPD8
  95      =1  #define EM_ADC_41                                               (EM_START + 41)//ADC41->MPD9
  96      =1  #define EM_ADC_42                                               (EM_START + 42)//ADC42->MPD10
  97      =1  #define EM_ADC_43                                               (EM_START + 43)//ADC42->MPD11
  98      =1  #define EM_ADC_44                                               (EM_START + 44)//ADC42->MPD12
  99      =1  #define EM_ADC_45                                               (EM_START + 45)//ADC42->MPD13
 100      =1  #define EM_ADC_46                                               (EM_START + 46)//ADC42->MPD14
 101      =1  #define EM_ADC_47                                               (EM_START + 47)//ADC42->MPD15
 102      =1  #define EM_ADC_48                                               (EM_START + 48)//ADC42->MPD16
 103      =1  #define EM_ADC_49                                               (EM_START + 49)//ADC42->MPD17
 104      =1  #define EM_ADC_50                                               (EM_START + 50)//ADC42->MPD18
 105      =1  #define EM_ADC_51                                               (EM_START + 51)//ADC42->MPD19
 106      =1  #define EM_ADC_52                                               (EM_START + 52)//ADC42->MPD20
 107      =1  #define EM_ADC_53                                               (EM_START + 53)//ADC43->MPD21
 108      =1  #define EM_ADC_54                                               (EM_START + 54)//ADC44->MPD22
 109      =1  #define EM_ADC_55                                               (EM_START + 55)//ADC45->MPD23
 110      =1  #define EM_ADC_56                                               (EM_START + 56)//ADC46->MPD24
 111      =1  #define EM_ADC_57                                               (EM_START + 57)//ADC47->MPD25
 112      =1  #define EM_ADC_58                                               (EM_START + 58)//ADC48->MPD26
 113      =1  #define EM_ADC_59                                               (EM_START + 59)//ADC49->MPD27
 114      =1  #define EM_ADC_60                                               (EM_START + 60)//ADC50->MPD28
 115      =1  #define EM_ADC_61                                               (EM_START + 61)//ADC50->MPD29
 116      =1  #define EM_ADC_62                                               (EM_START + 62)//ADC50->MPD30
 117      =1  #define EM_ADC_63                                               (EM_START + 63)//ADC50->MPD31
 118      =1  #define EM_DAC_0                                                (EM_START + 64)//DAC0
 119      =1  #define EM_DAC_1                                                (EM_START + 65)//DAC1
 120      =1  #define EM_DAC_2                                                (EM_START + 66)//DAC2
 121      =1  #define EM_DAC_3                                                (EM_START + 67)//DAC3
 122      =1  #define EM_DAC_4                                                (EM_START + 68)//DAC4
 123      =1  #define EM_DAC_5                                                (EM_START + 69)//DAC5
 124      =1  #define EM_DAC_6                                                (EM_START + 70)//DAC6
 125      =1  #define EM_DAC_7                                                (EM_START + 71)//DAC7
 126      =1  #define EM_DAC_8                                                (EM_START + 72)//DAC8
 127      =1  #define EM_DAC_9                                                (EM_START + 73)//DAC9
 128      =1  #define EM_DAC_10                                               (EM_START + 74)//DAC10
 129      =1  #define EM_DAC_11                                               (EM_START + 75)//DAC11
 130      =1  #define EM_DAC_12                                               (EM_START + 76)//DAC12
 131      =1  #define EM_DAC_13                                               (EM_START + 77)//DAC13
 132      =1  #define EM_DAC_14                                               (EM_START + 78)//DAC14
 133      =1  #define EM_DAC_15                                               (EM_START + 79)//DAC15
 134      =1  #define EM_DAC_16                                               (EM_START + 80)//DAC16
 135      =1  #define EM_DAC_17                                               (EM_START + 81)//DAC17
 136      =1  #define EM_DAC_18                                               (EM_START + 82)//DAC18
 137      =1  #define EM_DAC_19                                               (EM_START + 83)//DAC19
 138      =1  #define EM_DAC_20                                               (EM_START + 84)//DAC20
 139      =1  #define EM_DAC_21                                               (EM_START + 85)//DAC21
 140      =1  #define EM_DAC_22                                               (EM_START + 86)//DAC22
 141      =1  #define EM_DAC_23                                               (EM_START + 87)//DAC23
 142      =1  #define EM_DAC_24                                               (EM_START + 88)//DAC24
 143      =1  #define EM_DAC_25                                               (EM_START + 89)//DAC25
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 58  

 144      =1  #define EM_DAC_26                                               (EM_START + 90)//DAC26
 145      =1  #define EM_DAC_27                                               (EM_START + 91)//DAC27
 146      =1  #define EM_DAC_28                                               (EM_START + 92)//DAC28
 147      =1  #define EM_DAC_29                                               (EM_START + 93)//DAC29
 148      =1  #define EM_DAC_30                                               (EM_START + 94)//DAC30
 149      =1  #define EM_DAC_31                                               (EM_START + 95)//DAC31
 150      =1  /*****************************************************************************/
 151      =1  #define CONFIG_NVRAM_SIZE                               (SPCOIL_END + 1)
 152      =1  /*****************************************************************************/
 153      =1  #define SPCOIL_ON                                               (SPCOIL_START * 16 + 0)//长通线圈
 154      =1  #define SPCOIL_START_UP                                 (SPCOIL_START * 16 + 1)//初次上电
 155      =1  #define SPCOIL_PS1MS                                    (SPCOIL_START * 16 + 2)//1mS间隔 50%占空比脉冲
 156      =1  #define SPCOIL_PS10MS                                   (SPCOIL_START * 16 + 3)//10mS
 157      =1  #define SPCOIL_PS100MS                                  (SPCOIL_START * 16 + 4)//100mS  
 158      =1  #define SPCOIL_PS1000MS                                 (SPCOIL_START * 16 + 5)//1000mS 
 159      =1  #define SPCOIL_UART0_SEND_BUSY                  (SPCOIL_START * 16 + 10)//UART1发送忙
 160      =1  #define SPCOIL_UART0_RECV_BUSY                  (SPCOIL_START * 16 + 11)//UART1接收忙
 161      =1  #define SPCOIL_UART0_SEND_DONE                  (SPCOIL_START * 16 + 12)//发送完成
 162      =1  #define SPCOIL_UART0_RECV_DONE                  (SPCOIL_START * 16 + 13)//接收完成
 163      =1  #define SPCOIL_UART1_SEND_BUSY                  (SPCOIL_START * 16 + 14)//UART1发送忙
 164      =1  #define SPCOIL_UART1_RECV_BUSY                  (SPCOIL_START * 16 + 15)//UART1接收忙
 165      =1  #define SPCOIL_UART1_SEND_DONE                  (SPCOIL_START * 16 + 16)//发送完成
 166      =1  #define SPCOIL_UART1_RECV_DONE                  (SPCOIL_START * 16 + 17)//接收完成
 167      =1  /*****************************************************************************/
 168      =1  #define SPREG_RUNTIME_L                                 (SPREG_START + 0)//累计运行时间秒 32BIT
 169      =1  #define SPREG_RUNTIME_H                                 (SPREG_START + 1)//累计运行时间秒 32BIT         
 170      =1  /*****************************************************************************/
 171      =1  #define SPREG_UART0_SEND_BUFFER_ADR             (SPREG_START + 4)//UART0 发送缓冲NVRAM地址              
 172      =1  #define SPREG_UART0_SEND_LENGTH                 (SPREG_START + 5)//UART0 发送数据长度
 173      =1  #define SPREG_UART0_SEND_NUM                    (SPREG_START + 6)//UART0 已经发送数据长度
 174      =1  #define SPREG_UART0_RECV_BUFFER_ADR             (SPREG_START + 7)//UART0 接收缓冲NVRAM地址
 175      =1  #define SPREG_UART0_RECV_LENGTH                 (SPREG_START + 8)//UART0 接收数据长度
 176      =1  #define SPREG_UART0_RECV_NUM                    (SPREG_START + 9)//UART0 已经接收数据长度
 177      =1  /*****************************************************************************/
 178      =1  #define SPREG_UART1_SEND_BUFFER_ADR             (SPREG_START + 10)//UART1 发送缓冲NVRAM地址             
 179      =1  #define SPREG_UART1_SEND_LENGTH                 (SPREG_START + 11)//UART1 发送数据长度
 180      =1  #define SPREG_UART1_SEND_NUM                    (SPREG_START + 12)//UART1 已经发送数据长度
 181      =1  #define SPREG_UART1_RECV_BUFFER_ADR             (SPREG_START + 13)//UART1 接收缓冲NVRAM地址
 182      =1  #define SPREG_UART1_RECV_LENGTH                 (SPREG_START + 14)//UART1 接收数据长度
 183      =1  #define SPREG_UART1_RECV_NUM                    (SPREG_START + 15)//UART1 已经接收数据长度
 184      =1  /*****************************************************************************/
 185      =1  #define SPREG_CLEAR_NVRAM0                              (SPREG_END)//清除NVRAM后重新启动
 186      =1  /*****************************************************************************/
 187      =1  extern xdata int16_t volatile NVRAM0[CONFIG_NVRAM_SIZE];//掉电保持寄存器 当前
 188      =1  extern xdata int16_t volatile NVRAM1[CONFIG_NVRAM_SIZE];//掉电保持寄存器 上一次
 189      =1  /*****************************************************************************/
 190      =1  uint8_t getGlobalInterrupt(void);
 191      =1  void setLedRun(uint8_t st);
 192      =1  uint8_t getLedRun(void);
 193      =1  void setLedEprom(uint8_t st);
 194      =1  uint8_t getLedEprom(void);
 195      =1  void setLedDac(uint8_t st);
 196      =1  uint8_t getLedDac(void);
 197      =1  void setLedError(uint8_t st);
 198      =1  uint8_t getLedError(void);
 199      =1  void sPlcInit(void);//软逻辑初始化
 200      =1  void sPlcProcessStart(void);//sPLC轮询起始
 201      =1  void sPlcProcessEnd(void);//sPLC轮询结束
 202      =1  void wdtFeed(void) reentrant;
 203      =1  void wdtEnable(void) reentrant;
 204      =1  void wdtDisable(void) reentrant;
 205      =1  /*****************************************************************************/
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 59  

 206      =1  void assertCoilAddress(uint16_t adr) reentrant;
 207      =1  void assertRegisterAddress(uint16_t adr) reentrant;
 208      =1  /*****************************************************************************/
 209      =1  void nvramUpdata(void);
 210      =1  void clearDM(void);
 211      =1  void clearEM(void);
 212      =1  void clearR(void);
 213      =1  void clearT(void);
 214      =1  void clearTD(void);
 215      =1  void clearC(void);
 216      =1  void nvramLoad(void);
 217      =1  void nvramSave(void);
 218      =1  void nvramUpdata(void);
 219      =1  /*****************************************************************************/
 220      =1  void REBOOT(void) reentrant;//强制复位
 221      =1  void SET(uint16_t A) reentrant;//线圈置位
 222      =1  void RES(uint16_t A) reentrant;//线圈复位
 223      =1  void FLIP(uint16_t A) reentrant;//翻转
 224      =1  uint8_t LD(uint16_t A) reentrant;//载入
 225      =1  uint8_t LDB(uint16_t A) reentrant;//方向载入
 226      =1  uint8_t LDP(uint16_t A) reentrant;//脉冲上升沿
 227      =1  uint8_t LDN(uint16_t A) reentrant;//脉冲下降沿
 228      =1  void T100US(uint8_t A, uint8_t start, uint16_t value);
 229      =1  void T1MS(uint8_t A, uint8_t start, uint16_t value);
 230      =1  void T10MS(uint8_t A, uint8_t start, uint16_t value);
 231      =1  void T100MS(uint8_t A, uint8_t start, uint16_t value);
 232      =1  void DSUB(uint16_t Sa, uint16_t Sb, uint16_t D);
 233      =1  /*****************************************************************************/
 234      =1  void chipDacInit(void);
 235      =1  void chipAdcInit(void);
 236      =1  void sPlcInit(void);
 237      =1  void refreshInput(void);
 238      =1  void refreshOutput(void);
 239      =1  void refreshDac(void);
 240      =1  /*****************************************************************************/
 241      =1  #endif
   2          /*****************************************************************************/
   3          xdata int16_t volatile NVRAM0[CONFIG_NVRAM_SIZE];//掉电保持寄存器 当前
   4          xdata int16_t volatile NVRAM1[CONFIG_NVRAM_SIZE];//掉电保持寄存器 上一次
   5          static idata volatile uint8_t TimerCounter_1mS = 0;
   6          static idata volatile uint8_t TimerCounter_10mS = 0;
   7          static idata volatile uint8_t TimerCounter_100mS = 0;
   8          static idata volatile uint8_t Timer0_L, Timer0_H;
   9          /*****************************************************************************/
  10          static idata volatile int8_t inputFilter[(X_END - X_START + 1) * 16];//IO输入滤波器缓冲区
  11          /******************************************************************************/
  12          uint8_t getGlobalInterrupt(void){
  13   1              return EA;
  14   1      }
  15          void setLedRun(uint8_t idata st){//SETLED RUN P7_0
  16   1              if(st){
  17   2                      P7 |= (uint8_t)(1 << 0);
  18   2              }
  19   1              else{
  20   2                      P7 &= ~(uint8_t)(1 << 0);
  21   2              }
  22   1      }
  23          uint8_t getLedRun(void){//GET LED RUN P7_0
  24   1              return (uint8_t)((P7 >> 0) & 0x01);
  25   1      }
  26          void setLedEprom(uint8_t idata st){//SET LED EPROM P7_1
  27   1              if(st){
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 60  

  28   2                      P7 |= (uint8_t)(1 << 1);
  29   2              }
  30   1              else{
  31   2                      P7 &= ~(uint8_t)(1 << 1);
  32   2              }
  33   1      }
  34          uint8_t getLedEprom(void){//GET LED EPROM P7_1
  35   1              return (uint8_t)((P7 >> 1) & 0x01);
  36   1      }
  37          void setLedDac(uint8_t idata st){//SET LED DAC P7_2
  38   1              if(st){
  39   2                      P7 |= (uint8_t)(1 << 2);
  40   2              }
  41   1              else{
  42   2                      P7 &= ~(uint8_t)(1 << 2);
  43   2              }
  44   1      }
  45          uint8_t getLedDac(void){//GET LED DAC P7_2
  46   1              return (uint8_t)((P7 >> 2) & 0x01);
  47   1      }
  48          void setLedError(uint8_t idata st){//SET LED ERROR P7_3
  49   1              if(st){
  50   2                      P7 |= (uint8_t)(1 << 3);
  51   2              }
  52   1              else{
  53   2                      P7 &= ~(uint8_t)(1 << 3);
  54   2              }
  55   1      }
  56          uint8_t getLedError(void){//GET LED ERROR
  57   1              return (uint8_t)((P7 >> 3) & 0x01);
  58   1      }
  59          static void assertCoilAddress(uint16_t adr) reentrant{//检查线圈地址
  60   1      #if CONFIG_SPLC_ASSERT == 1
                      if(adr > (SPREG_END * 16))
                              while(1);
              #endif
  64   1      }
*** WARNING C280 IN LINE 59 OF MainApp\sPlc.c: 'adr': unreferenced local variable
  65          static void assertRegisterAddress(uint16_t adr) reentrant{//检查寄存器地址
  66   1      #if CONFIG_SPLC_ASSERT == 1
                      if(adr >= SPREG_END)
                              while(1);
              #endif
  70   1      }
*** WARNING C280 IN LINE 65 OF MainApp\sPlc.c: 'adr': unreferenced local variable
  71          static void clearDM(void){//清除DM寄存器
  72   1              uint16_t i;
  73   1              for(i = 0;i <= DM_END;i ++){
  74   2                      NVRAM0[i] = 0x0;
  75   2                      NVRAM1[i] = 0x0;
  76   2              }
  77   1      }
  78          static void clearMR(void){//清除MR寄存器
  79   1              uint16_t i;
  80   1              for(i = MR_START;i <= MR_END;i ++){
  81   2                      NVRAM0[i] = 0x0;
  82   2                      NVRAM1[i] = 0x0;
  83   2              }
  84   1      }
  85          static void clearEM(void){//清除EM寄存器
  86   1              uint16_t i;
  87   1              for(i = EM_START;i <= EM_END;i ++){
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 61  

  88   2                      NVRAM0[i] = 0x0;
  89   2                      NVRAM1[i] = 0x0;
  90   2              }
  91   1      }
  92          static void clearR(void){//清除R寄存器
  93   1              uint16_t i;
  94   1              for(i = R_START;i <= R_END;i ++){
  95   2                      NVRAM0[i] = 0x0;
  96   2                      NVRAM1[i] = 0x0;
  97   2              }
  98   1      }
  99          static void clearT(void){//清除T寄存器
 100   1              uint16_t i;
 101   1              for(i = T_1MS_START;i <= T_1MS_END;i ++){
 102   2                      NVRAM0[i] = 0x0;
 103   2                      NVRAM1[i] = 0x0;
 104   2              }
 105   1              for(i = T_10MS_START;i <= T_10MS_END;i ++){
 106   2                      NVRAM0[i] = 0x0;
 107   2                      NVRAM1[i] = 0x0;
 108   2              }
 109   1              for(i = T_100MS_START;i <= T_100MS_END;i ++){
 110   2                      NVRAM0[i] = 0x0;
 111   2                      NVRAM1[i] = 0x0;
 112   2              }
 113   1      }
 114          static void clearTD(void){//清除TD寄存器
 115   1              uint16_t i;
 116   1              for(i = TD_1MS_START;i <= TD_1MS_END;i ++){
 117   2                      NVRAM0[i] = 0x0;
 118   2                      NVRAM1[i] = 0x0;
 119   2              }
 120   1              for(i = TD_10MS_START;i <= TD_10MS_END;i ++){
 121   2                      NVRAM0[i] = 0x0;
 122   2                      NVRAM1[i] = 0x0;
 123   2              }
 124   1              for(i = TD_100MS_START;i <= TD_100MS_END;i ++){
 125   2                      NVRAM0[i] = 0x0;
 126   2                      NVRAM1[i] = 0x0;
 127   2              }
 128   1      }
 129          static void clearC(void){//清除C寄存器
 130   1              uint16_t i;
 131   1              for(i = C_START;i <= C_END;i ++){
 132   2                      NVRAM0[i] = 0x0;
 133   2                      NVRAM1[i] = 0x0;
 134   2              }
 135   1      }
 136          static void clearX(void){//清除X寄存器
 137   1              uint16_t i;
 138   1              for(i = X_START;i <= X_END;i ++){
 139   2                      NVRAM0[i] = 0x0;
 140   2                      NVRAM1[i] = 0x0;
 141   2              }
 142   1      }
 143          static void clearY(void){//清除Y寄存器
 144   1              uint16_t i;
 145   1              for(i = Y_START;i <= Y_END;i ++){
 146   2                      NVRAM0[i] = 0x0;
 147   2                      NVRAM1[i] = 0x0;
 148   2              }
 149   1      }
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 62  

 150          static void clearSPREG(void){//清除特殊寄存器
 151   1              uint16_t i;
 152   1              for(i = SPREG_START;i <= SPREG_END;i ++){
 153   2                      NVRAM0[i] = 0x0;
 154   2                      NVRAM1[i] = 0x0;
 155   2              }
 156   1      }
 157          static void clearSPCOIL(){//清除特特殊线圈
 158   1              uint16_t i;
 159   1              for(i = SPCOIL_START;i <= SPCOIL_END;i ++){
 160   2                      NVRAM0[i] = 0x0;
 161   2                      NVRAM1[i] = 0x0;
 162   2              }
 163   1      }
 164          static void loadNvram(void){//从EPROM中载入NVRAM
 165   1              memset(NVRAM0, 0x0, (CONFIG_NVRAM_SIZE * 2));//初始化NVRAM
 166   1              setLedEprom(DEBUG_LED_ON);
 167   1              epromRead(0, (uint8_t*)NVRAM0, (CONFIG_NVRAM_SIZE * 2));//从EPROM中恢复MR
 168   1              setLedEprom(DEBUG_LED_OFF);
 169   1              clearEM();
 170   1              clearR();
 171   1              clearT();
 172   1              clearTD();
 173   1              clearC();
 174   1              clearX();
 175   1              clearY();
 176   1              clearSPREG();
 177   1              clearSPCOIL();
 178   1              memcpy(NVRAM1, NVRAM0, (CONFIG_NVRAM_SIZE * 2));
 179   1      }
 180          static void saveNvram(void){//强制将NVRAM存入EPROM
 181   1              DISABLE_INTERRUPT;
 182   1              setLedEprom(DEBUG_LED_ON);
 183   1              epromWrite(0x0, (uint8_t*)NVRAM0, ((MR_END + 1) * 2));
 184   1              setLedEprom(DEBUG_LED_OFF);
 185   1              ENABLE_INTERRUPT;
 186   1      }
 187          static void updataNvram(void){//更新NVRAM->EPROM
 188   1              data uint8_t *sp0, *sp1;
 189   1              data uint16_t i;
 190   1              sp0 = (uint8_t*)NVRAM0;
 191   1              sp1 = (uint8_t*)NVRAM1;
 192   1              for(i = (MR_START * 2);i < ((MR_END + 1) * 2);i ++){//储存MR
 193   2                      if(*(sp0 + i) != *(sp1 + i)){
 194   3                              setLedEprom(DEBUG_LED_ON);
 195   3                              epromWriteOneByte(i, *(sp0 + i));
 196   3                              setLedEprom(DEBUG_LED_OFF);
 197   3                      }       
 198   2              }
 199   1              sp0 = (uint8_t*)NVRAM0;
 200   1              sp1 = (uint8_t*)NVRAM1;
 201   1              for(i = (DM_START * 2);i < ((DM_END + 1) * 2);i ++){//储存DM
 202   2                      if(*(sp0 + i) != *(sp1 + i)){
 203   3                              setLedEprom(DEBUG_LED_ON);
 204   3                              epromWriteOneByte(i, *(sp0 + i));
 205   3                              setLedEprom(DEBUG_LED_OFF);
 206   3                      }
 207   2              }
 208   1              memcpy((uint8_t*)NVRAM1, (uint8_t*)NVRAM0, (CONFIG_NVRAM_SIZE * 2));
 209   1      }
 210          static void clearNvram(void){//清除NVRAM数据    
 211   1              idata uint8_t oldEA;
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 63  

 212   1              idata uint16_t i;
 213   1              oldEA = EA;//关闭中断
 214   1              EA = 0;
 215   1              wdtDisable();
 216   1              for(i = 0; i<= CONFIG_EPROM_SIZE;i ++){
 217   2                      if(getLedEprom()){
 218   3                              setLedEprom(DEBUG_LED_OFF);
 219   3                      }
 220   2                      else{
 221   3                              setLedEprom(DEBUG_LED_ON);
 222   3                      }
 223   2                      epromWriteOneByte(i, 0x0);
 224   2                      
 225   2              }
 226   1              EA = oldEA;//恢复中断
 227   1      }
 228          static void selfTestNvram(void){//自检NVRAM
 229   1              
 230   1      }
 231          /*****************************************************************************/
 232          //软逻辑指令
 233          void REBOOT(void) reentrant{//软件复位
 234   1              RSTSRC |= 1 << 4;//强制复位
 235   1      }
 236          void SET(uint16_t A) reentrant{//线圈置位
 237   1              assertCoilAddress(A);//检查地址范围
 238   1              NVRAM0[(A / 16)] |= 1 << (A % 16);
 239   1      }
 240          void RES(uint16_t A) reentrant{//线圈置零
 241   1              assertCoilAddress(A);//检查地址范围
 242   1              NVRAM0[(A / 16)] &= ~(1 << (A % 16));
 243   1      }
 244          void FLIP(uint16_t A) reentrant{//翻转
 245   1              uint16_t temp;
 246   1              assertCoilAddress(A);//检查地址范围
 247   1              temp= NVRAM0[(A / 16)] & (1 << (A % 16));
 248   1              if(temp)
 249   1                      RES(A);
 250   1              else
 251   1                      SET(A);
 252   1      }
 253          uint8_t LD(uint16_t A) reentrant{//载入
 254   1              assertCoilAddress(A);//检查地址范围
 255   1              return (uint8_t)(NVRAM0[(A / 16)] >> (A % 16)) & 0x01;
 256   1      }
 257          uint8_t LDB(uint16_t A) reentrant{//方向载入
 258   1              assertCoilAddress(A);//检查地址范围
 259   1              return !((uint8_t)(NVRAM0[(A / 16)] >> (A % 16)) & 0x01);
 260   1      }
 261          uint8_t LDP(uint16_t A) reentrant{//脉冲上升沿
 262   1              uint8_t temp0, temp1;
 263   1              assertCoilAddress(A);//检查地址范围
 264   1              temp0 = (uint8_t)(NVRAM0[(A / 16)] >> (A % 16)) & 0x01;
 265   1              temp1 = (uint8_t)(NVRAM1[(A / 16)] >> (A % 16)) & 0x01;
 266   1              if(temp0 == 1 && temp1 != 1)
 267   1                      return true;
 268   1              else
 269   1                      return false;
 270   1      }
 271          uint8_t LDN(uint16_t A) reentrant{//脉冲下降沿
 272   1              uint8_t temp0, temp1;
 273   1              assertCoilAddress(A);
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 64  

 274   1              temp0 = (uint8_t)(NVRAM0[(A / 16)] >> NVRAM0[(A % 16)]);
 275   1              temp1 = (uint8_t)(NVRAM1[(A / 16)] >> NVRAM1[(A % 16)]);
 276   1              if(!temp0 && temp1)
 277   1                      return 1;
 278   1              else
 279   1                      return 0;
 280   1      }
 281          void T1MS(uint8_t A, uint8_t start, uint16_t value){//1MS延时器
 282   1      #if CONFIG_DEBUG
                      if(A > (TD_1MS_END - TD_1MS_START + 1))
                              printf("T1MS:%d Over Num\n", A);
              #endif
 286   1              if(start){
 287   2                      if(NVRAM0[(TD_1MS_START + A)] >= value){
 288   3                              NVRAM0[(T_1MS_START + (A / 16))] |= 1 << (A % 16);
 289   3                      }
 290   2                      else{
 291   3                              NVRAM0[(T_1MS_START + (A / 16))] &= ~(1 << (A % 16));
 292   3                      }
 293   2                              
 294   2              }
 295   1              else{
 296   2                      NVRAM0[(T_1MS_START + (A / 16))] &= ~(1 << (A % 16));
 297   2                      NVRAM0[(TD_1MS_START + A)] = 0x0;
 298   2              }       
 299   1      }
 300          void T10MS(uint8_t A, uint8_t start, uint16_t value){//10MS延时器
 301   1      #if CONFIG_DEBUG
                      if(A > (TD_10MS_END - TD_10MS_START + 1))
                              printf("T10MS:%d Over Num\n", A);
              #endif
 305   1              if(start){
 306   2                      if(NVRAM0[(TD_10MS_START + A)] >= value){
 307   3                              NVRAM0[(T_10MS_START + (A / 16))] |= 1 << (A % 16);
 308   3                      }
 309   2                      else{
 310   3                              NVRAM0[(T_10MS_START + (A / 16))] &= ~(1 << (A % 16));
 311   3                      }
 312   2              }
 313   1              else{
 314   2                      NVRAM0[(T_10MS_START + (A / 16))] &= ~(1 << (A % 16));
 315   2                      NVRAM0[(TD_10MS_START + A)] = 0x0;
 316   2              }       
 317   1      }
 318          void T100MS(uint8_t A, uint8_t start, uint16_t value){//100MS延时器
 319   1      #if CONFIG_DEBUG
                      if(A > (TD_100MS_END - TD_100MS_START + 1))
                              printf("T100MS:%d Over Num\n", A);
              #endif
 323   1              if(start){
 324   2                      if(NVRAM0[(TD_100MS_START + A)] >= value){
 325   3                              NVRAM0[(T_100MS_START + (A / 16))] |= 1 << (A % 16);
 326   3                      }
 327   2                      else{
 328   3                              NVRAM0[(T_100MS_START + (A / 16))] &= ~(1 << (A % 16));
 329   3                      }       
 330   2              }
 331   1              else{
 332   2                      NVRAM0[(T_100MS_START + (A / 16))] &= ~(1 << (A % 16));
 333   2                      NVRAM0[(TD_100MS_START + A)] = 0x0;
 334   2              }
 335   1      }
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 65  

 336          int16_t TNTC(int16_t dat){//CODE转换为NTC测量温度温度
 337   1              idata uint16_t temp;
 338   1              idata fp32_t ftemp;
 339   1              if(dat >= CONFIG_SPLC_ADC_INTERNAL_VREF) dat = CONFIG_SPLC_ADC_INTERNAL_VREF;//限制输入最大值
 340   1              if(dat < 0) dat = 0;
 341   1              
 342   1              temp = (int16_t)(CONFIG_SPLC_ADC_INTERNAL_VREF * dat / 4096);//单位mV
 343   1              temp = 10000 * 5000 / (5000 - temp);//电源5V 分压电阻10K
 344   1              
 345   1              ftemp = ((1.0 / 3477)*log((fp32_t)(temp) / 10000)) + (1 / (25+273.0));//limo R25=10740,B=3450    uniquemode
             - 3988
 346   1              ftemp = ( 1.0 / ftemp ) - 273.0;
 347   1              if(ftemp >= 100) ftemp = 100;
 348   1              if(ftemp <= -100) ftemp = -100;
 349   1              return (int16_t)(ftemp * 10);
 350   1      }
 351          int16_t TENV(int16_t dat){//CODE转换为环境温度
 352   1              idata uint16_t temp;
 353   1              temp = (int16_t)(CONFIG_SPLC_ADC_INTERNAL_VREF * dat / 4096);//单位mV
 354   1              temp = (int16_t)((temp - CONFIG_SPLC_ADC_TEMP_SENSOR_OFFSET) * 1000 / CONFIG_SPLC_ADC_TEMP_SENSOR_GAIN);
 355   1              return temp;
 356   1      }
 357          int16_t MAX(int16_t *s, uint8_t len){//找出长度为len的数据s中的最大值
 358   1              idata int16_t max;
 359   1              idata uint8_t i;
 360   1              max = *s;
 361   1              for(i = 0;i < len;i ++){
 362   2                      if(*(s +i) > max){
 363   3                              max = *(s + i);
 364   3                      }
 365   2              }
 366   1              return max;
 367   1      }
 368          int16_t MIN(int16_t *s, uint8_t len){//找出长度为len的数据s中的最小值
 369   1              idata int16_t min;
 370   1              idata uint8_t i;
 371   1              min = *s;
 372   1              for(i = 0;i < len;i ++){
 373   2                      if(*(s +i) < min){
 374   3                              min = *(s + i);
 375   3                      }
 376   2              }
 377   1              return min;
 378   1      }
 379          //void ADD(uint16_t idata Sa, uint16_t idata Sb, uint16_t idata D){//16位求和 D = Sa + Sb
 380          //      NVRAM0[D] = NVRAM0[Sa] + NVRAM0[Sb];
 381          //}
 382          void DADD(uint16_t Sa, uint16_t Sb, uint16_t D){//32位求和 D = Sa + Sb
 383   1              int32_t *tmp0, *tmp1, *tmp2;
 384   1              tmp0 = (int32_t*)(&NVRAM0[Sa]);
 385   1              tmp1 = (int32_t*)(&NVRAM0[Sb]);
 386   1              tmp2 = (int32_t*)(&NVRAM0[D]);
 387   1              *tmp2 = *tmp0 + *tmp1;
 388   1      }
 389          //void ADDS(uint16_t idata Sa, uint16_t idata Sb, uint16_t idata D){//16位饱和求和 D = Sa + Sb
 390          //      idata int32_t tmp;
 391          //      tmp = NVRAM0[Sa] + NVRAM0[Sb];
 392          //      if(tmp >= SHRT_MAX)
 393          //              tmp = SHRT_MAX;
 394          //      if(tmp <= SHRT_MIN)
 395          //              tmp = SHRT_MIN;
 396          //      NVRAM0[D] = tmp;
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 66  

 397          //}
 398          //void SUB(uint16_t Sa, uint16_t Sb, uint16_t D){//16位非饱和减法 D = Sa - Sb
 399          //      NVRAM0[D] = NVRAM0[Sa] - NVRAM0[Sb];
 400          //}
 401          //void SUBS(uint16_t idata Sa, uint16_t idata Sb, uint16_t idata D){//16位饱和减法 D = Sa - Sb
 402          //      idata int32_t tmp;
 403          //      tmp = NVRAM0[Sa] - NVRAM0[Sb];
 404          //      if(tmp >= SHRT_MAX)
 405          //              tmp = SHRT_MAX;
 406          //      if(tmp <= SHRT_MIN)
 407          //              tmp = SHRT_MIN;
 408          //      NVRAM0[D] = tmp;
 409          //}
 410          void DSUB(uint16_t Sa, uint16_t Sb, uint16_t D){//32位非饱和减法 D = Sa - Sb
 411   1              idata int32_t *tmp0, *tmp1, *tmp2;
 412   1              tmp0 = (int32_t*)(&NVRAM0[Sa]);
 413   1              tmp1 = (int32_t*)(&NVRAM0[Sb]);
 414   1              tmp2 = (int32_t*)(&NVRAM0[D]);
 415   1              *tmp2 = *tmp0 - *tmp1;
 416   1      }
 417          /*****************************************************************************/
 418          static void wdtInit(void){//看门狗初始化
 419   1              WDTCN = 0x07;//47mS
 420   1      }
 421          void wdtEnable(void) reentrant{//使能看门狗
 422   1      #ifdef C8051F020
 423   1              WDTCN = 0xA5;
 424   1      #endif
 425   1      }
 426          void wdtDisable(void) reentrant{//关闭看门狗(未锁定)
 427   1              uint8_t flagEA;
 428   1              flagEA = EA;
 429   1              EA = 0;
 430   1              WDTCN = 0xDE;
 431   1          WDTCN = 0xAD;
 432   1              EA = flagEA;
 433   1      }
 434          void wdtFeed(void) reentrant{//喂狗
 435   1              WDTCN = 0xA5;
 436   1      }
 437          static void pcaInit(void){//硬件PCA初始化
 438   1      }
 439          static void timer0Init(void){//硬件sTimer计时器初始化
 440   1              idata uint16_t temp;
 441   1              TimerCounter_1mS = 0;
 442   1              TimerCounter_10mS = 0;
 443   1              TimerCounter_100mS = 0;
 444   1              temp = (uint16_t)(65536 - (CONFIG_SYSCLK / 12 /CONFIG_SOFTPLC_HWTIME));
 445   1              Timer0_L = temp & 0xFF;
 446   1              Timer0_H = (temp >> 8) & 0xFF;
 447   1              TH0 = Timer0_H;// Init T0 High register
 448   1              TL0 = Timer0_L;// Init T0 Low register
 449   1              CKCON &= ~(1 << 3);//SYSCLK / 12        
 450   1              TMOD &= 0xF0;
 451   1              TMOD |= (1 << 0);// T0 in 16-bit mode
 452   1              ET0 = 1;// T0 interrupt enabled
 453   1              TR0 = 1;// T0 ON
 454   1      }
 455          static void timer0Isr(void) interrupt INTERRUPT_TIMER0{//硬件sTimer计时器中断 1mS
 456   1              idata uint16_t i;
 457   1              idata uint32_t tmp;
 458   1              TF0 = 0;
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 67  

 459   1              TR0 = 0;
 460   1              TH0 = Timer0_H;
 461   1              TL0 = Timer0_L;
 462   1              TR0 = 1;
 463   1              if(LD(SPCOIL_PS1MS)){//ON
 464   2                      RES(SPCOIL_PS1MS);
 465   2              }
 466   1              else{//OFF
 467   2                      SET(SPCOIL_PS1MS);
 468   2              }
 469   1              for(i = TD_1MS_START;i <= TD_1MS_END;i ++){//1mS计时
 470   2                      if(NVRAM0[i] < SHRT_MAX){
 471   3                              NVRAM0[i] ++;
 472   3                      }
 473   2              }
 474   1              if(TimerCounter_1mS >= 10){//10mS计算
 475   2                      if(LD(SPCOIL_PS10MS)){//ON
 476   3                              RES(SPCOIL_PS10MS);
 477   3                      }
 478   2                      else{//OFF
 479   3                              SET(SPCOIL_PS10MS);
 480   3                      }
 481   2                      for(i = TD_10MS_START;i <= TD_10MS_END;i ++){
 482   3                              if(NVRAM0[i] < SHRT_MAX){
 483   4                                      NVRAM0[i] ++;
 484   4                              }
 485   3                      }
 486   2                      TimerCounter_10mS ++;
 487   2                      TimerCounter_1mS = 0;
 488   2              }
 489   1              if(TimerCounter_10mS >= 10){//100ms计算
 490   2                      if(LD(SPCOIL_PS100MS)){//ON
 491   3                              RES(SPCOIL_PS100MS);
 492   3                      }
 493   2                      else{//OFF
 494   3                              SET(SPCOIL_PS100MS);
 495   3                      }
 496   2                      for(i = TD_100MS_START;i < TD_100MS_END;i ++){
 497   3                              if(NVRAM0[i] < SHRT_MAX){
 498   4                                      NVRAM0[i] ++;
 499   4                              }
 500   3                      }
 501   2                      TimerCounter_100mS ++;
 502   2                      TimerCounter_10mS = 0;
 503   2                      setLedRun(LD(SPCOIL_PS100MS));
 504   2              }
 505   1              if(TimerCounter_100mS >= 10){//1000mS计算
 506   2                      if(LD(SPCOIL_PS1000MS)){//ON
 507   3                              RES(SPCOIL_PS1000MS);
 508   3                      }
 509   2                      else{
 510   3                              SET(SPCOIL_PS1000MS);
 511   3                      }
 512   2                      tmp = 0;
 513   2                      tmp = NVRAM0[SPREG_RUNTIME_L] + (uint32_t)(NVRAM0[SPREG_RUNTIME_H]) * 65536L;
 514   2                      tmp += 1;
 515   2                      NVRAM0[SPREG_RUNTIME_H] = (tmp >> 16) & 0xFFFF;
 516   2                      NVRAM0[SPREG_RUNTIME_L] = tmp & 0xFFFF;
 517   2                      TimerCounter_100mS = 0;
 518   2              }
 519   1      #if CONFIG_SPLC_USING_CADC == 1
 520   1              chipAdcProcess();//ADC扫描
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 68  

 521   1      #endif
 522   1              TimerCounter_1mS ++;
 523   1      }
 524          static void inputInit(void){//IO输入滤波器初始化
 525   1              memset(inputFilter, 0x0, (X_END - X_START + 1) * 16);
 526   1      }
 527          static void outputInit(void){//IO输出初始化
 528   1      #ifdef C8051F020
 529   1              
 530   1      #endif
 531   1      }
 532          static void inputRefresh(void){//获取输入IO
 533   1              idata uint8_t ctemp0;
 534   1              ctemp0 = ((P6 >> 7) & 0x01);
 535   1              if(ctemp0){
 536   2                      if(inputFilter[0] < CONFIG_INPUT_FILTER_TIME){
 537   3                              inputFilter[0] ++;
 538   3                      }
 539   2                      else{
 540   3                              NVRAM0[X_START] |= (int16_t)(1 << 0);
 541   3                      }
 542   2              }
 543   1              else{
 544   2                      if(inputFilter[0] > (CONFIG_INPUT_FILTER_TIME * -1)){
 545   3                              inputFilter[0] --;
 546   3                      }
 547   2                      else{
 548   3                              NVRAM0[X_START] &= ~(uint16_t)(1 << 0);
 549   3                      }
 550   2              }
 551   1              ctemp0 = ((P6 >> 6) & 0x01);
 552   1              if(ctemp0){
 553   2                      if(inputFilter[1] < CONFIG_INPUT_FILTER_TIME){
 554   3                              inputFilter[1] ++;
 555   3                      }
 556   2                      else{
 557   3                              NVRAM0[X_START] |= (int16_t)(1 << 1);
 558   3                      }
 559   2              }
 560   1              else{
 561   2                      if(inputFilter[1] > (CONFIG_INPUT_FILTER_TIME * -1)){
 562   3                              inputFilter[1] --;
 563   3                      }
 564   2                      else{
 565   3                              NVRAM0[X_START] &= ~(uint16_t)(1 << 1);
 566   3                      }
 567   2              }
 568   1      }
 569          static void outputRefresh(void){//设置输出IO
 570   1              if((NVRAM0[Y_START] >> 0) & 0x01){//P6_5
 571   2                      P6 |= (uint8_t)(1 << 5);
 572   2              }
 573   1              else{
 574   2                      P6 &= ~(uint8_t)(1 << 5);
 575   2              }
 576   1              if((NVRAM0[Y_START] >> 1) & 0x01){//P6_4
 577   2                      P6 |= (uint8_t)(1 << 4);
 578   2              }
 579   1              else{
 580   2                      P6 &= ~(uint8_t)(1 << 4);
 581   2              }
 582   1      }
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 69  

 583          void sPlcInit(void){//软逻辑初始化
 584   1              setLedError(DEBUG_LED_OFF);
 585   1              setLedRun(DEBUG_LED_OFF);
 586   1              setLedDac(DEBUG_LED_OFF);
 587   1              setLedEprom(DEBUG_LED_OFF);
 588   1              wdtInit();//看门狗使能
 589   1              wdtDisable();//屏蔽看门狗
 590   1      #if CONFIG_SPLC_USING_UART1 == 1
 591   1              initUart1(CONFIG_UART1_BAUDRATE);//UART1初始化
 592   1      #endif  
 593   1      #if CONFIG_SPLC_USING_EPROM == 1
 594   1              loadNvram();//上电恢复NVRAM
 595   1      #endif
 596   1      #if CONFIG_SPLC_USING_CADC == 1
 597   1              initChipAdc();//初始化ADC模块
 598   1      #endif
 599   1      #if CONFIG_SPLC_USING_DAC == 1
 600   1              initChipDac();//初始化DAC模块
 601   1      #endif
 602   1      #if CONFIG_SPLC_USING_MB_RTU_SLAVE == 1
 603   1              initModbus(CONFIG_MB_RTU_SLAVE_ADDRESS, CONFIG_UART0_BAUDRATE);
 604   1      #endif
 605   1              timer0Init();//初始化硬件计时器模块
 606   1              SET(SPCOIL_ON);
 607   1              setLedError(DEBUG_LED_OFF);
 608   1              SET(SPCOIL_ON);
 609   1              SET(SPCOIL_START_UP);
 610   1              NVRAM0[EM_END] = CONFIG_SPLC_DEV;
 611   1      }
 612          void sPlcProcessStart(void){//sPLC轮询起始
 613   1      #if CONFIG_SPLC_USING_CLEAR_NVRAM == 1
 614   1              if(NVRAM0[SPREG_CLEAR_NVRAM0] == CONFIG_SPLC_CLEAR_CODE){
 615   2                      DISABLE_INTERRUPT;//关闭中断
 616   2                      setLedRun(DEBUG_LED_ON);//
 617   2                      setLedEprom(DEBUG_LED_ON);
 618   2                      if(epromTest()){//EPROM测试成功
 619   3                              setLedEprom(DEBUG_LED_OFF);
 620   3                              setLedError(DEBUG_LED_ON);
 621   3                              delayMs(500);
 622   3                              setLedError(DEBUG_LED_OFF);
 623   3                      }
 624   2                      else{//EPROM测试失败
 625   3                              setLedEprom(DEBUG_LED_OFF);
 626   3                              setLedError(DEBUG_LED_ON);
 627   3                              delayMs(500);
 628   3                              setLedError(DEBUG_LED_OFF);
 629   3                              delayMs(500);
 630   3                              setLedError(DEBUG_LED_ON);
 631   3                              delayMs(500);
 632   3                              setLedError(DEBUG_LED_OFF);
 633   3                              delayMs(500);
 634   3                              setLedError(DEBUG_LED_ON);
 635   3                              delayMs(500);
 636   3                              setLedError(DEBUG_LED_OFF);     
 637   3                      }
 638   2                      clearNvram();
 639   2                      REBOOT();       
 640   2              }
 641   1      #endif
 642   1      #if CONFIG_SPLC_USING_WDT == 1
 643   1              wdtFeed();//喂狗
 644   1      #endif
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 70  

 645   1      #if CONFIG_SPLC_USING_MB_RTU_SLAVE == 1
 646   1              modbusPorcess();//处理MODBUS
 647   1      #endif
 648   1      #if CONFIG_SPLC_USING_IO_INPUT == 1
 649   1              inputRefresh();//读取X口输入
 650   1      #endif
 651   1      #if CONFIG_SPLC_USING_WDT == 1
 652   1              wdtFeed();
 653   1      #endif
 654   1      }
 655          void sPlcProcessEnd(void){//sPLC轮询结束
 656   1      #if CONFIG_SPLC_USING_WDT == 1
 657   1              wdtFeed();//喂狗
 658   1      #endif
 659   1      #if CONFIG_SPLC_USING_IO_OUTPUT == 1
 660   1              outputRefresh();//更新Y口输出
 661   1      #endif
 662   1      #if CONFIG_SPLC_USING_DAC
 663   1              refreshDac();//更新DAC输出
 664   1      #endif
 665   1      #if CONFIG_SPLC_USING_EPROM == 1
 666   1              updataNvram();//更新NVRAM
 667   1      #endif
 668   1      #if CONFIG_SPLC_USING_WDT == 1
 669   1              wdtFeed();//喂狗
 670   1      #endif
 671   1              RES(SPCOIL_START_UP);
 672   1      }
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 71  

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION getGlobalInterrupt (BEGIN)
                                           ; SOURCE LINE # 12
                                           ; SOURCE LINE # 13
0000 A2AF              MOV     C,EA
0002 E4                CLR     A
0003 33                RLC     A
0004 FF                MOV     R7,A
                                           ; SOURCE LINE # 14
0005 22                RET     
             ; FUNCTION getGlobalInterrupt (END)

             ; FUNCTION _setLedRun (BEGIN)
                                           ; SOURCE LINE # 15
;---- Variable 'st' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 16
0000 EF                MOV     A,R7
0001 6004              JZ      ?C0002
                                           ; SOURCE LINE # 17
0003 439601            ORL     P7,#01H
                                           ; SOURCE LINE # 18
0006 22                RET     
0007         ?C0002:
                                           ; SOURCE LINE # 19
                                           ; SOURCE LINE # 20
0007 5396FE            ANL     P7,#0FEH
                                           ; SOURCE LINE # 21
                                           ; SOURCE LINE # 22
000A         ?C0004:
000A 22                RET     
             ; FUNCTION _setLedRun (END)

             ; FUNCTION getLedRun (BEGIN)
                                           ; SOURCE LINE # 23
                                           ; SOURCE LINE # 24
0000 E596              MOV     A,P7
0002 5401              ANL     A,#01H
0004 FF                MOV     R7,A
                                           ; SOURCE LINE # 25
0005 22                RET     
             ; FUNCTION getLedRun (END)

             ; FUNCTION _setLedEprom (BEGIN)
                                           ; SOURCE LINE # 26
;---- Variable 'st' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 27
0000 EF                MOV     A,R7
0001 6004              JZ      ?C0006
                                           ; SOURCE LINE # 28
0003 439602            ORL     P7,#02H
                                           ; SOURCE LINE # 29
0006 22                RET     
0007         ?C0006:
                                           ; SOURCE LINE # 30
                                           ; SOURCE LINE # 31
0007 5396FD            ANL     P7,#0FDH
                                           ; SOURCE LINE # 32
                                           ; SOURCE LINE # 33
000A         ?C0008:
000A 22                RET     
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 72  

             ; FUNCTION _setLedEprom (END)

             ; FUNCTION getLedEprom (BEGIN)
                                           ; SOURCE LINE # 34
                                           ; SOURCE LINE # 35
0000 E596              MOV     A,P7
0002 C3                CLR     C
0003 13                RRC     A
0004 5401              ANL     A,#01H
0006 FF                MOV     R7,A
                                           ; SOURCE LINE # 36
0007 22                RET     
             ; FUNCTION getLedEprom (END)

             ; FUNCTION _setLedDac (BEGIN)
                                           ; SOURCE LINE # 37
;---- Variable 'st' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 38
0000 EF                MOV     A,R7
0001 6004              JZ      ?C0010
                                           ; SOURCE LINE # 39
0003 439604            ORL     P7,#04H
                                           ; SOURCE LINE # 40
0006 22                RET     
0007         ?C0010:
                                           ; SOURCE LINE # 41
                                           ; SOURCE LINE # 42
0007 5396FB            ANL     P7,#0FBH
                                           ; SOURCE LINE # 43
                                           ; SOURCE LINE # 44
000A         ?C0012:
000A 22                RET     
             ; FUNCTION _setLedDac (END)

             ; FUNCTION getLedDac (BEGIN)
                                           ; SOURCE LINE # 45
                                           ; SOURCE LINE # 46
0000 E596              MOV     A,P7
0002 13                RRC     A
0003 13                RRC     A
0004 5401              ANL     A,#01H
0006 FF                MOV     R7,A
                                           ; SOURCE LINE # 47
0007 22                RET     
             ; FUNCTION getLedDac (END)

             ; FUNCTION _setLedError (BEGIN)
                                           ; SOURCE LINE # 48
;---- Variable 'st' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 49
0000 EF                MOV     A,R7
0001 6004              JZ      ?C0014
                                           ; SOURCE LINE # 50
0003 439608            ORL     P7,#08H
                                           ; SOURCE LINE # 51
0006 22                RET     
0007         ?C0014:
                                           ; SOURCE LINE # 52
                                           ; SOURCE LINE # 53
0007 5396F7            ANL     P7,#0F7H
                                           ; SOURCE LINE # 54
                                           ; SOURCE LINE # 55
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 73  

000A         ?C0016:
000A 22                RET     
             ; FUNCTION _setLedError (END)

             ; FUNCTION getLedError (BEGIN)
                                           ; SOURCE LINE # 56
                                           ; SOURCE LINE # 57
0000 E596              MOV     A,P7
0002 13                RRC     A
0003 13                RRC     A
0004 13                RRC     A
0005 5401              ANL     A,#01H
0007 FF                MOV     R7,A
                                           ; SOURCE LINE # 58
0008 22                RET     
             ; FUNCTION getLedError (END)

             ; FUNCTION L?0262 (BEGIN)
0000         L?0263:
0000 1500        E     DEC     ?C_IBP
0002 1500        E     DEC     ?C_IBP
0004 A800        E     MOV     R0,?C_IBP
0006 A606              MOV     @R0,AR6
0008 08                INC     R0
0009 A607              MOV     @R0,AR7
000B A800        E     MOV     R0,?C_IBP
000D         L?0264:
000D E6                MOV     A,@R0
000E FE                MOV     R6,A
000F 08                INC     R0
0010 E6                MOV     A,@R0
0011 FF                MOV     R7,A
             ; FUNCTION _?assertCoilAddress (BEGIN)
                                           ; SOURCE LINE # 59
0012 1500        E     DEC     ?C_IBP
0014 1500        E     DEC     ?C_IBP
0016 A800        E     MOV     R0,?C_IBP
0018 A606              MOV     @R0,AR6
001A 08                INC     R0
001B A607              MOV     @R0,AR7
                                           ; SOURCE LINE # 64
001D 0500        E     INC     ?C_IBP
001F 0500        E     INC     ?C_IBP
0021 22                RET     
             ; FUNCTION _?assertCoilAddress (END)

             ; FUNCTION _?assertRegisterAddress (BEGIN)
                                           ; SOURCE LINE # 65
0000 1500        E     DEC     ?C_IBP
0002 1500        E     DEC     ?C_IBP
0004 A800        E     MOV     R0,?C_IBP
0006 A606              MOV     @R0,AR6
0008 08                INC     R0
0009 A607              MOV     @R0,AR7
                                           ; SOURCE LINE # 70
000B 0500        E     INC     ?C_IBP
000D 0500        E     INC     ?C_IBP
000F 22                RET     
             ; FUNCTION _?assertRegisterAddress (END)

             ; FUNCTION clearDM (BEGIN)
                                           ; SOURCE LINE # 71
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 74  

                                           ; SOURCE LINE # 73
;---- Variable 'i' assigned to Register 'R4/R5' ----
0000 E4                CLR     A
0001 FD                MOV     R5,A
0002 FC                MOV     R4,A
0003         ?C0020:
                                           ; SOURCE LINE # 74
0003 ED                MOV     A,R5
0004 25E0              ADD     A,ACC
0006 FF                MOV     R7,A
0007 EC                MOV     A,R4
0008 33                RLC     A
0009 FE                MOV     R6,A
000A 7400        R     MOV     A,#LOW NVRAM0
000C 2F                ADD     A,R7
000D F582              MOV     DPL,A
000F 7400        R     MOV     A,#HIGH NVRAM0
0011 3E                ADDC    A,R6
0012 F583              MOV     DPH,A
0014 E4                CLR     A
0015 F0                MOVX    @DPTR,A
0016 A3                INC     DPTR
0017 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 75
0018 7400        R     MOV     A,#LOW NVRAM1
001A 2F                ADD     A,R7
001B F582              MOV     DPL,A
001D 7400        R     MOV     A,#HIGH NVRAM1
001F 3E                ADDC    A,R6
0020 F583              MOV     DPH,A
0022 E4                CLR     A
0023 F0                MOVX    @DPTR,A
0024 A3                INC     DPTR
0025 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 76
0026 0D                INC     R5
0027 BD0001            CJNE    R5,#00H,?C0199
002A 0C                INC     R4
002B         ?C0199:
002B ED                MOV     A,R5
002C 6414              XRL     A,#014H
002E 4C                ORL     A,R4
002F 70D2              JNZ     ?C0020
                                           ; SOURCE LINE # 77
0031         ?C0023:
0031 22                RET     
             ; FUNCTION clearDM (END)

             ; FUNCTION clearMR (BEGIN)
                                           ; SOURCE LINE # 78
                                           ; SOURCE LINE # 80
;---- Variable 'i' assigned to Register 'R4/R5' ----
0000 E4                CLR     A
0001 FD                MOV     R5,A
0002 FC                MOV     R4,A
0003         ?C0024:
                                           ; SOURCE LINE # 81
0003 ED                MOV     A,R5
0004 25E0              ADD     A,ACC
0006 FF                MOV     R7,A
0007 EC                MOV     A,R4
0008 33                RLC     A
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 75  

0009 FE                MOV     R6,A
000A 7400        R     MOV     A,#LOW NVRAM0
000C 2F                ADD     A,R7
000D F582              MOV     DPL,A
000F 7400        R     MOV     A,#HIGH NVRAM0
0011 3E                ADDC    A,R6
0012 F583              MOV     DPH,A
0014 E4                CLR     A
0015 F0                MOVX    @DPTR,A
0016 A3                INC     DPTR
0017 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 82
0018 7400        R     MOV     A,#LOW NVRAM1
001A 2F                ADD     A,R7
001B F582              MOV     DPL,A
001D 7400        R     MOV     A,#HIGH NVRAM1
001F 3E                ADDC    A,R6
0020 F583              MOV     DPH,A
0022 E4                CLR     A
0023 F0                MOVX    @DPTR,A
0024 A3                INC     DPTR
0025 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 83
0026 0D                INC     R5
0027 BD0001            CJNE    R5,#00H,?C0200
002A 0C                INC     R4
002B         ?C0200:
002B ED                MOV     A,R5
002C 6404              XRL     A,#04H
002E 4C                ORL     A,R4
002F 70D2              JNZ     ?C0024
                                           ; SOURCE LINE # 84
0031         ?C0027:
0031 22                RET     
             ; FUNCTION clearMR (END)

             ; FUNCTION clearEM (BEGIN)
                                           ; SOURCE LINE # 85
                                           ; SOURCE LINE # 87
;---- Variable 'i' assigned to Register 'R4/R5' ----
0000 7D14              MOV     R5,#014H
0002 7C00              MOV     R4,#00H
0004         ?C0028:
                                           ; SOURCE LINE # 88
0004 ED                MOV     A,R5
0005 25E0              ADD     A,ACC
0007 FF                MOV     R7,A
0008 EC                MOV     A,R4
0009 33                RLC     A
000A FE                MOV     R6,A
000B 7400        R     MOV     A,#LOW NVRAM0
000D 2F                ADD     A,R7
000E F582              MOV     DPL,A
0010 7400        R     MOV     A,#HIGH NVRAM0
0012 3E                ADDC    A,R6
0013 F583              MOV     DPH,A
0015 E4                CLR     A
0016 F0                MOVX    @DPTR,A
0017 A3                INC     DPTR
0018 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 89
0019 7400        R     MOV     A,#LOW NVRAM1
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 76  

001B 2F                ADD     A,R7
001C F582              MOV     DPL,A
001E 7400        R     MOV     A,#HIGH NVRAM1
0020 3E                ADDC    A,R6
0021 F583              MOV     DPH,A
0023 E4                CLR     A
0024 F0                MOVX    @DPTR,A
0025 A3                INC     DPTR
0026 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 90
0027 0D                INC     R5
0028 BD0001            CJNE    R5,#00H,?C0201
002B 0C                INC     R4
002C         ?C0201:
002C ED                MOV     A,R5
002D 64A0              XRL     A,#0A0H
002F 4C                ORL     A,R4
0030 70D2              JNZ     ?C0028
                                           ; SOURCE LINE # 91
0032         ?C0031:
0032 22                RET     
             ; FUNCTION clearEM (END)

             ; FUNCTION clearR (BEGIN)
                                           ; SOURCE LINE # 92
                                           ; SOURCE LINE # 94
;---- Variable 'i' assigned to Register 'R4/R5' ----
0000 7D04              MOV     R5,#04H
0002 7C00              MOV     R4,#00H
0004         ?C0032:
                                           ; SOURCE LINE # 95
0004 ED                MOV     A,R5
0005 25E0              ADD     A,ACC
0007 FF                MOV     R7,A
0008 EC                MOV     A,R4
0009 33                RLC     A
000A FE                MOV     R6,A
000B 7400        R     MOV     A,#LOW NVRAM0
000D 2F                ADD     A,R7
000E F582              MOV     DPL,A
0010 7400        R     MOV     A,#HIGH NVRAM0
0012 3E                ADDC    A,R6
0013 F583              MOV     DPH,A
0015 E4                CLR     A
0016 F0                MOVX    @DPTR,A
0017 A3                INC     DPTR
0018 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 96
0019 7400        R     MOV     A,#LOW NVRAM1
001B 2F                ADD     A,R7
001C F582              MOV     DPL,A
001E 7400        R     MOV     A,#HIGH NVRAM1
0020 3E                ADDC    A,R6
0021 F583              MOV     DPH,A
0023 E4                CLR     A
0024 F0                MOVX    @DPTR,A
0025 A3                INC     DPTR
0026 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 97
0027 0D                INC     R5
0028 BD0001            CJNE    R5,#00H,?C0202
002B 0C                INC     R4
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 77  

002C         ?C0202:
002C ED                MOV     A,R5
002D 640C              XRL     A,#0CH
002F 4C                ORL     A,R4
0030 70D2              JNZ     ?C0032
                                           ; SOURCE LINE # 98
0032         ?C0035:
0032 22                RET     
             ; FUNCTION clearR (END)

             ; FUNCTION clearT (BEGIN)
                                           ; SOURCE LINE # 99
                                           ; SOURCE LINE # 101
;---- Variable 'i' assigned to Register 'R4/R5' ----
0000 7DA0              MOV     R5,#0A0H
0002 7C00              MOV     R4,#00H
0004         ?C0036:
                                           ; SOURCE LINE # 102
0004 ED                MOV     A,R5
0005 25E0              ADD     A,ACC
0007 FF                MOV     R7,A
0008 EC                MOV     A,R4
0009 33                RLC     A
000A FE                MOV     R6,A
000B 7400        R     MOV     A,#LOW NVRAM0
000D 2F                ADD     A,R7
000E F582              MOV     DPL,A
0010 7400        R     MOV     A,#HIGH NVRAM0
0012 3E                ADDC    A,R6
0013 F583              MOV     DPH,A
0015 E4                CLR     A
0016 F0                MOVX    @DPTR,A
0017 A3                INC     DPTR
0018 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 103
0019 7400        R     MOV     A,#LOW NVRAM1
001B 2F                ADD     A,R7
001C F582              MOV     DPL,A
001E 7400        R     MOV     A,#HIGH NVRAM1
0020 3E                ADDC    A,R6
0021 F583              MOV     DPH,A
0023 E4                CLR     A
0024 F0                MOVX    @DPTR,A
0025 A3                INC     DPTR
0026 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 104
0027 0D                INC     R5
0028 BD0001            CJNE    R5,#00H,?C0203
002B 0C                INC     R4
002C         ?C0203:
002C ED                MOV     A,R5
002D 64A1              XRL     A,#0A1H
002F 4C                ORL     A,R4
0030 70D2              JNZ     ?C0036
0032         ?C0037:
                                           ; SOURCE LINE # 105
0032 7C00              MOV     R4,#00H
0034 7DA1              MOV     R5,#0A1H
0036         ?C0039:
                                           ; SOURCE LINE # 106
0036 ED                MOV     A,R5
0037 25E0              ADD     A,ACC
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 78  

0039 FF                MOV     R7,A
003A EC                MOV     A,R4
003B 33                RLC     A
003C FE                MOV     R6,A
003D 7400        R     MOV     A,#LOW NVRAM0
003F 2F                ADD     A,R7
0040 F582              MOV     DPL,A
0042 7400        R     MOV     A,#HIGH NVRAM0
0044 3E                ADDC    A,R6
0045 F583              MOV     DPH,A
0047 E4                CLR     A
0048 F0                MOVX    @DPTR,A
0049 A3                INC     DPTR
004A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 107
004B 7400        R     MOV     A,#LOW NVRAM1
004D 2F                ADD     A,R7
004E F582              MOV     DPL,A
0050 7400        R     MOV     A,#HIGH NVRAM1
0052 3E                ADDC    A,R6
0053 F583              MOV     DPH,A
0055 E4                CLR     A
0056 F0                MOVX    @DPTR,A
0057 A3                INC     DPTR
0058 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 108
0059 0D                INC     R5
005A BD0001            CJNE    R5,#00H,?C0204
005D 0C                INC     R4
005E         ?C0204:
005E ED                MOV     A,R5
005F 64A2              XRL     A,#0A2H
0061 4C                ORL     A,R4
0062 70D2              JNZ     ?C0039
0064         ?C0040:
                                           ; SOURCE LINE # 109
0064 7C00              MOV     R4,#00H
0066 7DA2              MOV     R5,#0A2H
0068         ?C0042:
                                           ; SOURCE LINE # 110
0068 ED                MOV     A,R5
0069 25E0              ADD     A,ACC
006B FF                MOV     R7,A
006C EC                MOV     A,R4
006D 33                RLC     A
006E FE                MOV     R6,A
006F 7400        R     MOV     A,#LOW NVRAM0
0071 2F                ADD     A,R7
0072 F582              MOV     DPL,A
0074 7400        R     MOV     A,#HIGH NVRAM0
0076 3E                ADDC    A,R6
0077 F583              MOV     DPH,A
0079 E4                CLR     A
007A F0                MOVX    @DPTR,A
007B A3                INC     DPTR
007C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 111
007D 7400        R     MOV     A,#LOW NVRAM1
007F 2F                ADD     A,R7
0080 F582              MOV     DPL,A
0082 7400        R     MOV     A,#HIGH NVRAM1
0084 3E                ADDC    A,R6
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 79  

0085 F583              MOV     DPH,A
0087 E4                CLR     A
0088 F0                MOVX    @DPTR,A
0089 A3                INC     DPTR
008A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 112
008B 0D                INC     R5
008C BD0001            CJNE    R5,#00H,?C0205
008F 0C                INC     R4
0090         ?C0205:
0090 ED                MOV     A,R5
0091 64A3              XRL     A,#0A3H
0093 4C                ORL     A,R4
0094 70D2              JNZ     ?C0042
                                           ; SOURCE LINE # 113
0096         ?C0045:
0096 22                RET     
             ; FUNCTION clearT (END)

             ; FUNCTION clearTD (BEGIN)
                                           ; SOURCE LINE # 114
                                           ; SOURCE LINE # 116
;---- Variable 'i' assigned to Register 'R4/R5' ----
0000 7DA3              MOV     R5,#0A3H
0002 7C00              MOV     R4,#00H
0004         ?C0046:
                                           ; SOURCE LINE # 117
0004 ED                MOV     A,R5
0005 25E0              ADD     A,ACC
0007 FF                MOV     R7,A
0008 EC                MOV     A,R4
0009 33                RLC     A
000A FE                MOV     R6,A
000B 7400        R     MOV     A,#LOW NVRAM0
000D 2F                ADD     A,R7
000E F582              MOV     DPL,A
0010 7400        R     MOV     A,#HIGH NVRAM0
0012 3E                ADDC    A,R6
0013 F583              MOV     DPH,A
0015 E4                CLR     A
0016 F0                MOVX    @DPTR,A
0017 A3                INC     DPTR
0018 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 118
0019 7400        R     MOV     A,#LOW NVRAM1
001B 2F                ADD     A,R7
001C F582              MOV     DPL,A
001E 7400        R     MOV     A,#HIGH NVRAM1
0020 3E                ADDC    A,R6
0021 F583              MOV     DPH,A
0023 E4                CLR     A
0024 F0                MOVX    @DPTR,A
0025 A3                INC     DPTR
0026 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 119
0027 0D                INC     R5
0028 BD0001            CJNE    R5,#00H,?C0206
002B 0C                INC     R4
002C         ?C0206:
002C ED                MOV     A,R5
002D 64B3              XRL     A,#0B3H
002F 4C                ORL     A,R4
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 80  

0030 70D2              JNZ     ?C0046
0032         ?C0047:
                                           ; SOURCE LINE # 120
0032 7C00              MOV     R4,#00H
0034 7DB3              MOV     R5,#0B3H
0036         ?C0049:
                                           ; SOURCE LINE # 121
0036 ED                MOV     A,R5
0037 25E0              ADD     A,ACC
0039 FF                MOV     R7,A
003A EC                MOV     A,R4
003B 33                RLC     A
003C FE                MOV     R6,A
003D 7400        R     MOV     A,#LOW NVRAM0
003F 2F                ADD     A,R7
0040 F582              MOV     DPL,A
0042 7400        R     MOV     A,#HIGH NVRAM0
0044 3E                ADDC    A,R6
0045 F583              MOV     DPH,A
0047 E4                CLR     A
0048 F0                MOVX    @DPTR,A
0049 A3                INC     DPTR
004A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 122
004B 7400        R     MOV     A,#LOW NVRAM1
004D 2F                ADD     A,R7
004E F582              MOV     DPL,A
0050 7400        R     MOV     A,#HIGH NVRAM1
0052 3E                ADDC    A,R6
0053 F583              MOV     DPH,A
0055 E4                CLR     A
0056 F0                MOVX    @DPTR,A
0057 A3                INC     DPTR
0058 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 123
0059 0D                INC     R5
005A BD0001            CJNE    R5,#00H,?C0207
005D 0C                INC     R4
005E         ?C0207:
005E ED                MOV     A,R5
005F 64C3              XRL     A,#0C3H
0061 4C                ORL     A,R4
0062 70D2              JNZ     ?C0049
0064         ?C0050:
                                           ; SOURCE LINE # 124
0064 7C00              MOV     R4,#00H
0066 7DC3              MOV     R5,#0C3H
0068         ?C0052:
                                           ; SOURCE LINE # 125
0068 ED                MOV     A,R5
0069 25E0              ADD     A,ACC
006B FF                MOV     R7,A
006C EC                MOV     A,R4
006D 33                RLC     A
006E FE                MOV     R6,A
006F 7400        R     MOV     A,#LOW NVRAM0
0071 2F                ADD     A,R7
0072 F582              MOV     DPL,A
0074 7400        R     MOV     A,#HIGH NVRAM0
0076 3E                ADDC    A,R6
0077 F583              MOV     DPH,A
0079 E4                CLR     A
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 81  

007A F0                MOVX    @DPTR,A
007B A3                INC     DPTR
007C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 126
007D 7400        R     MOV     A,#LOW NVRAM1
007F 2F                ADD     A,R7
0080 F582              MOV     DPL,A
0082 7400        R     MOV     A,#HIGH NVRAM1
0084 3E                ADDC    A,R6
0085 F583              MOV     DPH,A
0087 E4                CLR     A
0088 F0                MOVX    @DPTR,A
0089 A3                INC     DPTR
008A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 127
008B 0D                INC     R5
008C BD0001            CJNE    R5,#00H,?C0208
008F 0C                INC     R4
0090         ?C0208:
0090 ED                MOV     A,R5
0091 64D3              XRL     A,#0D3H
0093 4C                ORL     A,R4
0094 70D2              JNZ     ?C0052
                                           ; SOURCE LINE # 128
0096         ?C0055:
0096 22                RET     
             ; FUNCTION clearTD (END)

             ; FUNCTION clearC (BEGIN)
                                           ; SOURCE LINE # 129
                                           ; SOURCE LINE # 131
;---- Variable 'i' assigned to Register 'R4/R5' ----
0000 7DD3              MOV     R5,#0D3H
0002 7C00              MOV     R4,#00H
0004         ?C0056:
                                           ; SOURCE LINE # 132
0004 ED                MOV     A,R5
0005 25E0              ADD     A,ACC
0007 FF                MOV     R7,A
0008 EC                MOV     A,R4
0009 33                RLC     A
000A FE                MOV     R6,A
000B 7400        R     MOV     A,#LOW NVRAM0
000D 2F                ADD     A,R7
000E F582              MOV     DPL,A
0010 7400        R     MOV     A,#HIGH NVRAM0
0012 3E                ADDC    A,R6
0013 F583              MOV     DPH,A
0015 E4                CLR     A
0016 F0                MOVX    @DPTR,A
0017 A3                INC     DPTR
0018 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 133
0019 7400        R     MOV     A,#LOW NVRAM1
001B 2F                ADD     A,R7
001C F582              MOV     DPL,A
001E 7400        R     MOV     A,#HIGH NVRAM1
0020 3E                ADDC    A,R6
0021 F583              MOV     DPH,A
0023 E4                CLR     A
0024 F0                MOVX    @DPTR,A
0025 A3                INC     DPTR
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 82  

0026 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 134
0027 0D                INC     R5
0028 BD0001            CJNE    R5,#00H,?C0209
002B 0C                INC     R4
002C         ?C0209:
002C ED                MOV     A,R5
002D 64D4              XRL     A,#0D4H
002F 4C                ORL     A,R4
0030 70D2              JNZ     ?C0056
                                           ; SOURCE LINE # 135
0032         ?C0059:
0032 22                RET     
             ; FUNCTION clearC (END)

             ; FUNCTION clearX (BEGIN)
                                           ; SOURCE LINE # 136
                                           ; SOURCE LINE # 138
;---- Variable 'i' assigned to Register 'R4/R5' ----
0000 7DD4              MOV     R5,#0D4H
0002 7C00              MOV     R4,#00H
0004         ?C0060:
                                           ; SOURCE LINE # 139
0004 ED                MOV     A,R5
0005 25E0              ADD     A,ACC
0007 FF                MOV     R7,A
0008 EC                MOV     A,R4
0009 33                RLC     A
000A FE                MOV     R6,A
000B 7400        R     MOV     A,#LOW NVRAM0
000D 2F                ADD     A,R7
000E F582              MOV     DPL,A
0010 7400        R     MOV     A,#HIGH NVRAM0
0012 3E                ADDC    A,R6
0013 F583              MOV     DPH,A
0015 E4                CLR     A
0016 F0                MOVX    @DPTR,A
0017 A3                INC     DPTR
0018 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 140
0019 7400        R     MOV     A,#LOW NVRAM1
001B 2F                ADD     A,R7
001C F582              MOV     DPL,A
001E 7400        R     MOV     A,#HIGH NVRAM1
0020 3E                ADDC    A,R6
0021 F583              MOV     DPH,A
0023 E4                CLR     A
0024 F0                MOVX    @DPTR,A
0025 A3                INC     DPTR
0026 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 141
0027 0D                INC     R5
0028 BD0001            CJNE    R5,#00H,?C0210
002B 0C                INC     R4
002C         ?C0210:
002C ED                MOV     A,R5
002D 64D5              XRL     A,#0D5H
002F 4C                ORL     A,R4
0030 70D2              JNZ     ?C0060
                                           ; SOURCE LINE # 142
0032         ?C0063:
0032 22                RET     
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 83  

             ; FUNCTION clearX (END)

             ; FUNCTION clearY (BEGIN)
                                           ; SOURCE LINE # 143
                                           ; SOURCE LINE # 145
;---- Variable 'i' assigned to Register 'R4/R5' ----
0000 7DD5              MOV     R5,#0D5H
0002 7C00              MOV     R4,#00H
0004         ?C0064:
                                           ; SOURCE LINE # 146
0004 ED                MOV     A,R5
0005 25E0              ADD     A,ACC
0007 FF                MOV     R7,A
0008 EC                MOV     A,R4
0009 33                RLC     A
000A FE                MOV     R6,A
000B 7400        R     MOV     A,#LOW NVRAM0
000D 2F                ADD     A,R7
000E F582              MOV     DPL,A
0010 7400        R     MOV     A,#HIGH NVRAM0
0012 3E                ADDC    A,R6
0013 F583              MOV     DPH,A
0015 E4                CLR     A
0016 F0                MOVX    @DPTR,A
0017 A3                INC     DPTR
0018 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 147
0019 7400        R     MOV     A,#LOW NVRAM1
001B 2F                ADD     A,R7
001C F582              MOV     DPL,A
001E 7400        R     MOV     A,#HIGH NVRAM1
0020 3E                ADDC    A,R6
0021 F583              MOV     DPH,A
0023 E4                CLR     A
0024 F0                MOVX    @DPTR,A
0025 A3                INC     DPTR
0026 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 148
0027 0D                INC     R5
0028 BD0001            CJNE    R5,#00H,?C0211
002B 0C                INC     R4
002C         ?C0211:
002C ED                MOV     A,R5
002D 64D6              XRL     A,#0D6H
002F 4C                ORL     A,R4
0030 70D2              JNZ     ?C0064
                                           ; SOURCE LINE # 149
0032         ?C0067:
0032 22                RET     
             ; FUNCTION clearY (END)

             ; FUNCTION clearSPREG (BEGIN)
                                           ; SOURCE LINE # 150
                                           ; SOURCE LINE # 152
;---- Variable 'i' assigned to Register 'R4/R5' ----
0000 7DD6              MOV     R5,#0D6H
0002 7C00              MOV     R4,#00H
0004         ?C0068:
                                           ; SOURCE LINE # 153
0004 ED                MOV     A,R5
0005 25E0              ADD     A,ACC
0007 FF                MOV     R7,A
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 84  

0008 EC                MOV     A,R4
0009 33                RLC     A
000A FE                MOV     R6,A
000B 7400        R     MOV     A,#LOW NVRAM0
000D 2F                ADD     A,R7
000E F582              MOV     DPL,A
0010 7400        R     MOV     A,#HIGH NVRAM0
0012 3E                ADDC    A,R6
0013 F583              MOV     DPH,A
0015 E4                CLR     A
0016 F0                MOVX    @DPTR,A
0017 A3                INC     DPTR
0018 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 154
0019 7400        R     MOV     A,#LOW NVRAM1
001B 2F                ADD     A,R7
001C F582              MOV     DPL,A
001E 7400        R     MOV     A,#HIGH NVRAM1
0020 3E                ADDC    A,R6
0021 F583              MOV     DPH,A
0023 E4                CLR     A
0024 F0                MOVX    @DPTR,A
0025 A3                INC     DPTR
0026 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 155
0027 0D                INC     R5
0028 BD0001            CJNE    R5,#00H,?C0212
002B 0C                INC     R4
002C         ?C0212:
002C ED                MOV     A,R5
002D 64EE              XRL     A,#0EEH
002F 4C                ORL     A,R4
0030 70D2              JNZ     ?C0068
                                           ; SOURCE LINE # 156
0032         ?C0071:
0032 22                RET     
             ; FUNCTION clearSPREG (END)

             ; FUNCTION clearSPCOIL (BEGIN)
                                           ; SOURCE LINE # 157
                                           ; SOURCE LINE # 159
;---- Variable 'i' assigned to Register 'R4/R5' ----
0000 7DEE              MOV     R5,#0EEH
0002 7C00              MOV     R4,#00H
0004         ?C0072:
                                           ; SOURCE LINE # 160
0004 ED                MOV     A,R5
0005 25E0              ADD     A,ACC
0007 FF                MOV     R7,A
0008 EC                MOV     A,R4
0009 33                RLC     A
000A FE                MOV     R6,A
000B 7400        R     MOV     A,#LOW NVRAM0
000D 2F                ADD     A,R7
000E F582              MOV     DPL,A
0010 7400        R     MOV     A,#HIGH NVRAM0
0012 3E                ADDC    A,R6
0013 F583              MOV     DPH,A
0015 E4                CLR     A
0016 F0                MOVX    @DPTR,A
0017 A3                INC     DPTR
0018 F0                MOVX    @DPTR,A
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 85  

                                           ; SOURCE LINE # 161
0019 7400        R     MOV     A,#LOW NVRAM1
001B 2F                ADD     A,R7
001C F582              MOV     DPL,A
001E 7400        R     MOV     A,#HIGH NVRAM1
0020 3E                ADDC    A,R6
0021 F583              MOV     DPH,A
0023 E4                CLR     A
0024 F0                MOVX    @DPTR,A
0025 A3                INC     DPTR
0026 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 162
0027 0D                INC     R5
0028 BD0001            CJNE    R5,#00H,?C0213
002B 0C                INC     R4
002C         ?C0213:
002C ED                MOV     A,R5
002D 64F2              XRL     A,#0F2H
002F 4C                ORL     A,R4
0030 70D2              JNZ     ?C0072
                                           ; SOURCE LINE # 163
0032         ?C0075:
0032 22                RET     
             ; FUNCTION clearSPCOIL (END)

             ; FUNCTION loadNvram (BEGIN)
                                           ; SOURCE LINE # 164
                                           ; SOURCE LINE # 165
0000 7E01              MOV     R6,#01H
0002 7FE4              MOV     R7,#0E4H
0004 7D00              MOV     R5,#00H
0006 7B01              MOV     R3,#01H
0008 7A00        R     MOV     R2,#HIGH NVRAM0
000A 7900        R     MOV     R1,#LOW NVRAM0
000C 120000      E     LCALL   ?C?MEMSET
                                           ; SOURCE LINE # 166
000F E4                CLR     A
0010 FF                MOV     R7,A
0011 120000      R     LCALL   _setLedEprom
                                           ; SOURCE LINE # 167
0014 7B01              MOV     R3,#01H
0016 7A00        R     MOV     R2,#HIGH NVRAM0
0018 7900        R     MOV     R1,#LOW NVRAM0
001A 750001      E     MOV     ?_epromRead?BYTE+05H,#01H
001D 7500E4      E     MOV     ?_epromRead?BYTE+06H,#0E4H
0020 E4                CLR     A
0021 FE                MOV     R6,A
0022 120000      E     LCALL   _epromRead
                                           ; SOURCE LINE # 168
0025 7F01              MOV     R7,#01H
0027 120000      R     LCALL   _setLedEprom
                                           ; SOURCE LINE # 169
002A 120000      R     LCALL   clearEM
                                           ; SOURCE LINE # 170
002D 120000      R     LCALL   clearR
                                           ; SOURCE LINE # 171
0030 120000      R     LCALL   clearT
                                           ; SOURCE LINE # 172
0033 120000      R     LCALL   clearTD
                                           ; SOURCE LINE # 173
0036 120000      R     LCALL   clearC
                                           ; SOURCE LINE # 174
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 86  

0039 120000      R     LCALL   clearX
                                           ; SOURCE LINE # 175
003C 120000      R     LCALL   clearY
                                           ; SOURCE LINE # 176
003F 120000      R     LCALL   clearSPREG
                                           ; SOURCE LINE # 177
0042 120000      R     LCALL   clearSPCOIL
                                           ; SOURCE LINE # 178
0045 7800        R     MOV     R0,#LOW NVRAM1
0047 7C00        R     MOV     R4,#HIGH NVRAM1
0049 7D01              MOV     R5,#01H
004B 7B01              MOV     R3,#01H
004D 7A00        R     MOV     R2,#HIGH NVRAM0
004F 7900        R     MOV     R1,#LOW NVRAM0
0051 7E01              MOV     R6,#01H
0053 7FE4              MOV     R7,#0E4H
0055 020000      E     LJMP    ?C?COPY
             ; FUNCTION loadNvram (END)

             ; FUNCTION saveNvram (BEGIN)
                                           ; SOURCE LINE # 180
                                           ; SOURCE LINE # 181
0000 C2AF              CLR     EA
                                           ; SOURCE LINE # 182
0002 E4                CLR     A
0003 FF                MOV     R7,A
0004 120000      R     LCALL   _setLedEprom
                                           ; SOURCE LINE # 183
0007 7B01              MOV     R3,#01H
0009 7A00        R     MOV     R2,#HIGH NVRAM0
000B 7900        R     MOV     R1,#LOW NVRAM0
000D 750000      E     MOV     ?_epromWrite?BYTE+05H,#00H
0010 750008      E     MOV     ?_epromWrite?BYTE+06H,#08H
0013 E4                CLR     A
0014 FE                MOV     R6,A
0015 120000      E     LCALL   _epromWrite
                                           ; SOURCE LINE # 184
0018 7F01              MOV     R7,#01H
001A 120000      R     LCALL   _setLedEprom
                                           ; SOURCE LINE # 185
001D D2AF              SETB    EA
                                           ; SOURCE LINE # 186
001F 22                RET     
             ; FUNCTION saveNvram (END)

             ; FUNCTION updataNvram (BEGIN)
                                           ; SOURCE LINE # 187
                                           ; SOURCE LINE # 190
0000 750001      R     MOV     sp0,#01H
0003 750000      R     MOV     sp0+01H,#HIGH NVRAM0
0006 750000      R     MOV     sp0+02H,#LOW NVRAM0
                                           ; SOURCE LINE # 191
0009 750001      R     MOV     sp1,#01H
000C 750000      R     MOV     sp1+01H,#HIGH NVRAM1
000F 750000      R     MOV     sp1+02H,#LOW NVRAM1
                                           ; SOURCE LINE # 192
0012 E4                CLR     A
0013 F500        R     MOV     i,A
0015 F500        R     MOV     i+01H,A
0017         ?C0078:
                                           ; SOURCE LINE # 193
0017 AB00        R     MOV     R3,sp1
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 87  

0019 AA00        R     MOV     R2,sp1+01H
001B A900        R     MOV     R1,sp1+02H
001D 850082      R     MOV     DPL,i+01H
0020 850083      R     MOV     DPH,i
0023 120000      E     LCALL   ?C?CLDOPTR
0026 FF                MOV     R7,A
0027 AB00        R     MOV     R3,sp0
0029 AA00        R     MOV     R2,sp0+01H
002B A900        R     MOV     R1,sp0+02H
002D 850082      R     MOV     DPL,i+01H
0030 850083      R     MOV     DPH,i
0033 120000      E     LCALL   ?C?CLDOPTR
0036 6F                XRL     A,R7
0037 6021              JZ      ?C0080
                                           ; SOURCE LINE # 194
0039 E4                CLR     A
003A FF                MOV     R7,A
003B 120000      R     LCALL   _setLedEprom
                                           ; SOURCE LINE # 195
003E AB00        R     MOV     R3,sp0
0040 AA00        R     MOV     R2,sp0+01H
0042 A900        R     MOV     R1,sp0+02H
0044 850082      R     MOV     DPL,i+01H
0047 850083      R     MOV     DPH,i
004A 120000      E     LCALL   ?C?CLDOPTR
004D FD                MOV     R5,A
004E AF00        R     MOV     R7,i+01H
0050 AE00        R     MOV     R6,i
0052 120000      E     LCALL   _epromWriteOneByte
                                           ; SOURCE LINE # 196
0055 7F01              MOV     R7,#01H
0057 120000      R     LCALL   _setLedEprom
                                           ; SOURCE LINE # 197
                                           ; SOURCE LINE # 198
005A         ?C0080:
005A 0500        R     INC     i+01H
005C E500        R     MOV     A,i+01H
005E 7002              JNZ     ?C0214
0060 0500        R     INC     i
0062         ?C0214:
0062 C3                CLR     C
0063 9408              SUBB    A,#08H
0065 E500        R     MOV     A,i
0067 9400              SUBB    A,#00H
0069 40AC              JC      ?C0078
006B         ?C0079:
                                           ; SOURCE LINE # 199
006B 750001      R     MOV     sp0,#01H
006E 750000      R     MOV     sp0+01H,#HIGH NVRAM0
0071 750000      R     MOV     sp0+02H,#LOW NVRAM0
                                           ; SOURCE LINE # 200
0074 750001      R     MOV     sp1,#01H
0077 750000      R     MOV     sp1+01H,#HIGH NVRAM1
007A 750000      R     MOV     sp1+02H,#LOW NVRAM1
                                           ; SOURCE LINE # 201
007D 750000      R     MOV     i,#00H
0080 750018      R     MOV     i+01H,#018H
0083         ?C0082:
                                           ; SOURCE LINE # 202
0083 AB00        R     MOV     R3,sp1
0085 AA00        R     MOV     R2,sp1+01H
0087 A900        R     MOV     R1,sp1+02H
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 88  

0089 850082      R     MOV     DPL,i+01H
008C 850083      R     MOV     DPH,i
008F 120000      E     LCALL   ?C?CLDOPTR
0092 FF                MOV     R7,A
0093 AB00        R     MOV     R3,sp0
0095 AA00        R     MOV     R2,sp0+01H
0097 A900        R     MOV     R1,sp0+02H
0099 850082      R     MOV     DPL,i+01H
009C 850083      R     MOV     DPH,i
009F 120000      E     LCALL   ?C?CLDOPTR
00A2 6F                XRL     A,R7
00A3 6021              JZ      ?C0084
                                           ; SOURCE LINE # 203
00A5 E4                CLR     A
00A6 FF                MOV     R7,A
00A7 120000      R     LCALL   _setLedEprom
                                           ; SOURCE LINE # 204
00AA AB00        R     MOV     R3,sp0
00AC AA00        R     MOV     R2,sp0+01H
00AE A900        R     MOV     R1,sp0+02H
00B0 850082      R     MOV     DPL,i+01H
00B3 850083      R     MOV     DPH,i
00B6 120000      E     LCALL   ?C?CLDOPTR
00B9 FD                MOV     R5,A
00BA AF00        R     MOV     R7,i+01H
00BC AE00        R     MOV     R6,i
00BE 120000      E     LCALL   _epromWriteOneByte
                                           ; SOURCE LINE # 205
00C1 7F01              MOV     R7,#01H
00C3 120000      R     LCALL   _setLedEprom
                                           ; SOURCE LINE # 206
                                           ; SOURCE LINE # 207
00C6         ?C0084:
00C6 0500        R     INC     i+01H
00C8 E500        R     MOV     A,i+01H
00CA 7002              JNZ     ?C0215
00CC 0500        R     INC     i
00CE         ?C0215:
00CE C3                CLR     C
00CF 9428              SUBB    A,#028H
00D1 E500        R     MOV     A,i
00D3 9400              SUBB    A,#00H
00D5 40AC              JC      ?C0082
00D7         ?C0083:
                                           ; SOURCE LINE # 208
00D7 7800        R     MOV     R0,#LOW NVRAM1
00D9 7C00        R     MOV     R4,#HIGH NVRAM1
00DB 7D01              MOV     R5,#01H
00DD 7B01              MOV     R3,#01H
00DF 7A00        R     MOV     R2,#HIGH NVRAM0
00E1 7900        R     MOV     R1,#LOW NVRAM0
00E3 7E01              MOV     R6,#01H
00E5 7FE4              MOV     R7,#0E4H
00E7 020000      E     LJMP    ?C?COPY
             ; FUNCTION updataNvram (END)

             ; FUNCTION clearNvram (BEGIN)
                                           ; SOURCE LINE # 210
                                           ; SOURCE LINE # 213
0000 A2AF              MOV     C,EA
0002 E4                CLR     A
0003 33                RLC     A
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 89  

0004 7800        R     MOV     R0,#LOW oldEA
0006 F6                MOV     @R0,A
                                           ; SOURCE LINE # 214
0007 C2AF              CLR     EA
                                           ; SOURCE LINE # 215
0009 120000      R     LCALL   _?wdtDisable
                                           ; SOURCE LINE # 216
000C E4                CLR     A
000D 7800        R     MOV     R0,#LOW i
000F F6                MOV     @R0,A
0010 08                INC     R0
0011 F6                MOV     @R0,A
0012         ?C0087:
                                           ; SOURCE LINE # 217
0012 120000      R     LCALL   getLedEprom
0015 EF                MOV     A,R7
0016 6004              JZ      ?C0090
                                           ; SOURCE LINE # 218
0018 7F01              MOV     R7,#01H
                                           ; SOURCE LINE # 219
001A 8002              SJMP    ?C0257
001C         ?C0090:
                                           ; SOURCE LINE # 220
                                           ; SOURCE LINE # 221
001C E4                CLR     A
001D FF                MOV     R7,A
001E         ?C0257:
001E 120000      R     LCALL   _setLedEprom
                                           ; SOURCE LINE # 222
0021         ?C0091:
                                           ; SOURCE LINE # 223
0021 7800        R     MOV     R0,#LOW i
0023 E6                MOV     A,@R0
0024 FE                MOV     R6,A
0025 08                INC     R0
0026 E6                MOV     A,@R0
0027 FF                MOV     R7,A
0028 E4                CLR     A
0029 FD                MOV     R5,A
002A 120000      E     LCALL   _epromWriteOneByte
                                           ; SOURCE LINE # 225
002D 7800        R     MOV     R0,#LOW i+01H
002F 06                INC     @R0
0030 E6                MOV     A,@R0
0031 18                DEC     R0
0032 7001              JNZ     ?C0216
0034 06                INC     @R0
0035         ?C0216:
0035 D3                SETB    C
0036 7800        R     MOV     R0,#LOW i+01H
0038 E6                MOV     A,@R0
0039 9400              SUBB    A,#00H
003B 18                DEC     R0
003C E6                MOV     A,@R0
003D 9420              SUBB    A,#020H
003F 40D1              JC      ?C0087
0041         ?C0088:
                                           ; SOURCE LINE # 226
0041 7800        R     MOV     R0,#LOW oldEA
0043 E6                MOV     A,@R0
0044 24FF              ADD     A,#0FFH
0046 92AF              MOV     EA,C
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 90  

                                           ; SOURCE LINE # 227
0048 22                RET     
             ; FUNCTION clearNvram (END)

             ; FUNCTION selfTestNvram (BEGIN)
                                           ; SOURCE LINE # 228
                                           ; SOURCE LINE # 230
0000 22                RET     
             ; FUNCTION selfTestNvram (END)

             ; FUNCTION _?REBOOT (BEGIN)
                                           ; SOURCE LINE # 233
                                           ; SOURCE LINE # 234
0000 43EF10            ORL     RSTSRC,#010H
                                           ; SOURCE LINE # 235
0003 22                RET     
             ; FUNCTION _?REBOOT (END)

             ; FUNCTION _?SET (BEGIN)
                                           ; SOURCE LINE # 236
                                           ; SOURCE LINE # 237
0000 120000      R     LCALL   L?0262
                                           ; SOURCE LINE # 238
0003 A900        E     MOV     R1,?C_IBP
0005 E7                MOV     A,@R1
0006 C4                SWAP    A
0007 F8                MOV     R0,A
0008 54F0              ANL     A,#0F0H
000A C8                XCH     A,R0
000B 68                XRL     A,R0
000C FE                MOV     R6,A
000D 09                INC     R1
000E E7                MOV     A,@R1
000F C4                SWAP    A
0010 540F              ANL     A,#0FH
0012 48                ORL     A,R0
0013 25E0              ADD     A,ACC
0015 FF                MOV     R7,A
0016 EE                MOV     A,R6
0017 33                RLC     A
0018 FE                MOV     R6,A
0019 7400        R     MOV     A,#LOW NVRAM0
001B 2F                ADD     A,R7
001C F582              MOV     DPL,A
001E 7400        R     MOV     A,#HIGH NVRAM0
0020 3E                ADDC    A,R6
0021 F583              MOV     DPH,A
0023 C083              PUSH    DPH
0025 C082              PUSH    DPL
0027 E0                MOVX    A,@DPTR
0028 FC                MOV     R4,A
0029 A3                INC     DPTR
002A E0                MOVX    A,@DPTR
002B FD                MOV     R5,A
002C A800        E     MOV     R0,?C_IBP
002E 08                INC     R0
002F E6                MOV     A,@R0
0030 540F              ANL     A,#0FH
0032 FF                MOV     R7,A
0033 7E00              MOV     R6,#00H
0035 7401              MOV     A,#01H
0037 A807              MOV     R0,AR7
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 91  

0039 08                INC     R0
003A 8005              SJMP    ?C0218
003C         ?C0217:
003C C3                CLR     C
003D 33                RLC     A
003E CE                XCH     A,R6
003F 33                RLC     A
0040 CE                XCH     A,R6
0041         ?C0218:
0041 D8F9              DJNZ    R0,?C0217
0043 FF                MOV     R7,A
0044 EC                MOV     A,R4
0045 4E                ORL     A,R6
0046 FE                MOV     R6,A
0047 ED                MOV     A,R5
0048 4F                ORL     A,R7
0049 FF                MOV     R7,A
004A D082              POP     DPL
004C D083              POP     DPH
004E EE                MOV     A,R6
004F F0                MOVX    @DPTR,A
0050 A3                INC     DPTR
0051 EF                MOV     A,R7
0052 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 239
0053 0500        E     INC     ?C_IBP
0055 0500        E     INC     ?C_IBP
0057 22                RET     
             ; FUNCTION _?SET (END)

             ; FUNCTION _?RES (BEGIN)
                                           ; SOURCE LINE # 240
                                           ; SOURCE LINE # 241
0000 120000      R     LCALL   L?0262
                                           ; SOURCE LINE # 242
0003 A900        E     MOV     R1,?C_IBP
0005 E7                MOV     A,@R1
0006 C4                SWAP    A
0007 F8                MOV     R0,A
0008 54F0              ANL     A,#0F0H
000A C8                XCH     A,R0
000B 68                XRL     A,R0
000C FE                MOV     R6,A
000D 09                INC     R1
000E E7                MOV     A,@R1
000F C4                SWAP    A
0010 540F              ANL     A,#0FH
0012 48                ORL     A,R0
0013 25E0              ADD     A,ACC
0015 FF                MOV     R7,A
0016 EE                MOV     A,R6
0017 33                RLC     A
0018 FE                MOV     R6,A
0019 7400        R     MOV     A,#LOW NVRAM0
001B 2F                ADD     A,R7
001C F582              MOV     DPL,A
001E 7400        R     MOV     A,#HIGH NVRAM0
0020 3E                ADDC    A,R6
0021 F583              MOV     DPH,A
0023 C083              PUSH    DPH
0025 C082              PUSH    DPL
0027 E0                MOVX    A,@DPTR
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 92  

0028 FC                MOV     R4,A
0029 A3                INC     DPTR
002A E0                MOVX    A,@DPTR
002B FD                MOV     R5,A
002C A800        E     MOV     R0,?C_IBP
002E 08                INC     R0
002F E6                MOV     A,@R0
0030 540F              ANL     A,#0FH
0032 FF                MOV     R7,A
0033 7E00              MOV     R6,#00H
0035 7401              MOV     A,#01H
0037 A807              MOV     R0,AR7
0039 08                INC     R0
003A 8005              SJMP    ?C0220
003C         ?C0219:
003C C3                CLR     C
003D 33                RLC     A
003E CE                XCH     A,R6
003F 33                RLC     A
0040 CE                XCH     A,R6
0041         ?C0220:
0041 D8F9              DJNZ    R0,?C0219
0043 F4                CPL     A
0044 FF                MOV     R7,A
0045 EE                MOV     A,R6
0046 F4                CPL     A
0047 5C                ANL     A,R4
0048 FE                MOV     R6,A
0049 ED                MOV     A,R5
004A 5F                ANL     A,R7
004B FF                MOV     R7,A
004C D082              POP     DPL
004E D083              POP     DPH
0050 EE                MOV     A,R6
0051 F0                MOVX    @DPTR,A
0052 A3                INC     DPTR
0053 EF                MOV     A,R7
0054 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 243
0055 0500        E     INC     ?C_IBP
0057 0500        E     INC     ?C_IBP
0059 22                RET     
             ; FUNCTION _?RES (END)

             ; FUNCTION _?FLIP (BEGIN)
                                           ; SOURCE LINE # 244
0000 1500        E     DEC     ?C_IBP
0002 1500        E     DEC     ?C_IBP
0004 A800        E     MOV     R0,?C_IBP
0006 A606              MOV     @R0,AR6
0008 08                INC     R0
0009 A607              MOV     @R0,AR7
000B 1500        E     DEC     ?C_IBP
000D 1500        E     DEC     ?C_IBP
                                           ; SOURCE LINE # 246
000F A800        E     MOV     R0,?C_IBP
0011 08                INC     R0
0012 08                INC     R0
0013 120000      R     LCALL   L?0264
                                           ; SOURCE LINE # 247
0016 A800        E     MOV     R0,?C_IBP
0018 08                INC     R0
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 93  

0019 08                INC     R0
001A E6                MOV     A,@R0
001B FC                MOV     R4,A
001C 08                INC     R0
001D E6                MOV     A,@R0
001E FD                MOV     R5,A
001F EC                MOV     A,R4
0020 C4                SWAP    A
0021 F8                MOV     R0,A
0022 54F0              ANL     A,#0F0H
0024 C8                XCH     A,R0
0025 68                XRL     A,R0
0026 FE                MOV     R6,A
0027 ED                MOV     A,R5
0028 C4                SWAP    A
0029 540F              ANL     A,#0FH
002B 48                ORL     A,R0
002C 25E0              ADD     A,ACC
002E FF                MOV     R7,A
002F EE                MOV     A,R6
0030 33                RLC     A
0031 FE                MOV     R6,A
0032 7400        R     MOV     A,#LOW NVRAM0
0034 2F                ADD     A,R7
0035 F582              MOV     DPL,A
0037 7400        R     MOV     A,#HIGH NVRAM0
0039 3E                ADDC    A,R6
003A F583              MOV     DPH,A
003C E0                MOVX    A,@DPTR
003D FA                MOV     R2,A
003E A3                INC     DPTR
003F E0                MOVX    A,@DPTR
0040 FB                MOV     R3,A
0041 ED                MOV     A,R5
0042 540F              ANL     A,#0FH
0044 FF                MOV     R7,A
0045 7E00              MOV     R6,#00H
0047 7401              MOV     A,#01H
0049 A807              MOV     R0,AR7
004B 08                INC     R0
004C 8005              SJMP    ?C0222
004E         ?C0221:
004E C3                CLR     C
004F 33                RLC     A
0050 CE                XCH     A,R6
0051 33                RLC     A
0052 CE                XCH     A,R6
0053         ?C0222:
0053 D8F9              DJNZ    R0,?C0221
0055 FF                MOV     R7,A
0056 EA                MOV     A,R2
0057 5E                ANL     A,R6
0058 FE                MOV     R6,A
0059 EB                MOV     A,R3
005A 5F                ANL     A,R7
005B A800        E     MOV     R0,?C_IBP
005D A606              MOV     @R0,AR6
005F 08                INC     R0
0060 F6                MOV     @R0,A
                                           ; SOURCE LINE # 248
0061 A900        E     MOV     R1,?C_IBP
0063 09                INC     R1
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 94  

0064 E7                MOV     A,@R1
0065 19                DEC     R1
0066 47                ORL     A,@R1
0067 A800        E     MOV     R0,?C_IBP
0069 08                INC     R0
006A 08                INC     R0
006B 600A              JZ      ?C0097
                                           ; SOURCE LINE # 249
006D E6                MOV     A,@R0
006E FE                MOV     R6,A
006F 08                INC     R0
0070 E6                MOV     A,@R0
0071 FF                MOV     R7,A
0072 120000      R     LCALL   _?RES
0075 8008              SJMP    ?C0099
0077         ?C0097:
                                           ; SOURCE LINE # 251
0077 E6                MOV     A,@R0
0078 FE                MOV     R6,A
0079 08                INC     R0
007A E6                MOV     A,@R0
007B FF                MOV     R7,A
007C 120000      R     LCALL   _?SET
                                           ; SOURCE LINE # 252
007F         ?C0099:
007F E500        E     MOV     A,?C_IBP
0081 2404              ADD     A,#04H
0083 F500        E     MOV     ?C_IBP,A
0085 22                RET     
             ; FUNCTION _?FLIP (END)

             ; FUNCTION _?LD (BEGIN)
                                           ; SOURCE LINE # 253
                                           ; SOURCE LINE # 254
0000 120000      R     LCALL   L?0263
                                           ; SOURCE LINE # 255
0003 A800        E     MOV     R0,?C_IBP
0005 E6                MOV     A,@R0
0006 FC                MOV     R4,A
0007 08                INC     R0
0008 E6                MOV     A,@R0
0009 FD                MOV     R5,A
000A EC                MOV     A,R4
000B C4                SWAP    A
000C F8                MOV     R0,A
000D 54F0              ANL     A,#0F0H
000F C8                XCH     A,R0
0010 68                XRL     A,R0
0011 FE                MOV     R6,A
0012 ED                MOV     A,R5
0013 C4                SWAP    A
0014 540F              ANL     A,#0FH
0016 48                ORL     A,R0
0017 25E0              ADD     A,ACC
0019 FF                MOV     R7,A
001A EE                MOV     A,R6
001B 33                RLC     A
001C FE                MOV     R6,A
001D 7400        R     MOV     A,#LOW NVRAM0
001F 2F                ADD     A,R7
0020 F582              MOV     DPL,A
0022 7400        R     MOV     A,#HIGH NVRAM0
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 95  

0024 3E                ADDC    A,R6
0025 F583              MOV     DPH,A
0027 E0                MOVX    A,@DPTR
0028 FE                MOV     R6,A
0029 A3                INC     DPTR
002A E0                MOVX    A,@DPTR
002B FF                MOV     R7,A
002C ED                MOV     A,R5
002D 540F              ANL     A,#0FH
002F FD                MOV     R5,A
0030 EF                MOV     A,R7
0031 A805              MOV     R0,AR5
0033 08                INC     R0
0034 8006              SJMP    ?C0224
0036         ?C0223:
0036 CE                XCH     A,R6
0037 A2E7              MOV     C,ACC.7
0039 13                RRC     A
003A CE                XCH     A,R6
003B 13                RRC     A
003C         ?C0224:
003C D8F8              DJNZ    R0,?C0223
003E 5401              ANL     A,#01H
0040 FF                MOV     R7,A
                                           ; SOURCE LINE # 256
0041 0500        E     INC     ?C_IBP
0043 0500        E     INC     ?C_IBP
0045 22                RET     
             ; FUNCTION _?LD (END)

             ; FUNCTION _?LDB (BEGIN)
                                           ; SOURCE LINE # 257
                                           ; SOURCE LINE # 258
0000 120000      R     LCALL   L?0263
                                           ; SOURCE LINE # 259
0003 A800        E     MOV     R0,?C_IBP
0005 E6                MOV     A,@R0
0006 FC                MOV     R4,A
0007 08                INC     R0
0008 E6                MOV     A,@R0
0009 FD                MOV     R5,A
000A EC                MOV     A,R4
000B C4                SWAP    A
000C F8                MOV     R0,A
000D 54F0              ANL     A,#0F0H
000F C8                XCH     A,R0
0010 68                XRL     A,R0
0011 FE                MOV     R6,A
0012 ED                MOV     A,R5
0013 C4                SWAP    A
0014 540F              ANL     A,#0FH
0016 48                ORL     A,R0
0017 25E0              ADD     A,ACC
0019 FF                MOV     R7,A
001A EE                MOV     A,R6
001B 33                RLC     A
001C FE                MOV     R6,A
001D 7400        R     MOV     A,#LOW NVRAM0
001F 2F                ADD     A,R7
0020 F582              MOV     DPL,A
0022 7400        R     MOV     A,#HIGH NVRAM0
0024 3E                ADDC    A,R6
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 96  

0025 F583              MOV     DPH,A
0027 E0                MOVX    A,@DPTR
0028 FE                MOV     R6,A
0029 A3                INC     DPTR
002A E0                MOVX    A,@DPTR
002B FF                MOV     R7,A
002C ED                MOV     A,R5
002D 540F              ANL     A,#0FH
002F FD                MOV     R5,A
0030 EF                MOV     A,R7
0031 A805              MOV     R0,AR5
0033 08                INC     R0
0034 8006              SJMP    ?C0226
0036         ?C0225:
0036 CE                XCH     A,R6
0037 A2E7              MOV     C,ACC.7
0039 13                RRC     A
003A CE                XCH     A,R6
003B 13                RRC     A
003C         ?C0226:
003C D8F8              DJNZ    R0,?C0225
003E 20E004            JB      ACC.0,?C0101
0041 7F01              MOV     R7,#01H
0043 8002              SJMP    ?C0102
0045         ?C0101:
0045 7F00              MOV     R7,#00H
0047         ?C0102:
                                           ; SOURCE LINE # 260
0047 0500        E     INC     ?C_IBP
0049 0500        E     INC     ?C_IBP
004B 22                RET     
             ; FUNCTION _?LDB (END)

             ; FUNCTION _?LDP (BEGIN)
                                           ; SOURCE LINE # 261
0000 1500        E     DEC     ?C_IBP
0002 1500        E     DEC     ?C_IBP
0004 A800        E     MOV     R0,?C_IBP
0006 A606              MOV     @R0,AR6
0008 08                INC     R0
0009 A607              MOV     @R0,AR7
000B 1500        E     DEC     ?C_IBP
000D 1500        E     DEC     ?C_IBP
                                           ; SOURCE LINE # 263
000F A800        E     MOV     R0,?C_IBP
0011 08                INC     R0
0012 08                INC     R0
0013 120000      R     LCALL   L?0264
                                           ; SOURCE LINE # 264
0016 A800        E     MOV     R0,?C_IBP
0018 08                INC     R0
0019 08                INC     R0
001A E6                MOV     A,@R0
001B FC                MOV     R4,A
001C 08                INC     R0
001D E6                MOV     A,@R0
001E FD                MOV     R5,A
001F EC                MOV     A,R4
0020 C4                SWAP    A
0021 F8                MOV     R0,A
0022 54F0              ANL     A,#0F0H
0024 C8                XCH     A,R0
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 97  

0025 68                XRL     A,R0
0026 FE                MOV     R6,A
0027 ED                MOV     A,R5
0028 C4                SWAP    A
0029 540F              ANL     A,#0FH
002B 48                ORL     A,R0
002C 25E0              ADD     A,ACC
002E FB                MOV     R3,A
002F EE                MOV     A,R6
0030 33                RLC     A
0031 FA                MOV     R2,A
0032 7400        R     MOV     A,#LOW NVRAM0
0034 2B                ADD     A,R3
0035 F582              MOV     DPL,A
0037 7400        R     MOV     A,#HIGH NVRAM0
0039 3A                ADDC    A,R2
003A F583              MOV     DPH,A
003C E0                MOVX    A,@DPTR
003D FE                MOV     R6,A
003E A3                INC     DPTR
003F E0                MOVX    A,@DPTR
0040 FF                MOV     R7,A
0041 ED                MOV     A,R5
0042 540F              ANL     A,#0FH
0044 FD                MOV     R5,A
0045 EF                MOV     A,R7
0046 A805              MOV     R0,AR5
0048 08                INC     R0
0049 8006              SJMP    ?C0228
004B         ?C0227:
004B CE                XCH     A,R6
004C A2E7              MOV     C,ACC.7
004E 13                RRC     A
004F CE                XCH     A,R6
0050 13                RRC     A
0051         ?C0228:
0051 D8F8              DJNZ    R0,?C0227
0053 5401              ANL     A,#01H
0055 A800        E     MOV     R0,?C_IBP
0057 F6                MOV     @R0,A
                                           ; SOURCE LINE # 265
0058 7400        R     MOV     A,#LOW NVRAM1
005A 2B                ADD     A,R3
005B F582              MOV     DPL,A
005D 7400        R     MOV     A,#HIGH NVRAM1
005F 3A                ADDC    A,R2
0060 F583              MOV     DPH,A
0062 E0                MOVX    A,@DPTR
0063 FE                MOV     R6,A
0064 A3                INC     DPTR
0065 E0                MOVX    A,@DPTR
0066 A805              MOV     R0,AR5
0068 08                INC     R0
0069 8006              SJMP    ?C0230
006B         ?C0229:
006B CE                XCH     A,R6
006C A2E7              MOV     C,ACC.7
006E 13                RRC     A
006F CE                XCH     A,R6
0070 13                RRC     A
0071         ?C0230:
0071 D8F8              DJNZ    R0,?C0229
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 98  

0073 5401              ANL     A,#01H
0075 A800        E     MOV     R0,?C_IBP
0077 08                INC     R0
0078 F6                MOV     @R0,A
                                           ; SOURCE LINE # 266
0079 A800        E     MOV     R0,?C_IBP
007B E6                MOV     A,@R0
007C 6401              XRL     A,#01H
007E 700A              JNZ     ?C0104
0080 08                INC     R0
0081 E6                MOV     A,@R0
0082 6401              XRL     A,#01H
0084 6004              JZ      ?C0104
                                           ; SOURCE LINE # 267
0086 7F01              MOV     R7,#01H
0088 8002              SJMP    ?C0105
008A         ?C0104:
                                           ; SOURCE LINE # 269
008A 7F00              MOV     R7,#00H
                                           ; SOURCE LINE # 270
008C         ?C0105:
008C E500        E     MOV     A,?C_IBP
008E 2404              ADD     A,#04H
0090 F500        E     MOV     ?C_IBP,A
0092 22                RET     
             ; FUNCTION _?LDP (END)

             ; FUNCTION _?LDN (BEGIN)
                                           ; SOURCE LINE # 271
0000 1500        E     DEC     ?C_IBP
0002 1500        E     DEC     ?C_IBP
0004 A800        E     MOV     R0,?C_IBP
0006 A606              MOV     @R0,AR6
0008 08                INC     R0
0009 A607              MOV     @R0,AR7
000B 1500        E     DEC     ?C_IBP
000D 1500        E     DEC     ?C_IBP
                                           ; SOURCE LINE # 273
000F A800        E     MOV     R0,?C_IBP
0011 08                INC     R0
0012 08                INC     R0
0013 120000      R     LCALL   L?0264
                                           ; SOURCE LINE # 274
0016 A800        E     MOV     R0,?C_IBP
0018 08                INC     R0
0019 08                INC     R0
001A 08                INC     R0
001B E6                MOV     A,@R0
001C 540F              ANL     A,#0FH
001E 25E0              ADD     A,ACC
0020 FD                MOV     R5,A
0021 E4                CLR     A
0022 33                RLC     A
0023 FC                MOV     R4,A
0024 7400        R     MOV     A,#LOW NVRAM0
0026 2D                ADD     A,R5
0027 F582              MOV     DPL,A
0029 7400        R     MOV     A,#HIGH NVRAM0
002B 3C                ADDC    A,R4
002C F583              MOV     DPH,A
002E E0                MOVX    A,@DPTR
002F A3                INC     DPTR
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 99  

0030 E0                MOVX    A,@DPTR
0031 FB                MOV     R3,A
0032 A800        E     MOV     R0,?C_IBP
0034 08                INC     R0
0035 08                INC     R0
0036 A900              MOV     R1,AR0
0038 E7                MOV     A,@R1
0039 C4                SWAP    A
003A F8                MOV     R0,A
003B 54F0              ANL     A,#0F0H
003D C8                XCH     A,R0
003E 68                XRL     A,R0
003F FE                MOV     R6,A
0040 09                INC     R1
0041 E7                MOV     A,@R1
0042 C4                SWAP    A
0043 540F              ANL     A,#0FH
0045 48                ORL     A,R0
0046 25E0              ADD     A,ACC
0048 FF                MOV     R7,A
0049 EE                MOV     A,R6
004A 33                RLC     A
004B FE                MOV     R6,A
004C 7400        R     MOV     A,#LOW NVRAM0
004E 2F                ADD     A,R7
004F F582              MOV     DPL,A
0051 7400        R     MOV     A,#HIGH NVRAM0
0053 3E                ADDC    A,R6
0054 F583              MOV     DPH,A
0056 E0                MOVX    A,@DPTR
0057 FE                MOV     R6,A
0058 A3                INC     DPTR
0059 E0                MOVX    A,@DPTR
005A A803              MOV     R0,AR3
005C 08                INC     R0
005D 8006              SJMP    ?C0232
005F         ?C0231:
005F CE                XCH     A,R6
0060 A2E7              MOV     C,ACC.7
0062 13                RRC     A
0063 CE                XCH     A,R6
0064 13                RRC     A
0065         ?C0232:
0065 D8F8              DJNZ    R0,?C0231
0067 A800        E     MOV     R0,?C_IBP
0069 F6                MOV     @R0,A
                                           ; SOURCE LINE # 275
006A 7400        R     MOV     A,#LOW NVRAM1
006C 2D                ADD     A,R5
006D F582              MOV     DPL,A
006F 7400        R     MOV     A,#HIGH NVRAM1
0071 3C                ADDC    A,R4
0072 F583              MOV     DPH,A
0074 E0                MOVX    A,@DPTR
0075 A3                INC     DPTR
0076 E0                MOVX    A,@DPTR
0077 FD                MOV     R5,A
0078 A800        E     MOV     R0,?C_IBP
007A 08                INC     R0
007B 08                INC     R0
007C A900              MOV     R1,AR0
007E E7                MOV     A,@R1
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 100 

007F C4                SWAP    A
0080 F8                MOV     R0,A
0081 54F0              ANL     A,#0F0H
0083 C8                XCH     A,R0
0084 68                XRL     A,R0
0085 FE                MOV     R6,A
0086 09                INC     R1
0087 E7                MOV     A,@R1
0088 C4                SWAP    A
0089 540F              ANL     A,#0FH
008B 48                ORL     A,R0
008C 25E0              ADD     A,ACC
008E FF                MOV     R7,A
008F EE                MOV     A,R6
0090 33                RLC     A
0091 FE                MOV     R6,A
0092 7400        R     MOV     A,#LOW NVRAM1
0094 2F                ADD     A,R7
0095 F582              MOV     DPL,A
0097 7400        R     MOV     A,#HIGH NVRAM1
0099 3E                ADDC    A,R6
009A F583              MOV     DPH,A
009C E0                MOVX    A,@DPTR
009D FE                MOV     R6,A
009E A3                INC     DPTR
009F E0                MOVX    A,@DPTR
00A0 A805              MOV     R0,AR5
00A2 08                INC     R0
00A3 8006              SJMP    ?C0234
00A5         ?C0233:
00A5 CE                XCH     A,R6
00A6 A2E7              MOV     C,ACC.7
00A8 13                RRC     A
00A9 CE                XCH     A,R6
00AA 13                RRC     A
00AB         ?C0234:
00AB D8F8              DJNZ    R0,?C0233
00AD A800        E     MOV     R0,?C_IBP
00AF 08                INC     R0
00B0 F6                MOV     @R0,A
                                           ; SOURCE LINE # 276
00B1 A800        E     MOV     R0,?C_IBP
00B3 E6                MOV     A,@R0
00B4 7008              JNZ     ?C0107
00B6 08                INC     R0
00B7 E6                MOV     A,@R0
00B8 6004              JZ      ?C0107
                                           ; SOURCE LINE # 277
00BA 7F01              MOV     R7,#01H
00BC 8002              SJMP    ?C0108
00BE         ?C0107:
                                           ; SOURCE LINE # 279
00BE 7F00              MOV     R7,#00H
                                           ; SOURCE LINE # 280
00C0         ?C0108:
00C0 E500        E     MOV     A,?C_IBP
00C2 2404              ADD     A,#04H
00C4 F500        E     MOV     ?C_IBP,A
00C6 22                RET     
             ; FUNCTION _?LDN (END)

             ; FUNCTION _T1MS (BEGIN)
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 101 

                                           ; SOURCE LINE # 281
0000 8F00        R     MOV     A,R7
;---- Variable 'value' assigned to Register 'R2/R3' ----
;---- Variable 'start' assigned to Register 'R5' ----
                                           ; SOURCE LINE # 286
0002 ED                MOV     A,R5
0003 7003              JNZ     $ + 5H
0005 020000      R     LJMP    ?C0110
                                           ; SOURCE LINE # 287
0008 EF                MOV     A,R7
0009 25E0              ADD     A,ACC
000B FF                MOV     R7,A
000C E4                CLR     A
000D 33                RLC     A
000E FE                MOV     R6,A
000F 7400        R     MOV     A,#LOW NVRAM0+0146H
0011 2F                ADD     A,R7
0012 F582              MOV     DPL,A
0014 7400        R     MOV     A,#HIGH NVRAM0+0146H
0016 3E                ADDC    A,R6
0017 F583              MOV     DPH,A
0019 E0                MOVX    A,@DPTR
001A FE                MOV     R6,A
001B A3                INC     DPTR
001C E0                MOVX    A,@DPTR
001D C3                CLR     C
001E 9B                SUBB    A,R3
001F EE                MOV     A,R6
0020 9A                SUBB    A,R2
0021 4037              JC      ?C0111
                                           ; SOURCE LINE # 288
0023 E500        R     MOV     A,A
0025 C4                SWAP    A
0026 540F              ANL     A,#0FH
0028 25E0              ADD     A,ACC
002A FF                MOV     R7,A
002B E4                CLR     A
002C 33                RLC     A
002D FE                MOV     R6,A
002E 7400        R     MOV     A,#LOW NVRAM0+0140H
0030 2F                ADD     A,R7
0031 F582              MOV     DPL,A
0033 7400        R     MOV     A,#HIGH NVRAM0+0140H
0035 3E                ADDC    A,R6
0036 F583              MOV     DPH,A
0038 C083              PUSH    DPH
003A C082              PUSH    DPL
003C E500        R     MOV     A,A
003E 540F              ANL     A,#0FH
0040 FF                MOV     R7,A
0041 7E00              MOV     R6,#00H
0043 7401              MOV     A,#01H
0045 A807              MOV     R0,AR7
0047 08                INC     R0
0048 8005              SJMP    ?C0236
004A         ?C0235:
004A C3                CLR     C
004B 33                RLC     A
004C CE                XCH     A,R6
004D 33                RLC     A
004E CE                XCH     A,R6
004F         ?C0236:
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 102 

004F D8F9              DJNZ    R0,?C0235
0051 FF                MOV     R7,A
0052 E0                MOVX    A,@DPTR
0053 4E                ORL     A,R6
0054 FE                MOV     R6,A
0055 A3                INC     DPTR
0056 E0                MOVX    A,@DPTR
0057 4F                ORL     A,R7
                                           ; SOURCE LINE # 289
0058 8039              SJMP    ?C0258
005A         ?C0111:
                                           ; SOURCE LINE # 290
                                           ; SOURCE LINE # 291
005A E500        R     MOV     A,A
005C C4                SWAP    A
005D 540F              ANL     A,#0FH
005F 25E0              ADD     A,ACC
0061 FF                MOV     R7,A
0062 E4                CLR     A
0063 33                RLC     A
0064 FE                MOV     R6,A
0065 7400        R     MOV     A,#LOW NVRAM0+0140H
0067 2F                ADD     A,R7
0068 F582              MOV     DPL,A
006A 7400        R     MOV     A,#HIGH NVRAM0+0140H
006C 3E                ADDC    A,R6
006D F583              MOV     DPH,A
006F C083              PUSH    DPH
0071 C082              PUSH    DPL
0073 E500        R     MOV     A,A
0075 540F              ANL     A,#0FH
0077 FF                MOV     R7,A
0078 7E00              MOV     R6,#00H
007A 7401              MOV     A,#01H
007C A807              MOV     R0,AR7
007E 08                INC     R0
007F 8005              SJMP    ?C0238
0081         ?C0237:
0081 C3                CLR     C
0082 33                RLC     A
0083 CE                XCH     A,R6
0084 33                RLC     A
0085 CE                XCH     A,R6
0086         ?C0238:
0086 D8F9              DJNZ    R0,?C0237
0088 F4                CPL     A
0089 FF                MOV     R7,A
008A EE                MOV     A,R6
008B F4                CPL     A
008C FE                MOV     R6,A
008D E0                MOVX    A,@DPTR
008E 5E                ANL     A,R6
008F FE                MOV     R6,A
0090 A3                INC     DPTR
0091 E0                MOVX    A,@DPTR
0092 5F                ANL     A,R7
0093         ?C0258:
0093 FF                MOV     R7,A
0094 D082              POP     DPL
0096 D083              POP     DPH
0098 EE                MOV     A,R6
0099 F0                MOVX    @DPTR,A
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 103 

009A A3                INC     DPTR
009B EF                MOV     A,R7
009C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 292
                                           ; SOURCE LINE # 294
009D 22                RET     
009E         ?C0110:
                                           ; SOURCE LINE # 295
                                           ; SOURCE LINE # 296
009E E500        R     MOV     A,A
00A0 C4                SWAP    A
00A1 540F              ANL     A,#0FH
00A3 25E0              ADD     A,ACC
00A5 FF                MOV     R7,A
00A6 E4                CLR     A
00A7 33                RLC     A
00A8 FE                MOV     R6,A
00A9 7400        R     MOV     A,#LOW NVRAM0+0140H
00AB 2F                ADD     A,R7
00AC F582              MOV     DPL,A
00AE 7400        R     MOV     A,#HIGH NVRAM0+0140H
00B0 3E                ADDC    A,R6
00B1 F583              MOV     DPH,A
00B3 C083              PUSH    DPH
00B5 C082              PUSH    DPL
00B7 E500        R     MOV     A,A
00B9 540F              ANL     A,#0FH
00BB FF                MOV     R7,A
00BC 7E00              MOV     R6,#00H
00BE 7401              MOV     A,#01H
00C0 A807              MOV     R0,AR7
00C2 08                INC     R0
00C3 8005              SJMP    ?C0240
00C5         ?C0239:
00C5 C3                CLR     C
00C6 33                RLC     A
00C7 CE                XCH     A,R6
00C8 33                RLC     A
00C9 CE                XCH     A,R6
00CA         ?C0240:
00CA D8F9              DJNZ    R0,?C0239
00CC F4                CPL     A
00CD FF                MOV     R7,A
00CE EE                MOV     A,R6
00CF F4                CPL     A
00D0 FE                MOV     R6,A
00D1 E0                MOVX    A,@DPTR
00D2 5E                ANL     A,R6
00D3 FE                MOV     R6,A
00D4 A3                INC     DPTR
00D5 E0                MOVX    A,@DPTR
00D6 5F                ANL     A,R7
00D7 FF                MOV     R7,A
00D8 D082              POP     DPL
00DA D083              POP     DPH
00DC EE                MOV     A,R6
00DD F0                MOVX    @DPTR,A
00DE A3                INC     DPTR
00DF EF                MOV     A,R7
00E0 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 297
00E1 E500        R     MOV     A,A
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 104 

00E3 25E0              ADD     A,ACC
00E5 FF                MOV     R7,A
00E6 E4                CLR     A
00E7 33                RLC     A
00E8 FE                MOV     R6,A
00E9 7400        R     MOV     A,#LOW NVRAM0+0146H
00EB 2F                ADD     A,R7
00EC F582              MOV     DPL,A
00EE 7400        R     MOV     A,#HIGH NVRAM0+0146H
00F0 3E                ADDC    A,R6
00F1 F583              MOV     DPH,A
00F3 E4                CLR     A
00F4 F0                MOVX    @DPTR,A
00F5 A3                INC     DPTR
00F6 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 298
                                           ; SOURCE LINE # 299
00F7         ?C0114:
00F7 22                RET     
             ; FUNCTION _T1MS (END)

             ; FUNCTION _T10MS (BEGIN)
                                           ; SOURCE LINE # 300
0000 8F00        R     MOV     A,R7
;---- Variable 'value' assigned to Register 'R2/R3' ----
;---- Variable 'start' assigned to Register 'R5' ----
                                           ; SOURCE LINE # 305
0002 ED                MOV     A,R5
0003 7003              JNZ     $ + 5H
0005 020000      R     LJMP    ?C0115
                                           ; SOURCE LINE # 306
0008 EF                MOV     A,R7
0009 25E0              ADD     A,ACC
000B FF                MOV     R7,A
000C E4                CLR     A
000D 33                RLC     A
000E FE                MOV     R6,A
000F 7400        R     MOV     A,#LOW NVRAM0+0166H
0011 2F                ADD     A,R7
0012 F582              MOV     DPL,A
0014 7400        R     MOV     A,#HIGH NVRAM0+0166H
0016 3E                ADDC    A,R6
0017 F583              MOV     DPH,A
0019 E0                MOVX    A,@DPTR
001A FE                MOV     R6,A
001B A3                INC     DPTR
001C E0                MOVX    A,@DPTR
001D C3                CLR     C
001E 9B                SUBB    A,R3
001F EE                MOV     A,R6
0020 9A                SUBB    A,R2
0021 4037              JC      ?C0116
                                           ; SOURCE LINE # 307
0023 E500        R     MOV     A,A
0025 C4                SWAP    A
0026 540F              ANL     A,#0FH
0028 25E0              ADD     A,ACC
002A FF                MOV     R7,A
002B E4                CLR     A
002C 33                RLC     A
002D FE                MOV     R6,A
002E 7400        R     MOV     A,#LOW NVRAM0+0142H
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 105 

0030 2F                ADD     A,R7
0031 F582              MOV     DPL,A
0033 7400        R     MOV     A,#HIGH NVRAM0+0142H
0035 3E                ADDC    A,R6
0036 F583              MOV     DPH,A
0038 C083              PUSH    DPH
003A C082              PUSH    DPL
003C E500        R     MOV     A,A
003E 540F              ANL     A,#0FH
0040 FF                MOV     R7,A
0041 7E00              MOV     R6,#00H
0043 7401              MOV     A,#01H
0045 A807              MOV     R0,AR7
0047 08                INC     R0
0048 8005              SJMP    ?C0242
004A         ?C0241:
004A C3                CLR     C
004B 33                RLC     A
004C CE                XCH     A,R6
004D 33                RLC     A
004E CE                XCH     A,R6
004F         ?C0242:
004F D8F9              DJNZ    R0,?C0241
0051 FF                MOV     R7,A
0052 E0                MOVX    A,@DPTR
0053 4E                ORL     A,R6
0054 FE                MOV     R6,A
0055 A3                INC     DPTR
0056 E0                MOVX    A,@DPTR
0057 4F                ORL     A,R7
                                           ; SOURCE LINE # 308
0058 8039              SJMP    ?C0259
005A         ?C0116:
                                           ; SOURCE LINE # 309
                                           ; SOURCE LINE # 310
005A E500        R     MOV     A,A
005C C4                SWAP    A
005D 540F              ANL     A,#0FH
005F 25E0              ADD     A,ACC
0061 FF                MOV     R7,A
0062 E4                CLR     A
0063 33                RLC     A
0064 FE                MOV     R6,A
0065 7400        R     MOV     A,#LOW NVRAM0+0142H
0067 2F                ADD     A,R7
0068 F582              MOV     DPL,A
006A 7400        R     MOV     A,#HIGH NVRAM0+0142H
006C 3E                ADDC    A,R6
006D F583              MOV     DPH,A
006F C083              PUSH    DPH
0071 C082              PUSH    DPL
0073 E500        R     MOV     A,A
0075 540F              ANL     A,#0FH
0077 FF                MOV     R7,A
0078 7E00              MOV     R6,#00H
007A 7401              MOV     A,#01H
007C A807              MOV     R0,AR7
007E 08                INC     R0
007F 8005              SJMP    ?C0244
0081         ?C0243:
0081 C3                CLR     C
0082 33                RLC     A
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 106 

0083 CE                XCH     A,R6
0084 33                RLC     A
0085 CE                XCH     A,R6
0086         ?C0244:
0086 D8F9              DJNZ    R0,?C0243
0088 F4                CPL     A
0089 FF                MOV     R7,A
008A EE                MOV     A,R6
008B F4                CPL     A
008C FE                MOV     R6,A
008D E0                MOVX    A,@DPTR
008E 5E                ANL     A,R6
008F FE                MOV     R6,A
0090 A3                INC     DPTR
0091 E0                MOVX    A,@DPTR
0092 5F                ANL     A,R7
0093         ?C0259:
0093 FF                MOV     R7,A
0094 D082              POP     DPL
0096 D083              POP     DPH
0098 EE                MOV     A,R6
0099 F0                MOVX    @DPTR,A
009A A3                INC     DPTR
009B EF                MOV     A,R7
009C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 311
                                           ; SOURCE LINE # 312
009D 22                RET     
009E         ?C0115:
                                           ; SOURCE LINE # 313
                                           ; SOURCE LINE # 314
009E E500        R     MOV     A,A
00A0 C4                SWAP    A
00A1 540F              ANL     A,#0FH
00A3 25E0              ADD     A,ACC
00A5 FF                MOV     R7,A
00A6 E4                CLR     A
00A7 33                RLC     A
00A8 FE                MOV     R6,A
00A9 7400        R     MOV     A,#LOW NVRAM0+0142H
00AB 2F                ADD     A,R7
00AC F582              MOV     DPL,A
00AE 7400        R     MOV     A,#HIGH NVRAM0+0142H
00B0 3E                ADDC    A,R6
00B1 F583              MOV     DPH,A
00B3 C083              PUSH    DPH
00B5 C082              PUSH    DPL
00B7 E500        R     MOV     A,A
00B9 540F              ANL     A,#0FH
00BB FF                MOV     R7,A
00BC 7E00              MOV     R6,#00H
00BE 7401              MOV     A,#01H
00C0 A807              MOV     R0,AR7
00C2 08                INC     R0
00C3 8005              SJMP    ?C0246
00C5         ?C0245:
00C5 C3                CLR     C
00C6 33                RLC     A
00C7 CE                XCH     A,R6
00C8 33                RLC     A
00C9 CE                XCH     A,R6
00CA         ?C0246:
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 107 

00CA D8F9              DJNZ    R0,?C0245
00CC F4                CPL     A
00CD FF                MOV     R7,A
00CE EE                MOV     A,R6
00CF F4                CPL     A
00D0 FE                MOV     R6,A
00D1 E0                MOVX    A,@DPTR
00D2 5E                ANL     A,R6
00D3 FE                MOV     R6,A
00D4 A3                INC     DPTR
00D5 E0                MOVX    A,@DPTR
00D6 5F                ANL     A,R7
00D7 FF                MOV     R7,A
00D8 D082              POP     DPL
00DA D083              POP     DPH
00DC EE                MOV     A,R6
00DD F0                MOVX    @DPTR,A
00DE A3                INC     DPTR
00DF EF                MOV     A,R7
00E0 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 315
00E1 E500        R     MOV     A,A
00E3 25E0              ADD     A,ACC
00E5 FF                MOV     R7,A
00E6 E4                CLR     A
00E7 33                RLC     A
00E8 FE                MOV     R6,A
00E9 7400        R     MOV     A,#LOW NVRAM0+0166H
00EB 2F                ADD     A,R7
00EC F582              MOV     DPL,A
00EE 7400        R     MOV     A,#HIGH NVRAM0+0166H
00F0 3E                ADDC    A,R6
00F1 F583              MOV     DPH,A
00F3 E4                CLR     A
00F4 F0                MOVX    @DPTR,A
00F5 A3                INC     DPTR
00F6 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 316
                                           ; SOURCE LINE # 317
00F7         ?C0119:
00F7 22                RET     
             ; FUNCTION _T10MS (END)

             ; FUNCTION _T100MS (BEGIN)
                                           ; SOURCE LINE # 318
0000 8F00        R     MOV     A,R7
;---- Variable 'value' assigned to Register 'R2/R3' ----
;---- Variable 'start' assigned to Register 'R5' ----
                                           ; SOURCE LINE # 323
0002 ED                MOV     A,R5
0003 7003              JNZ     $ + 5H
0005 020000      R     LJMP    ?C0120
                                           ; SOURCE LINE # 324
0008 EF                MOV     A,R7
0009 25E0              ADD     A,ACC
000B FF                MOV     R7,A
000C E4                CLR     A
000D 33                RLC     A
000E FE                MOV     R6,A
000F 7400        R     MOV     A,#LOW NVRAM0+0186H
0011 2F                ADD     A,R7
0012 F582              MOV     DPL,A
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 108 

0014 7400        R     MOV     A,#HIGH NVRAM0+0186H
0016 3E                ADDC    A,R6
0017 F583              MOV     DPH,A
0019 E0                MOVX    A,@DPTR
001A FE                MOV     R6,A
001B A3                INC     DPTR
001C E0                MOVX    A,@DPTR
001D C3                CLR     C
001E 9B                SUBB    A,R3
001F EE                MOV     A,R6
0020 9A                SUBB    A,R2
0021 4037              JC      ?C0121
                                           ; SOURCE LINE # 325
0023 E500        R     MOV     A,A
0025 C4                SWAP    A
0026 540F              ANL     A,#0FH
0028 25E0              ADD     A,ACC
002A FF                MOV     R7,A
002B E4                CLR     A
002C 33                RLC     A
002D FE                MOV     R6,A
002E 7400        R     MOV     A,#LOW NVRAM0+0144H
0030 2F                ADD     A,R7
0031 F582              MOV     DPL,A
0033 7400        R     MOV     A,#HIGH NVRAM0+0144H
0035 3E                ADDC    A,R6
0036 F583              MOV     DPH,A
0038 C083              PUSH    DPH
003A C082              PUSH    DPL
003C E500        R     MOV     A,A
003E 540F              ANL     A,#0FH
0040 FF                MOV     R7,A
0041 7E00              MOV     R6,#00H
0043 7401              MOV     A,#01H
0045 A807              MOV     R0,AR7
0047 08                INC     R0
0048 8005              SJMP    ?C0248
004A         ?C0247:
004A C3                CLR     C
004B 33                RLC     A
004C CE                XCH     A,R6
004D 33                RLC     A
004E CE                XCH     A,R6
004F         ?C0248:
004F D8F9              DJNZ    R0,?C0247
0051 FF                MOV     R7,A
0052 E0                MOVX    A,@DPTR
0053 4E                ORL     A,R6
0054 FE                MOV     R6,A
0055 A3                INC     DPTR
0056 E0                MOVX    A,@DPTR
0057 4F                ORL     A,R7
                                           ; SOURCE LINE # 326
0058 8039              SJMP    ?C0260
005A         ?C0121:
                                           ; SOURCE LINE # 327
                                           ; SOURCE LINE # 328
005A E500        R     MOV     A,A
005C C4                SWAP    A
005D 540F              ANL     A,#0FH
005F 25E0              ADD     A,ACC
0061 FF                MOV     R7,A
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 109 

0062 E4                CLR     A
0063 33                RLC     A
0064 FE                MOV     R6,A
0065 7400        R     MOV     A,#LOW NVRAM0+0144H
0067 2F                ADD     A,R7
0068 F582              MOV     DPL,A
006A 7400        R     MOV     A,#HIGH NVRAM0+0144H
006C 3E                ADDC    A,R6
006D F583              MOV     DPH,A
006F C083              PUSH    DPH
0071 C082              PUSH    DPL
0073 E500        R     MOV     A,A
0075 540F              ANL     A,#0FH
0077 FF                MOV     R7,A
0078 7E00              MOV     R6,#00H
007A 7401              MOV     A,#01H
007C A807              MOV     R0,AR7
007E 08                INC     R0
007F 8005              SJMP    ?C0250
0081         ?C0249:
0081 C3                CLR     C
0082 33                RLC     A
0083 CE                XCH     A,R6
0084 33                RLC     A
0085 CE                XCH     A,R6
0086         ?C0250:
0086 D8F9              DJNZ    R0,?C0249
0088 F4                CPL     A
0089 FF                MOV     R7,A
008A EE                MOV     A,R6
008B F4                CPL     A
008C FE                MOV     R6,A
008D E0                MOVX    A,@DPTR
008E 5E                ANL     A,R6
008F FE                MOV     R6,A
0090 A3                INC     DPTR
0091 E0                MOVX    A,@DPTR
0092 5F                ANL     A,R7
0093         ?C0260:
0093 FF                MOV     R7,A
0094 D082              POP     DPL
0096 D083              POP     DPH
0098 EE                MOV     A,R6
0099 F0                MOVX    @DPTR,A
009A A3                INC     DPTR
009B EF                MOV     A,R7
009C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 329
                                           ; SOURCE LINE # 330
009D 22                RET     
009E         ?C0120:
                                           ; SOURCE LINE # 331
                                           ; SOURCE LINE # 332
009E E500        R     MOV     A,A
00A0 C4                SWAP    A
00A1 540F              ANL     A,#0FH
00A3 25E0              ADD     A,ACC
00A5 FF                MOV     R7,A
00A6 E4                CLR     A
00A7 33                RLC     A
00A8 FE                MOV     R6,A
00A9 7400        R     MOV     A,#LOW NVRAM0+0144H
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 110 

00AB 2F                ADD     A,R7
00AC F582              MOV     DPL,A
00AE 7400        R     MOV     A,#HIGH NVRAM0+0144H
00B0 3E                ADDC    A,R6
00B1 F583              MOV     DPH,A
00B3 C083              PUSH    DPH
00B5 C082              PUSH    DPL
00B7 E500        R     MOV     A,A
00B9 540F              ANL     A,#0FH
00BB FF                MOV     R7,A
00BC 7E00              MOV     R6,#00H
00BE 7401              MOV     A,#01H
00C0 A807              MOV     R0,AR7
00C2 08                INC     R0
00C3 8005              SJMP    ?C0252
00C5         ?C0251:
00C5 C3                CLR     C
00C6 33                RLC     A
00C7 CE                XCH     A,R6
00C8 33                RLC     A
00C9 CE                XCH     A,R6
00CA         ?C0252:
00CA D8F9              DJNZ    R0,?C0251
00CC F4                CPL     A
00CD FF                MOV     R7,A
00CE EE                MOV     A,R6
00CF F4                CPL     A
00D0 FE                MOV     R6,A
00D1 E0                MOVX    A,@DPTR
00D2 5E                ANL     A,R6
00D3 FE                MOV     R6,A
00D4 A3                INC     DPTR
00D5 E0                MOVX    A,@DPTR
00D6 5F                ANL     A,R7
00D7 FF                MOV     R7,A
00D8 D082              POP     DPL
00DA D083              POP     DPH
00DC EE                MOV     A,R6
00DD F0                MOVX    @DPTR,A
00DE A3                INC     DPTR
00DF EF                MOV     A,R7
00E0 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 333
00E1 E500        R     MOV     A,A
00E3 25E0              ADD     A,ACC
00E5 FF                MOV     R7,A
00E6 E4                CLR     A
00E7 33                RLC     A
00E8 FE                MOV     R6,A
00E9 7400        R     MOV     A,#LOW NVRAM0+0186H
00EB 2F                ADD     A,R7
00EC F582              MOV     DPL,A
00EE 7400        R     MOV     A,#HIGH NVRAM0+0186H
00F0 3E                ADDC    A,R6
00F1 F583              MOV     DPH,A
00F3 E4                CLR     A
00F4 F0                MOVX    @DPTR,A
00F5 A3                INC     DPTR
00F6 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 334
                                           ; SOURCE LINE # 335
00F7         ?C0124:
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 111 

00F7 22                RET     
             ; FUNCTION _T100MS (END)

             ; FUNCTION _TNTC (BEGIN)
                                           ; SOURCE LINE # 336
;---- Variable 'dat' assigned to Register 'DPTR' ----
0000 8F82              MOV     DPL,R7
0002 8E83              MOV     DPH,R6
                                           ; SOURCE LINE # 339
0004 EE                MOV     A,R6
0005 33                RLC     A
0006 95E0              SUBB    A,ACC
0008 FD                MOV     R5,A
0009 FC                MOV     R4,A
000A E4                CLR     A
000B 7B60              MOV     R3,#060H
000D 7A09              MOV     R2,#09H
000F F9                MOV     R1,A
0010 F8                MOV     R0,A
0011 D3                SETB    C
0012 120000      E     LCALL   ?C?SLCMP
0015 5003              JNC     ?C0125
0017 900960            MOV     DPTR,#0960H
001A         ?C0125:
                                           ; SOURCE LINE # 340
001A C3                CLR     C
001B E583              MOV     A,DPH
001D 6480              XRL     A,#080H
001F 9480              SUBB    A,#080H
0021 5005              JNC     ?C0126
0023 E4                CLR     A
0024 F583              MOV     DPH,A
0026 F582              MOV     DPL,A
0028         ?C0126:
                                           ; SOURCE LINE # 342
0028 AE83              MOV     R6,DPH
002A AF82              MOV     R7,DPL
002C EE                MOV     A,R6
002D 33                RLC     A
002E 95E0              SUBB    A,ACC
0030 FD                MOV     R5,A
0031 FC                MOV     R4,A
0032 E4                CLR     A
0033 7B60              MOV     R3,#060H
0035 7A09              MOV     R2,#09H
0037 F9                MOV     R1,A
0038 F8                MOV     R0,A
0039 120000      E     LCALL   ?C?LMUL
003C E4                CLR     A
003D FB                MOV     R3,A
003E 7A10              MOV     R2,#010H
0040 F9                MOV     R1,A
0041 F8                MOV     R0,A
0042 120000      E     LCALL   ?C?SLDIV
0045 7800        R     MOV     R0,#LOW temp
0047 EE                MOV     A,R6
0048 F6                MOV     @R0,A
0049 08                INC     R0
004A EF                MOV     A,R7
004B F6                MOV     @R0,A
                                           ; SOURCE LINE # 343
004C C3                CLR     C
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 112 

004D 7488              MOV     A,#088H
004F 9F                SUBB    A,R7
0050 FD                MOV     R5,A
0051 7413              MOV     A,#013H
0053 9E                SUBB    A,R6
0054 FC                MOV     R4,A
0055 7EF0              MOV     R6,#0F0H
0057 7F80              MOV     R7,#080H
0059 120000      E     LCALL   ?C?UIDIV
005C 7800        R     MOV     R0,#LOW temp
005E EE                MOV     A,R6
005F F6                MOV     @R0,A
0060 08                INC     R0
0061 EF                MOV     A,R7
0062 F6                MOV     @R0,A
                                           ; SOURCE LINE # 345
0063 FD                MOV     R5,A
0064 AC06              MOV     R4,AR6
0066 E4                CLR     A
0067 120000      E     LCALL   ?C?FCASTI
006A 7B00              MOV     R3,#00H
006C 7A40              MOV     R2,#040H
006E 791C              MOV     R1,#01CH
0070 7846              MOV     R0,#046H
0072 120000      E     LCALL   ?C?FPDIV
0075 120000      E     LCALL   _log
0078 7B97              MOV     R3,#097H
007A 7AC9              MOV     R2,#0C9H
007C 7996              MOV     R1,#096H
007E 7839              MOV     R0,#039H
0080 120000      E     LCALL   ?C?FPMUL
0083 7B62              MOV     R3,#062H
0085 7AEB              MOV     R2,#0EBH
0087 795B              MOV     R1,#05BH
0089 783B              MOV     R0,#03BH
008B 120000      E     LCALL   ?C?FPADD
008E 7800        R     MOV     R0,#LOW ftemp
0090 120000      E     LCALL   ?C?LSTIDATA
                                           ; SOURCE LINE # 346
0093 7800        R     MOV     R0,#LOW ftemp
0095 120000      E     LCALL   ?C?LLDIDATA0
0098 E4                CLR     A
0099 FF                MOV     R7,A
009A FE                MOV     R6,A
009B 7D80              MOV     R5,#080H
009D 7C3F              MOV     R4,#03FH
009F 120000      E     LCALL   ?C?FPDIV
00A2 7B00              MOV     R3,#00H
00A4 7A80              MOV     R2,#080H
00A6 7988              MOV     R1,#088H
00A8 78C3              MOV     R0,#0C3H
00AA 120000      E     LCALL   ?C?FPADD
00AD 7800        R     MOV     R0,#LOW ftemp
00AF 120000      E     LCALL   ?C?LSTIDATA
                                           ; SOURCE LINE # 347
00B2 E4                CLR     A
00B3 FF                MOV     R7,A
00B4 FE                MOV     R6,A
00B5 7DC8              MOV     R5,#0C8H
00B7 7C42              MOV     R4,#042H
00B9 7800        R     MOV     R0,#LOW ftemp
00BB 120000      E     LCALL   ?C?LLDIDATA0
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 113 

00BE 120000      E     LCALL   ?C?FPCMP3
00C1 4009              JC      ?C0127
00C3 7800        R     MOV     R0,#LOW ftemp
00C5 120000      E     LCALL   ?C?LSTKIDATA
00C8 42                DB      042H
00C9 C8                DB      0C8H
00CA 00                DB      00H
00CB 00                DB      00H
00CC         ?C0127:
                                           ; SOURCE LINE # 348
00CC E4                CLR     A
00CD FF                MOV     R7,A
00CE FE                MOV     R6,A
00CF 7DC8              MOV     R5,#0C8H
00D1 7CC2              MOV     R4,#0C2H
00D3 7800        R     MOV     R0,#LOW ftemp
00D5 120000      E     LCALL   ?C?LLDIDATA0
00D8 120000      E     LCALL   ?C?FPCMP3
00DB 6002              JZ      $ + 4H
00DD 5009              JNC     ?C0128
00DF 7800        R     MOV     R0,#LOW ftemp
00E1 120000      E     LCALL   ?C?LSTKIDATA
00E4 C2                DB      0C2H
00E5 C8                DB      0C8H
00E6 00                DB      00H
00E7 00                DB      00H
00E8         ?C0128:
                                           ; SOURCE LINE # 349
00E8 E4                CLR     A
00E9 FF                MOV     R7,A
00EA FE                MOV     R6,A
00EB 7D20              MOV     R5,#020H
00ED 7C41              MOV     R4,#041H
00EF 7800        R     MOV     R0,#LOW ftemp
00F1 120000      E     LCALL   ?C?LLDIDATA0
00F4 120000      E     LCALL   ?C?FPMUL
00F7 020000      E     LJMP    ?C?CASTF
             ; FUNCTION _TNTC (END)

             ; FUNCTION _TENV (BEGIN)
                                           ; SOURCE LINE # 351
;---- Variable 'dat' assigned to Register 'R6/R7' ----
                                           ; SOURCE LINE # 353
0000 EE                MOV     A,R6
0001 33                RLC     A
0002 95E0              SUBB    A,ACC
0004 FD                MOV     R5,A
0005 FC                MOV     R4,A
0006 E4                CLR     A
0007 7B60              MOV     R3,#060H
0009 7A09              MOV     R2,#09H
000B F9                MOV     R1,A
000C F8                MOV     R0,A
000D 120000      E     LCALL   ?C?LMUL
0010 E4                CLR     A
0011 FB                MOV     R3,A
0012 7A10              MOV     R2,#010H
0014 F9                MOV     R1,A
0015 F8                MOV     R0,A
0016 120000      E     LCALL   ?C?SLDIV
0019 7800        R     MOV     R0,#LOW temp
001B EE                MOV     A,R6
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 114 

001C F6                MOV     @R0,A
001D 08                INC     R0
001E EF                MOV     A,R7
001F F6                MOV     @R0,A
                                           ; SOURCE LINE # 354
0020 EF                MOV     A,R7
0021 24A8              ADD     A,#0A8H
0023 FF                MOV     R7,A
0024 EE                MOV     A,R6
0025 34FC              ADDC    A,#0FCH
0027 FE                MOV     R6,A
0028 E4                CLR     A
0029 34FF              ADDC    A,#0FFH
002B FD                MOV     R5,A
002C E4                CLR     A
002D 34FF              ADDC    A,#0FFH
002F FC                MOV     R4,A
0030 E4                CLR     A
0031 7BE8              MOV     R3,#0E8H
0033 7A03              MOV     R2,#03H
0035 F9                MOV     R1,A
0036 F8                MOV     R0,A
0037 120000      E     LCALL   ?C?LMUL
003A E4                CLR     A
003B 7B02              MOV     R3,#02H
003D 7A0D              MOV     R2,#0DH
003F F9                MOV     R1,A
0040 F8                MOV     R0,A
0041 120000      E     LCALL   ?C?SLDIV
0044 7800        R     MOV     R0,#LOW temp
0046 EE                MOV     A,R6
0047 F6                MOV     @R0,A
0048 08                INC     R0
0049 EF                MOV     A,R7
004A F6                MOV     @R0,A
                                           ; SOURCE LINE # 355
                                           ; SOURCE LINE # 356
004B 22                RET     
             ; FUNCTION _TENV (END)

             ; FUNCTION _MAX (BEGIN)
                                           ; SOURCE LINE # 357
0000 8D00        R     MOV     len,R5
0002 8B00        R     MOV     s,R3
0004 8A00        R     MOV     s+01H,R2
0006 8900        R     MOV     s+02H,R1
                                           ; SOURCE LINE # 360
0008 120000      E     LCALL   ?C?ILDPTR
000B 7800        R     MOV     R0,#LOW max
000D A6F0              MOV     @R0,B
000F 08                INC     R0
0010 F6                MOV     @R0,A
                                           ; SOURCE LINE # 361
0011 E4                CLR     A
0012 08                INC     R0
0013 F6                MOV     @R0,A
0014         ?C0131:
0014 7800        R     MOV     R0,#LOW i
0016 E6                MOV     A,@R0
0017 FF                MOV     R7,A
0018 C3                CLR     C
0019 9500        R     SUBB    A,len
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 115 

001B 5031              JNC     ?C0132
                                           ; SOURCE LINE # 362
001D AB00        R     MOV     R3,s
001F AA00        R     MOV     R2,s+01H
0021 A900        R     MOV     R1,s+02H
0023 75F002            MOV     B,#02H
0026 EF                MOV     A,R7
0027 A4                MUL     AB
0028 F582              MOV     DPL,A
002A 85F083            MOV     DPH,B
002D 120000      E     LCALL   ?C?ILDOPTR
0030 FF                MOV     R7,A
0031 AEF0              MOV     R6,B
0033 D3                SETB    C
0034 7800        R     MOV     R0,#LOW max+01H
0036 96                SUBB    A,@R0
0037 18                DEC     R0
0038 E6                MOV     A,@R0
0039 6480              XRL     A,#080H
003B F8                MOV     R0,A
003C EE                MOV     A,R6
003D 6480              XRL     A,#080H
003F 98                SUBB    A,R0
0040 4007              JC      ?C0133
                                           ; SOURCE LINE # 363
0042 7800        R     MOV     R0,#LOW max
0044 A606              MOV     @R0,AR6
0046 08                INC     R0
0047 A607              MOV     @R0,AR7
                                           ; SOURCE LINE # 364
                                           ; SOURCE LINE # 365
0049         ?C0133:
0049 7800        R     MOV     R0,#LOW i
004B 06                INC     @R0
004C 80C6              SJMP    ?C0131
004E         ?C0132:
                                           ; SOURCE LINE # 366
004E 7800        R     MOV     R0,#LOW max
0050 E6                MOV     A,@R0
0051 FE                MOV     R6,A
0052 08                INC     R0
0053 E6                MOV     A,@R0
0054 FF                MOV     R7,A
                                           ; SOURCE LINE # 367
0055 22                RET     
             ; FUNCTION _MAX (END)

             ; FUNCTION _MIN (BEGIN)
                                           ; SOURCE LINE # 368
0000 8D00        R     MOV     len,R5
0002 8B00        R     MOV     s,R3
0004 8A00        R     MOV     s+01H,R2
0006 8900        R     MOV     s+02H,R1
                                           ; SOURCE LINE # 371
0008 120000      E     LCALL   ?C?ILDPTR
000B 7800        R     MOV     R0,#LOW min
000D A6F0              MOV     @R0,B
000F 08                INC     R0
0010 F6                MOV     @R0,A
                                           ; SOURCE LINE # 372
0011 E4                CLR     A
0012 08                INC     R0
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 116 

0013 F6                MOV     @R0,A
0014         ?C0136:
0014 7800        R     MOV     R0,#LOW i
0016 E6                MOV     A,@R0
0017 FF                MOV     R7,A
0018 C3                CLR     C
0019 9500        R     SUBB    A,len
001B 5031              JNC     ?C0137
                                           ; SOURCE LINE # 373
001D AB00        R     MOV     R3,s
001F AA00        R     MOV     R2,s+01H
0021 A900        R     MOV     R1,s+02H
0023 75F002            MOV     B,#02H
0026 EF                MOV     A,R7
0027 A4                MUL     AB
0028 F582              MOV     DPL,A
002A 85F083            MOV     DPH,B
002D 120000      E     LCALL   ?C?ILDOPTR
0030 FF                MOV     R7,A
0031 AEF0              MOV     R6,B
0033 C3                CLR     C
0034 7800        R     MOV     R0,#LOW min+01H
0036 96                SUBB    A,@R0
0037 18                DEC     R0
0038 E6                MOV     A,@R0
0039 6480              XRL     A,#080H
003B F8                MOV     R0,A
003C EE                MOV     A,R6
003D 6480              XRL     A,#080H
003F 98                SUBB    A,R0
0040 5007              JNC     ?C0138
                                           ; SOURCE LINE # 374
0042 7800        R     MOV     R0,#LOW min
0044 A606              MOV     @R0,AR6
0046 08                INC     R0
0047 A607              MOV     @R0,AR7
                                           ; SOURCE LINE # 375
                                           ; SOURCE LINE # 376
0049         ?C0138:
0049 7800        R     MOV     R0,#LOW i
004B 06                INC     @R0
004C 80C6              SJMP    ?C0136
004E         ?C0137:
                                           ; SOURCE LINE # 377
004E 7800        R     MOV     R0,#LOW min
0050 E6                MOV     A,@R0
0051 FE                MOV     R6,A
0052 08                INC     R0
0053 E6                MOV     A,@R0
0054 FF                MOV     R7,A
                                           ; SOURCE LINE # 378
0055 22                RET     
             ; FUNCTION _MIN (END)

             ; FUNCTION _DADD (BEGIN)
                                           ; SOURCE LINE # 382
0000 8E00        R     MOV     Sa,R6
0002 8F00        R     MOV     Sa+01H,R7
;---- Variable 'Sb' assigned to Register 'R4/R5' ----
;---- Variable 'D' assigned to Register 'DPTR' ----
0004 8B82              MOV     DPL,R3
0006 8A83              MOV     DPH,R2
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 117 

                                           ; SOURCE LINE # 384
0008 E500        R     MOV     A,Sa+01H
000A 25E0              ADD     A,ACC
000C FF                MOV     R7,A
000D E500        R     MOV     A,Sa
000F 33                RLC     A
0010 FE                MOV     R6,A
0011 7400        R     MOV     A,#LOW NVRAM0
0013 2F                ADD     A,R7
0014 F9                MOV     R1,A
0015 7400        R     MOV     A,#HIGH NVRAM0
0017 3E                ADDC    A,R6
0018 750001      R     MOV     tmp0,#01H
001B F500        R     MOV     tmp0+01H,A
001D 8900        R     MOV     tmp0+02H,R1
                                           ; SOURCE LINE # 385
001F ED                MOV     A,R5
0020 25E0              ADD     A,ACC
0022 FF                MOV     R7,A
0023 EC                MOV     A,R4
0024 33                RLC     A
0025 FE                MOV     R6,A
0026 7400        R     MOV     A,#LOW NVRAM0
0028 2F                ADD     A,R7
0029 F9                MOV     R1,A
002A 7400        R     MOV     A,#HIGH NVRAM0
002C 3E                ADDC    A,R6
002D 750001      R     MOV     tmp1,#01H
0030 F500        R     MOV     tmp1+01H,A
0032 8900        R     MOV     tmp1+02H,R1
                                           ; SOURCE LINE # 386
0034 E582              MOV     A,DPL
0036 25E0              ADD     A,ACC
0038 FF                MOV     R7,A
0039 E583              MOV     A,DPH
003B 33                RLC     A
003C FE                MOV     R6,A
003D 7400        R     MOV     A,#LOW NVRAM0
003F 2F                ADD     A,R7
0040 F9                MOV     R1,A
0041 7400        R     MOV     A,#HIGH NVRAM0
0043 3E                ADDC    A,R6
0044 750001      R     MOV     tmp2,#01H
0047 F500        R     MOV     tmp2+01H,A
0049 8900        R     MOV     tmp2+02H,R1
                                           ; SOURCE LINE # 387
004B AB00        R     MOV     R3,tmp1
004D AA00        R     MOV     R2,tmp1+01H
004F A900        R     MOV     R1,tmp1+02H
0051 120000      E     LCALL   ?C?LLDPTR
0054 AB00        R     MOV     R3,tmp0
0056 AA00        R     MOV     R2,tmp0+01H
0058 A900        R     MOV     R1,tmp0+02H
005A 120000      E     LCALL   ?C?LLDPTR0
005D EB                MOV     A,R3
005E 2F                ADD     A,R7
005F FF                MOV     R7,A
0060 EA                MOV     A,R2
0061 3E                ADDC    A,R6
0062 FE                MOV     R6,A
0063 E9                MOV     A,R1
0064 3D                ADDC    A,R5
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 118 

0065 FD                MOV     R5,A
0066 E8                MOV     A,R0
0067 3C                ADDC    A,R4
0068 FC                MOV     R4,A
0069 AB00        R     MOV     R3,tmp2
006B AA00        R     MOV     R2,tmp2+01H
006D A900        R     MOV     R1,tmp2+02H
006F 020000      E     LJMP    ?C?LSTPTR
             ; FUNCTION _DADD (END)

             ; FUNCTION _DSUB (BEGIN)
                                           ; SOURCE LINE # 410
0000 8E00        R     MOV     Sa,R6
0002 8F00        R     MOV     Sa+01H,R7
;---- Variable 'Sb' assigned to Register 'R4/R5' ----
;---- Variable 'D' assigned to Register 'DPTR' ----
0004 8B82              MOV     DPL,R3
0006 8A83              MOV     DPH,R2
                                           ; SOURCE LINE # 412
0008 E500        R     MOV     A,Sa+01H
000A 25E0              ADD     A,ACC
000C FF                MOV     R7,A
000D E500        R     MOV     A,Sa
000F 33                RLC     A
0010 FE                MOV     R6,A
0011 7400        R     MOV     A,#LOW NVRAM0
0013 2F                ADD     A,R7
0014 F9                MOV     R1,A
0015 7400        R     MOV     A,#HIGH NVRAM0
0017 3E                ADDC    A,R6
0018 7800        R     MOV     R0,#LOW tmp0
001A 7601              MOV     @R0,#01H
001C 08                INC     R0
001D F6                MOV     @R0,A
001E 08                INC     R0
001F A601              MOV     @R0,AR1
                                           ; SOURCE LINE # 413
0021 ED                MOV     A,R5
0022 25E0              ADD     A,ACC
0024 FF                MOV     R7,A
0025 EC                MOV     A,R4
0026 33                RLC     A
0027 FE                MOV     R6,A
0028 7400        R     MOV     A,#LOW NVRAM0
002A 2F                ADD     A,R7
002B F9                MOV     R1,A
002C 7400        R     MOV     A,#HIGH NVRAM0
002E 3E                ADDC    A,R6
002F 08                INC     R0
0030 7601              MOV     @R0,#01H
0032 08                INC     R0
0033 F6                MOV     @R0,A
0034 08                INC     R0
0035 A601              MOV     @R0,AR1
                                           ; SOURCE LINE # 414
0037 E582              MOV     A,DPL
0039 25E0              ADD     A,ACC
003B FF                MOV     R7,A
003C E583              MOV     A,DPH
003E 33                RLC     A
003F FE                MOV     R6,A
0040 7400        R     MOV     A,#LOW NVRAM0
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 119 

0042 2F                ADD     A,R7
0043 F9                MOV     R1,A
0044 7400        R     MOV     A,#HIGH NVRAM0
0046 3E                ADDC    A,R6
0047 08                INC     R0
0048 7601              MOV     @R0,#01H
004A 08                INC     R0
004B F6                MOV     @R0,A
004C 08                INC     R0
004D A601              MOV     @R0,AR1
                                           ; SOURCE LINE # 415
004F 7800        R     MOV     R0,#LOW tmp1
0051 8603              MOV     AR3,@R0
0053 08                INC     R0
0054 E6                MOV     A,@R0
0055 FA                MOV     R2,A
0056 08                INC     R0
0057 E6                MOV     A,@R0
0058 F9                MOV     R1,A
0059 120000      E     LCALL   ?C?LLDPTR0
005C C000              PUSH    AR0
005E C001              PUSH    AR1
0060 C002              PUSH    AR2
0062 C003              PUSH    AR3
0064 7800        R     MOV     R0,#LOW tmp0
0066 8603              MOV     AR3,@R0
0068 08                INC     R0
0069 E6                MOV     A,@R0
006A FA                MOV     R2,A
006B 08                INC     R0
006C E6                MOV     A,@R0
006D F9                MOV     R1,A
006E 120000      E     LCALL   ?C?LLDPTR
0071 D003              POP     AR3
0073 D002              POP     AR2
0075 D001              POP     AR1
0077 D000              POP     AR0
0079 C3                CLR     C
007A EF                MOV     A,R7
007B 9B                SUBB    A,R3
007C FF                MOV     R7,A
007D EE                MOV     A,R6
007E 9A                SUBB    A,R2
007F FE                MOV     R6,A
0080 ED                MOV     A,R5
0081 99                SUBB    A,R1
0082 FD                MOV     R5,A
0083 EC                MOV     A,R4
0084 98                SUBB    A,R0
0085 FC                MOV     R4,A
0086 7800        R     MOV     R0,#LOW tmp2
0088 8603              MOV     AR3,@R0
008A 08                INC     R0
008B E6                MOV     A,@R0
008C FA                MOV     R2,A
008D 08                INC     R0
008E E6                MOV     A,@R0
008F F9                MOV     R1,A
0090 020000      E     LJMP    ?C?LSTPTR
             ; FUNCTION _DSUB (END)

             ; FUNCTION wdtInit (BEGIN)
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 120 

                                           ; SOURCE LINE # 418
                                           ; SOURCE LINE # 419
0000 75FF07            MOV     WDTCN,#07H
                                           ; SOURCE LINE # 420
0003 22                RET     
             ; FUNCTION wdtInit (END)

             ; FUNCTION _?wdtEnable (BEGIN)
                                           ; SOURCE LINE # 421
                                           ; SOURCE LINE # 423
0000 75FFA5            MOV     WDTCN,#0A5H
                                           ; SOURCE LINE # 425
0003 22                RET     
             ; FUNCTION _?wdtEnable (END)

             ; FUNCTION _?wdtDisable (BEGIN)
                                           ; SOURCE LINE # 426
0000 1500        E     DEC     ?C_IBP
                                           ; SOURCE LINE # 428
0002 A2AF              MOV     C,EA
0004 E4                CLR     A
0005 33                RLC     A
0006 A800        E     MOV     R0,?C_IBP
0008 F6                MOV     @R0,A
                                           ; SOURCE LINE # 429
0009 C2AF              CLR     EA
                                           ; SOURCE LINE # 430
000B 75FFDE            MOV     WDTCN,#0DEH
                                           ; SOURCE LINE # 431
000E 75FFAD            MOV     WDTCN,#0ADH
                                           ; SOURCE LINE # 432
0011 E6                MOV     A,@R0
0012 24FF              ADD     A,#0FFH
0014 92AF              MOV     EA,C
                                           ; SOURCE LINE # 433
0016 0500        E     INC     ?C_IBP
0018 22                RET     
             ; FUNCTION _?wdtDisable (END)

             ; FUNCTION _?wdtFeed (BEGIN)
                                           ; SOURCE LINE # 434
                                           ; SOURCE LINE # 435
0000 75FFA5            MOV     WDTCN,#0A5H
                                           ; SOURCE LINE # 436
0003 22                RET     
             ; FUNCTION _?wdtFeed (END)

             ; FUNCTION pcaInit (BEGIN)
                                           ; SOURCE LINE # 437
                                           ; SOURCE LINE # 438
0000 22                RET     
             ; FUNCTION pcaInit (END)

             ; FUNCTION timer0Init (BEGIN)
                                           ; SOURCE LINE # 439
                                           ; SOURCE LINE # 441
0000 E4                CLR     A
0001 7800        R     MOV     R0,#LOW TimerCounter_1mS
0003 F6                MOV     @R0,A
                                           ; SOURCE LINE # 442
0004 08                INC     R0
0005 F6                MOV     @R0,A
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 121 

                                           ; SOURCE LINE # 443
0006 08                INC     R0
0007 F6                MOV     @R0,A
                                           ; SOURCE LINE # 444
0008 7800        R     MOV     R0,#LOW temp
000A 76F8              MOV     @R0,#0F8H
000C 08                INC     R0
000D 76CD              MOV     @R0,#0CDH
                                           ; SOURCE LINE # 445
000F 18                DEC     R0
0010 E6                MOV     A,@R0
0011 FE                MOV     R6,A
0012 08                INC     R0
0013 E6                MOV     A,@R0
0014 7800        R     MOV     R0,#LOW Timer0_L
0016 F6                MOV     @R0,A
                                           ; SOURCE LINE # 446
0017 EE                MOV     A,R6
0018 08                INC     R0
0019 F6                MOV     @R0,A
                                           ; SOURCE LINE # 447
001A E6                MOV     A,@R0
001B F58C              MOV     TH0,A
                                           ; SOURCE LINE # 448
001D 18                DEC     R0
001E E6                MOV     A,@R0
001F F58A              MOV     TL0,A
                                           ; SOURCE LINE # 449
0021 538EF7            ANL     CKCON,#0F7H
                                           ; SOURCE LINE # 450
0024 5389F0            ANL     TMOD,#0F0H
                                           ; SOURCE LINE # 451
0027 438901            ORL     TMOD,#01H
                                           ; SOURCE LINE # 452
002A D2A9              SETB    ET0
                                           ; SOURCE LINE # 453
002C D28C              SETB    TR0
                                           ; SOURCE LINE # 454
002E 22                RET     
             ; FUNCTION timer0Init (END)

             ; FUNCTION timer0Isr (BEGIN)
0000 C0E0              PUSH    ACC
0002 C0F0              PUSH    B
0004 C083              PUSH    DPH
0006 C082              PUSH    DPL
0008 C0D0              PUSH    PSW
000A 75D000            MOV     PSW,#00H
000D C000              PUSH    AR0
000F C001              PUSH    AR1
0011 C002              PUSH    AR2
0013 C003              PUSH    AR3
0015 C004              PUSH    AR4
0017 C005              PUSH    AR5
0019 C006              PUSH    AR6
001B C007              PUSH    AR7
                                           ; SOURCE LINE # 455
                                           ; SOURCE LINE # 458
001D C28D              CLR     TF0
                                           ; SOURCE LINE # 459
001F C28C              CLR     TR0
                                           ; SOURCE LINE # 460
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 122 

0021 7800        R     MOV     R0,#LOW Timer0_H
0023 E6                MOV     A,@R0
0024 F58C              MOV     TH0,A
                                           ; SOURCE LINE # 461
0026 18                DEC     R0
0027 E6                MOV     A,@R0
0028 F58A              MOV     TL0,A
                                           ; SOURCE LINE # 462
002A D28C              SETB    TR0
                                           ; SOURCE LINE # 463
002C 7E0E              MOV     R6,#0EH
002E 7FE2              MOV     R7,#0E2H
0030 120000      R     LCALL   _?LD
0033 EF                MOV     A,R7
0034 7E0E              MOV     R6,#0EH
0036 7FE2              MOV     R7,#0E2H
0038 6005              JZ      ?C0149
                                           ; SOURCE LINE # 464
003A 120000      R     LCALL   _?RES
                                           ; SOURCE LINE # 465
003D 8003              SJMP    ?C0150
003F         ?C0149:
                                           ; SOURCE LINE # 466
                                           ; SOURCE LINE # 467
003F 120000      R     LCALL   _?SET
                                           ; SOURCE LINE # 468
0042         ?C0150:
                                           ; SOURCE LINE # 469
0042 7800        R     MOV     R0,#LOW i
0044 7600              MOV     @R0,#00H
0046 08                INC     R0
0047 76A3              MOV     @R0,#0A3H
0049         ?C0151:
0049 7800        R     MOV     R0,#LOW i
004B E6                MOV     A,@R0
004C FE                MOV     R6,A
004D 08                INC     R0
004E E6                MOV     A,@R0
004F FF                MOV     R7,A
0050 D3                SETB    C
0051 94B2              SUBB    A,#0B2H
0053 EE                MOV     A,R6
0054 9400              SUBB    A,#00H
0056 503A              JNC     ?C0152
                                           ; SOURCE LINE # 470
0058 EF                MOV     A,R7
0059 25E0              ADD     A,ACC
005B FF                MOV     R7,A
005C EE                MOV     A,R6
005D 33                RLC     A
005E FE                MOV     R6,A
005F 7400        R     MOV     A,#LOW NVRAM0
0061 2F                ADD     A,R7
0062 F582              MOV     DPL,A
0064 7400        R     MOV     A,#HIGH NVRAM0
0066 3E                ADDC    A,R6
0067 F583              MOV     DPH,A
0069 E0                MOVX    A,@DPTR
006A FC                MOV     R4,A
006B A3                INC     DPTR
006C E0                MOVX    A,@DPTR
006D C3                CLR     C
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 123 

006E 94FF              SUBB    A,#0FFH
0070 EC                MOV     A,R4
0071 6480              XRL     A,#080H
0073 94FF              SUBB    A,#0FFH
0075 5011              JNC     ?C0153
                                           ; SOURCE LINE # 471
0077 7400        R     MOV     A,#LOW NVRAM0
0079 2F                ADD     A,R7
007A F582              MOV     DPL,A
007C 7400        R     MOV     A,#HIGH NVRAM0
007E 3E                ADDC    A,R6
007F F583              MOV     DPH,A
0081 E4                CLR     A
0082 75F001            MOV     B,#01H
0085 120000      E     LCALL   ?C?IILDX
                                           ; SOURCE LINE # 472
                                           ; SOURCE LINE # 473
0088         ?C0153:
0088 7800        R     MOV     R0,#LOW i+01H
008A 06                INC     @R0
008B E6                MOV     A,@R0
008C 18                DEC     R0
008D 70BA              JNZ     ?C0151
008F 06                INC     @R0
0090         ?C0253:
0090 80B7              SJMP    ?C0151
0092         ?C0152:
                                           ; SOURCE LINE # 474
0092 7800        R     MOV     R0,#LOW TimerCounter_1mS
0094 E6                MOV     A,@R0
0095 C3                CLR     C
0096 940A              SUBB    A,#0AH
0098 7480              MOV     A,#080H
009A 9480              SUBB    A,#080H
009C 406C              JC      ?C0155
                                           ; SOURCE LINE # 475
009E 7E0E              MOV     R6,#0EH
00A0 7FE3              MOV     R7,#0E3H
00A2 120000      R     LCALL   _?LD
00A5 EF                MOV     A,R7
00A6 7E0E              MOV     R6,#0EH
00A8 7FE3              MOV     R7,#0E3H
00AA 6005              JZ      ?C0156
                                           ; SOURCE LINE # 476
00AC 120000      R     LCALL   _?RES
                                           ; SOURCE LINE # 477
00AF 8003              SJMP    ?C0157
00B1         ?C0156:
                                           ; SOURCE LINE # 478
                                           ; SOURCE LINE # 479
00B1 120000      R     LCALL   _?SET
                                           ; SOURCE LINE # 480
00B4         ?C0157:
                                           ; SOURCE LINE # 481
00B4 7800        R     MOV     R0,#LOW i
00B6 7600              MOV     @R0,#00H
00B8 08                INC     R0
00B9 76B3              MOV     @R0,#0B3H
00BB         ?C0158:
00BB 7800        R     MOV     R0,#LOW i
00BD E6                MOV     A,@R0
00BE FE                MOV     R6,A
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 124 

00BF 08                INC     R0
00C0 E6                MOV     A,@R0
00C1 FF                MOV     R7,A
00C2 D3                SETB    C
00C3 94C2              SUBB    A,#0C2H
00C5 EE                MOV     A,R6
00C6 9400              SUBB    A,#00H
00C8 503A              JNC     ?C0159
                                           ; SOURCE LINE # 482
00CA EF                MOV     A,R7
00CB 25E0              ADD     A,ACC
00CD FF                MOV     R7,A
00CE EE                MOV     A,R6
00CF 33                RLC     A
00D0 FE                MOV     R6,A
00D1 7400        R     MOV     A,#LOW NVRAM0
00D3 2F                ADD     A,R7
00D4 F582              MOV     DPL,A
00D6 7400        R     MOV     A,#HIGH NVRAM0
00D8 3E                ADDC    A,R6
00D9 F583              MOV     DPH,A
00DB E0                MOVX    A,@DPTR
00DC FC                MOV     R4,A
00DD A3                INC     DPTR
00DE E0                MOVX    A,@DPTR
00DF C3                CLR     C
00E0 94FF              SUBB    A,#0FFH
00E2 EC                MOV     A,R4
00E3 6480              XRL     A,#080H
00E5 94FF              SUBB    A,#0FFH
00E7 5011              JNC     ?C0160
                                           ; SOURCE LINE # 483
00E9 7400        R     MOV     A,#LOW NVRAM0
00EB 2F                ADD     A,R7
00EC F582              MOV     DPL,A
00EE 7400        R     MOV     A,#HIGH NVRAM0
00F0 3E                ADDC    A,R6
00F1 F583              MOV     DPH,A
00F3 E4                CLR     A
00F4 75F001            MOV     B,#01H
00F7 120000      E     LCALL   ?C?IILDX
                                           ; SOURCE LINE # 484
                                           ; SOURCE LINE # 485
00FA         ?C0160:
00FA 7800        R     MOV     R0,#LOW i+01H
00FC 06                INC     @R0
00FD E6                MOV     A,@R0
00FE 18                DEC     R0
00FF 70BA              JNZ     ?C0158
0101 06                INC     @R0
0102         ?C0254:
0102 80B7              SJMP    ?C0158
0104         ?C0159:
                                           ; SOURCE LINE # 486
0104 7800        R     MOV     R0,#LOW TimerCounter_10mS
0106 06                INC     @R0
                                           ; SOURCE LINE # 487
0107 18                DEC     R0
0108 7600              MOV     @R0,#00H
                                           ; SOURCE LINE # 488
010A         ?C0155:
                                           ; SOURCE LINE # 489
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 125 

010A 7800        R     MOV     R0,#LOW TimerCounter_10mS
010C E6                MOV     A,@R0
010D C3                CLR     C
010E 940A              SUBB    A,#0AH
0110 7480              MOV     A,#080H
0112 9480              SUBB    A,#080H
0114 4076              JC      ?C0162
                                           ; SOURCE LINE # 490
0116 7E0E              MOV     R6,#0EH
0118 7FE4              MOV     R7,#0E4H
011A 120000      R     LCALL   _?LD
011D EF                MOV     A,R7
011E 7E0E              MOV     R6,#0EH
0120 7FE4              MOV     R7,#0E4H
0122 6005              JZ      ?C0163
                                           ; SOURCE LINE # 491
0124 120000      R     LCALL   _?RES
                                           ; SOURCE LINE # 492
0127 8003              SJMP    ?C0164
0129         ?C0163:
                                           ; SOURCE LINE # 493
                                           ; SOURCE LINE # 494
0129 120000      R     LCALL   _?SET
                                           ; SOURCE LINE # 495
012C         ?C0164:
                                           ; SOURCE LINE # 496
012C 7800        R     MOV     R0,#LOW i
012E 7600              MOV     @R0,#00H
0130 08                INC     R0
0131 76C3              MOV     @R0,#0C3H
0133         ?C0165:
0133 7800        R     MOV     R0,#LOW i
0135 E6                MOV     A,@R0
0136 FE                MOV     R6,A
0137 08                INC     R0
0138 E6                MOV     A,@R0
0139 FF                MOV     R7,A
013A C3                CLR     C
013B 94D2              SUBB    A,#0D2H
013D EE                MOV     A,R6
013E 9400              SUBB    A,#00H
0140 503A              JNC     ?C0166
                                           ; SOURCE LINE # 497
0142 EF                MOV     A,R7
0143 25E0              ADD     A,ACC
0145 FF                MOV     R7,A
0146 EE                MOV     A,R6
0147 33                RLC     A
0148 FE                MOV     R6,A
0149 7400        R     MOV     A,#LOW NVRAM0
014B 2F                ADD     A,R7
014C F582              MOV     DPL,A
014E 7400        R     MOV     A,#HIGH NVRAM0
0150 3E                ADDC    A,R6
0151 F583              MOV     DPH,A
0153 E0                MOVX    A,@DPTR
0154 FC                MOV     R4,A
0155 A3                INC     DPTR
0156 E0                MOVX    A,@DPTR
0157 C3                CLR     C
0158 94FF              SUBB    A,#0FFH
015A EC                MOV     A,R4
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 126 

015B 6480              XRL     A,#080H
015D 94FF              SUBB    A,#0FFH
015F 5011              JNC     ?C0167
                                           ; SOURCE LINE # 498
0161 7400        R     MOV     A,#LOW NVRAM0
0163 2F                ADD     A,R7
0164 F582              MOV     DPL,A
0166 7400        R     MOV     A,#HIGH NVRAM0
0168 3E                ADDC    A,R6
0169 F583              MOV     DPH,A
016B E4                CLR     A
016C 75F001            MOV     B,#01H
016F 120000      E     LCALL   ?C?IILDX
                                           ; SOURCE LINE # 499
                                           ; SOURCE LINE # 500
0172         ?C0167:
0172 7800        R     MOV     R0,#LOW i+01H
0174 06                INC     @R0
0175 E6                MOV     A,@R0
0176 18                DEC     R0
0177 70BA              JNZ     ?C0165
0179 06                INC     @R0
017A         ?C0255:
017A 80B7              SJMP    ?C0165
017C         ?C0166:
                                           ; SOURCE LINE # 501
017C 7800        R     MOV     R0,#LOW TimerCounter_100mS
017E 06                INC     @R0
                                           ; SOURCE LINE # 502
017F 18                DEC     R0
0180 7600              MOV     @R0,#00H
                                           ; SOURCE LINE # 503
0182 7E0E              MOV     R6,#0EH
0184 7FE4              MOV     R7,#0E4H
0186 120000      R     LCALL   _?LD
0189 120000      R     LCALL   _setLedRun
                                           ; SOURCE LINE # 504
018C         ?C0162:
                                           ; SOURCE LINE # 505
018C 7800        R     MOV     R0,#LOW TimerCounter_100mS
018E E6                MOV     A,@R0
018F C3                CLR     C
0190 940A              SUBB    A,#0AH
0192 7480              MOV     A,#080H
0194 9480              SUBB    A,#080H
0196 5003              JNC     $ + 5H
0198 020000      R     LJMP    ?C0169
                                           ; SOURCE LINE # 506
019B 7E0E              MOV     R6,#0EH
019D 7FE5              MOV     R7,#0E5H
019F 120000      R     LCALL   _?LD
01A2 EF                MOV     A,R7
01A3 7E0E              MOV     R6,#0EH
01A5 7FE5              MOV     R7,#0E5H
01A7 6005              JZ      ?C0170
                                           ; SOURCE LINE # 507
01A9 120000      R     LCALL   _?RES
                                           ; SOURCE LINE # 508
01AC 8003              SJMP    ?C0171
01AE         ?C0170:
                                           ; SOURCE LINE # 509
                                           ; SOURCE LINE # 510
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 127 

01AE 120000      R     LCALL   _?SET
                                           ; SOURCE LINE # 511
01B1         ?C0171:
                                           ; SOURCE LINE # 512
01B1 7800        R     MOV     R0,#LOW tmp
01B3 120000      E     LCALL   ?C?LSTKIDATA
01B6 00                DB      00H
01B7 00                DB      00H
01B8 00                DB      00H
01B9 00                DB      00H
                                           ; SOURCE LINE # 513
01BA 900000      R     MOV     DPTR,#NVRAM0+01AEH
01BD E0                MOVX    A,@DPTR
01BE FE                MOV     R6,A
01BF A3                INC     DPTR
01C0 E0                MOVX    A,@DPTR
01C1 FF                MOV     R7,A
01C2 EE                MOV     A,R6
01C3 33                RLC     A
01C4 95E0              SUBB    A,ACC
01C6 FD                MOV     R5,A
01C7 FC                MOV     R4,A
01C8 E4                CLR     A
01C9 FB                MOV     R3,A
01CA FA                MOV     R2,A
01CB 7901              MOV     R1,#01H
01CD F8                MOV     R0,A
01CE 120000      E     LCALL   ?C?LMUL
01D1 A804              MOV     R0,AR4
01D3 A905              MOV     R1,AR5
01D5 AA06              MOV     R2,AR6
01D7 AB07              MOV     R3,AR7
01D9 900000      R     MOV     DPTR,#NVRAM0+01ACH
01DC E0                MOVX    A,@DPTR
01DD FE                MOV     R6,A
01DE A3                INC     DPTR
01DF E0                MOVX    A,@DPTR
01E0 FF                MOV     R7,A
01E1 EE                MOV     A,R6
01E2 33                RLC     A
01E3 95E0              SUBB    A,ACC
01E5 FD                MOV     R5,A
01E6 FC                MOV     R4,A
01E7 EB                MOV     A,R3
01E8 2F                ADD     A,R7
01E9 FF                MOV     R7,A
01EA EA                MOV     A,R2
01EB 3E                ADDC    A,R6
01EC FE                MOV     R6,A
01ED E9                MOV     A,R1
01EE 3D                ADDC    A,R5
01EF FD                MOV     R5,A
01F0 E8                MOV     A,R0
01F1 3C                ADDC    A,R4
01F2 FC                MOV     R4,A
01F3 7800        R     MOV     R0,#LOW tmp
01F5 120000      E     LCALL   ?C?LSTIDATA
                                           ; SOURCE LINE # 514
01F8 7800        R     MOV     R0,#LOW tmp
01FA 120000      E     LCALL   ?C?LLDIDATA
01FD EF                MOV     A,R7
01FE 2401              ADD     A,#01H
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 128 

0200 FF                MOV     R7,A
0201 E4                CLR     A
0202 3E                ADDC    A,R6
0203 FE                MOV     R6,A
0204 E4                CLR     A
0205 3D                ADDC    A,R5
0206 FD                MOV     R5,A
0207 E4                CLR     A
0208 3C                ADDC    A,R4
0209 FC                MOV     R4,A
020A 7800        R     MOV     R0,#LOW tmp
020C 120000      E     LCALL   ?C?LSTIDATA
                                           ; SOURCE LINE # 515
020F 7800        R     MOV     R0,#LOW tmp
0211 120000      E     LCALL   ?C?LLDIDATA
0214 7810              MOV     R0,#010H
0216 120000      E     LCALL   ?C?ULSHR
0219 900000      R     MOV     DPTR,#NVRAM0+01AEH
021C EE                MOV     A,R6
021D F0                MOVX    @DPTR,A
021E A3                INC     DPTR
021F EF                MOV     A,R7
0220 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 516
0221 7800        R     MOV     R0,#LOW tmp
0223 120000      E     LCALL   ?C?LLDIDATA
0226 900000      R     MOV     DPTR,#NVRAM0+01ACH
0229 EE                MOV     A,R6
022A F0                MOVX    @DPTR,A
022B A3                INC     DPTR
022C EF                MOV     A,R7
022D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 517
022E 7800        R     MOV     R0,#LOW TimerCounter_100mS
0230 7600              MOV     @R0,#00H
                                           ; SOURCE LINE # 518
0232         ?C0169:
                                           ; SOURCE LINE # 520
0232 120000      E     LCALL   chipAdcProcess
                                           ; SOURCE LINE # 522
0235 7800        R     MOV     R0,#LOW TimerCounter_1mS
0237 06                INC     @R0
                                           ; SOURCE LINE # 523
0238 D007              POP     AR7
023A D006              POP     AR6
023C D005              POP     AR5
023E D004              POP     AR4
0240 D003              POP     AR3
0242 D002              POP     AR2
0244 D001              POP     AR1
0246 D000              POP     AR0
0248 D0D0              POP     PSW
024A D082              POP     DPL
024C D083              POP     DPH
024E D0F0              POP     B
0250 D0E0              POP     ACC
0252 32                RETI    
             ; FUNCTION timer0Isr (END)

             ; FUNCTION inputInit (BEGIN)
                                           ; SOURCE LINE # 524
                                           ; SOURCE LINE # 525
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 129 

0000 7E00              MOV     R6,#00H
0002 7F10              MOV     R7,#010H
0004 7D00              MOV     R5,#00H
0006 7B00              MOV     R3,#00H
0008 7A00        R     MOV     R2,#HIGH inputFilter
000A 7900        R     MOV     R1,#LOW inputFilter
000C 020000      E     LJMP    ?C?MEMSET
             ; FUNCTION inputInit (END)

             ; FUNCTION outputInit (BEGIN)
                                           ; SOURCE LINE # 527
                                           ; SOURCE LINE # 531
0000 22                RET     
             ; FUNCTION outputInit (END)

             ; FUNCTION inputRefresh (BEGIN)
                                           ; SOURCE LINE # 532
                                           ; SOURCE LINE # 534
0000 E586              MOV     A,P6
0002 C4                SWAP    A
0003 13                RRC     A
0004 13                RRC     A
0005 13                RRC     A
0006 5401              ANL     A,#01H
0008 7800        R     MOV     R0,#LOW ctemp0
000A F6                MOV     @R0,A
                                           ; SOURCE LINE # 535
000B E6                MOV     A,@R0
000C 601F              JZ      ?C0175
                                           ; SOURCE LINE # 536
000E 7800        R     MOV     R0,#LOW inputFilter
0010 E6                MOV     A,@R0
0011 FF                MOV     R7,A
0012 33                RLC     A
0013 95E0              SUBB    A,ACC
0015 FE                MOV     R6,A
0016 C3                CLR     C
0017 EF                MOV     A,R7
0018 9403              SUBB    A,#03H
001A EE                MOV     A,R6
001B 6480              XRL     A,#080H
001D 9480              SUBB    A,#080H
001F 5003              JNC     ?C0176
                                           ; SOURCE LINE # 537
0021 06                INC     @R0
                                           ; SOURCE LINE # 538
0022 8026              SJMP    ?C0178
0024         ?C0176:
                                           ; SOURCE LINE # 539
                                           ; SOURCE LINE # 540
0024 900000      R     MOV     DPTR,#NVRAM0+01A9H
0027 E0                MOVX    A,@DPTR
0028 4401              ORL     A,#01H
002A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 541
                                           ; SOURCE LINE # 542
002B 801D              SJMP    ?C0178
002D         ?C0175:
                                           ; SOURCE LINE # 543
                                           ; SOURCE LINE # 544
002D 7800        R     MOV     R0,#LOW inputFilter
002F E6                MOV     A,@R0
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 130 

0030 FF                MOV     R7,A
0031 33                RLC     A
0032 95E0              SUBB    A,ACC
0034 FE                MOV     R6,A
0035 D3                SETB    C
0036 EF                MOV     A,R7
0037 94FD              SUBB    A,#0FDH
0039 EE                MOV     A,R6
003A 6480              XRL     A,#080H
003C 947F              SUBB    A,#07FH
003E 4003              JC      ?C0179
                                           ; SOURCE LINE # 545
0040 16                DEC     @R0
                                           ; SOURCE LINE # 546
0041 8007              SJMP    ?C0178
0043         ?C0179:
                                           ; SOURCE LINE # 547
                                           ; SOURCE LINE # 548
0043 900000      R     MOV     DPTR,#NVRAM0+01A9H
0046 E0                MOVX    A,@DPTR
0047 54FE              ANL     A,#0FEH
0049 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 549
                                           ; SOURCE LINE # 550
004A         ?C0178:
                                           ; SOURCE LINE # 551
004A E586              MOV     A,P6
004C C4                SWAP    A
004D 13                RRC     A
004E 13                RRC     A
004F 5401              ANL     A,#01H
0051 7800        R     MOV     R0,#LOW ctemp0
0053 F6                MOV     @R0,A
                                           ; SOURCE LINE # 552
0054 E6                MOV     A,@R0
0055 601D              JZ      ?C0181
                                           ; SOURCE LINE # 553
0057 7800        R     MOV     R0,#LOW inputFilter+01H
0059 E6                MOV     A,@R0
005A FF                MOV     R7,A
005B 33                RLC     A
005C 95E0              SUBB    A,ACC
005E FE                MOV     R6,A
005F C3                CLR     C
0060 EF                MOV     A,R7
0061 9403              SUBB    A,#03H
0063 EE                MOV     A,R6
0064 6480              XRL     A,#080H
0066 9480              SUBB    A,#080H
0068 5002              JNC     ?C0182
                                           ; SOURCE LINE # 554
006A 06                INC     @R0
                                           ; SOURCE LINE # 555
006B 22                RET     
006C         ?C0182:
                                           ; SOURCE LINE # 556
                                           ; SOURCE LINE # 557
006C 900000      R     MOV     DPTR,#NVRAM0+01A9H
006F E0                MOVX    A,@DPTR
0070 4402              ORL     A,#02H
0072 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 558
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 131 

                                           ; SOURCE LINE # 559
0073 22                RET     
0074         ?C0181:
                                           ; SOURCE LINE # 560
                                           ; SOURCE LINE # 561
0074 7800        R     MOV     R0,#LOW inputFilter+01H
0076 E6                MOV     A,@R0
0077 FF                MOV     R7,A
0078 33                RLC     A
0079 95E0              SUBB    A,ACC
007B FE                MOV     R6,A
007C D3                SETB    C
007D EF                MOV     A,R7
007E 94FD              SUBB    A,#0FDH
0080 EE                MOV     A,R6
0081 6480              XRL     A,#080H
0083 947F              SUBB    A,#07FH
0085 4002              JC      ?C0185
                                           ; SOURCE LINE # 562
0087 16                DEC     @R0
                                           ; SOURCE LINE # 563
0088 22                RET     
0089         ?C0185:
                                           ; SOURCE LINE # 564
                                           ; SOURCE LINE # 565
0089 900000      R     MOV     DPTR,#NVRAM0+01A9H
008C E0                MOVX    A,@DPTR
008D 54FD              ANL     A,#0FDH
008F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 566
                                           ; SOURCE LINE # 567
                                           ; SOURCE LINE # 568
0090         ?C0187:
0090 22                RET     
             ; FUNCTION inputRefresh (END)

             ; FUNCTION outputRefresh (BEGIN)
                                           ; SOURCE LINE # 569
                                           ; SOURCE LINE # 570
0000 900000      R     MOV     DPTR,#NVRAM0+01ABH
0003 E0                MOVX    A,@DPTR
0004 30E005            JNB     ACC.0,?C0188
                                           ; SOURCE LINE # 571
0007 438620            ORL     P6,#020H
                                           ; SOURCE LINE # 572
000A 8003              SJMP    ?C0189
000C         ?C0188:
                                           ; SOURCE LINE # 573
                                           ; SOURCE LINE # 574
000C 5386DF            ANL     P6,#0DFH
                                           ; SOURCE LINE # 575
000F         ?C0189:
                                           ; SOURCE LINE # 576
000F 900000      R     MOV     DPTR,#NVRAM0+01AAH
0012 E0                MOVX    A,@DPTR
0013 A2E7              MOV     C,ACC.7
0015 13                RRC     A
0016 A3                INC     DPTR
0017 E0                MOVX    A,@DPTR
0018 13                RRC     A
0019 30E004            JNB     ACC.0,?C0190
                                           ; SOURCE LINE # 577
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 132 

001C 438610            ORL     P6,#010H
                                           ; SOURCE LINE # 578
001F 22                RET     
0020         ?C0190:
                                           ; SOURCE LINE # 579
                                           ; SOURCE LINE # 580
0020 5386EF            ANL     P6,#0EFH
                                           ; SOURCE LINE # 581
                                           ; SOURCE LINE # 582
0023         ?C0192:
0023 22                RET     
             ; FUNCTION outputRefresh (END)

             ; FUNCTION sPlcInit (BEGIN)
                                           ; SOURCE LINE # 583
                                           ; SOURCE LINE # 584
0000 7F01              MOV     R7,#01H
0002 120000      R     LCALL   _setLedError
                                           ; SOURCE LINE # 585
0005 120000      R     LCALL   _setLedRun
                                           ; SOURCE LINE # 586
0008 120000      R     LCALL   _setLedDac
                                           ; SOURCE LINE # 587
000B 120000      R     LCALL   _setLedEprom
                                           ; SOURCE LINE # 588
000E 120000      R     LCALL   wdtInit
                                           ; SOURCE LINE # 589
0011 120000      R     LCALL   _?wdtDisable
                                           ; SOURCE LINE # 591
0014 7F80              MOV     R7,#080H
0016 7E25              MOV     R6,#025H
0018 7D00              MOV     R5,#00H
001A 7C00              MOV     R4,#00H
001C 120000      E     LCALL   _initUart1
                                           ; SOURCE LINE # 594
001F 120000      R     LCALL   loadNvram
                                           ; SOURCE LINE # 597
0022 120000      E     LCALL   initChipAdc
                                           ; SOURCE LINE # 600
0025 120000      E     LCALL   initChipDac
                                           ; SOURCE LINE # 603
0028 750000      E     MOV     ?_initModbus?BYTE+04H,#00H
002B 7500C2      E     MOV     ?_initModbus?BYTE+03H,#0C2H
002E 750001      E     MOV     ?_initModbus?BYTE+02H,#01H
0031 750000      E     MOV     ?_initModbus?BYTE+01H,#00H
0034 7F01              MOV     R7,#01H
0036 120000      E     LCALL   _initModbus
                                           ; SOURCE LINE # 605
0039 120000      R     LCALL   timer0Init
                                           ; SOURCE LINE # 606
003C 7E0E              MOV     R6,#0EH
003E 7FE0              MOV     R7,#0E0H
0040 120000      R     LCALL   _?SET
                                           ; SOURCE LINE # 607
0043 7F01              MOV     R7,#01H
0045 120000      R     LCALL   _setLedError
                                           ; SOURCE LINE # 608
0048 7E0E              MOV     R6,#0EH
004A 7FE0              MOV     R7,#0E0H
004C 120000      R     LCALL   _?SET
                                           ; SOURCE LINE # 609
004F 7E0E              MOV     R6,#0EH
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 133 

0051 7FE1              MOV     R7,#0E1H
0053 120000      R     LCALL   _?SET
                                           ; SOURCE LINE # 610
0056 900000      R     MOV     DPTR,#NVRAM0+013EH
0059 740A              MOV     A,#0AH
005B F0                MOVX    @DPTR,A
005C A3                INC     DPTR
005D 7401              MOV     A,#01H
005F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 611
0060 22                RET     
             ; FUNCTION sPlcInit (END)

             ; FUNCTION sPlcProcessStart (BEGIN)
                                           ; SOURCE LINE # 612
                                           ; SOURCE LINE # 614
0000 900000      R     MOV     DPTR,#NVRAM0+01DAH
0003 E0                MOVX    A,@DPTR
0004 64A5              XRL     A,#0A5H
0006 7004              JNZ     ?C0256
0008 A3                INC     DPTR
0009 E0                MOVX    A,@DPTR
000A 648E              XRL     A,#08EH
000C         ?C0256:
000C 7058              JNZ     ?C0194
                                           ; SOURCE LINE # 615
000E C2AF              CLR     EA
                                           ; SOURCE LINE # 616
0010 FF                MOV     R7,A
0011 120000      R     LCALL   _setLedRun
                                           ; SOURCE LINE # 617
0014 120000      R     LCALL   _setLedEprom
                                           ; SOURCE LINE # 618
0017 120000      E     LCALL   epromTest
001A EF                MOV     A,R7
001B 6008              JZ      ?C0195
                                           ; SOURCE LINE # 619
001D 7F01              MOV     R7,#01H
001F 120000      R     LCALL   _setLedEprom
                                           ; SOURCE LINE # 620
0022 1F                DEC     R7
                                           ; SOURCE LINE # 621
                                           ; SOURCE LINE # 622
                                           ; SOURCE LINE # 623
0023 802E              SJMP    ?C0261
0025         ?C0195:
                                           ; SOURCE LINE # 624
                                           ; SOURCE LINE # 625
0025 7F01              MOV     R7,#01H
0027 120000      R     LCALL   _setLedEprom
                                           ; SOURCE LINE # 626
002A 1F                DEC     R7
002B 120000      R     LCALL   _setLedError
                                           ; SOURCE LINE # 627
002E 7FF4              MOV     R7,#0F4H
0030 120000      E     LCALL   _?delayMs
                                           ; SOURCE LINE # 628
0033 7F01              MOV     R7,#01H
0035 120000      R     LCALL   _setLedError
                                           ; SOURCE LINE # 629
0038 7FF4              MOV     R7,#0F4H
003A 120000      E     LCALL   _?delayMs
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 134 

                                           ; SOURCE LINE # 630
003D E4                CLR     A
003E FF                MOV     R7,A
003F 120000      R     LCALL   _setLedError
                                           ; SOURCE LINE # 631
0042 7FF4              MOV     R7,#0F4H
0044 120000      E     LCALL   _?delayMs
                                           ; SOURCE LINE # 632
0047 7F01              MOV     R7,#01H
0049 120000      R     LCALL   _setLedError
                                           ; SOURCE LINE # 633
004C 7FF4              MOV     R7,#0F4H
004E 120000      E     LCALL   _?delayMs
                                           ; SOURCE LINE # 634
0051 E4                CLR     A
0052 FF                MOV     R7,A
0053         ?C0261:
0053 120000      R     LCALL   _setLedError
                                           ; SOURCE LINE # 635
0056 7FF4              MOV     R7,#0F4H
0058 120000      E     LCALL   _?delayMs
                                           ; SOURCE LINE # 636
005B 7F01              MOV     R7,#01H
005D 120000      R     LCALL   _setLedError
                                           ; SOURCE LINE # 637
0060         ?C0196:
                                           ; SOURCE LINE # 638
0060 120000      R     LCALL   clearNvram
                                           ; SOURCE LINE # 639
0063 120000      R     LCALL   _?REBOOT
                                           ; SOURCE LINE # 640
0066         ?C0194:
                                           ; SOURCE LINE # 643
0066 120000      R     LCALL   _?wdtFeed
                                           ; SOURCE LINE # 646
0069 120000      E     LCALL   modbusPorcess
                                           ; SOURCE LINE # 649
006C 120000      R     LCALL   inputRefresh
                                           ; SOURCE LINE # 652
006F 020000      R     LJMP    _?wdtFeed
             ; FUNCTION sPlcProcessStart (END)

             ; FUNCTION sPlcProcessEnd (BEGIN)
                                           ; SOURCE LINE # 655
                                           ; SOURCE LINE # 657
0000 120000      R     LCALL   _?wdtFeed
                                           ; SOURCE LINE # 660
0003 120000      R     LCALL   outputRefresh
                                           ; SOURCE LINE # 663
0006 120000      E     LCALL   refreshDac
                                           ; SOURCE LINE # 666
0009 120000      R     LCALL   updataNvram
                                           ; SOURCE LINE # 669
000C 120000      R     LCALL   _?wdtFeed
                                           ; SOURCE LINE # 671
000F 7E0E              MOV     R6,#0EH
0011 7FE1              MOV     R7,#0E1H
0013 020000      R     LJMP    _?RES
             ; FUNCTION sPlcProcessEnd (END)

C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 135 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


uint8_t. . . . . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
uint16_t . . . . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
uint32_t . . . . . . . . . . . . . . .  TYPEDEF  -----  U_LONG   -----  4
uint64_t . . . . . . . . . . . . . . .  TYPEDEF  -----  ARRAY    -----  8
int8_t . . . . . . . . . . . . . . . .  TYPEDEF  -----  CHAR     -----  1
int16_t. . . . . . . . . . . . . . . .  TYPEDEF  -----  INT      -----  2
int32_t. . . . . . . . . . . . . . . .  TYPEDEF  -----  LONG     -----  4
int64_t. . . . . . . . . . . . . . . .  TYPEDEF  -----  ARRAY    -----  8
fp32_t . . . . . . . . . . . . . . . .  TYPEDEF  -----  FLOAT    -----  4
fp64_t . . . . . . . . . . . . . . . .  TYPEDEF  -----  FLOAT    -----  4
bool . . . . . . . . . . . . . . . . .  TYPEDEF  -----  BIT      -----  1
false. . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
true . . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
SI_UU16. . . . . . . . . . . . . . . .  * TAG *  -----  UNION    -----  2
  u16. . . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0000H  2
  s16. . . . . . . . . . . . . . . . .  MEMBER   -----  INT      0000H  2
  u8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
  s8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
SI_UU16_t. . . . . . . . . . . . . . .  TYPEDEF  -----  UNION    -----  2
  u16. . . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0000H  2
  s16. . . . . . . . . . . . . . . . .  MEMBER   -----  INT      0000H  2
  u8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
  s8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
SI_UU32. . . . . . . . . . . . . . . .  * TAG *  -----  UNION    -----  4
  u32. . . . . . . . . . . . . . . . .  MEMBER   -----  U_LONG   0000H  4
  s32. . . . . . . . . . . . . . . . .  MEMBER   -----  LONG     0000H  4
  uu16 . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  u16. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  s16. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  u8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  s8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
SI_UU32_t. . . . . . . . . . . . . . .  TYPEDEF  -----  UNION    -----  4
  u32. . . . . . . . . . . . . . . . .  MEMBER   -----  U_LONG   0000H  4
  s32. . . . . . . . . . . . . . . . .  MEMBER   -----  LONG     0000H  4
  uu16 . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  u16. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  s16. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  u8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  s8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
GPTR_t . . . . . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  3
  memtype. . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  address. . . . . . . . . . . . . . .  MEMBER   -----  UNION    0001H  2
SI_GEN_PTR . . . . . . . . . . . . . .  * TAG *  -----  UNION    -----  3
  u8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  3
  gptr . . . . . . . . . . . . . . . .  MEMBER   -----  STRUCT   0000H  3
SI_GEN_PTR_t . . . . . . . . . . . . .  TYPEDEF  -----  UNION    -----  3
  u8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  3
  gptr . . . . . . . . . . . . . . . .  MEMBER   -----  STRUCT   0000H  3
U8 . . . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
U16. . . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
U32. . . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_LONG   -----  4
S8 . . . . . . . . . . . . . . . . . .  TYPEDEF  -----  CHAR     -----  1
S16. . . . . . . . . . . . . . . . . .  TYPEDEF  -----  INT      -----  2
S32. . . . . . . . . . . . . . . . . .  TYPEDEF  -----  LONG     -----  4
UU16 . . . . . . . . . . . . . . . . .  * TAG *  -----  UNION    -----  2
  U16. . . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0000H  2
  S16. . . . . . . . . . . . . . . . .  MEMBER   -----  INT      0000H  2
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 136 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


  U8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
  S8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
UU16 . . . . . . . . . . . . . . . . .  TYPEDEF  -----  UNION    -----  2
  U16. . . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0000H  2
  S16. . . . . . . . . . . . . . . . .  MEMBER   -----  INT      0000H  2
  U8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
  S8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
UU32 . . . . . . . . . . . . . . . . .  * TAG *  -----  UNION    -----  4
  U32. . . . . . . . . . . . . . . . .  MEMBER   -----  U_LONG   0000H  4
  S32. . . . . . . . . . . . . . . . .  MEMBER   -----  LONG     0000H  4
  UU16 . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  U16. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  S16. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  U8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  S8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
UU32 . . . . . . . . . . . . . . . . .  TYPEDEF  -----  UNION    -----  4
  U32. . . . . . . . . . . . . . . . .  MEMBER   -----  U_LONG   0000H  4
  S32. . . . . . . . . . . . . . . . .  MEMBER   -----  LONG     0000H  4
  UU16 . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  U16. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  S16. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  U8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  S8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
SI_GENERIC_PTR . . . . . . . . . . . .  * TAG *  -----  UNION    -----  3
  U8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  3
  GPTR . . . . . . . . . . . . . . . .  MEMBER   -----  STRUCT   0000H  3
SI_GENERIC_PTR . . . . . . . . . . . .  TYPEDEF  -----  UNION    -----  3
  U8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  3
  GPTR . . . . . . . . . . . . . . . .  MEMBER   -----  STRUCT   0000H  3
P6 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0086H  1
TMOD . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0089H  1
TL0. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008AH  1
TH0. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008CH  1
CKCON. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008EH  1
P7 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0096H  1
RSTSRC . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00EFH  1
WDTCN. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FFH  1
TF0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008DH  1
TR0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008CH  1
EA . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00AFH  1
ET0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A9H  1
size_t . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
wchar_t. . . . . . . . . . . . . . . .  TYPEDEF  -----  CHAR     -----  1
_log . . . . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
_?delayMs. . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
_epromWriteOneByte . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
_epromRead . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
_epromWrite. . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
epromTest. . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
_initUart1 . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
adcTempDat_t . . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  31
  dat. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  28
  out. . . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    001CH  2
  wIndex . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   001EH  1
initChipAdc. . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
chipAdcProcess . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
initChipDac. . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 137 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


refreshDac . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
_initModbus. . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
modbusPorcess. . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
NVRAM0 . . . . . . . . . . . . . . . .  PUBLIC   XDATA  ARRAY    0000H  484
NVRAM1 . . . . . . . . . . . . . . . .  PUBLIC   XDATA  ARRAY    01E4H  484
getGlobalInterrupt . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
_setLedRun . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  st . . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
getLedRun. . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
_setLedEprom . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  st . . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
getLedEprom. . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
_setLedDac . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  st . . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
getLedDac. . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
_setLedError . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  st . . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
getLedError. . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
sPlcInit . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
sPlcProcessStart . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
sPlcProcessEnd . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
_?wdtFeed. . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
_?wdtEnable. . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
_?wdtDisable . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  flagEA . . . . . . . . . . . . . . .  AUTO     IDATA  U_CHAR   0000H  1
_?assertCoilAddress. . . . . . . . . .  STATIC   CODE   PROC     0012H  -----
  adr. . . . . . . . . . . . . . . . .  AUTO     IDATA  U_INT    0000H  2
_?assertRegisterAddress. . . . . . . .  STATIC   CODE   PROC     0000H  -----
  adr. . . . . . . . . . . . . . . . .  AUTO     IDATA  U_INT    0000H  2
clearDM. . . . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
  i. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0004H  2
clearEM. . . . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
  i. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0004H  2
clearR . . . . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
  i. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0004H  2
clearT . . . . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
  i. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0004H  2
clearTD. . . . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
  i. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0004H  2
clearC . . . . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
  i. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0004H  2
_?REBOOT . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
_?SET. . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  A. . . . . . . . . . . . . . . . . .  AUTO     IDATA  U_INT    0000H  2
_?RES. . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  A. . . . . . . . . . . . . . . . . .  AUTO     IDATA  U_INT    0000H  2
_?FLIP . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  A. . . . . . . . . . . . . . . . . .  AUTO     IDATA  U_INT    0002H  2
  temp . . . . . . . . . . . . . . . .  AUTO     IDATA  U_INT    0000H  2
_?LD . . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  A. . . . . . . . . . . . . . . . . .  AUTO     IDATA  U_INT    0000H  2
_?LDB. . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  A. . . . . . . . . . . . . . . . . .  AUTO     IDATA  U_INT    0000H  2
_?LDP. . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  A. . . . . . . . . . . . . . . . . .  AUTO     IDATA  U_INT    0002H  2
  temp0. . . . . . . . . . . . . . . .  AUTO     IDATA  U_CHAR   0000H  1
  temp1. . . . . . . . . . . . . . . .  AUTO     IDATA  U_CHAR   0001H  1
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 138 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


_?LDN. . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  A. . . . . . . . . . . . . . . . . .  AUTO     IDATA  U_INT    0002H  2
  temp0. . . . . . . . . . . . . . . .  AUTO     IDATA  U_CHAR   0000H  1
  temp1. . . . . . . . . . . . . . . .  AUTO     IDATA  U_CHAR   0001H  1
_T1MS. . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  A. . . . . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0000H  1
  start. . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0005H  1
  value. . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0002H  2
_T10MS . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  A. . . . . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0000H  1
  start. . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0005H  1
  value. . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0002H  2
_T100MS. . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  A. . . . . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0000H  1
  start. . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0005H  1
  value. . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0002H  2
_DSUB. . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  Sa . . . . . . . . . . . . . . . . .  AUTO     DATA   U_INT    0000H  2
  Sb . . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0004H  2
  D. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0082H  2
  tmp0 . . . . . . . . . . . . . . . .  AUTO     IDATA  PTR      0000H  3
  tmp1 . . . . . . . . . . . . . . . .  AUTO     IDATA  PTR      0003H  3
  tmp2 . . . . . . . . . . . . . . . .  AUTO     IDATA  PTR      0006H  3
TimerCounter_1mS . . . . . . . . . . .  STATIC   IDATA  U_CHAR   0000H  1
TimerCounter_10mS. . . . . . . . . . .  STATIC   IDATA  U_CHAR   0001H  1
TimerCounter_100mS . . . . . . . . . .  STATIC   IDATA  U_CHAR   0002H  1
Timer0_L . . . . . . . . . . . . . . .  STATIC   IDATA  U_CHAR   0003H  1
Timer0_H . . . . . . . . . . . . . . .  STATIC   IDATA  U_CHAR   0004H  1
inputFilter. . . . . . . . . . . . . .  STATIC   IDATA  ARRAY    0005H  16
clearMR. . . . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
  i. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0004H  2
clearX . . . . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
  i. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0004H  2
clearY . . . . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
  i. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0004H  2
clearSPREG . . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
  i. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0004H  2
clearSPCOIL. . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
  i. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0004H  2
loadNvram. . . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
saveNvram. . . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
updataNvram. . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
  sp0. . . . . . . . . . . . . . . . .  AUTO     DATA   PTR      0000H  3
  sp1. . . . . . . . . . . . . . . . .  AUTO     DATA   PTR      0003H  3
  i. . . . . . . . . . . . . . . . . .  AUTO     DATA   U_INT    0006H  2
clearNvram . . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
  oldEA. . . . . . . . . . . . . . . .  AUTO     IDATA  U_CHAR   0000H  1
  i. . . . . . . . . . . . . . . . . .  AUTO     IDATA  U_INT    0001H  2
selfTestNvram. . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
_TNTC. . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  dat. . . . . . . . . . . . . . . . .  * REG *  DATA   INT      0082H  2
  temp . . . . . . . . . . . . . . . .  AUTO     IDATA  U_INT    0000H  2
  ftemp. . . . . . . . . . . . . . . .  AUTO     IDATA  FLOAT    0002H  4
_TENV. . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  dat. . . . . . . . . . . . . . . . .  * REG *  DATA   INT      0006H  2
  temp . . . . . . . . . . . . . . . .  AUTO     IDATA  U_INT    0000H  2
_MAX . . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
C51 COMPILER V9.59.0.0   SPLC                                                              01/18/2019 16:27:28 PAGE 139 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


  s. . . . . . . . . . . . . . . . . .  AUTO     DATA   PTR      0000H  3
  len. . . . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0003H  1
  max. . . . . . . . . . . . . . . . .  AUTO     IDATA  INT      0000H  2
  i. . . . . . . . . . . . . . . . . .  AUTO     IDATA  U_CHAR   0002H  1
_MIN . . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  s. . . . . . . . . . . . . . . . . .  AUTO     DATA   PTR      0000H  3
  len. . . . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0003H  1
  min. . . . . . . . . . . . . . . . .  AUTO     IDATA  INT      0000H  2
  i. . . . . . . . . . . . . . . . . .  AUTO     IDATA  U_CHAR   0002H  1
_DADD. . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  Sa . . . . . . . . . . . . . . . . .  AUTO     DATA   U_INT    0000H  2
  Sb . . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0004H  2
  D. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0082H  2
  tmp0 . . . . . . . . . . . . . . . .  AUTO     DATA   PTR      0002H  3
  tmp1 . . . . . . . . . . . . . . . .  AUTO     DATA   PTR      0005H  3
  tmp2 . . . . . . . . . . . . . . . .  AUTO     DATA   PTR      0008H  3
wdtInit. . . . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
pcaInit. . . . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
timer0Init . . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
  temp . . . . . . . . . . . . . . . .  AUTO     IDATA  U_INT    0000H  2
timer0Isr. . . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
  i. . . . . . . . . . . . . . . . . .  AUTO     IDATA  U_INT    0000H  2
  tmp. . . . . . . . . . . . . . . . .  AUTO     IDATA  U_LONG   0002H  4
inputInit. . . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
outputInit . . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
inputRefresh . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
  ctemp0 . . . . . . . . . . . . . . .  AUTO     IDATA  U_CHAR   0000H  1
outputRefresh. . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   4739    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    968    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      32
   IDATA SIZE       =     21      35
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  2 WARNING(S),  0 ERROR(S)
