C51 COMPILER V9.59.0.0   MAINAPP                                                           12/19/2018 23:00:15 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MAINAPP
OBJECT MODULE PLACED IN .\Objects\MainApp.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE MainApp\MainApp.c COMPACT OPTIMIZE(8,SPEED) REGFILE(.\Objects\dwLaser_F0
                    -20.ORC) BROWSE ORDER INCDIR(.\Lib;.\Driver;.\MainApp;.\Modbus) DEFINE(C8051F020) DEBUG OBJECTEXTEND PRINT(.\Listings\Mai
                    -nApp.lst) OBJECT(.\Objects\MainApp.obj)

line level    source

   1          #include "MainApp.h"
   2          /*****************************************************************************/
   3          //TIMER0 ->Laser Pulse
   4          //TIMER1 ->UART0/1 Buadrate
   5          //TIMER2 ->Modbus Slave TIMER
   6          //TIMER3 ->HW I2C
   7          //TIMER4 ->SoftPLC HWTIMER
   8          /*****************************************************************************/
   9          //sbit LED_MCU = P2^3;//处理器指示LED
  10          //sbit LED_LASER0 = P1^7;//激光发射指示LED0 980nM
  11          //sbit LED_LASER1 = P1^6;//激光发射指示LED1 1470nM
  12          //bit  TP0, TP1, TP2, TP3;
  13          /*****************************************************************************/
  14          #define ENUM_CHANNEL1                                   4321
  15          #define ENUM_CHANNEL2                                   8765
  16          #define ENUM_CHANNEL_BOTH                               9431
  17          #define ENUM_MODE_CW                                    0//连续模式
  18          #define ENUM_MODE_SP                                    1//单脉冲模式
  19          #define ENUM_MODE_MP                                    2//多脉冲模式
  20          #define ENUM_MODE_GP                                    3//群脉冲模式
  21          #define ENUM_MODE_CC                                    4//校正模式
  22          /*****************************************************************************/
  23          #define INPUT_FOOTSWITCH_NC                             0
  24          #define INPUT_FOOTSWITCH_NO                             1
  25          #define INPUT_INTERLOCK                                 2
  26          #define INPUT_OPENCASE                                  3
  27          #define INPUT_FIBERDETECT0                              4
  28          #define INPUT_FIBERDETECT1                              5
  29          
  30          #define STIMER_1MS_INPUT_FILTER                 0//输入滤波计时器                       
  31          #define STIMER_1MS_SP_LASER_ON                  1//单脉冲ON计时器
  32          #define STIMER_1MS_MP_LASER_ON                  2//多脉冲ON计时器
  33          #define STIMER_1MS_MP_LASER_OFF                 3//多脉冲OFF计时器
  34          #define STIMER_1MS_GP_LASER_ON                  4//可变脉冲ON计时器
  35          #define STIMER_IMS_GP_LASER_OFF                 5//可变脉冲OFF计时器
  36          #define STIMER_1MS_GP_SPACE                             6//可变脉冲间隔计时器
  37          
  38          #define STIMER_1000MS_PID                               61//PID温度周期计时器
  39          #define STIMER_100MS_OFF_BEEM                   44//发射激光器时蜂鸣器OFF计时器
  40          #define STIMER_100MS_ON_BEEM                    45//发射激光器时蜂鸣器ON计时器
  41          #define STIMER_100MS_INTOREADY_BEEM             46//INTO READY后蜂鸣器计时器
  42          
  43          #define STIMER_1000MS_LED_ON                    62//LED闪烁ON计时器
  44          #define STIMER_1000MS_LED_OFF                   63//LED闪烁OFF计时器
  45          /*****************************************************************************/
  46          
  47          #define STEPNUM_FAULT                                   -1//故障
  48          #define STEPNUM_INIT                                    0//初始化
  49          #define STEPNUM_STANDBY                                 1//待机
  50          #define STEPNUM_INTO_READY                              2//进入准备
  51          #define STEPNUM_READY                                   3//准备
  52          #define STEPNUM_LASERON                                 4//激光开始
  53          
C51 COMPILER V9.59.0.0   MAINAPP                                                           12/19/2018 23:00:15 PAGE 2   

  54          
  55          
  56          //#define DM_LASER_CURRENT_0                    0//激光器电流0
  57          //#define DM_LASER_CURRENT_1                    1//激光器电流1
  58          //#define DM_PHOTODIODE_0                               2//激光器反馈0
  59          //#define DM_PHOTODIODE_1                               3//激光器反馈1
  60          //#define DM_LASER_MODE                         4//激光发射模式
  61          //#define DM_LASER_POSWIDTH                     5//激光脉冲正脉宽
  62          //#define DM_LASER_NEGWIDTH                     6//激光脉冲正脉宽
  63          //#define DM_LASER_GROUP_NUM                    7//激光群脉冲个数
  64          //#define DM_LASER_GROUP_SPACE          8//激光群脉冲间隔
  65          //#define DM_LASER_SELECT_CHANNEL               9//激光通道选择
  66          
  67          
  68          //#define DM_LASER_HTEMP//激光器高温保护
  69          //#define DM_LASER_LTEMP//激光器低温保护
  70          //#define DM_DRIVER_HTEMP//驱动器高温保护
  71          //#define DM_DRIVER_LTEMP//驱动器低温保护
  72          //#define DM_CHIP_HTEMP//芯片高温保护
  73          //#define DM_CHIP_LTEMP//芯片低温保护
  74          //#define DM_ENVI_HTEMP//环境温度高温保护
  75          //#define DM_EMVI_LTEMP//环境温度低温保护
  76          
  77          //#define EM_FAN_SET_SPEED_0//风扇0转速设置
  78          //#define EM_FAN_SET_SPEED_1//风扇1转速设置
  79          //#define EM_FAN_SET_SPEED_2//风扇2转速设置
  80          //#define EM_FAN_GET_SPEED_0//风扇0转速读取
  81          //#define EM_FAN_GET_SPEED_1//风扇1转速读取
  82          //#define EM_FAN_GET_SPEED_2//风扇2转速读取
  83          //#define EM_EDAC0//扩展DAC0输出值
  84          //#define EM_EDAC1//扩展DAC1输出值
  85          //#define EM_EDAC2//扩展DAC2输出值
  86          //#define EM_EDAC3//扩展DAC3输出值
  87          //#define EM_CDAC0//板载DAC0输出值
  88          //#define EM_CDAC1//板载DAC1输出值
  89          //#define EM_CADC0//板载ADC0输入值
  90          //#define EM_CADC1//板载ADC1输入值
  91          //#define EM_CADC2//板载ADC2输入值
  92          //#define EM_CADC3//板载ADC3输入值
  93          //#define EM_CTEMP//板载温度值
  94          //#define XR_0
  95          //#define XR_1
  96          //#define XR_2
  97          //#define XR_3
  98          //#define XR_4
  99          //#define XR_5
 100          //#define XR_6
 101          //#define XR_7
 102          //#define YR_0
 103          //#define YR_1
 104          #define MCP4768_DAC1            1
 105          #define MCP4768_DAC2            2
 106          #define MCP4768_DAC3            3
 107          #define MCP4768_DAC4            4
 108          void readNvram(void)
 109          {//EPROM->NVRAM0
 110   1              //readEprom();
 111   1              //NVRAM0->NVRAM1
 112   1              //memcpy((uint8_t*)Nvram1, (uint8_t*)Nvram0, (CONFIG_NVRAM_SIZE * 2));
 113   1              
 114   1      }
 115          void writeNvram(void)
C51 COMPILER V9.59.0.0   MAINAPP                                                           12/19/2018 23:00:15 PAGE 3   

 116          {//掉电保持寄存器全部写入NVRAM 强制全部写入
 117   1              //DM0写入NVRAM
 118   1      }
 119          void updateNvram(void)
 120          {//掉电保持寄存器更新入NVRAM 仅写入更新部分
 121   1              //
 122   1      }
 123          
 124          void upDateDac0(uint16_t dat);
 125          void upDateDac1(uint16_t dat);
 126          /*****************************************************************************/
 127          
 128          void main(void)
 129          {
 130   1              uint8_t rbuf[8];
 131   1              uint8_t wbuf[8] = {1,2,3,4,5,6,7,8};
 132   1              Init_Device();
 133   1              //timer0Init();
 134   1              //inPca9554Init();
 135   1              //outPca9554Init();
 136   1              //mcp47x6Init();
 137   1              //setModbusSlaveAddr(0x1);//设置从机地址
 138   1              //InitModbusHardware(CONFIG_UART0_BAUDRATE);
 139   1              InitPetitModbus(1, 115200);
 140   1              ES0 = 1;
 141   1              ENABLE_INTERRUPT;
 142   1              //nvramLoad();//上电恢复NVRAM
 143   1              while(1)
 144   1              {
 145   2                      ProcessPetitModbus();
 146   2                      //refreshInput();//刷新输入IO
 147   2      //              modbusSlaveAsciiPoll();
 148   2      ////            SET(10);
 149   2      ////            RESET(10);
 150   2      ////            SET(10);
 151   2      ////            RESET(10);
 152   2      ////            SET(10);
 153   2      ////            RESET(10);
 154   2      ////            SET(10);
 155   2      ////            RESET(10);
 156   2      ////            FLIP(10);
 157   2      ////            FLIP(10);
 158   2      ////            FLIP(10);
 159   2      ////            FLIP(10);
 160   2      ////            //读取IO
 161   2      ////            //执行程序
 162   2      ////            //输出IO
 163   2      ////            T100MS(0, 1, 2);
 164   2      ////            if(LD(TD_100MS_START * 16 + 0));
 165   2      ////            {
 166   2      ////                    SET(0); 
 167   2      ////            }
 168   2                      //nvramUpdata();//更新NVRAM
 169   2                      //refreshOutput();//刷新输出IO
 170   2              }
 171   1      }
*** WARNING C280 IN LINE 130 OF MainApp\MainApp.c: 'rbuf': unreferenced local variable
 172          //void main(void)
 173          //{
 174          //      int8_t temp;
 175          //      int16_t tecOnTime, tecOffTime;//制冷开关时间
 176          ////    my_t *p = my;
C51 COMPILER V9.59.0.0   MAINAPP                                                           12/19/2018 23:00:15 PAGE 4   

 177          ////    pidFuzzy_t pidFuzzy;
 178          //      Init_Device();//初始化MCU
 179          //#if CONFIG_USING_WDT == 1
 180          //      if ((RSTSRC & 0x02) == 0x00)
 181          //      {
 182          //              if (RSTSRC == 0x08)
 183          //              {//检测WDT看门狗 看门狗复位后锁定
 184          //                      //所有IO ->LOW
 185          //                      //关闭DAC
 186          //                      //关闭
 187          //                      LED_MCU = true;
 188          //                      LED_LASER0 = false;
 189          //                      LED_LASER1 = true;
 190          //                      while(1);
 191          //              }
 192          //      }
 193          //#endif
 194          
 195                  //pidFuzzyInit(&pidFuzzy, 2, 0.5, 0.1);
 196          //      setModbusSlaveAddr(CONFIG_LOCAL_ADDRESS);//设置从机地址
 197          //      InitModbusHardware(CONFIG_UART0_BAUDRATE);//初始化MODBUS从机串口
 198          //      /**********************************************************************/
 199          ////初始化my结构体
 200          //      //my.stepNum = 0;
 201          //      //my.checkCode = ((CONFIG_CHECK_CODE << 8) & 0xFF00);
 202          //      //my.checkCode |= CONFIG_VERSION;
 203          //      
 204          ////使能看门狗
 205          //#if CONFIG_USING_WDT == 1
 206          //      Watchdog_Init();
 207          //#endif        
 208          //      EA = 1;
 209          //      
 210          //      while(1)
 211          //      {//开始循环扫描周期
 212          ////看门狗喂狗
 213          //#if CONFIG_USING_WDT == 1
 214          //               WDTCN = 0xA5;//喂狗
 215          //#endif
 216          ////上位机使能MCU软复位
 217          //#if CONFIG_USING_RESET == 1
 218          //              if(my.mcuReset)
 219          //              {
 220          //                      RSTSRC |= (1 << 1);//Forces a Power-On Reset. /RST is driven low.
 221          //              }
 222          //#endif
 223          //              //数字滤波扫描输入IO
 224          
 225          //              p->flagConnectErr = 0;//每次扫描错误标志清零
 226          //              //心跳->PLC
 227          //              if(my.heartFlag)
 228          //              {
 229          //                      my.heatFlag = 0;
 230          //              }
 231          //              else
 232          //              {
 233          //                      my.heatFlag = 1;
 234          //              }
 235          //              
 236          //              //获取过热状态
 237          //              my.overTempFault = (my.overTempDiode && !my.overTempDiodeIgnore) ||
 238          //                                                        (my.overTempAmplifier && !my.overTempAmplifierIgnore) ||
C51 COMPILER V9.59.0.0   MAINAPP                                                           12/19/2018 23:00:15 PAGE 5   

 239          //                                (my.overTempEnvironment && !my.overTempEnvironmentIgnore) ||
 240          //                                                        (my.overTempMcu && !my.overTempMcuIgnore);
 241          //          my.overTempFault = my.overTempFault && !my.overTempIgnore;
 242          //              //获取安全状态
 243          //              my.safeFault = (my.safeInterlock && !my.safeInterlockIgnore) ||
 244          //                                      (my.safeFiberDetect0 && my.safeFiberDetect0Ignore) ||
 245          //                                      (my.safeFiberDetect1 && my.safeFiberDetect1Ignore) ||
 246          //                                      (my.safeOpenCase && my.safeOpenCaseIgnore);
 247          //              my.safeFault = my.safeFault && !my.safeFaultIgnore;
 248          //              //模拟输入扫描
 249          //              STEP_LOOP_START:
 250          //              if(my.stepNum == STEPNUM_INIT)
 251          //              {//初始化
 252          //                      my.stepNum = STEPNUM_STANDBY;//Goto next step
 253          //                      goto STEP_LOOP_END;
 254          //              }
 255          //              if(my.stepNum == STEPNUM_STANDBY)
 256          //              {//第一步 待机状态->蜂鸣器提示
 257          //                      if(my.safeFault ||
 258          //               my.overTempFault)
 259          //                      {
 260          //                              my.stepNum = STEPNUM_FAULT;
 261          //                      }
 262          //                      else if(my.readyFlag)
 263          //                      {
 264          //                              my.beemOn = true;
 265          //                              my.stepNum = STEPNUM_INTO_READY;
 266          //                      }
 267          //                      else
 268          //                      {
 269          //                              my.stepNum = STEPNUM_STANDBY;
 270          //                      }
 271          //                      goto STEP_LOOP_END;
 272          //              }
 273          //              if(my.stepNum == STEPNUM_INTO_READY)
 274          //              {//第二步 等待1秒后进入
 275          //                      if(my.readyFlag)
 276          //                      {
 277          //                              my.beemOn = true;
 278          //                              sTimerCtrl(STIMER_ON, STIMER_100MS_INTOREADY_BEEM, 10);
 279          //                              if(sTimer[STIMER_100MS_INTOREADY_BEEM].status)
 280          //                              {//计时达到进入READY步骤
 281          //                                      sTimerCtrl(STIMER_OFF, STIMER_100MS_INTOREADY_BEEM, 10);
 282          //                                      my.beemOn = false;
 283          //                                      my.stepNum = STEPNUM_READY;
 284          //                              }
 285          //                      }
 286          //                      goto STEP_LOOP_END;
 287          //              }
 288          //              if(my.stepNum == STEPNUM_READY)
 289          //              {//第三步 准备状态 等待脚踏信号发射激光
 290          //                      if(my.safeFault ||
 291          //               my.overTempFault)
 292          //                      {
 293          //                              my.stepNum = STEPNUM_FAULT;
 294          //                      }
 295          //                      else if((my.footSwitch && 0x01) &&
 296          //                                  !(my.footSwitch && 0x02))//检测footSwitch上升沿
 297          //                      {//发射激光步骤
 298          //                              //打开激光
 299          //                              my.stepNum = STEPNUM_LASERON;
 300          //                              my.laserEmitOver = 0x0;//发射完成标志清零
C51 COMPILER V9.59.0.0   MAINAPP                                                           12/19/2018 23:00:15 PAGE 6   

 301          //                              switch(my.laserMode)
 302          //                              {
 303          //                                      case ENUM_MODE_CW:
 304          //                                      {
 305          //                                              my.laserEmiting |=  1 << ENUM_MODE_CW;
 306          //                                              break;
 307          //                                      }
 308          //                                      case ENUM_MODE_SP:
 309          //                                      {
 310          //                                              my.laserEmiting |=  1 << ENUM_MODE_SP;
 311          //                                              break;
 312          //                                      }
 313          //                                      case ENUM_MODE_MP:
 314          //                                      {
 315          //                                              my.laserEmiting |=  1 << ENUM_MODE_MP;
 316          //                                              break;
 317          //                                      }
 318          //                                      case ENUM_MODE_GP:
 319          //                                      {
 320          //                                              my.laserEmiting |=  1 << ENUM_MODE_GP;
 321          //                                              break;
 322          //                                      }
 323          //                                      case ENUM_MODE_CC:
 324          //                                      {
 325          //                                              my.laserEmiting |=  1 << ENUM_MODE_CC;
 326          //                                              break;
 327          //                                      }
 328          //                                      default:break;
 329          //                              }
 330          //                      }
 331          //                      goto STEP_LOOP_END;
 332          //              }
 333          //              if(my.stepNum == STEPNUM_LASERON)
 334          //              {
 335          //                      if(my.safeFault || my.overTempFault)
 336          //                      {//故障:
 337          //                              my.stepNum = STEPNUM_FAULT;
 338          //                      }
 339          //                      else if(!(my.footSwitch & 0x01))//脚踏复位
 340          //                      {
 341          //                              //关闭激光
 342          //                              my.stepNum = STEPNUM_READY;//返回READY步骤
 343          //                      }
 344          //                      else
 345          //                      {
 346          //                              if( my.laserEmiting == ENUM_MODE_CW)
 347          //                              {//连续模式
 348          //                                      switch(my.selectChannel)
 349          //                                      {
 350          //                                              case ENUM_CHANNEL_BOTH:
 351          //                                              {
 352          //                                                      upDateDac0(laserCurrent[0]);
 353          //                                                      upDateDac1(laserCurrent[1]);
 354          //                                                      break;
 355          //                                              }
 356          //                                              case ENUM_CHANNEL1:
 357          //                                              {
 358          //                                                      upDateDac0(laserCurrent[0]);
 359          //                                                      break;
 360          //                                              }
 361          //                                              case ENUM_CHANNEL2:
 362          //                                              {
C51 COMPILER V9.59.0.0   MAINAPP                                                           12/19/2018 23:00:15 PAGE 7   

 363          //                                                      upDateDac1(laserCurrent[1]);
 364          //                                                      break;
 365          //                                              }
 366          //                                              default:break;
 367          //                                      }
 368          //                              }
 369          //                              if( my.laserEmiting == ENUM_MODE_SP )
 370          //                              {//单脉冲模式
 371          //                                      if(selectChannel == ENUM_CHANNEL_BOTH)
 372          //                                      {
 373          //                                              upDateDac0(laserCurrent[0]);
 374          //                                              upDateDac1(laserCurrent[1]);
 375          //                                      }
 376          //                                      if(selectChannel == ENUM_CHANNEL1)
 377          //                                      {
 378          //                                              upDateDac0(laserCurrent[0]);
 379          //                                      }
 380          //                                      if(selectChannel = ENUM_CHANNEL2)
 381          //                                      {
 382          //                                              upDateDac1(laserCurrent[1]);
 383          //                                      }
 384          //                                      sTimerCtrl(STIMER_ON, STIMER_1MS_SP_LASER_ON, my.posWidth);
 385          //                                      if(sTimer[STIMER_1MS_LASER_ON].status)
 386          //                                      {
 387          //                                              upDateDac0(0x0);
 388          //                                              upDateDac1(0x0);
 389          //                                              my.laserEmiting &=  ~(1<< ENUM_MODE_CW);//发射完成清空正在发射标志位
 390          //                                              my.laserEmitOver |= 1 << ENUM_MODE_CW;//发射完成标志位置位
 391          //                                              sTimerCtrl(STIMER_OFF, STIMER_1MS_SP_LASER_ON, my.posWidth);
 392          //                                      }
 393          //                              }       
 394          //                              if( my.laserEmiting == ENUM_MODE_MP )
 395          //                              {//多脉冲模式
 396          //                                      if(!sTimer[STIMER_1MS_LASER_ON].enable)
 397          //                                      {//正脉宽计时
 398          //                                      if(selectChannel == ENUM_CHANNEL_BOTH)
 399          //                              {
 400          //                                      DAC0 = laserCurrent[0];
 401          //                                      DAC1 = laserCurrent[1];
 402          //                              }
 403          //                              if(selectChannel == ENUM_CHANNEL1)
 404          //                              {
 405          //                                      
 406          //                              }
 407          //                              if(selectChannel = ENUM_CHANNEL2)
 408          //                              {
 409          //                              }
 410          //                              sTimerCtrl(STIMER_ON, STIMER_1MS_LASER_ON, my.posWidth);
 411          //                              if(sTimer[STIMER_1MS_LASER_ON].status)
 412          //                              {
 413          //                                      //关闭激光
 414          //                                      //关闭计时器
 415          //                                      my.laserOnFlag = 0;
 416          //                                      sTimerCtrl(STIMER_OFF, STIMER_1MS_LASER_ON, my.posWidth);
 417          //                              }       
 418          //                      }
 419          //                      else if(!my.laserOnFlag)
 420          //                      {//负脉宽计时
 421          //                              sTimerCtrl(STIMER_ON, STIMER_1MS_LASER_OFF, my.negWidth);
 422          //                              if(sTimer[STIMER_1MS_LASER_OFF].status)
 423          //                              {
 424          //                                      my.laserOnFlag = 1;
C51 COMPILER V9.59.0.0   MAINAPP                                                           12/19/2018 23:00:15 PAGE 8   

 425          //                                      sTimerCtrl(STIMER_OFF, STIMER_1MS_LASER_ON, my.posWidth);
 426          //                              }
 427          //                      }
 428          //              }
 429          //              if( !my.triggerCW || !my.triggerSP || !my.triggerMP || !my.triggerGP || my.triggerCC)
 430          //              {//校正模式
 431          //                      
 432          //              }
 433          //                      }
 434          //                      goto STEP_LOOP_END;
 435          //              }
 436          //              if(my.stepNum == STEPNUM_FAULT)
 437          //              {//错误状态
 438          //                      //关闭激光
 439          //                      if(!my.safeFault &&
 440          //               !my.overTempFault)
 441          //                      {//错误消除
 442          //                              if(my.clearError)
 443          //                              {//错误消除返回待机状态
 444          //                                      my.clearError = 0;
 445          //                                      my.stepNum = STEPNUM_STANDBY;
 446          //                              }
 447          //                      }
 448          //                      else
 449          //                      {
 450          //                              my.stepNum = STEPNUM_FAULT;
 451          //                      }
 452          //                      goto STEP_LOOP_END;
 453          //              }
 454          //              STEP_LOOP_END:
 455          //              if( my.triggerCW || !my.triggerSP || !my.triggerMP || !my.triggerGP || !my.triggerCC)
 456          //              {//连续模式
 457          //                      if(!my.laserOnFlag)
 458          //                      {       
 459          //                              switch(my.selectChannel)
 460          //                              {
 461          //                                      case ENUM_CHANNEL_BOTH:
 462          //                                      {
 463          //                                              DAC0 = laserCurrent[0];
 464          //                                              DAC1 = laserCurrent[1];
 465          //                                              break;
 466          //                                      }
 467          //                                      case ENUM_CHANNEL1:
 468          //                                      {
 469          //                                              DAC0 = laserCurrent[0]; 
 470          //                                              break;
 471          //                                      }
 472          //                                      case ENUM_CHANNEL2:
 473          //                                      {
 474          //                                              DAC1 = laserCurrent[1];
 475          //                                              break;
 476          //                                      }
 477          //                                      default:break;
 478          //                              }
 479          //                              my.laserOnFlag = 1;
 480          //                      }
 481          //                      
 482          //              }
 483          //              if( my.triggerCW || !my.triggerSP || !my.triggerMP || !my.triggerGP || !my.triggerCC)
 484          //              {//单脉冲模式
 485          //                      if(!my.laserOnFlag)
 486          //                      {
C51 COMPILER V9.59.0.0   MAINAPP                                                           12/19/2018 23:00:15 PAGE 9   

 487          //                              if(selectChannel == ENUM_CHANNEL_BOTH)
 488          //                              {
 489          //                                      DAC0 = laserCurrent[0];
 490          //                                      DAC1 = laserCurrent[1];
 491          //                              }
 492          //                              if(selectChannel == ENUM_CHANNEL1)
 493          //                              {
 494          //                                      DAC0 = laserCurrent[0];
 495          //                              }
 496          //                              if(selectChannel = ENUM_CHANNEL2)
 497          //                              {
 498          //                                      DAC1 = laserCurrent[1];
 499          //                              }
 500          //                              sTimerCtrl(STIMER_ON, STIMER_1MS_SP_LASER_ON, my.posWidth);
 501          //                              if(sTimer[STIMER_1MS_LASER_ON].status)
 502          //                              {
 503          //                                      DAC0 = 0x0;
 504          //                                      DAC1 = 0x0;
 505          //                                      my.laserOnFlag = 0;
 506          //                                      my.triggerSP = 0;
 507          //                                      sTimerCtrl(STIMER_OFF, STIMER_1MS_SP_LASER_ON, my.posWidth);
 508          //                              }
 509          //                      }
 510          //                      
 511          //              }
 512          //              if( !my.triggerCW || !my.triggerSP || my.triggerMP || !my.triggerGP || !my.triggerCC)
 513          //              {//多脉冲模式
 514          //                      if(my.laserOnFlag)
 515          //                      {//正脉宽计时
 516          //                              if(selectChannel == ENUM_CHANNEL_BOTH)
 517          //                              {
 518          //                                      DAC0 = laserCurrent[0];
 519          //                                      DAC1 = laserCurrent[1];
 520          //                              }
 521          //                              if(selectChannel == ENUM_CHANNEL1)
 522          //                              {
 523          //                                      
 524          //                              }
 525          //                              if(selectChannel = ENUM_CHANNEL2)
 526          //                              {
 527          //                              }
 528          //                              sTimerCtrl(STIMER_ON, STIMER_1MS_LASER_ON, my.posWidth);
 529          //                              if(sTimer[STIMER_1MS_LASER_ON].status)
 530          //                              {
 531          //                                      //关闭激光
 532          //                                      //关闭计时器
 533          //                                      my.laserOnFlag = 0;
 534          //                                      sTimerCtrl(STIMER_OFF, STIMER_1MS_LASER_ON, my.posWidth);
 535          //                              }       
 536          //                      }
 537          //                      else if(!my.laserOnFlag)
 538          //                      {//负脉宽计时
 539          //                              sTimerCtrl(STIMER_ON, STIMER_1MS_LASER_OFF, my.negWidth);
 540          //                              if(sTimer[STIMER_1MS_LASER_OFF].status)
 541          //                              {
 542          //                                      my.laserOnFlag = 1;
 543          //                                      sTimerCtrl(STIMER_OFF, STIMER_1MS_LASER_ON, my.posWidth);
 544          //                              }
 545          //                      }
 546          //              }
 547          //              if( !my.triggerCW || !my.triggerSP || !my.triggerMP || !my.triggerGP || my.triggerCC)
 548          //              {//校正模式
C51 COMPILER V9.59.0.0   MAINAPP                                                           12/19/2018 23:00:15 PAGE 10  

 549          //                      
 550          //              }
 551          //              
 552          //              //Debug LED闪烁
 553          //              if(LED_MCU)
 554          //              {
 555          //                      if(sTimer[STIMER_1000MS_LED_ON].status)//等待时间A
 556          //                      {
 557          //                              LED_MCU = 0;
 558          //                              sTimerCtrl(STIMER_OFF, STIMER_1000MS_LED_ON, 1);
 559          //                      }
 560          //                      else
 561          //                              sTimerCtrl(STIMER_ON, STIMER_1000MS_LED_ON, 1);
 562          //              }
 563          //              if(!LED_MCU)
 564          //              {
 565          //                      if(sTimer[STIMER_1000MS_LED_OFF].status)//等待时间B
 566          //                      {
 567          //                              LED_MCU = 1;
 568          //                              sTimerCtrl(STIMER_OFF, STIMER_1000MS_LED_OFF, 1);
 569          //                      }
 570          //                      else
 571          //                              sTimerCtrl(STIMER_ON, STIMER_1000MS_LED_OFF, 1);
 572          //              }
 573          //              //PID 温控指令
 574          //              if(sTimer[(CONFIG_STIMER_100MS_END - 3)].status)//等待A时间
 575          //              {
 576          //                      my.pidOut += pidFuzzyRealize(&pidFuzzy, 25.0, 26.0);
 577          //                      if(my.pidOut > 1)
 578          //                              my.pidOut = 1;
 579          //                      if(my.pidOut < 0)
 580          //                              my.pidOut = 0;
 581          //                      //my.onTimerPid = (int16_t)(my.pidOut * CONFIG_PIDOUT_PWM);
 582          //                      //my.offTimerPid = CONFIG_TECOUT_MAX_CYCLE - my.onTimerPid; 
 583          //                      sTimerCtrl(STIMER_OFF, (CONFIG_STIMER_100MS_END - 3), 10);
 584          //              }
 585          //              else
 586          //                      sTimerCtrl(STIMER_ON, (CONFIG_STIMER_100MS_END - 3), 10);
 587          //              //PID结果输出
 588          
 589          //              if(sTimer[1].value >= CONFIG_TECOUT_CYCLE || sTimer[1].enable == 0)
 590          //              {
 591          //                      COOL_OUT = 1;
 592          //                      //tecOnTime = (int16_t)(my.pidOut * CONFIG_TECOUT_CYCLE);
 593          //                      tecOnTime = (int16_t)(0.25 * CONFIG_TECOUT_CYCLE);
 594          //                      sTimerCtrl(STIMER_OFF, 1, tecOnTime);
 595          //                      sTimerCtrl(STIMER_ON, 1, tecOnTime);
 596          //              }
 597          //              if(sTimer[1].value >= tecOnTime)
 598          //              {
 599          //                      COOL_OUT = 0;
 600          //              }
 601          //              modbusPoll();//执行MODBUS POLL
 602          //              
 603          //              //setOutput();//更新输出IO
 604          //      
 605          //      }               
 606          //}
 607          
 608          //void startLaser(void)
 609          //{//开始发射脉冲       
 610          //      if(my.laserMode == ENUM_MODE_CW )
C51 COMPILER V9.59.0.0   MAINAPP                                                           12/19/2018 23:00:15 PAGE 11  

 611          //      {
 612          //              DAC0 = my.laserCurrent[0];
 613          //              DAC1 = my.laserCurrent[1];
 614          //      }
 615          //      else if((my.LaserMode == ENUM_MODE_SP) | 
 616          //                      (my.LaserMode == ENUM_MODE_MP) |
 617          //                      (my.LaserMode == ENUM_MODE_GP))
 618          //      {
 619          //              my.laserTimer.tMate = my.PosWidth;//设置匹配值
 620          //              my.laserTimer.tOverflow = my.NegWidth + my.PosWidth;//设置溢出值
 621          //              my.laserTimer.tCounter = 0x0;   
 622          //              my.laserTimer.pMate = 0x0;//脉冲个数匹配值
 623          //              my.laserTimer.sMate = 0x0;//脉个数溢出值
 624          //              my.laserTimer.pCounter = 0x0;
 625          //              my.laserTimer.sCounter = 0x0;   
 626          //              TF2H = 0;//Timer 2 High Byte Overflow Flag.
 627          //              ET2 = 1;
 628          //              TMR2L = 0xFF;
 629          //              TMR2H = 0xFF;
 630          //              TR2 = 1;//使能TIMER2计时器
 631          //      }
 632          //      else if(my.LaserMode == ENUM_MODE_CC)
 633          //      {//校正模式
 634          //              my.laserTimer.tMate = my.PosWidth;//设置匹配值
 635          //              my.laserTimer.tOverflow = my.NegWidth + my.PosWidth;//设置溢出值
 636          //              my.laserTimer.tCounter = 0x0;   
 637          //              my.laserTimer.pMate = my.GroupNum;//脉冲个数匹配值
 638          //              my.laserTimer.sMate = my.GroupSpace;//脉个数溢出值
 639          //              my.laserTimer.pCounter = 0x0;
 640          //              my.laserTimer.sCounter = 0x0;   
 641          //              TF2H = 0;//Timer 2 High Byte Overflow Flag.
 642          //              ET2 = 1;
 643          //              TMR2L = 0xFF;
 644          //              TMR2H = 0xFF;
 645          //              TR2 = 1;//使能TIMER2计时器
 646          //      }
 647          //      my.FlagIndicate = 1;
 648          //}
 649          //void stopLaser(myDevice_t *p)
 650          //{//停止发射脉冲
 651          //      TR2 = 0;
 652          //      ET2 = 0;
 653          //      TF2H = 0;
 654          //      DAC0 = 0;
 655          //      DAC1 = 0;
 656          //      my.FlagIndicate = 0;    
 657          //}
 658          
 659          //void Timer0_ISR(void) interrupt INTERRUPT_TIMER0
 660          //{//TIMER2 中断 激光发射
 661          //      
 662          //      TF2H = 0;
 663          //      switch(my.LaserMode)
 664          //      {
 665          //              case ENUM_MODE_CC:
 666          //              {//CC模式
 667          //                      SetLaserCurrent(p);
 668          //                      break;
 669          //              }
 670          //              case ENUM_MODE_SP:
 671          //              {//SP模式
 672          //                      break;
C51 COMPILER V9.59.0.0   MAINAPP                                                           12/19/2018 23:00:15 PAGE 12  

 673          //              }
 674          //              case ENUM_MODE_MP:
 675          //              {//MP模式       
 676          //                      if(p->softTimer.tCounter == p->softTimer.tMate)
 677          //                      {//计时器匹配
 678          //                              LaserMod_PIN = LASER_OFF;//翻转输出
 679          //                      }
 680          //                      if(p->softTimer.tCounter == p->softTimer.tOverflow)
 681          //                      {//计时器溢出
 682          //                              p->softTimer.tCounter = 0;//清零
 683          //                      }
 684          //                      if(p->softTimer.tCounter == 0)
 685          //                      {//翻转
 686          //                              LaserMod_PIN = LASER_ON;//翻转输出
 687          //                      }
 688          //                      p->softTimer.tCounter ++;
 689          //                      break;
 690          //              }
 691          //              case ENUM_MODE_GP:
 692          //              {//GP模式
 693          //                      if(p->softTimer.pCounter < p->softTimer.pMate)
 694          //                      {
 695          //                              if(p->softTimer.tCounter == 0)
 696          //                              {
 697          //                                      if(p->softTimer.pCounter < p->softTimer.pMate)
 698          //                                      {
 699          //                                              LaserMod_PIN = LASER_ON;//翻转输出                                              
 700          //                                      }
 701          //                              }
 702          //                              if(p->softTimer.tCounter == p->softTimer.tMate)
 703          //                              {//计时器匹配
 704          //                                      LaserMod_PIN = LASER_OFF;//翻转输出
 705          //                              }
 706          //                              if(p->softTimer.tCounter == (p->softTimer.tOverflow - 1))
 707          //                              {//计时器溢出
 708          //                                      p->softTimer.tCounter = 0xFFFF;//清零
 709          //                                      p->softTimer.pCounter ++;//清零 
 710          //                              }
 711          //                              p->softTimer.tCounter ++;
 712          //                      }
 713          //                      if(p->softTimer.pCounter == p->softTimer.pMate && p->softTimer.tCounter == 0)
 714          //                      {//脉冲个数发现匹配
 715          //                              LaserMod_PIN = LASER_OFF;
 716          //                              p->softTimer.pCounter = 0xFFFF;
 717          //                              p->softTimer.sCounter = 0x0;
 718          //                      }
 719          //                      if(p->softTimer.pCounter == 0xFFFF)
 720          //                      {               
 721          //                              if(p->softTimer.sCounter == p->softTimer.sMate)
 722          //                              {
 723          //                                      p->softTimer.pCounter = 0;      
 724          //                              }
 725          //                              p->softTimer.sCounter ++;
 726          //                      }
 727          //                      break;
 728          //              }
 729          //              default:break;
 730          //      }
 731          //}
 732          
 733          //void upDateDac0(uint16_t dat)
 734          //{//刷新DAC0
C51 COMPILER V9.59.0.0   MAINAPP                                                           12/19/2018 23:00:15 PAGE 13  

 735          //      static uint16_t oldDac0;
 736          //      if(dat != oldDac0)
 737          //      {
 738          //              DAC0 = dat;
 739          //              oldDac0 = dat;
 740          //      }
 741          //}
 742          //void upDateDac1(uint16_t dat)
 743          //{//刷新DAC1
 744          //      static uint16_t oldDac1;
 745          //      if(dat != oldDac1)
 746          //      {
 747          //              DAC0 = dat;
 748          //              oldDac1 = dat;
 749          //      }
 750          //}


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =     48    ----
   CONSTANT SIZE    =      8    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----      16
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
