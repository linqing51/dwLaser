C51 COMPILER V9.59.0.0   MAINAPP                                                           12/22/2018 00:42:45 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MAINAPP
OBJECT MODULE PLACED IN .\Objects\MainApp.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE MainApp\MainApp.c COMPACT OPTIMIZE(8,SPEED) REGFILE(.\Objects\dwLaser_F0
                    -20.ORC) BROWSE ORDER INCDIR(.\Lib;.\Driver;.\MainApp;.\Modbus) DEFINE(C8051F020) DEBUG OBJECTEXTEND PRINT(.\Listings\Mai
                    -nApp.lst) PREPRINT(.\Listings\MainApp.i) OBJECT(.\Objects\MainApp.obj)

line level    source

   1          #include "MainApp.h"
   2          /*****************************************************************************/
   3          //TIMER0 ->Laser Pulse
   4          //TIMER1 ->UART0/1 Buadrate
   5          //TIMER2 ->Modbus Slave TIMER
   6          //TIMER3 ->HW I2C
   7          //TIMER4 ->SoftPLC HWTIMER
   8          /*****************************************************************************/
   9          //sbit LED_MCU = P2^3;//处理器指示LED
  10          //sbit LED_LASER0 = P1^7;//激光发射指示LED0 980nM
  11          //sbit LED_LASER1 = P1^6;//激光发射指示LED1 1470nM
  12          //bit  TP0, TP1, TP2, TP3;
  13          /*****************************************************************************/
  14          #define ENUM_CHANNEL1                                   4321
  15          #define ENUM_CHANNEL2                                   8765
  16          #define ENUM_CHANNEL_BOTH                               9431
  17          #define ENUM_MODE_CW                                    0//连续模式
  18          #define ENUM_MODE_SP                                    1//单脉冲模式
  19          #define ENUM_MODE_MP                                    2//多脉冲模式
  20          #define ENUM_MODE_GP                                    3//群脉冲模式
  21          #define ENUM_MODE_CC                                    4//校正模式
  22          /*****************************************************************************/
  23          #define INPUT_FOOTSWITCH_NC                             0
  24          #define INPUT_FOOTSWITCH_NO                             1
  25          #define INPUT_INTERLOCK                                 2
  26          #define INPUT_OPENCASE                                  3
  27          #define INPUT_FIBERDETECT0                              4
  28          #define INPUT_FIBERDETECT1                              5
  29          
  30          #define STIMER_1MS_INPUT_FILTER                 0//输入滤波计时器                       
  31          #define STIMER_1MS_SP_LASER_ON                  1//单脉冲ON计时器
  32          #define STIMER_1MS_MP_LASER_ON                  2//多脉冲ON计时器
  33          #define STIMER_1MS_MP_LASER_OFF                 3//多脉冲OFF计时器
  34          #define STIMER_1MS_GP_LASER_ON                  4//可变脉冲ON计时器
  35          #define STIMER_IMS_GP_LASER_OFF                 5//可变脉冲OFF计时器
  36          #define STIMER_1MS_GP_SPACE                             6//可变脉冲间隔计时器
  37          
  38          #define STIMER_1000MS_PID                               61//PID温度周期计时器
  39          #define STIMER_100MS_OFF_BEEM                   44//发射激光器时蜂鸣器OFF计时器
  40          #define STIMER_100MS_ON_BEEM                    45//发射激光器时蜂鸣器ON计时器
  41          #define STIMER_100MS_INTOREADY_BEEM             46//INTO READY后蜂鸣器计时器
  42          
  43          #define STIMER_1000MS_LED_ON                    62//LED闪烁ON计时器
  44          #define STIMER_1000MS_LED_OFF                   63//LED闪烁OFF计时器
  45          /*****************************************************************************/
  46          
  47          #define STEPNUM_FAULT                                   -1//故障
  48          #define STEPNUM_INIT                                    0//初始化
  49          #define STEPNUM_STANDBY                                 1//待机
  50          #define STEPNUM_INTO_READY                              2//进入准备
  51          #define STEPNUM_READY                                   3//准备
  52          #define STEPNUM_LASERON                                 4//激光开始
  53          
C51 COMPILER V9.59.0.0   MAINAPP                                                           12/22/2018 00:42:45 PAGE 2   

  54          
  55          
  56          //#define DM_LASER_CURRENT_0                    0//激光器电流0
  57          //#define DM_LASER_CURRENT_1                    1//激光器电流1
  58          //#define DM_PHOTODIODE_0                               2//激光器反馈0
  59          //#define DM_PHOTODIODE_1                               3//激光器反馈1
  60          //#define DM_LASER_MODE                         4//激光发射模式
  61          //#define DM_LASER_POSWIDTH                     5//激光脉冲正脉宽
  62          //#define DM_LASER_NEGWIDTH                     6//激光脉冲正脉宽
  63          //#define DM_LASER_GROUP_NUM                    7//激光群脉冲个数
  64          //#define DM_LASER_GROUP_SPACE          8//激光群脉冲间隔
  65          //#define DM_LASER_SELECT_CHANNEL               9//激光通道选择
  66          
  67          
  68          //#define DM_LASER_HTEMP//激光器高温保护
  69          //#define DM_LASER_LTEMP//激光器低温保护
  70          //#define DM_DRIVER_HTEMP//驱动器高温保护
  71          //#define DM_DRIVER_LTEMP//驱动器低温保护
  72          //#define DM_CHIP_HTEMP//芯片高温保护
  73          //#define DM_CHIP_LTEMP//芯片低温保护
  74          //#define DM_ENVI_HTEMP//环境温度高温保护
  75          //#define DM_EMVI_LTEMP//环境温度低温保护
  76          
  77          //#define EM_FAN_SET_SPEED_0//风扇0转速设置
  78          //#define EM_FAN_SET_SPEED_1//风扇1转速设置
  79          //#define EM_FAN_SET_SPEED_2//风扇2转速设置
  80          //#define EM_FAN_GET_SPEED_0//风扇0转速读取
  81          //#define EM_FAN_GET_SPEED_1//风扇1转速读取
  82          //#define EM_FAN_GET_SPEED_2//风扇2转速读取
  83          //#define EM_EDAC0//扩展DAC0输出值
  84          //#define EM_EDAC1//扩展DAC1输出值
  85          //#define EM_EDAC2//扩展DAC2输出值
  86          //#define EM_EDAC3//扩展DAC3输出值
  87          //#define EM_CDAC0//板载DAC0输出值
  88          //#define EM_CDAC1//板载DAC1输出值
  89          //#define EM_CADC0//板载ADC0输入值
  90          //#define EM_CADC1//板载ADC1输入值
  91          //#define EM_CADC2//板载ADC2输入值
  92          //#define EM_CADC3//板载ADC3输入值
  93          //#define EM_CTEMP//板载温度值
  94          //#define XR_0
  95          //#define XR_1
  96          //#define XR_2
  97          //#define XR_3
  98          //#define XR_4
  99          //#define XR_5
 100          //#define XR_6
 101          //#define XR_7
 102          //#define YR_0
 103          //#define YR_1
 104          #define MCP4768_DAC1            1
 105          #define MCP4768_DAC2            2
 106          #define MCP4768_DAC3            3
 107          #define MCP4768_DAC4            4
 108          
 109          void upDateDac0(uint16_t dat);
 110          void upDateDac1(uint16_t dat);
 111          /*****************************************************************************/
 112          
 113          void main(void){
 114   1              Init_Device();
 115   1              //timer0Init();
C51 COMPILER V9.59.0.0   MAINAPP                                                           12/22/2018 00:42:45 PAGE 3   

 116   1              //inPca9554Init();
 117   1              //outPca9554Init();
 118   1              //mcp47x6Init();
 119   1              initModbus(CONFIG_MODBUS_SLAVE_ADDRESS, CONFIG_UART0_BAUDRATE);
 120   1              ES0 = 1;
 121   1              ENABLE_INTERRUPT;
 122   1              nvramLoad();//上电恢复NVRAM
 123   1              while(1){
 124   2                      processModbus();
 125   2                      //refreshInput();//刷新输入IO
 126   2                      //getAdc();
 127   2      ////            SET(10);
 128   2      ////            RESET(10);
 129   2      ////            SET(10);
 130   2      ////            RESET(10);
 131   2      ////            SET(10);
 132   2      ////            RESET(10);
 133   2      ////            SET(10);
 134   2      ////            RESET(10);
 135   2      ////            FLIP(10);
 136   2      ////            FLIP(10);
 137   2      ////            FLIP(10);
 138   2      ////            FLIP(10);
 139   2      ////            //读取IO
 140   2      ////            //执行程序
 141   2      ////            //输出IO
 142   2      ////            T100MS(0, 1, 2);
 143   2      ////            if(LD(TD_100MS_START * 16 + 0));
 144   2      ////            {
 145   2      ////                    SET(0); 
 146   2      ////            }
 147   2                      nvramUpdata();//更新NVRAM
 148   2                      //refreshOutput();//刷新输出IO
 149   2              }
 150   1      }
 151          //void main(void)
 152          //{
 153          //      int8_t temp;
 154          //      int16_t tecOnTime, tecOffTime;//制冷开关时间
 155          ////    my_t *p = my;
 156          ////    pidFuzzy_t pidFuzzy;
 157          //      Init_Device();//初始化MCU
 158          //#if CONFIG_USING_WDT == 1
 159          //      if ((RSTSRC & 0x02) == 0x00)
 160          //      {
 161          //              if (RSTSRC == 0x08)
 162          //              {//检测WDT看门狗 看门狗复位后锁定
 163          //                      //所有IO ->LOW
 164          //                      //关闭DAC
 165          //                      //关闭
 166          //                      LED_MCU = true;
 167          //                      LED_LASER0 = false;
 168          //                      LED_LASER1 = true;
 169          //                      while(1);
 170          //              }
 171          //      }
 172          //#endif
 173          
 174                  //pidFuzzyInit(&pidFuzzy, 2, 0.5, 0.1);
 175          //      setModbusSlaveAddr(CONFIG_LOCAL_ADDRESS);//设置从机地址
 176          //      InitModbusHardware(CONFIG_UART0_BAUDRATE);//初始化MODBUS从机串口
 177          //      /**********************************************************************/
C51 COMPILER V9.59.0.0   MAINAPP                                                           12/22/2018 00:42:45 PAGE 4   

 178          ////初始化my结构体
 179          //      //my.stepNum = 0;
 180          //      //my.checkCode = ((CONFIG_CHECK_CODE << 8) & 0xFF00);
 181          //      //my.checkCode |= CONFIG_VERSION;
 182          //      
 183          ////使能看门狗
 184          //#if CONFIG_USING_WDT == 1
 185          //      Watchdog_Init();
 186          //#endif        
 187          //      EA = 1;
 188          //      
 189          //      while(1)
 190          //      {//开始循环扫描周期
 191          ////看门狗喂狗
 192          //#if CONFIG_USING_WDT == 1
 193          //               WDTCN = 0xA5;//喂狗
 194          //#endif
 195          ////上位机使能MCU软复位
 196          //#if CONFIG_USING_RESET == 1
 197          //              if(my.mcuReset)
 198          //              {
 199          //                      RSTSRC |= (1 << 1);//Forces a Power-On Reset. /RST is driven low.
 200          //              }
 201          //#endif
 202          //              //数字滤波扫描输入IO
 203          
 204          //              p->flagConnectErr = 0;//每次扫描错误标志清零
 205          //              //心跳->PLC
 206          //              if(my.heartFlag)
 207          //              {
 208          //                      my.heatFlag = 0;
 209          //              }
 210          //              else
 211          //              {
 212          //                      my.heatFlag = 1;
 213          //              }
 214          //              
 215          //              //获取过热状态
 216          //              my.overTempFault = (my.overTempDiode && !my.overTempDiodeIgnore) ||
 217          //                                                        (my.overTempAmplifier && !my.overTempAmplifierIgnore) ||
 218          //                                (my.overTempEnvironment && !my.overTempEnvironmentIgnore) ||
 219          //                                                        (my.overTempMcu && !my.overTempMcuIgnore);
 220          //          my.overTempFault = my.overTempFault && !my.overTempIgnore;
 221          //              //获取安全状态
 222          //              my.safeFault = (my.safeInterlock && !my.safeInterlockIgnore) ||
 223          //                                      (my.safeFiberDetect0 && my.safeFiberDetect0Ignore) ||
 224          //                                      (my.safeFiberDetect1 && my.safeFiberDetect1Ignore) ||
 225          //                                      (my.safeOpenCase && my.safeOpenCaseIgnore);
 226          //              my.safeFault = my.safeFault && !my.safeFaultIgnore;
 227          //              //模拟输入扫描
 228          //              STEP_LOOP_START:
 229          //              if(my.stepNum == STEPNUM_INIT)
 230          //              {//初始化
 231          //                      my.stepNum = STEPNUM_STANDBY;//Goto next step
 232          //                      goto STEP_LOOP_END;
 233          //              }
 234          //              if(my.stepNum == STEPNUM_STANDBY)
 235          //              {//第一步 待机状态->蜂鸣器提示
 236          //                      if(my.safeFault ||
 237          //               my.overTempFault)
 238          //                      {
 239          //                              my.stepNum = STEPNUM_FAULT;
C51 COMPILER V9.59.0.0   MAINAPP                                                           12/22/2018 00:42:45 PAGE 5   

 240          //                      }
 241          //                      else if(my.readyFlag)
 242          //                      {
 243          //                              my.beemOn = true;
 244          //                              my.stepNum = STEPNUM_INTO_READY;
 245          //                      }
 246          //                      else
 247          //                      {
 248          //                              my.stepNum = STEPNUM_STANDBY;
 249          //                      }
 250          //                      goto STEP_LOOP_END;
 251          //              }
 252          //              if(my.stepNum == STEPNUM_INTO_READY)
 253          //              {//第二步 等待1秒后进入
 254          //                      if(my.readyFlag)
 255          //                      {
 256          //                              my.beemOn = true;
 257          //                              sTimerCtrl(STIMER_ON, STIMER_100MS_INTOREADY_BEEM, 10);
 258          //                              if(sTimer[STIMER_100MS_INTOREADY_BEEM].status)
 259          //                              {//计时达到进入READY步骤
 260          //                                      sTimerCtrl(STIMER_OFF, STIMER_100MS_INTOREADY_BEEM, 10);
 261          //                                      my.beemOn = false;
 262          //                                      my.stepNum = STEPNUM_READY;
 263          //                              }
 264          //                      }
 265          //                      goto STEP_LOOP_END;
 266          //              }
 267          //              if(my.stepNum == STEPNUM_READY)
 268          //              {//第三步 准备状态 等待脚踏信号发射激光
 269          //                      if(my.safeFault ||
 270          //               my.overTempFault)
 271          //                      {
 272          //                              my.stepNum = STEPNUM_FAULT;
 273          //                      }
 274          //                      else if((my.footSwitch && 0x01) &&
 275          //                                  !(my.footSwitch && 0x02))//检测footSwitch上升沿
 276          //                      {//发射激光步骤
 277          //                              //打开激光
 278          //                              my.stepNum = STEPNUM_LASERON;
 279          //                              my.laserEmitOver = 0x0;//发射完成标志清零
 280          //                              switch(my.laserMode)
 281          //                              {
 282          //                                      case ENUM_MODE_CW:
 283          //                                      {
 284          //                                              my.laserEmiting |=  1 << ENUM_MODE_CW;
 285          //                                              break;
 286          //                                      }
 287          //                                      case ENUM_MODE_SP:
 288          //                                      {
 289          //                                              my.laserEmiting |=  1 << ENUM_MODE_SP;
 290          //                                              break;
 291          //                                      }
 292          //                                      case ENUM_MODE_MP:
 293          //                                      {
 294          //                                              my.laserEmiting |=  1 << ENUM_MODE_MP;
 295          //                                              break;
 296          //                                      }
 297          //                                      case ENUM_MODE_GP:
 298          //                                      {
 299          //                                              my.laserEmiting |=  1 << ENUM_MODE_GP;
 300          //                                              break;
 301          //                                      }
C51 COMPILER V9.59.0.0   MAINAPP                                                           12/22/2018 00:42:45 PAGE 6   

 302          //                                      case ENUM_MODE_CC:
 303          //                                      {
 304          //                                              my.laserEmiting |=  1 << ENUM_MODE_CC;
 305          //                                              break;
 306          //                                      }
 307          //                                      default:break;
 308          //                              }
 309          //                      }
 310          //                      goto STEP_LOOP_END;
 311          //              }
 312          //              if(my.stepNum == STEPNUM_LASERON)
 313          //              {
 314          //                      if(my.safeFault || my.overTempFault)
 315          //                      {//故障:
 316          //                              my.stepNum = STEPNUM_FAULT;
 317          //                      }
 318          //                      else if(!(my.footSwitch & 0x01))//脚踏复位
 319          //                      {
 320          //                              //关闭激光
 321          //                              my.stepNum = STEPNUM_READY;//返回READY步骤
 322          //                      }
 323          //                      else
 324          //                      {
 325          //                              if( my.laserEmiting == ENUM_MODE_CW)
 326          //                              {//连续模式
 327          //                                      switch(my.selectChannel)
 328          //                                      {
 329          //                                              case ENUM_CHANNEL_BOTH:
 330          //                                              {
 331          //                                                      upDateDac0(laserCurrent[0]);
 332          //                                                      upDateDac1(laserCurrent[1]);
 333          //                                                      break;
 334          //                                              }
 335          //                                              case ENUM_CHANNEL1:
 336          //                                              {
 337          //                                                      upDateDac0(laserCurrent[0]);
 338          //                                                      break;
 339          //                                              }
 340          //                                              case ENUM_CHANNEL2:
 341          //                                              {
 342          //                                                      upDateDac1(laserCurrent[1]);
 343          //                                                      break;
 344          //                                              }
 345          //                                              default:break;
 346          //                                      }
 347          //                              }
 348          //                              if( my.laserEmiting == ENUM_MODE_SP )
 349          //                              {//单脉冲模式
 350          //                                      if(selectChannel == ENUM_CHANNEL_BOTH)
 351          //                                      {
 352          //                                              upDateDac0(laserCurrent[0]);
 353          //                                              upDateDac1(laserCurrent[1]);
 354          //                                      }
 355          //                                      if(selectChannel == ENUM_CHANNEL1)
 356          //                                      {
 357          //                                              upDateDac0(laserCurrent[0]);
 358          //                                      }
 359          //                                      if(selectChannel = ENUM_CHANNEL2)
 360          //                                      {
 361          //                                              upDateDac1(laserCurrent[1]);
 362          //                                      }
 363          //                                      sTimerCtrl(STIMER_ON, STIMER_1MS_SP_LASER_ON, my.posWidth);
C51 COMPILER V9.59.0.0   MAINAPP                                                           12/22/2018 00:42:45 PAGE 7   

 364          //                                      if(sTimer[STIMER_1MS_LASER_ON].status)
 365          //                                      {
 366          //                                              upDateDac0(0x0);
 367          //                                              upDateDac1(0x0);
 368          //                                              my.laserEmiting &=  ~(1<< ENUM_MODE_CW);//发射完成清空正在发射标志位
 369          //                                              my.laserEmitOver |= 1 << ENUM_MODE_CW;//发射完成标志位置位
 370          //                                              sTimerCtrl(STIMER_OFF, STIMER_1MS_SP_LASER_ON, my.posWidth);
 371          //                                      }
 372          //                              }       
 373          //                              if( my.laserEmiting == ENUM_MODE_MP )
 374          //                              {//多脉冲模式
 375          //                                      if(!sTimer[STIMER_1MS_LASER_ON].enable)
 376          //                                      {//正脉宽计时
 377          //                                      if(selectChannel == ENUM_CHANNEL_BOTH)
 378          //                              {
 379          //                                      DAC0 = laserCurrent[0];
 380          //                                      DAC1 = laserCurrent[1];
 381          //                              }
 382          //                              if(selectChannel == ENUM_CHANNEL1)
 383          //                              {
 384          //                                      
 385          //                              }
 386          //                              if(selectChannel = ENUM_CHANNEL2)
 387          //                              {
 388          //                              }
 389          //                              sTimerCtrl(STIMER_ON, STIMER_1MS_LASER_ON, my.posWidth);
 390          //                              if(sTimer[STIMER_1MS_LASER_ON].status)
 391          //                              {
 392          //                                      //关闭激光
 393          //                                      //关闭计时器
 394          //                                      my.laserOnFlag = 0;
 395          //                                      sTimerCtrl(STIMER_OFF, STIMER_1MS_LASER_ON, my.posWidth);
 396          //                              }       
 397          //                      }
 398          //                      else if(!my.laserOnFlag)
 399          //                      {//负脉宽计时
 400          //                              sTimerCtrl(STIMER_ON, STIMER_1MS_LASER_OFF, my.negWidth);
 401          //                              if(sTimer[STIMER_1MS_LASER_OFF].status)
 402          //                              {
 403          //                                      my.laserOnFlag = 1;
 404          //                                      sTimerCtrl(STIMER_OFF, STIMER_1MS_LASER_ON, my.posWidth);
 405          //                              }
 406          //                      }
 407          //              }
 408          //              if( !my.triggerCW || !my.triggerSP || !my.triggerMP || !my.triggerGP || my.triggerCC)
 409          //              {//校正模式
 410          //                      
 411          //              }
 412          //                      }
 413          //                      goto STEP_LOOP_END;
 414          //              }
 415          //              if(my.stepNum == STEPNUM_FAULT)
 416          //              {//错误状态
 417          //                      //关闭激光
 418          //                      if(!my.safeFault &&
 419          //               !my.overTempFault)
 420          //                      {//错误消除
 421          //                              if(my.clearError)
 422          //                              {//错误消除返回待机状态
 423          //                                      my.clearError = 0;
 424          //                                      my.stepNum = STEPNUM_STANDBY;
 425          //                              }
C51 COMPILER V9.59.0.0   MAINAPP                                                           12/22/2018 00:42:45 PAGE 8   

 426          //                      }
 427          //                      else
 428          //                      {
 429          //                              my.stepNum = STEPNUM_FAULT;
 430          //                      }
 431          //                      goto STEP_LOOP_END;
 432          //              }
 433          //              STEP_LOOP_END:
 434          //              if( my.triggerCW || !my.triggerSP || !my.triggerMP || !my.triggerGP || !my.triggerCC)
 435          //              {//连续模式
 436          //                      if(!my.laserOnFlag)
 437          //                      {       
 438          //                              switch(my.selectChannel)
 439          //                              {
 440          //                                      case ENUM_CHANNEL_BOTH:
 441          //                                      {
 442          //                                              DAC0 = laserCurrent[0];
 443          //                                              DAC1 = laserCurrent[1];
 444          //                                              break;
 445          //                                      }
 446          //                                      case ENUM_CHANNEL1:
 447          //                                      {
 448          //                                              DAC0 = laserCurrent[0]; 
 449          //                                              break;
 450          //                                      }
 451          //                                      case ENUM_CHANNEL2:
 452          //                                      {
 453          //                                              DAC1 = laserCurrent[1];
 454          //                                              break;
 455          //                                      }
 456          //                                      default:break;
 457          //                              }
 458          //                              my.laserOnFlag = 1;
 459          //                      }
 460          //                      
 461          //              }
 462          //              if( my.triggerCW || !my.triggerSP || !my.triggerMP || !my.triggerGP || !my.triggerCC)
 463          //              {//单脉冲模式
 464          //                      if(!my.laserOnFlag)
 465          //                      {
 466          //                              if(selectChannel == ENUM_CHANNEL_BOTH)
 467          //                              {
 468          //                                      DAC0 = laserCurrent[0];
 469          //                                      DAC1 = laserCurrent[1];
 470          //                              }
 471          //                              if(selectChannel == ENUM_CHANNEL1)
 472          //                              {
 473          //                                      DAC0 = laserCurrent[0];
 474          //                              }
 475          //                              if(selectChannel = ENUM_CHANNEL2)
 476          //                              {
 477          //                                      DAC1 = laserCurrent[1];
 478          //                              }
 479          //                              sTimerCtrl(STIMER_ON, STIMER_1MS_SP_LASER_ON, my.posWidth);
 480          //                              if(sTimer[STIMER_1MS_LASER_ON].status)
 481          //                              {
 482          //                                      DAC0 = 0x0;
 483          //                                      DAC1 = 0x0;
 484          //                                      my.laserOnFlag = 0;
 485          //                                      my.triggerSP = 0;
 486          //                                      sTimerCtrl(STIMER_OFF, STIMER_1MS_SP_LASER_ON, my.posWidth);
 487          //                              }
C51 COMPILER V9.59.0.0   MAINAPP                                                           12/22/2018 00:42:45 PAGE 9   

 488          //                      }
 489          //                      
 490          //              }
 491          //              if( !my.triggerCW || !my.triggerSP || my.triggerMP || !my.triggerGP || !my.triggerCC)
 492          //              {//多脉冲模式
 493          //                      if(my.laserOnFlag)
 494          //                      {//正脉宽计时
 495          //                              if(selectChannel == ENUM_CHANNEL_BOTH)
 496          //                              {
 497          //                                      DAC0 = laserCurrent[0];
 498          //                                      DAC1 = laserCurrent[1];
 499          //                              }
 500          //                              if(selectChannel == ENUM_CHANNEL1)
 501          //                              {
 502          //                                      
 503          //                              }
 504          //                              if(selectChannel = ENUM_CHANNEL2)
 505          //                              {
 506          //                              }
 507          //                              sTimerCtrl(STIMER_ON, STIMER_1MS_LASER_ON, my.posWidth);
 508          //                              if(sTimer[STIMER_1MS_LASER_ON].status)
 509          //                              {
 510          //                                      //关闭激光
 511          //                                      //关闭计时器
 512          //                                      my.laserOnFlag = 0;
 513          //                                      sTimerCtrl(STIMER_OFF, STIMER_1MS_LASER_ON, my.posWidth);
 514          //                              }       
 515          //                      }
 516          //                      else if(!my.laserOnFlag)
 517          //                      {//负脉宽计时
 518          //                              sTimerCtrl(STIMER_ON, STIMER_1MS_LASER_OFF, my.negWidth);
 519          //                              if(sTimer[STIMER_1MS_LASER_OFF].status)
 520          //                              {
 521          //                                      my.laserOnFlag = 1;
 522          //                                      sTimerCtrl(STIMER_OFF, STIMER_1MS_LASER_ON, my.posWidth);
 523          //                              }
 524          //                      }
 525          //              }
 526          //              if( !my.triggerCW || !my.triggerSP || !my.triggerMP || !my.triggerGP || my.triggerCC)
 527          //              {//校正模式
 528          //                      
 529          //              }
 530          //              
 531          //              //Debug LED闪烁
 532          //              if(LED_MCU)
 533          //              {
 534          //                      if(sTimer[STIMER_1000MS_LED_ON].status)//等待时间A
 535          //                      {
 536          //                              LED_MCU = 0;
 537          //                              sTimerCtrl(STIMER_OFF, STIMER_1000MS_LED_ON, 1);
 538          //                      }
 539          //                      else
 540          //                              sTimerCtrl(STIMER_ON, STIMER_1000MS_LED_ON, 1);
 541          //              }
 542          //              if(!LED_MCU)
 543          //              {
 544          //                      if(sTimer[STIMER_1000MS_LED_OFF].status)//等待时间B
 545          //                      {
 546          //                              LED_MCU = 1;
 547          //                              sTimerCtrl(STIMER_OFF, STIMER_1000MS_LED_OFF, 1);
 548          //                      }
 549          //                      else
C51 COMPILER V9.59.0.0   MAINAPP                                                           12/22/2018 00:42:45 PAGE 10  

 550          //                              sTimerCtrl(STIMER_ON, STIMER_1000MS_LED_OFF, 1);
 551          //              }
 552          //              //PID 温控指令
 553          //              if(sTimer[(CONFIG_STIMER_100MS_END - 3)].status)//等待A时间
 554          //              {
 555          //                      my.pidOut += pidFuzzyRealize(&pidFuzzy, 25.0, 26.0);
 556          //                      if(my.pidOut > 1)
 557          //                              my.pidOut = 1;
 558          //                      if(my.pidOut < 0)
 559          //                              my.pidOut = 0;
 560          //                      //my.onTimerPid = (int16_t)(my.pidOut * CONFIG_PIDOUT_PWM);
 561          //                      //my.offTimerPid = CONFIG_TECOUT_MAX_CYCLE - my.onTimerPid; 
 562          //                      sTimerCtrl(STIMER_OFF, (CONFIG_STIMER_100MS_END - 3), 10);
 563          //              }
 564          //              else
 565          //                      sTimerCtrl(STIMER_ON, (CONFIG_STIMER_100MS_END - 3), 10);
 566          //              //PID结果输出
 567          
 568          //              if(sTimer[1].value >= CONFIG_TECOUT_CYCLE || sTimer[1].enable == 0)
 569          //              {
 570          //                      COOL_OUT = 1;
 571          //                      //tecOnTime = (int16_t)(my.pidOut * CONFIG_TECOUT_CYCLE);
 572          //                      tecOnTime = (int16_t)(0.25 * CONFIG_TECOUT_CYCLE);
 573          //                      sTimerCtrl(STIMER_OFF, 1, tecOnTime);
 574          //                      sTimerCtrl(STIMER_ON, 1, tecOnTime);
 575          //              }
 576          //              if(sTimer[1].value >= tecOnTime)
 577          //              {
 578          //                      COOL_OUT = 0;
 579          //              }
 580          //              modbusPoll();//执行MODBUS POLL
 581          //              
 582          //              //setOutput();//更新输出IO
 583          //      
 584          //      }               
 585          //}
 586          
 587          //void startLaser(void)
 588          //{//开始发射脉冲       
 589          //      if(my.laserMode == ENUM_MODE_CW )
 590          //      {
 591          //              DAC0 = my.laserCurrent[0];
 592          //              DAC1 = my.laserCurrent[1];
 593          //      }
 594          //      else if((my.LaserMode == ENUM_MODE_SP) | 
 595          //                      (my.LaserMode == ENUM_MODE_MP) |
 596          //                      (my.LaserMode == ENUM_MODE_GP))
 597          //      {
 598          //              my.laserTimer.tMate = my.PosWidth;//设置匹配值
 599          //              my.laserTimer.tOverflow = my.NegWidth + my.PosWidth;//设置溢出值
 600          //              my.laserTimer.tCounter = 0x0;   
 601          //              my.laserTimer.pMate = 0x0;//脉冲个数匹配值
 602          //              my.laserTimer.sMate = 0x0;//脉个数溢出值
 603          //              my.laserTimer.pCounter = 0x0;
 604          //              my.laserTimer.sCounter = 0x0;   
 605          //              TF2H = 0;//Timer 2 High Byte Overflow Flag.
 606          //              ET2 = 1;
 607          //              TMR2L = 0xFF;
 608          //              TMR2H = 0xFF;
 609          //              TR2 = 1;//使能TIMER2计时器
 610          //      }
 611          //      else if(my.LaserMode == ENUM_MODE_CC)
C51 COMPILER V9.59.0.0   MAINAPP                                                           12/22/2018 00:42:45 PAGE 11  

 612          //      {//校正模式
 613          //              my.laserTimer.tMate = my.PosWidth;//设置匹配值
 614          //              my.laserTimer.tOverflow = my.NegWidth + my.PosWidth;//设置溢出值
 615          //              my.laserTimer.tCounter = 0x0;   
 616          //              my.laserTimer.pMate = my.GroupNum;//脉冲个数匹配值
 617          //              my.laserTimer.sMate = my.GroupSpace;//脉个数溢出值
 618          //              my.laserTimer.pCounter = 0x0;
 619          //              my.laserTimer.sCounter = 0x0;   
 620          //              TF2H = 0;//Timer 2 High Byte Overflow Flag.
 621          //              ET2 = 1;
 622          //              TMR2L = 0xFF;
 623          //              TMR2H = 0xFF;
 624          //              TR2 = 1;//使能TIMER2计时器
 625          //      }
 626          //      my.FlagIndicate = 1;
 627          //}
 628          //void stopLaser(myDevice_t *p)
 629          //{//停止发射脉冲
 630          //      TR2 = 0;
 631          //      ET2 = 0;
 632          //      TF2H = 0;
 633          //      DAC0 = 0;
 634          //      DAC1 = 0;
 635          //      my.FlagIndicate = 0;    
 636          //}
 637          
 638          //void Timer0_ISR(void) interrupt INTERRUPT_TIMER0
 639          //{//TIMER2 中断 激光发射
 640          //      
 641          //      TF2H = 0;
 642          //      switch(my.LaserMode)
 643          //      {
 644          //              case ENUM_MODE_CC:
 645          //              {//CC模式
 646          //                      SetLaserCurrent(p);
 647          //                      break;
 648          //              }
 649          //              case ENUM_MODE_SP:
 650          //              {//SP模式
 651          //                      break;
 652          //              }
 653          //              case ENUM_MODE_MP:
 654          //              {//MP模式       
 655          //                      if(p->softTimer.tCounter == p->softTimer.tMate)
 656          //                      {//计时器匹配
 657          //                              LaserMod_PIN = LASER_OFF;//翻转输出
 658          //                      }
 659          //                      if(p->softTimer.tCounter == p->softTimer.tOverflow)
 660          //                      {//计时器溢出
 661          //                              p->softTimer.tCounter = 0;//清零
 662          //                      }
 663          //                      if(p->softTimer.tCounter == 0)
 664          //                      {//翻转
 665          //                              LaserMod_PIN = LASER_ON;//翻转输出
 666          //                      }
 667          //                      p->softTimer.tCounter ++;
 668          //                      break;
 669          //              }
 670          //              case ENUM_MODE_GP:
 671          //              {//GP模式
 672          //                      if(p->softTimer.pCounter < p->softTimer.pMate)
 673          //                      {
C51 COMPILER V9.59.0.0   MAINAPP                                                           12/22/2018 00:42:45 PAGE 12  

 674          //                              if(p->softTimer.tCounter == 0)
 675          //                              {
 676          //                                      if(p->softTimer.pCounter < p->softTimer.pMate)
 677          //                                      {
 678          //                                              LaserMod_PIN = LASER_ON;//翻转输出                                              
 679          //                                      }
 680          //                              }
 681          //                              if(p->softTimer.tCounter == p->softTimer.tMate)
 682          //                              {//计时器匹配
 683          //                                      LaserMod_PIN = LASER_OFF;//翻转输出
 684          //                              }
 685          //                              if(p->softTimer.tCounter == (p->softTimer.tOverflow - 1))
 686          //                              {//计时器溢出
 687          //                                      p->softTimer.tCounter = 0xFFFF;//清零
 688          //                                      p->softTimer.pCounter ++;//清零 
 689          //                              }
 690          //                              p->softTimer.tCounter ++;
 691          //                      }
 692          //                      if(p->softTimer.pCounter == p->softTimer.pMate && p->softTimer.tCounter == 0)
 693          //                      {//脉冲个数发现匹配
 694          //                              LaserMod_PIN = LASER_OFF;
 695          //                              p->softTimer.pCounter = 0xFFFF;
 696          //                              p->softTimer.sCounter = 0x0;
 697          //                      }
 698          //                      if(p->softTimer.pCounter == 0xFFFF)
 699          //                      {               
 700          //                              if(p->softTimer.sCounter == p->softTimer.sMate)
 701          //                              {
 702          //                                      p->softTimer.pCounter = 0;      
 703          //                              }
 704          //                              p->softTimer.sCounter ++;
 705          //                      }
 706          //                      break;
 707          //              }
 708          //              default:break;
 709          //      }
 710          //}
 711          
 712          //void upDateDac0(uint16_t dat)
 713          //{//刷新DAC0
 714          //      static uint16_t oldDac0;
 715          //      if(dat != oldDac0)
 716          //      {
 717          //              DAC0 = dat;
 718          //              oldDac0 = dat;
 719          //      }
 720          //}
 721          //void upDateDac1(uint16_t dat)
 722          //{//刷新DAC1
 723          //      static uint16_t oldDac1;
 724          //      if(dat != oldDac1)
 725          //      {
 726          //              DAC0 = dat;
 727          //              oldDac1 = dat;
 728          //      }
 729          //}


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =     32    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
C51 COMPILER V9.59.0.0   MAINAPP                                                           12/22/2018 00:42:45 PAGE 13  

   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
