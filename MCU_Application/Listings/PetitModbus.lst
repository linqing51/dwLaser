C51 COMPILER V9.59.0.0   PETITMODBUS                                                       12/19/2018 23:00:14 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE PETITMODBUS
OBJECT MODULE PLACED IN .\Objects\PetitModbus.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Modbus\PetitModbus.c COMPACT OPTIMIZE(8,SPEED) REGFILE(.\Objects\dwLaser
                    -_F020.ORC) BROWSE ORDER INCDIR(.\Lib;.\Driver;.\MainApp;.\Modbus) DEFINE(C8051F020) DEBUG OBJECTEXTEND PRINT(.\Listings\
                    -PetitModbus.lst) OBJECT(.\Objects\PetitModbus.obj)

line level    source

   1          #include "PetitModbus.h"
   2          #include "PetitModbusPort.h"
   3          
   4          /*******************************ModBus Functions*******************************/
   5          #define PETITMODBUS_READ_COILS                  1
   6          #define PETITMODBUS_READ_DISCRETE_INPUTS        2
   7          #define PETITMODBUS_READ_HOLDING_REGISTERS      3
   8          #define PETITMODBUS_READ_INPUT_REGISTERS        4
   9          #define PETITMODBUS_WRITE_SINGLE_COIL           5
  10          #define PETITMODBUS_WRITE_SINGLE_REGISTER       6
  11          #define PETITMODBUS_WRITE_MULTIPLE_COILS        15
  12          #define PETITMODBUS_WRITE_MULTIPLE_REGISTERS    16
  13          /****************************End of ModBus Functions***************************/
  14          
  15          #define PETIT_FALSE_FUNCTION                    0
  16          #define PETIT_FALSE_SLAVE_ADDRESS               1
  17          #define PETIT_DATA_NOT_READY                    2
  18          #define PETIT_DATA_READY                        3
  19          
  20          #define PETIT_ERROR_CODE_01                     0x01                            // Function code is not su
             -pported
  21          #define PETIT_ERROR_CODE_02                     0x02                            // Register address is not
             - allowed or write-protected
  22          #define PETIT_ERROR_CODE_03                     0x03                            // Some data values are ou
             -t of range, invalid number of register
  23          
  24          unsigned char PETITMODBUS_SLAVE_ADDRESS         =1;
  25          
  26          typedef enum
  27          {
  28              PETIT_RXTX_IDLE,
  29              PETIT_RXTX_START,
  30              PETIT_RXTX_DATABUF,
  31              PETIT_RXTX_WAIT_ANSWER,
  32              PETIT_RXTX_TIMEOUT
  33          }PETIT_RXTX_STATE;
  34          
  35          typedef struct
  36          {
  37            unsigned char     Address;
  38            unsigned char     Function;
  39            unsigned char     DataBuf[PETITMODBUS_RXTX_BUFFER_SIZE];
  40            unsigned short    DataLen;
  41          }PETIT_RXTX_DATA;
  42          
  43          /**********************Slave Transmit and Receive Variables********************/
  44          PETIT_RXTX_DATA     Petit_Tx_Data;
  45          unsigned int        Petit_Tx_Current              = 0;
  46          unsigned int        Petit_Tx_CRC16                = 0xFFFF;
  47          PETIT_RXTX_STATE    Petit_Tx_State                = PETIT_RXTX_IDLE;
  48          unsigned char       Petit_Tx_Buf[PETITMODBUS_TRANSMIT_BUFFER_SIZE];
  49          unsigned int        Petit_Tx_Buf_Size             = 0;
  50          
C51 COMPILER V9.59.0.0   PETITMODBUS                                                       12/19/2018 23:00:14 PAGE 2   

  51          PETIT_RXTX_DATA     Petit_Rx_Data;
  52          unsigned int        Petit_Rx_CRC16                = 0xFFFF;
  53          PETIT_RXTX_STATE    Petit_Rx_State                = PETIT_RXTX_IDLE;
  54          unsigned char       Petit_Rx_Data_Available       = FALSE;
  55          
  56          volatile unsigned short PetitModbusTimerValue         = 0;
  57          /****************End of Slave Transmit and Receive Variables*******************/
  58          
  59          /*
  60           * Function Name        : CRC16
  61           * @param[in]           : Data  - Data to Calculate CRC
  62           * @param[in/out]       : CRC   - Anlik CRC degeri
  63           * @How to use          : First initial data has to be 0xFFFF.
  64           */
  65          void Petit_CRC16(const unsigned char Data, unsigned int* CRC)
  66          {
  67   1          unsigned int i;
  68   1      
  69   1          *CRC = *CRC ^(unsigned int) Data;
  70   1          for (i = 8; i > 0; i--)
  71   1          {
  72   2              if (*CRC & 0x0001)
  73   2                  *CRC = (*CRC >> 1) ^ 0xA001;
  74   2              else
  75   2                  *CRC >>= 1;
  76   2          }
  77   1      }
  78          
  79          /******************************************************************************/
  80          
  81          /*
  82           * Function Name        : DoTx
  83           * @param[out]          : TRUE
  84           * @How to use          : It is used for send data package over physical layer
  85           */
  86          unsigned char Petit_DoSlaveTX(void)
  87          {  
  88   1          PetitModBus_UART_String(Petit_Tx_Buf,Petit_Tx_Buf_Size);
  89   1      
  90   1          Petit_Tx_Buf_Size = 0;
  91   1          return TRUE;
  92   1      }
  93          
  94          /******************************************************************************/
  95          
  96          /*
  97           * Function Name        : SendMessage
  98           * @param[out]          : TRUE/FALSE
  99           * @How to use          : This function start to sending messages
 100           */
 101          unsigned char PetitSendMessage(void)
 102          {
 103   1          if (Petit_Tx_State != PETIT_RXTX_IDLE)
 104   1              return FALSE;
 105   1      
 106   1          Petit_Tx_Current  =0;
 107   1          Petit_Tx_State    =PETIT_RXTX_START;
 108   1      
 109   1          return TRUE;
 110   1      }
 111          
 112          /******************************************************************************/
C51 COMPILER V9.59.0.0   PETITMODBUS                                                       12/19/2018 23:00:14 PAGE 3   

 113          
 114          /*
 115           * Function Name        : HandleModbusError
 116           * @How to use          : This function generated errors to Modbus Master
 117           */
 118          void HandlePetitModbusError(char ErrorCode)
 119          {
 120   1          // Initialise the output buffer. The first byte in the buffer says how many registers we have read
 121   1          Petit_Tx_Data.Function    = ErrorCode | 0x80;
 122   1          Petit_Tx_Data.Address     = PETITMODBUS_SLAVE_ADDRESS;
 123   1          Petit_Tx_Data.DataLen     = 0;
 124   1          PetitSendMessage();
 125   1      }
 126          
 127          /******************************************************************************/
 128          
 129          /*
 130           * Function Name        : HandleModbusReadHoldingRegisters
 131           * @How to use          : Modbus function 03 - Read holding registers
 132           */
 133          #if PETITMODBUS_READ_HOLDING_REGISTERS_ENABLED > 0
 134          void HandlePetitModbusReadHoldingRegisters(void)
 135          {
 136   1          // Holding registers are effectively numerical outputs that can be written to by the host.
 137   1          // They can be control registers or analogue outputs.
 138   1          // We potientially have one - the pwm output value
 139   1          unsigned int    Petit_StartAddress        = 0;
 140   1          unsigned int    Petit_NumberOfRegisters   = 0;
 141   1          unsigned int    Petit_i                   = 0;
 142   1      
 143   1          // The message contains the requested start address and number of registers
 144   1          Petit_StartAddress        = ((unsigned int) (Petit_Rx_Data.DataBuf[0]) << 8) + (unsigned int) (Petit_R
             -x_Data.DataBuf[1]);
 145   1          Petit_NumberOfRegisters   = ((unsigned int) (Petit_Rx_Data.DataBuf[2]) << 8) + (unsigned int) (Petit_R
             -x_Data.DataBuf[3]);
 146   1      
 147   1          // If it is bigger than RegisterNumber return error to Modbus Master
 148   1          if((Petit_StartAddress+Petit_NumberOfRegisters)>NUMBER_OF_OUTPUT_PETITREGISTERS)
 149   1              HandlePetitModbusError(PETIT_ERROR_CODE_02);
 150   1          else
 151   1          {
 152   2              // Initialise the output buffer. The first byte in the buffer says how many registers we have read
 153   2              Petit_Tx_Data.Function    = PETITMODBUS_READ_HOLDING_REGISTERS;
 154   2              Petit_Tx_Data.Address     = PETITMODBUS_SLAVE_ADDRESS;
 155   2              Petit_Tx_Data.DataLen     = 1;
 156   2              Petit_Tx_Data.DataBuf[0]  = 0;
 157   2      
 158   2              for (Petit_i = 0; Petit_i < Petit_NumberOfRegisters; Petit_i++)
 159   2              {
 160   3                  unsigned short Petit_CurrentData = PetitRegisters[Petit_StartAddress+Petit_i].ActValue;
 161   3      
 162   3                  Petit_Tx_Data.DataBuf[Petit_Tx_Data.DataLen]        = (unsigned char) ((Petit_CurrentData & 0x
             -FF00) >> 8);
 163   3                  Petit_Tx_Data.DataBuf[Petit_Tx_Data.DataLen + 1]    = (unsigned char) (Petit_CurrentData & 0xF
             -F);
 164   3                  Petit_Tx_Data.DataLen                        += 2;
 165   3                  Petit_Tx_Data.DataBuf[0]                      = Petit_Tx_Data.DataLen - 1;
 166   3              }
 167   2      
 168   2              PetitSendMessage();
 169   2          }
 170   1      }
C51 COMPILER V9.59.0.0   PETITMODBUS                                                       12/19/2018 23:00:14 PAGE 4   

 171          #endif
 172          
 173          /******************************************************************************/
 174          
 175          /*
 176           * Function Name        : HandleModbusReadInputRegisters
 177           * @How to use          : Modbus function 06 - Write single register
 178           */
 179          #if PETITMODBUSWRITE_SINGLE_REGISTER_ENABLED > 0
 180          void HandlePetitModbusWriteSingleRegister(void)
 181          {
 182   1          // Write single numerical output
 183   1          unsigned int    Petit_Address   = 0;
 184   1          unsigned int    Petit_Value     = 0;
 185   1          unsigned char   Petit_i         = 0;
 186   1      
 187   1          // The message contains the requested start address and number of registers
 188   1          Petit_Address   = ((unsigned int) (Petit_Rx_Data.DataBuf[0]) << 8) + (unsigned int) (Petit_Rx_Data.Dat
             -aBuf[1]);
 189   1          Petit_Value     = ((unsigned int) (Petit_Rx_Data.DataBuf[2]) << 8) + (unsigned int) (Petit_Rx_Data.Dat
             -aBuf[3]);
 190   1      
 191   1          // Initialise the output buffer. The first byte in the buffer says how many registers we have read
 192   1          Petit_Tx_Data.Function    = PETITMODBUS_WRITE_SINGLE_REGISTER;
 193   1          Petit_Tx_Data.Address     = PETITMODBUS_SLAVE_ADDRESS;
 194   1          Petit_Tx_Data.DataLen     = 4;
 195   1      
 196   1          if(Petit_Address>=NUMBER_OF_OUTPUT_PETITREGISTERS)
 197   1              HandlePetitModbusError(PETIT_ERROR_CODE_03);
 198   1          else
 199   1          {
 200   2              PetitRegisters[Petit_Address].ActValue=Petit_Value;
 201   2              // Output data buffer is exact copy of input buffer
 202   2              for (Petit_i = 0; Petit_i < 4; ++Petit_i)
 203   2                  Petit_Tx_Data.DataBuf[Petit_i] = Petit_Rx_Data.DataBuf[Petit_i];
 204   2          }
 205   1      
 206   1          PetitSendMessage();
 207   1      }
 208          #endif
 209          
 210          /******************************************************************************/
 211          
 212          /*
 213           * Function Name        : HandleModbusWriteMultipleRegisters
 214           * @How to use          : Modbus function 16 - Write multiple registers
 215           */
 216          #if PETITMODBUS_WRITE_MULTIPLE_REGISTERS_ENABLED > 0
 217          void HandleMPetitodbusWriteMultipleRegisters(void)
 218          {
 219   1          // Write single numerical output
 220   1          unsigned int    Petit_StartAddress            =0;
 221   1          unsigned char   Petit_ByteCount               =0;
 222   1          unsigned int    Petit_NumberOfRegisters       =0;
 223   1          unsigned char   Petit_i                       =0;
 224   1          unsigned int        Petit_Value                   =0;
 225   1      
 226   1          // The message contains the requested start address and number of registers
 227   1          Petit_StartAddress        = ((unsigned int) (Petit_Rx_Data.DataBuf[0]) << 8) + (unsigned int) (Petit_R
             -x_Data.DataBuf[1]);
 228   1          Petit_NumberOfRegisters   = ((unsigned int) (Petit_Rx_Data.DataBuf[2]) << 8) + (unsigned int) (Petit_R
             -x_Data.DataBuf[3]);
C51 COMPILER V9.59.0.0   PETITMODBUS                                                       12/19/2018 23:00:14 PAGE 5   

 229   1          Petit_ByteCount           = Petit_Rx_Data.DataBuf[4];
 230   1      
 231   1          // If it is bigger than RegisterNumber return error to Modbus Master
 232   1          if((Petit_StartAddress+Petit_NumberOfRegisters)>NUMBER_OF_OUTPUT_PETITREGISTERS)
 233   1              HandlePetitModbusError(PETIT_ERROR_CODE_03);
 234   1          else
 235   1          {
 236   2              // Initialise the output buffer. The first byte in the buffer says how many outputs we have set
 237   2              Petit_Tx_Data.Function    = PETITMODBUS_WRITE_MULTIPLE_REGISTERS;
 238   2              Petit_Tx_Data.Address     = PETITMODBUS_SLAVE_ADDRESS;
 239   2              Petit_Tx_Data.DataLen     = 4;
 240   2              Petit_Tx_Data.DataBuf[0]  = Petit_Rx_Data.DataBuf[0];
 241   2              Petit_Tx_Data.DataBuf[1]  = Petit_Rx_Data.DataBuf[1];
 242   2              Petit_Tx_Data.DataBuf[2]  = Petit_Rx_Data.DataBuf[2];
 243   2              Petit_Tx_Data.DataBuf[3]  = Petit_Rx_Data.DataBuf[3];
 244   2      
 245   2              // Output data buffer is exact copy of input buffer
 246   2              for (Petit_i = 0; Petit_i <Petit_NumberOfRegisters; Petit_i++)
 247   2              {
 248   3                  Petit_Value=(Petit_Rx_Data.DataBuf[5+2*Petit_i]<<8)+(Petit_Rx_Data.DataBuf[6+2*Petit_i]);
 249   3                  PetitRegisters[Petit_StartAddress+Petit_i].ActValue=Petit_Value;
 250   3              }
 251   2      
 252   2              PetitSendMessage();
 253   2          }
 254   1      }
 255          #endif
 256          
 257          /******************************************************************************/
 258          
 259          /*
 260           * Function Name        : RxDataAvailable
 261           * @return              : If Data is Ready, Return TRUE
 262           *                        If Data is not Ready, Return FALSE
 263           */
 264          unsigned char Petit_RxDataAvailable(void)
 265          {
 266   1          unsigned char Result    = Petit_Rx_Data_Available;
 267   1          
 268   1          Petit_Rx_Data_Available       = FALSE;
 269   1      
 270   1          return Result;
 271   1      }
 272          
 273          /******************************************************************************/
 274          
 275          /*
 276           * Function Name        : CheckRxTimeout
 277           * @return              : If Time is out return TRUE
 278           *                        If Time is not out return FALSE
 279           */
 280          unsigned char Petit_CheckRxTimeout(void)
 281          {
 282   1          // A return value of true indicates there is a timeout    
 283   1          if (PetitModbusTimerValue>= PETITMODBUS_TIMEOUTTIMER)
 284   1          {
 285   2              PetitModbusTimerValue   =0;
 286   2              PetitReceiveCounter     =0;
 287   2              return TRUE;
 288   2          }
 289   1      
 290   1          return FALSE;
C51 COMPILER V9.59.0.0   PETITMODBUS                                                       12/19/2018 23:00:14 PAGE 6   

 291   1      }
 292          
 293          /******************************************************************************/
 294          
 295          /*
 296           * Function Name        : CheckBufferComplete
 297           * @return              : If data is ready, return              DATA_READY
 298           *                        If slave address is wrong, return     FALSE_SLAVE_ADDRESS
 299           *                        If data is not ready, return          DATA_NOT_READY
 300           *                        If functions is wrong, return         FALSE_FUNCTION
 301           */
 302          unsigned char CheckPetitModbusBufferComplete(void)
 303          {
 304   1          int PetitExpectedReceiveCount=0;
 305   1      
 306   1          if(PetitReceiveCounter>4)
 307   1          {
 308   2              if(PetitReceiveBuffer[0]==PETITMODBUS_SLAVE_ADDRESS)
 309   2              {
 310   3                  if(PetitReceiveBuffer[1]==0x01 || PetitReceiveBuffer[1]==0x02 || PetitReceiveBuffer[1]==0x03 |
             -| PetitReceiveBuffer[1]==0x04 || PetitReceiveBuffer[1]==0x05 || PetitReceiveBuffer[1]==0x06)  // RHR
 311   3                  {
 312   4                      PetitExpectedReceiveCount    =8;
 313   4                  }
 314   3                  else if(PetitReceiveBuffer[1]==0x0F || PetitReceiveBuffer[1]==0x10)
 315   3                  {
 316   4                      PetitExpectedReceiveCount=PetitReceiveBuffer[6]+9;
 317   4                  }
 318   3                  else
 319   3                  {
 320   4                      PetitReceiveCounter=0;
 321   4                      return PETIT_FALSE_FUNCTION;
 322   4                  }
 323   3              }
 324   2              else
 325   2              {
 326   3                  PetitReceiveCounter=0;
 327   3                  return PETIT_FALSE_SLAVE_ADDRESS;
 328   3              }
 329   2          }
 330   1          else
 331   1              return PETIT_DATA_NOT_READY;
 332   1      
 333   1          if(PetitReceiveCounter==PetitExpectedReceiveCount)
 334   1          {
 335   2              return PETIT_DATA_READY;
 336   2          }
 337   1      
 338   1          return PETIT_DATA_NOT_READY;
 339   1      }
 340          
 341          /******************************************************************************/
 342          
 343          /*
 344           * Function Name        : RxRTU
 345           * @How to use          : Check for data ready, if it is good return answer
 346           */
 347          void Petit_RxRTU(void)
 348          {
 349   1          unsigned char   Petit_i;
 350   1          unsigned char   Petit_ReceiveBufferControl=0;
 351   1      
C51 COMPILER V9.59.0.0   PETITMODBUS                                                       12/19/2018 23:00:14 PAGE 7   

 352   1          Petit_ReceiveBufferControl    =CheckPetitModbusBufferComplete();
 353   1      
 354   1          if(Petit_ReceiveBufferControl==PETIT_DATA_READY)
 355   1          {
 356   2              Petit_Rx_Data.Address               =PetitReceiveBuffer[0];
 357   2              Petit_Rx_CRC16                      = 0xffff;
 358   2              Petit_CRC16(Petit_Rx_Data.Address, &Petit_Rx_CRC16);
 359   2              Petit_Rx_Data.Function              =PetitReceiveBuffer[1];
 360   2              Petit_CRC16(Petit_Rx_Data.Function, &Petit_Rx_CRC16);
 361   2      
 362   2              Petit_Rx_Data.DataLen=0;
 363   2      
 364   2              for(Petit_i=2;Petit_i<PetitReceiveCounter;Petit_i++)
 365   2                  Petit_Rx_Data.DataBuf[Petit_Rx_Data.DataLen++]=PetitReceiveBuffer[Petit_i];
 366   2      
 367   2              Petit_Rx_State =PETIT_RXTX_DATABUF;
 368   2      
 369   2              PetitReceiveCounter=0;
 370   2          }
 371   1      
 372   1          Petit_CheckRxTimeout();
 373   1      
 374   1          if ((Petit_Rx_State == PETIT_RXTX_DATABUF) && (Petit_Rx_Data.DataLen >= 2))
 375   1          {
 376   2              // Finish off our CRC check
 377   2              Petit_Rx_Data.DataLen -= 2;
 378   2              for (Petit_i = 0; Petit_i < Petit_Rx_Data.DataLen; ++Petit_i)
 379   2              {
 380   3                  Petit_CRC16(Petit_Rx_Data.DataBuf[Petit_i], &Petit_Rx_CRC16);
 381   3              }
 382   2              
 383   2              if (((unsigned int) Petit_Rx_Data.DataBuf[Petit_Rx_Data.DataLen] + ((unsigned int) Petit_Rx_Data.D
             -ataBuf[Petit_Rx_Data.DataLen + 1] << 8)) == Petit_Rx_CRC16)
 384   2              {
 385   3                  // Valid message!
 386   3                  Petit_Rx_Data_Available = TRUE;
 387   3              }
 388   2      
 389   2              Petit_Rx_State = PETIT_RXTX_IDLE;
 390   2          }
 391   1      }
 392          
 393          /******************************************************************************/
 394          
 395          /*
 396           * Function Name        : TxRTU
 397           * @How to use          : If it is ready send answers!
 398           */
 399          void Petit_TxRTU(void)
 400          {
 401   1          Petit_Tx_CRC16                =0xFFFF;
 402   1          Petit_Tx_Buf_Size             =0;
 403   1          Petit_Tx_Buf[Petit_Tx_Buf_Size++]   =Petit_Tx_Data.Address;
 404   1          Petit_CRC16(Petit_Tx_Data.Address, &Petit_Tx_CRC16);
 405   1          Petit_Tx_Buf[Petit_Tx_Buf_Size++]   =Petit_Tx_Data.Function;
 406   1          Petit_CRC16(Petit_Tx_Data.Function, &Petit_Tx_CRC16);
 407   1      
 408   1          for(Petit_Tx_Current=0; Petit_Tx_Current < Petit_Tx_Data.DataLen; Petit_Tx_Current++)
 409   1          {
 410   2              Petit_Tx_Buf[Petit_Tx_Buf_Size++]=Petit_Tx_Data.DataBuf[Petit_Tx_Current];
 411   2              Petit_CRC16(Petit_Tx_Data.DataBuf[Petit_Tx_Current], &Petit_Tx_CRC16);
 412   2          }
C51 COMPILER V9.59.0.0   PETITMODBUS                                                       12/19/2018 23:00:14 PAGE 8   

 413   1          
 414   1          Petit_Tx_Buf[Petit_Tx_Buf_Size++] = Petit_Tx_CRC16 & 0x00FF;
 415   1          Petit_Tx_Buf[Petit_Tx_Buf_Size++] =(Petit_Tx_CRC16 & 0xFF00) >> 8;
 416   1      
 417   1          Petit_DoSlaveTX();
 418   1      
 419   1          Petit_Tx_State    =PETIT_RXTX_IDLE;
 420   1      }
 421          
 422          /******************************************************************************/
 423          
 424          /*
 425           * Function Name        : ProcessModbus
 426           * @How to use          : ModBus main core! Call this function into main!
 427           */
 428          void ProcessPetitModbus(void)
 429          {
 430   1          if (Petit_Tx_State != PETIT_RXTX_IDLE)                                      // If answer is ready, sen
             -d it!
 431   1              Petit_TxRTU();
 432   1      
 433   1          Petit_RxRTU();                                                              // Call this function ever
             -y cycle
 434   1      
 435   1          if (Petit_RxDataAvailable())                                                // If data is ready enter 
             -this!
 436   1          {
 437   2              if (Petit_Rx_Data.Address == PETITMODBUS_SLAVE_ADDRESS)                 // Is Data for us?
 438   2              {
 439   3                  switch (Petit_Rx_Data.Function)                                     // Data is for us but whic
             -h function?
 440   3                  {
 441   4                      #if PETITMODBUS_READ_HOLDING_REGISTERS_ENABLED > 0
 442   4                      case PETITMODBUS_READ_HOLDING_REGISTERS:    {   HandlePetitModbusReadHoldingRegisters();  
             -      break;  }
 443   4                      #endif
 444   4                      #if PETITMODBUSWRITE_SINGLE_REGISTER_ENABLED > 0
 445   4                      case PETITMODBUS_WRITE_SINGLE_REGISTER:     {   HandlePetitModbusWriteSingleRegister();   
             -      break;  }
 446   4                      #endif
 447   4                      #if PETITMODBUS_WRITE_MULTIPLE_REGISTERS_ENABLED > 0
 448   4                      case PETITMODBUS_WRITE_MULTIPLE_REGISTERS:  {   HandleMPetitodbusWriteMultipleRegisters();
             -      break;  }
 449   4                      #endif
 450   4                      default:                                    {   HandlePetitModbusError(PETIT_ERROR_CODE_01
             -);    break;  }
 451   4                  }
 452   3              }
 453   2          }
 454   1      }
 455          
 456          /******************************************************************************/
 457          
 458          /*
 459           * Function Name        : InitPetitModbus
 460           * @How to use          : Petite ModBus slave initialize
 461           */
 462          void InitPetitModbus(unsigned char PetitModbusSlaveAddress, unsigned long baudrate)
 463          {
 464   1          PETITMODBUS_SLAVE_ADDRESS    =PetitModbusSlaveAddress;
 465   1          
 466   1          PetitModBus_UART_Initialise(baudrate);
C51 COMPILER V9.59.0.0   PETITMODBUS                                                       12/19/2018 23:00:14 PAGE 9   

 467   1          PetitModBus_TIMER_Initialise();
 468   1      }
 469          
 470          /******************************************************************************/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1253    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =     97      19
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
