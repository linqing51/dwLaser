C51 COMPILER V9.59.0.0   MODBUSSLAVEASCII                                                  12/16/2018 17:20:06 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MODBUSSLAVEASCII
OBJECT MODULE PLACED IN .\Objects\modbusSlaveAscii.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Modbus\modbusSlaveAscii.c LARGE OPTIMIZE(8,SPEED) REGFILE(.\Objects\dwLa
                    -ser_F020.ORC) BROWSE ORDER INCDIR(.\Lib;.\Driver;.\MainApp;.\Modbus) DEFINE(C8051F340) DEBUG OBJECTEXTEND PRINT(.\Listin
                    -gs\modbusSlaveAscii.lst) OBJECT(.\Objects\modbusSlaveAscii.obj)

line level    source

   1          #include "modbusSlaveAscii.h"
   2          /****************************************************************************/
   3          #define MODBUS_NO_ERR                           0
   4          #define MODBUS_ADR_ERR                          1
   5          #define MODBUS_LRC_ERR                          2
   6          #define MODBUS_OVERTIME_ERR                     3
   7          #define CONFIG_LADDER_SECTORS_START             64
   8          #define CONFIG_LADDER_SECTORS_END       128
   9          data uint8_t ModbusSlaveRxNum, ModbusSlaveTxNum;                    
  10          xdata uint8_t ModbusSlaveRxBuf[CONFIG_MODBUS_SLAVE_RX_BUFFER_SIZE], ModbusSlaveTxBuf[CONFIG_MODBUS_SLAVE_T
             -X_BUFFER_SIZE];
  11          data uint8_t *pModbusSlaveTxRead;//发送中断读取指针
  12          data uint8_t *pModbusSlaveRxWrite;//接收中断写入指针
  13          data uint8_t ModbusSlaveFlagRxDone, ModbusSlaveFlagRxDoing, ModbusSlaveFlagTxDone, ModbusSlaveFlagTxDoing;
  14          /****************************************************************************/
  15          static void uint32ToAscii(uint32_t *dat, uint8_t *pstr){//将32位有符号数转换为8个ASCII字符
  16   1              SEG_DATA uint8_t temp;  
  17   1              temp = *dat & 0xF;//0x0000000A
  18   1              if(temp <= 0x09){
  19   2                      *(pstr + 0) = (temp + 0x30);
  20   2          }
  21   1          else{
  22   2                       *(pstr + 0) = (temp + 0x37);
  23   2          }
  24   1              
  25   1              temp = (*dat >> 4) & 0xF;//0x000000A0
  26   1              if(temp <= 0x09){
  27   2                      *(pstr + 1) = (temp + 0x30);
  28   2          }
  29   1          else{
  30   2                       *(pstr + 1) = (temp + 0x37);
  31   2          }
  32   1              
  33   1              temp = (*dat >> 8) & 0xF;//0x00000A00
  34   1              if(temp <= 0x09){
  35   2                      *(pstr + 2) = (temp + 0x30);
  36   2          }
  37   1          else{
  38   2                       *(pstr + 2) = (temp + 0x37);
  39   2          }
  40   1              
  41   1              temp = (*dat >> 12) & 0xF;//0x0000A000
  42   1              if(temp <= 0x09){
  43   2                      *pstr = (temp + 0x30);
  44   2          }
  45   1          else{
  46   2                      *pstr = (temp + 0x37);
  47   2          }
  48   1              
  49   1              temp = (*dat >> 16) & 0xF;//0x000A0000
  50   1              if(temp <= 0x09){
  51   2                      *(pstr + 4) = (temp + 0x30);
  52   2          }
C51 COMPILER V9.59.0.0   MODBUSSLAVEASCII                                                  12/16/2018 17:20:06 PAGE 2   

  53   1          else{
  54   2                       *(pstr + 4) = (temp + 0x37);
  55   2          }
  56   1      
  57   1              temp = (*dat >> 20) & 0xF;//0x00A00000
  58   1              if(temp <= 0x09){
  59   2                      *(pstr + 5) = (temp + 0x30);
  60   2          }
  61   1          else{
  62   2                       *(pstr + 5) = (temp + 0x37);
  63   2          }
  64   1              
  65   1              temp = (*dat >> 24) & 0xF;//0x0A000000
  66   1              if(temp <= 0x09){
  67   2                      *(pstr + 6) = (temp + 0x30);
  68   2          }
  69   1          else{
  70   2                       *(pstr + 6) = (temp + 0x37);
  71   2          }
  72   1              
  73   1              temp = (*dat >> 28) & 0xF;//0x00A00000
  74   1              if(temp <= 0x09){
  75   2                      *(pstr + 7) = (temp + 0x30);
  76   2          }
  77   1          else{
  78   2                       *(pstr + 7) = (temp + 0x37);
  79   2          }
  80   1      }
  81          static uint32_t asciiToUint32(uint8_t *pstr){//将8个BCD组合成一个32进制数
  82   1              SEG_DATA uint8_t temp[8];
  83   1              SEG_DATA uint32_t hex;
  84   1              //取出0x0000000A
  85   1              if(*pstr >= 'A' && *pstr <='F'){//A-F
  86   2                      temp[0] = *pstr - 0x37; 
  87   2              }
  88   1              else if(*pstr >= '0' && *pstr <='9'){
  89   2                      temp[0] = *pstr - 0x30; 
  90   2              }
  91   1              //取出0x000000A0
  92   1              if(*(pstr + 1) >= 'A' && *(pstr + 1) <='F'){//A-F
  93   2                      temp[1] = *(pstr + 1) - 0x37; 
  94   2              }
  95   1              else if(*(pstr + 1) >= '0' && *(pstr + 1) <='9'){
  96   2                      temp[1] = *(pstr + 1) - 0x30;   
  97   2              }
  98   1              //取出0x00000A00
  99   1              if(*pstr >= 'A' && *pstr <='F'){//A-F
 100   2                      temp[2] = *pstr - 0x37; 
 101   2              }
 102   1              else if(*pstr >= '0' && *pstr <='9'){
 103   2                      temp[2] = *pstr - 0x30; 
 104   2              }
 105   1              //取出0x0000A000
 106   1              if(*(pstr + 1) >= 'A' && *(pstr + 1) <='F'){//A-F
 107   2                      temp[3] = *(pstr + 1) - 0x37; 
 108   2              }
 109   1              else if(*(pstr + 1) >= '0' && *(pstr + 1) <='9'){
 110   2                      temp[3] = *(pstr + 1) - 0x30;   
 111   2              }
 112   1              
 113   1              //取出0x0000A000
 114   1              if(*pstr >= 'A' && *pstr <='F'){//A-F
C51 COMPILER V9.59.0.0   MODBUSSLAVEASCII                                                  12/16/2018 17:20:06 PAGE 3   

 115   2                      temp[4] = *pstr - 0x37; 
 116   2              }
 117   1              else if(*pstr >= '0' && *pstr <='9'){
 118   2                      temp[4] = *pstr - 0x30; 
 119   2              }
 120   1              //取出0x00000A00
 121   1              if(*(pstr + 1) >= 'A' && *(pstr + 1) <='F'){//A-F
 122   2                      temp[5] = *(pstr + 1) - 0x37; 
 123   2              }
 124   1              else if(*(pstr + 1) >= '0' && *(pstr + 1) <='9'){
 125   2                      temp[5] = *(pstr + 1) - 0x30;   
 126   2              }
 127   1              //取出0x000000A0
 128   1              if(*pstr >= 'A' && *pstr <='F'){//A-F
 129   2                      temp[6] = *pstr - 0x37; 
 130   2              }
 131   1              else if(*pstr >= '0' && *pstr <='9'){
 132   2                      temp[6] = *pstr - 0x30; 
 133   2              }
 134   1              //取出0x0000000A
 135   1              if(*(pstr + 1) >= 'A' && *(pstr + 1) <='F'){//A-F
 136   2                      temp[7] = *(pstr + 1) - 0x37; 
 137   2              }
 138   1              else if(*(pstr + 1) >= '0' && *(pstr + 1) <='9'){
 139   2                      temp[7] = *(pstr + 1) - 0x30;   
 140   2              }
 141   1              hex = 0;
 142   1              hex |= (temp[0] & 0x0000000F);
 143   1              hex |= (((temp[1] & 0x0F) << 4) & 0x000000F0);
 144   1              hex |= (((temp[2] & 0x0F) << 8) & 0x00000F00);
 145   1              hex |= (((temp[3] & 0x0F) << 12) & 0x0000F000);
 146   1              hex |= (((temp[4] & 0x0F) << 16) & 0x000F0000);
 147   1              hex |= (((temp[5] & 0x0F) << 20) & 0x00F00000);
 148   1              hex |= (((temp[6] & 0x0F) << 24) & 0x00F00000);
 149   1              hex |= (((temp[7] & 0x0F) << 28) & 0x00F00000);
 150   1              return hex;
 151   1      }
 152          static void uint16ToAscii(uint16_t *dat, uint8_t *pstr){//将16位有符号数转换为4个ASCII字符
 153   1              SEG_DATA uint8_t temp;
 154   1              temp = *dat & 0x000F;//0x000A
 155   1              if(temp <= 0x09){
 156   2                      *(pstr + 0) = (temp + 0x30);
 157   2          }
 158   1          else{
 159   2                       *(pstr + 0) = (temp + 0x37);
 160   2          }
 161   1              temp = (*dat >> 4) & 0x000F;//0x00A0
 162   1              if(temp <= 0x09){
 163   2                      *(pstr + 1) = (temp + 0x30);
 164   2          }
 165   1          else{
 166   2                       *(pstr + 1) = (temp + 0x37);
 167   2          }
 168   1              temp = (*dat >> 8) & 0x000F;//0x0A00
 169   1              if(temp <= 0x09){
 170   2                      *(pstr + 2) = (temp + 0x30);
 171   2          }
 172   1          else{
 173   2                       *(pstr + 2) = (temp + 0x37);
 174   2          }
 175   1              temp = (*dat >> 12) & 0x000F;//0xA000
 176   1              if(temp <= 0x09){
C51 COMPILER V9.59.0.0   MODBUSSLAVEASCII                                                  12/16/2018 17:20:06 PAGE 4   

 177   2                      *(pstr + 3) = (temp + 0x30);
 178   2          }
 179   1          else{
 180   2                      *(pstr + 3) = (temp + 0x37);
 181   2          }
 182   1      }
 183          static void uint8ToAscii(uint8_t *dat, uint8_t *pstr){//将16进制数转换成两个ASCII字符
 184   1              SEG_DATA uint8_t temp;
 185   1              temp = (*dat & 0x0f);
 186   1              if(temp <= 0x09){
 187   2                      *(pstr + 1) = (temp + 0x30);
 188   2          }
 189   1          else{
 190   2                       *(pstr + 1) = (temp + 0x37);
 191   2          }
 192   1              temp = ((*dat & 0xf0) >> 4);
 193   1              if(temp <= 0x09){
 194   2                      *pstr = (temp + 0x30);
 195   2              }
 196   1              else{
 197   2                      *pstr = (temp + 0x37);
 198   2              }
 199   1      }
 200          static uint8_t asciiToUint8(uint8_t *pstr){//将两个int8_t 组合成一个16进制数
 201   1              SEG_DATA uint8_t temp[2];
 202   1              SEG_DATA uint8_t hex;
 203   1              if(*pstr >= 'A' && *pstr <='F'){//A-F
 204   2                      temp[0] = *pstr - 0x37; 
 205   2              }
 206   1              else if(*pstr >= '0' && *pstr <='9'){
 207   2                      temp[0] = *pstr - 0x30; 
 208   2              }
 209   1              if(*(pstr + 1) >= 'A' && *(pstr + 1) <='F'){//A-F
 210   2                      temp[1] = *(pstr + 1) - 0x37; 
 211   2              }
 212   1              else if(*(pstr + 1) >= '0' && *(pstr + 1) <='9'){
 213   2                      temp[1] = *(pstr + 1) - 0x30;   
 214   2              }
 215   1              hex = 0;
 216   1              hex |= temp[1] & 0xF;
 217   1              hex |= ((temp[0] << 4) & 0xF0);
 218   1              return hex;
 219   1      }
 220          static uint16_t asciiToUint16(uint8_t *pstr){
 221   1              SEG_DATA uint8_t temp[4];
 222   1              SEG_DATA uint16_t hex;
 223   1              //取出0xA000
 224   1              if(*pstr >= 'A' && *pstr <='F'){//A-F
 225   2                      temp[3] = *pstr - 0x37; 
 226   2              }
 227   1              else if(*pstr >= '0' && *pstr <='9'){
 228   2                      temp[3] = *pstr - 0x30; 
 229   2              }
 230   1              //取出0x0A00
 231   1              if(*(pstr + 1) >= 'A' && *(pstr + 1) <='F'){//A-F
 232   2                      temp[2] = *(pstr + 1) - 0x37; 
 233   2              }
 234   1              else if(*(pstr + 1) >= '0' && *(pstr + 1) <='9'){
 235   2                      temp[2] = *(pstr + 1) - 0x30;   
 236   2              }
 237   1              //取出0x00A0
 238   1              if(*pstr >= 'A' && *pstr <='F'){//A-F
C51 COMPILER V9.59.0.0   MODBUSSLAVEASCII                                                  12/16/2018 17:20:06 PAGE 5   

 239   2                      temp[1] = *pstr - 0x37; 
 240   2              }
 241   1              else if(*pstr >= '0' && *pstr <='9'){
 242   2                      temp[1] = *pstr - 0x30; 
 243   2              }
 244   1              //取出0x000A
 245   1              if(*(pstr + 1) >= 'A' && *(pstr + 1) <='F'){//A-F
 246   2                      temp[0] = *(pstr + 1) - 0x37; 
 247   2              }
 248   1              else if(*(pstr + 1) >= '0' && *(pstr + 1) <='9'){
 249   2                      temp[0] = *(pstr + 1) - 0x30;   
 250   2              }
 251   1              hex = 0;
 252   1              hex |= temp[0] & 0x000F;
 253   1              hex |= ((temp[1] & 0x0F) << 4) & 0x00F0;
 254   1              hex |= ((temp[2] & 0x0F) << 8) & 0x0F00;
 255   1              hex |= ((temp[3] & 0x0F) << 12) & 0xF000;
 256   1              return hex;
 257   1      }
 258          static uint8_t LRC(uint8_t *buf, uint32_t len){//计算LRC LRC方法是将消息中的8Bit的字节连续累加，丢弃了进位
 259   1              SEG_DATA uint32_t i;
 260   1              SEG_DATA uint8_t lrc = 0;        /*lrc字节初始化*/
 261   1              for( i = 0; i < len; i++ ){
 262   2                      lrc = lrc + buf[i];
 263   2              }
 264   1              return lrc;
 265   1      }
 266          
 267          void modbusSerialInit(int32_t baudrate){//初始化MODBUS串口
 268   1      //      uint32_t temp;
 269   1      //      temp = (uint32_t)(CONFIG_SYSCLK / 32 / baudrate);
 270   1      //      temp = 65536 - temp;    
 271   1      //      
 272   1      //      T2CON &= 1 << 4;//Timer 1 overflows used for transmit clock.
 273   1      //      T2CON &= 1 << 5;//Timer 1 overflows used for receive clock.
 274   1      //      
 275   1      //      TMOD &= 0x0F;
 276   1      //      TMOD |= 1 << 5;//Mode 2: 8-bit counter/timer with auto-reload
 277   1      //      
 278   1      //      TH1 = (uint8_t)(temp & 0xff);
 279   1      //      TL1 = (uint8_t)(temp & 0xff);
 280   1      //      TR1 = 1;
 281   1      //      //T2CON |= 1 << 2;//Timer 2 enabled
 282   1      //      //RS485_DIRECTION_RXD;//接收状态
 283   1              ES0 = 1;
 284   1              TI0 = 0;//清除发送完成                  
 285   1              RI0 = 0;//清除接收完成                  
 286   1      }
*** WARNING C280 IN LINE 267 OF Modbus\modbusSlaveAscii.c: 'baudrate': unreferenced local variable
 287          static void ModbusSlaveStartSend(void){
 288   1              ModbusSlaveFlagTxDone = 0;
 289   1              pModbusSlaveTxRead = ModbusSlaveTxBuf;
 290   1              TI0 = 1;
 291   1      }
 292          void modbusSlaveSerialIsr() interrupt INTERRUPT_UART0{
 293   1              if(TI0){
 294   2              TI0 = 0;        
 295   2              if(ModbusSlaveTxNum == 0){
 296   3                  ModbusSlaveFlagTxDone = 1;                    
 297   3              }
 298   2              else if(ModbusSlaveTxNum > 0)
 299   2                              SBUF0 = *pModbusSlaveTxRead;                    
C51 COMPILER V9.59.0.0   MODBUSSLAVEASCII                                                  12/16/2018 17:20:06 PAGE 6   

 300   2                  ModbusSlaveTxNum --;        
 301   2                              if(pModbusSlaveTxRead == (ModbusSlaveTxBuf + CONFIG_MODBUS_SLAVE_TX_BUFFER_SIZE - 1)){
 302   3                      pModbusSlaveTxRead = ModbusSlaveTxBuf;
 303   3                                      ModbusSlaveTxNum = 0;
 304   3                  }
 305   2                  else{
 306   3                      pModbusSlaveTxRead ++;
 307   3                  }               
 308   2              }
 309   1          if(RI0)
 310   1          {
 311   2              RI0 = 0;  
 312   2                  if(SBUF0 == MODBUS_ASCII_STX){//接收到起始符号
 313   3                              //ModbusSlaveAsciiOverTimeCounter = 0;
 314   3                              //memset(ModbusSlaveRxBuf, 0x00, SerialRCV);
 315   3                              pModbusSlaveRxWrite = ModbusSlaveRxBuf;
 316   3                              *pModbusSlaveRxWrite = SBUF0;
 317   3                              ModbusSlaveFlagRxDoing = 1;
 318   3                              ModbusSlaveFlagRxDone = 0;
 319   3                              ModbusSlaveRxNum = 1;
 320   3                      }
 321   2                      else if(SBUF0 == MODBUS_ASCII_END1){ //接收到终止符号
 322   3                              *pModbusSlaveRxWrite = SBUF0;
 323   3                              ModbusSlaveRxNum++;
 324   3                              pModbusSlaveRxWrite = ModbusSlaveRxBuf;
 325   3                              ModbusSlaveFlagRxDone = 1;
 326   3                              ModbusSlaveFlagRxDoing = 0;
 327   3                      }
 328   2                      else if(ModbusSlaveFlagRxDoing && !ModbusSlaveFlagRxDone){//接收数据中 
 329   3                              *pModbusSlaveRxWrite = SBUF0;        
 330   3                              if(pModbusSlaveRxWrite == (ModbusSlaveRxBuf + CONFIG_MODBUS_SLAVE_RX_BUFFER_SIZE - 1)){
 331   4                                      pModbusSlaveRxWrite = ModbusSlaveRxBuf;
 332   4                                      ModbusSlaveRxNum = 0;
 333   4                              }
 334   3                              else {
 335   4                                      pModbusSlaveRxWrite++;
 336   4                              }    
 337   3                              ModbusSlaveRxNum++;
 338   3                      }
 339   2         }   
 340   1      }
 341                                                 
 342          void modbusSlaveAsciiPoll(void){//Modbus Slave Ascii 轮询 
 343   1              data uint8_t *prx, *ptx;
 344   1              data uint8_t ctemp[4];
 345   1              data int16_t stemp[4], i, j, k;
 346   1              prx = ModbusSlaveRxBuf;
 347   1              if(ModbusSlaveFlagRxDone){
 348   2                      DISABLE_MODBUS_SERIAL_RX_INTERRUPT//关闭协议接收中断
 349   2                      ctemp[0] = asciiToUint8(ModbusSlaveRxBuf + 1);
 350   2                      if(ctemp[0] == CONFIG_MODBUS_SLAVE_ADDRESS){//从地址正确
 351   3                              ctemp[0] = LRC((ModbusSlaveRxBuf + 1), (ModbusSlaveRxNum - 5));//计算接收数据LRC校验值
 352   3                              ctemp[1] = asciiToUint8(ModbusSlaveRxBuf + ModbusSlaveRxNum - 3);
 353   3                              if(ctemp[0] == ctemp[1]){//LRC校验正确
 354   4                                      ctemp[0] = asciiToUint8(ModbusSlaveRxBuf + 3);//功能号
 355   4                                      switch(ctemp[0]){
 356   5                                              case 1:{//读取线圈状态
 357   6                                                      //modbusSlaveFun1();
 358   6                                                      break;
 359   6                                              }
 360   5                                              case 2:{//读取输入状态
 361   6                                                      break;
C51 COMPILER V9.59.0.0   MODBUSSLAVEASCII                                                  12/16/2018 17:20:06 PAGE 7   

 362   6                                              }
 363   5                                              case 3:{//读取保持寄存器
 364   6                                                      break;
 365   6                                              }
 366   5                                              case 4:{//读取输入寄存器
 367   6                                                      break;
 368   6                                              }
 369   5                                              case 5:{//强置单线圈
 370   6                                                      stemp[0] = asciiToUint16(ModbusSlaveRxBuf + 5);//获取输出地址 
 371   6                                                      stemp[1] = asciiToUint16(ModbusSlaveRxBuf + 9);//获取输出值
 372   6                                                      if(stemp[1] == 0xFF00){
 373   7                                                              //SET(stemp[0]);
 374   7                                                      }
 375   6                                                      else{
 376   7                                                              //RESET(stemp[0]);
 377   7                                                      }
 378   6                                                      ModbusSlaveTxBuf[0] = ModbusSlaveRxBuf[0];//STX
 379   6                                                      ModbusSlaveTxBuf[1] = ModbusSlaveRxBuf[1];//SLAVE ID
 380   6                                                      ModbusSlaveTxBuf[2] = ModbusSlaveRxBuf[2];
 381   6                                                      ModbusSlaveTxBuf[3] = ModbusSlaveRxBuf[3];//FUN
 382   6                                                      ModbusSlaveTxBuf[4] = ModbusSlaveRxBuf[4];
 383   6                                                      ModbusSlaveTxBuf[5] = ModbusSlaveRxBuf[5];//ADR
 384   6                                                      ModbusSlaveTxBuf[6] = ModbusSlaveRxBuf[6];
 385   6                                                      ModbusSlaveTxBuf[7] = ModbusSlaveRxBuf[7];
 386   6                                                      ModbusSlaveTxBuf[8] = ModbusSlaveRxBuf[8];
 387   6                                                      ModbusSlaveTxBuf[9] = ModbusSlaveRxBuf[9];//DAT
 388   6                                                      ModbusSlaveTxBuf[10] = ModbusSlaveRxBuf[10];
 389   6                                                      ModbusSlaveTxBuf[11] = ModbusSlaveRxBuf[11];
 390   6                                                      ModbusSlaveTxBuf[12] = ModbusSlaveRxBuf[12];
 391   6                                                      ModbusSlaveTxBuf[13] = MODBUS_ASCII_END0;
 392   6                                                      ModbusSlaveTxBuf[14] = MODBUS_ASCII_END1;                                               
 393   6                                                      ModbusSlaveTxNum = 15;  
 394   6                                                      ModbusSlaveStartSend();
 395   6                                                      //NVRAM0[SP_EM_MODBUS_SLAVE_ERR] = MODBUS_NO_ERR; 
 396   6                                                      break;
 397   6                                              }
 398   5                                              case 6:{//预置单寄存器
 399   6                                                      stemp[0] = asciiToUint16(ModbusSlaveRxBuf + 5);//获取输出地址 
 400   6                                                      stemp[1] = asciiToUint16(ModbusSlaveRxBuf + 9);//获取输出值
 401   6                                                      //assertRegisterAddress(stemp[0]);
 402   6                                                      //NVRAM0[(stemp[0])] = stemp[1];
 403   6                                                      ModbusSlaveTxBuf[0] = ModbusSlaveRxBuf[0];//STX
 404   6                                                      ModbusSlaveTxBuf[1] = ModbusSlaveRxBuf[1];//SLAVE ID
 405   6                                                      ModbusSlaveTxBuf[2] = ModbusSlaveRxBuf[2];
 406   6                                                      ModbusSlaveTxBuf[3] = ModbusSlaveRxBuf[3];//FUN
 407   6                                                      ModbusSlaveTxBuf[4] = ModbusSlaveRxBuf[4];
 408   6                                                      ModbusSlaveTxBuf[5] = ModbusSlaveRxBuf[5];//ADR
 409   6                                                      ModbusSlaveTxBuf[6] = ModbusSlaveRxBuf[6];
 410   6                                                      ModbusSlaveTxBuf[7] = ModbusSlaveRxBuf[7];
 411   6                                                      ModbusSlaveTxBuf[8] = ModbusSlaveRxBuf[8];
 412   6                                                      ModbusSlaveTxBuf[9] = ModbusSlaveRxBuf[9];//DAT
 413   6                                                      ModbusSlaveTxBuf[10] = ModbusSlaveRxBuf[10];
 414   6                                                      ModbusSlaveTxBuf[11] = ModbusSlaveRxBuf[11];
 415   6                                                      ModbusSlaveTxBuf[12] = ModbusSlaveRxBuf[12];
 416   6                                                      ModbusSlaveTxBuf[13] = MODBUS_ASCII_END0;
 417   6                                                      ModbusSlaveTxBuf[14] = MODBUS_ASCII_END1;
 418   6                                                      ModbusSlaveTxNum = 15;  
 419   6                                                      ModbusSlaveStartSend();
 420   6                                                      //NVRAM0[SP_EM_MODBUS_SLAVE_ERR] = MODBUS_NO_ERR; 
 421   6                                                      break;
 422   6                                              }
 423   5                                              case 7:{//读取异常状态
C51 COMPILER V9.59.0.0   MODBUSSLAVEASCII                                                  12/16/2018 17:20:06 PAGE 8   

 424   6                                              }
 425   5                                              case 8:{//回送诊断校验
 426   6                                              }
 427   5                                              case 9:{//编程
 428   6                                                      stemp[0] = asciiToUint16(ModbusSlaveRxBuf + 5);//获取编程扇区位置
 429   6                                                      if(stemp[0] >= CONFIG_LADDER_SECTORS_START && stemp[0 <= CONFIG_LADDER_SECTORS_END]){
 430   7                                                      //检查写入扇区是否合法
 431   7                                                              
 432   7                                                      }
 433   6                                                      // XXXX:写入扇区
 434   6                                                      // XXXX:512BYTE 写入数据
 435   6                                                      break;
 436   6                                              }
 437   5                                              case 10:{//控询
 438   6                                                      break;
 439   6                                              }
 440   5                                              case 11:{//读取事件计数
 441   6                                                      break;
 442   6                                              }
 443   5                                              case 12:{//读取通信事件记录
 444   6                                                      break;
 445   6                                              }
 446   5                                              case 13:{//编程（184/384 484 584）
 447   6                                                      break;
 448   6                                              }
 449   5                                              case 14:{//探询（184/384 484 584）
 450   6                                                      break;
 451   6                                              }
 452   5                                              case 15:{//强置多线圈
 453   6                                                      stemp[0] = asciiToUint16(ModbusSlaveRxBuf + 5);//获取输出地址 
 454   6                                                      stemp[1] = asciiToUint16(ModbusSlaveRxBuf + 9);//获取输出数量
 455   6                                                      if(stemp[1] >= 1 && stemp[1] <= 0x07B0){//检查输出数量
 456   7                                                              for(i = 0;i <stemp[1];i ++){
 457   8                                                                      ctemp[0] = *(ModbusSlaveRxBuf + 13 + i);
 458   8                                                                      ctemp[0] = (ctemp[0] >> (stemp[1] % 8)) & 0x01;
 459   8                                                                      if(ctemp[0]){
 460   9                                                                              //SET(stemp[0] - 1 + i);
 461   9                                                                      }
 462   8                                                                      else{
 463   9                                                                              //RESET(stemp[0] - 1 + i);
 464   9                                                                      }
 465   8                                                              }
 466   7                                                      }
 467   6                                                      ModbusSlaveTxBuf[0] = ModbusSlaveRxBuf[0];//STX
 468   6                                                      ModbusSlaveTxBuf[1] = ModbusSlaveRxBuf[1];//SLAVE ID
 469   6                                                      ModbusSlaveTxBuf[2] = ModbusSlaveRxBuf[2];
 470   6                                                      ModbusSlaveTxBuf[3] = ModbusSlaveRxBuf[3];//FUN
 471   6                                                      ModbusSlaveTxBuf[4] = ModbusSlaveRxBuf[4];
 472   6                                                      ModbusSlaveTxBuf[5] = ModbusSlaveRxBuf[5];//ADR
 473   6                                                      ModbusSlaveTxBuf[6] = ModbusSlaveRxBuf[6];
 474   6                                                      ModbusSlaveTxBuf[7] = ModbusSlaveRxBuf[7];
 475   6                                                      ModbusSlaveTxBuf[8] = ModbusSlaveRxBuf[8];
 476   6                                                      ModbusSlaveTxBuf[9] = ModbusSlaveRxBuf[9];//NUM
 477   6                                                      ModbusSlaveTxBuf[10] = ModbusSlaveRxBuf[10];
 478   6                                                      ModbusSlaveTxBuf[11] = ModbusSlaveRxBuf[11];
 479   6                                                      ModbusSlaveTxBuf[12] = ModbusSlaveRxBuf[12];
 480   6                                                      ModbusSlaveTxBuf[13] = MODBUS_ASCII_END0;
 481   6                                                      ModbusSlaveTxBuf[14] = MODBUS_ASCII_END1;                                               
 482   6                                                      ModbusSlaveTxNum = 15;  
 483   6                                                      ModbusSlaveStartSend();
 484   6                                                      //NVRAM0[SP_EM_MODBUS_SLAVE_ERR] = MODBUS_NO_ERR; 
 485   6                                                      break;
C51 COMPILER V9.59.0.0   MODBUSSLAVEASCII                                                  12/16/2018 17:20:06 PAGE 9   

 486   6                                              }
 487   5                                              case 16:{//预置多寄存器
 488   6                                                      stemp[0] = asciiToUint16(ModbusSlaveRxBuf + 5);//获取输出地址 
 489   6                                                      stemp[1] = asciiToUint16(ModbusSlaveRxBuf + 9);//获取输出数量
 490   6                                                      if(stemp[1] >= 1 && stemp[1] <= 0x0078){//检查输出数量
 491   7                                                              for(i = 0;i <stemp[1];i ++){
 492   8                                                                      ctemp[0] = *(ModbusSlaveRxBuf + 13 + i);
 493   8                                                                      stemp[2] = asciiToUint16(ModbusSlaveRxBuf + 13 + (i * 4));
 494   8                                                                      //NVRAM0[(stemp[0])] = stemp[2];
 495   8                                                              }
 496   7                                                      }
 497   6                                                      ModbusSlaveTxBuf[0] = ModbusSlaveRxBuf[0];
 498   6                                                      ModbusSlaveTxBuf[1] = ModbusSlaveRxBuf[1];
 499   6                                                      ModbusSlaveTxBuf[2] = ModbusSlaveRxBuf[2];
 500   6                                                      ModbusSlaveTxBuf[3] = ModbusSlaveRxBuf[3];
 501   6                                                      ModbusSlaveTxBuf[4] = ModbusSlaveRxBuf[4];
 502   6                                                      ModbusSlaveTxBuf[5] = ModbusSlaveRxBuf[5];
 503   6                                                      ModbusSlaveTxBuf[6] = ModbusSlaveRxBuf[6];
 504   6                                                      ModbusSlaveTxBuf[7] = ModbusSlaveRxBuf[7];
 505   6                                                      ModbusSlaveTxBuf[8] = ModbusSlaveRxBuf[8];
 506   6                                                      ModbusSlaveTxBuf[9] = ModbusSlaveRxBuf[9];
 507   6                                                      ModbusSlaveTxBuf[10] = ModbusSlaveRxBuf[10];
 508   6                                                      ModbusSlaveTxBuf[11] = ModbusSlaveRxBuf[11];
 509   6                                                      ModbusSlaveTxBuf[12] = ModbusSlaveRxBuf[12];
 510   6                                                      ModbusSlaveTxBuf[13] = MODBUS_ASCII_END0;
 511   6                                                      ModbusSlaveTxBuf[14] = MODBUS_ASCII_END1;                                               
 512   6                                                      ModbusSlaveTxNum = 15;  
 513   6                                                      ModbusSlaveStartSend();
 514   6                                                      //NVRAM0[SP_EM_MODBUS_SLAVE_ERR] = MODBUS_NO_ERR; 
 515   6                                                      break;
 516   6                                              }
 517   5                                              case 17:{//报告从机标识
 518   6                                                      break;
 519   6                                              }
 520   5                                              case 18:{//884和MICRO 84
 521   6                                                      break;
 522   6                                              }
 523   5                                              case 19:{//重置通信链路
 524   6                                                      break;
 525   6                                              }
 526   5                                              case 20:{//读取通用参数（584L）
 527   6                                                      break;
 528   6                                              }
 529   5                                              case 21:{//写入通用参数（584L）
 530   6                                                      break;
 531   6                                              }
 532   5                                              default:break;
 533   5                                      }
 534   4                              }
 535   3                              else{//从地址错误
 536   4                                      ModbusSlaveFlagRxDone = 0;//接收完成清零
 537   4                                      //NVRAM0[SP_EM_MODBUS_SLAVE_ERR] = MODBUS_LRC_ERR;                              
 538   4                              }
 539   3                      }
 540   2                      else{//LRC校验错误
 541   3                              ModbusSlaveFlagRxDone = 0;//接收完成清零
 542   3                              //NVRAM0[SP_EM_MODBUS_SLAVE_ERR] = MODBUS_ADR_ERR;
 543   3                      }
 544   2                      ENABLE_MODBUS_SERIAL_INTERRUPT//打开协议接收中断
 545   2              }               
 546   1      }
*** WARNING C280 IN LINE 343 OF Modbus\modbusSlaveAscii.c: 'ptx': unreferenced local variable
C51 COMPILER V9.59.0.0   MODBUSSLAVEASCII                                                  12/16/2018 17:20:06 PAGE 10  

*** WARNING C280 IN LINE 345 OF Modbus\modbusSlaveAscii.c: 'j': unreferenced local variable
*** WARNING C280 IN LINE 345 OF Modbus\modbusSlaveAscii.c: 'k': unreferenced local variable


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2701    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    256      29
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     12      53
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  4 WARNING(S),  0 ERROR(S)
