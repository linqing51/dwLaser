C51 COMPILER V9.59.0.0   SLAVEMODBUS                                                       12/17/2018 23:24:15 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE SLAVEMODBUS
OBJECT MODULE PLACED IN .\Objects\slaveModbus.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Modbus\slaveModbus.c LARGE OPTIMIZE(8,SPEED) REGFILE(.\Objects\dwLaser_F
                    -020.ORC) BROWSE ORDER INCDIR(.\Lib;.\Driver;.\MainApp;.\Modbus) DEFINE(C8051F340) DEBUG OBJECTEXTEND PRINT(.\Listings\sl
                    -aveModbus.lst) OBJECT(.\Objects\slaveModbus.obj)

line level    source

   1          #include "slaveModbus.h"
   2          /*****************************************************************************/
   3          static data uint8_t localAddr; //单片机控制板的地址
   4          static data uint16_t idleCounter;//接收超时
   5          static data uint16_t maxIdleCounter;
   6          static data uint8_t sendCounter;//发送字节个数
   7          static data uint8_t receCounter;//接收到的字节个数
   8          static uint8_t flagResetReceBuf;//复位接收缓冲
   9          static xdata uint8_t receBuf[CONFIG_MODBUS_SLAVE_RX_BUFFER_SIZE];
  10          static xdata uint8_t sendBuf[CONFIG_MODBUS_SLAVE_TX_BUFFER_SIZE];
  11          static data uint8_t bt1ms;//定时标志位
  12          static void timeProc(void);
  13          static void checkComm0Modbus(void);
  14           
  15          uint8_t code auchCRCHi[] = 
  16          {//CRC 高位字节值表 
  17                  0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 
  18                  0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 
  19                  0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 
  20                  0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 
  21                  0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 
  22                  0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 
  23                  0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 
  24                  0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 
  25                  0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 
  26                  0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 
  27                  0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 
  28                  0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 
  29                  0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 
  30                  0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 
  31                  0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 
  32                  0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 
  33                  0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 
  34                  0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 
  35                  0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 
  36                  0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 
  37                  0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 
  38                  0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 
  39                  0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 
  40                  0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 
  41                  0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 
  42                  0x80, 0x41, 0x00, 0xC1, 0x81, 0x40 
  43          } ; 
  44          
  45          uint8_t code auchCRCLo[] = 
  46          {//CRC低位字节值表
  47                  0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06, 
  48                  0x07, 0xC7, 0x05, 0xC5, 0xC4, 0x04, 0xCC, 0x0C, 0x0D, 0xCD, 
  49                  0x0F, 0xCF, 0xCE, 0x0E, 0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09,               
  50                  0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9, 0x1B, 0xDB, 0xDA, 0x1A, 
  51                  0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 0x1D, 0x1C, 0xDC, 0x14, 0xD4, 
  52                  0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3, 
  53                  0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 
C51 COMPILER V9.59.0.0   SLAVEMODBUS                                                       12/17/2018 23:24:15 PAGE 2   

  54                  0xF2, 0x32, 0x36, 0xF6, 0xF7, 0x37, 0xF5, 0x35, 0x34, 0xF4, 
  55                  0x3C, 0xFC, 0xFD, 0x3D, 0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A, 
  56                  0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38, 0x28, 0xE8, 0xE9, 0x29, 
  57                  0xEB, 0x2B, 0x2A, 0xEA, 0xEE, 0x2E, 0x2F, 0xEF, 0x2D, 0xED, 
  58                  0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26, 
  59                  0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60, 
  60                  0x61, 0xA1, 0x63, 0xA3, 0xA2, 0x62, 0x66, 0xA6, 0xA7, 0x67, 
  61                  0xA5, 0x65, 0x64, 0xA4, 0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F, 
  62                  0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB, 0x69, 0xA9, 0xA8, 0x68, 
  63                  0x78, 0xB8, 0xB9, 0x79, 0xBB, 0x7B, 0x7A, 0xBA, 0xBE, 0x7E, 
  64                  0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5, 
  65                  0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 
  66                  0x70, 0xB0, 0x50, 0x90, 0x91, 0x51, 0x93, 0x53, 0x52, 0x92, 
  67                  0x96, 0x56, 0x57, 0x97, 0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C, 
  68                  0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B, 
  69                  0x99, 0x59, 0x58, 0x98, 0x88, 0x48, 0x49, 0x89, 0x4B, 0x8B, 
  70                  0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C, 
  71                  0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 
  72                  0x43, 0x83, 0x41, 0x81, 0x80, 0x40 
  73          };
  74          
  75          void presetSingleRegister(void);
  76          void setCoilVal(uint16_t addr,uint16_t tempData);
  77          void getCoilVal(uint16_t addr,uint16_t *tempData);
  78          void getRegisterVal(uint16_t addr,uint16_t *tempData);
  79          void setRegisterVal(uint16_t addr,uint16_t tempData);
  80          
  81          /*****************************************************************************/
  82          void InitModbusHardware(uint32_t baudrate)
  83          {//初始化MODBUS硬件
  84   1              maxIdleCounter = 99;
  85   1              InitModbusTimer();//初始化计时器
  86   1              InitModbusSerial(baudrate);//初始化串口
  87   1      }
  88          void modbusTimerHandle(void)
  89          {//计时器中断
  90   1              if(idleCounter < maxIdleCounter){
  91   2                      idleCounter ++;
  92   2              }
  93   1              else{
  94   2                      flagResetReceBuf |= 0x01;
  95   2              }
  96   1              
  97   1      }
  98          void modbusSerialRxHandle(void)
  99          {//串口接收中断
 100   1              if(receCounter < CONFIG_MODBUS_SLAVE_RX_BUFFER_SIZE){
 101   2                      receBuf[receCounter] = SBUF0;
 102   2                      receCounter ++;          //接收地址偏移寄存器加1        
 103   2              }
 104   1              else{
 105   2                      flagResetReceBuf = 0x01;
 106   2              }
 107   1              
 108   1      }
 109          void modbusSerialTxHandle(void)
 110          {//串口发射中断
 111   1      }
 112          void modbusPoll(void)
 113          {
 114   1              if(flagResetReceBuf)
 115   1              {
C51 COMPILER V9.59.0.0   SLAVEMODBUS                                                       12/17/2018 23:24:15 PAGE 3   

 116   2                      RS485_DIRECTION_RXD;//将485置为接收状态  
 117   2                      receCounter = 0x0;//
 118   2                      idleCounter = 0x0;
 119   2                      flagResetReceBuf = 0x0;
 120   2              }
 121   1              else{
 122   2                      checkComm0Modbus();     
 123   2              }
 124   1      
 125   1              
 126   1      }
 127          void setModbusSlaveAddr(uint8_t addr)
 128          {//设置从机地址
 129   1              localAddr = addr;
 130   1      }
 131          /*****************************************************************************/
 132          static uint16_t crc16(uint8_t *puchMsg, uint16_t usDataLen) 
 133          {//CRC16生成器 
 134   1              data uint8_t uchCRCHi = 0xFF ; /* 高CRC字节初始化 */ 
 135   1              data uint8_t uchCRCLo = 0xFF ; /* 低CRC 字节初始化 */ 
 136   1              data uint16_t uIndex ; /* CRC循环中的索引 */ 
 137   1              while (usDataLen--) /* 传输消息缓冲区 */ 
 138   1              { 
 139   2                      uIndex = uchCRCHi ^ *puchMsg++ ; /* 计算CRC */ 
 140   2                      uchCRCHi = uchCRCLo ^ auchCRCHi[uIndex] ; 
 141   2                      uchCRCLo = auchCRCLo[uIndex] ; 
 142   2              } 
 143   1              return (uchCRCLo << 8 | uchCRCHi) ; 
 144   1      }               
 145          static void beginSend(void)
 146          {//发送数据
 147   1              RS485_DIRECTION_TXD;//处于发送
 148   1              modbusSerialSendBuffer(sendBuf, sendCounter);
 149   1              RS485_DIRECTION_RXD;//发送完后将485置于接收状态
 150   1          receCounter = 0;   //清接收地址偏移寄存器
 151   1      }
 152          static void readCoils(void)
 153          {//fuction:01 读单个或多个线圈状态
 154   1              uint16_t addr;
 155   1              uint16_t tempAddr;
 156   1              uint16_t byteCount;
 157   1              uint16_t bitCount;
 158   1              uint16_t crcData;
 159   1              uint16_t position;
 160   1              uint16_t i, k;
 161   1              uint16_t tempData;
 162   1              uint8_t exit = 0;
 163   1              addr = (receBuf[2]<<8) + receBuf[3]; 
 164   1              tempAddr = addr;
 165   1              bitCount = (receBuf[4]<<8) + receBuf[5]; //读取的位个数
 166   1              byteCount = bitCount / 8;    //字节个数
 167   1              if(bitCount%8 != 0)
 168   1              {
 169   2                byteCount++;
 170   2              }               
 171   1              for(k = 0; k < byteCount; k ++)//字节位置
 172   1              {
 173   2                      position = k + 3;
 174   2                      sendBuf[position] = 0;
 175   2                      for(i = 0; i < 8; i ++)
 176   2                      {
 177   3                              getCoilVal(tempAddr, &tempData);
C51 COMPILER V9.59.0.0   SLAVEMODBUS                                                       12/17/2018 23:24:15 PAGE 4   

 178   3                              sendBuf[position] |= tempData << i;
 179   3                              tempAddr++;
 180   3                              if(tempAddr >= addr + bitCount)//读完
 181   3                              { 
 182   4                                      exit = 1;
 183   4                                      break;
 184   4                              } 
 185   3                      }
 186   2                      if(exit == 1)
 187   2                      break;
 188   2              }
 189   1              sendBuf[0] = localAddr;
 190   1              sendBuf[1] = 0x01; 
 191   1              sendBuf[2] = byteCount;
 192   1              byteCount += 3;
 193   1              crcData = crc16(sendBuf,byteCount); 
 194   1              sendBuf[byteCount] = crcData & 0xff;
 195   1              byteCount++;
 196   1              sendBuf[byteCount] = crcData >> 8;
 197   1              sendCounter = byteCount + 1;
 198   1              beginSend();   
 199   1      }
 200          static void readInPutCoils(void)
 201          {//fuction:02 读取线圈输入（只读寄存器）状态
 202   1              uint16_t addr;
 203   1              uint16_t tempAddr;
 204   1              uint16_t byteCount;
 205   1              uint16_t  bitCount;
 206   1              uint16_t crcData;
 207   1              uint16_t  position;
 208   1              uint16_t  i,k;
 209   1              uint16_t tempData;
 210   1              uint8_t  exit = 0;
 211   1              addr = (receBuf[2]<<8) + receBuf[3]; 
 212   1              tempAddr = addr +10000;        //只读线圈寄存器偏移地址10000
 213   1              bitCount = (receBuf[4]<<8) + receBuf[5]; //读取的位个数
 214   1              byteCount = bitCount / 8;    //字节个数
 215   1              if(bitCount%8 != 0)
 216   1              {
 217   2                      byteCount++;
 218   2              }               
 219   1              for(k=0;k<byteCount;k++)//字节位置
 220   1              {
 221   2                      position = k + 3;
 222   2                      sendBuf[position] = 0;
 223   2                      for(i=0;i<8;i++)
 224   2                      {
 225   3                              getCoilVal(tempAddr,&tempData);
 226   3                              sendBuf[position] |= tempData << i;
 227   3                              tempAddr++;
 228   3                              if(tempAddr >= addr+bitCount)//读完
 229   3                              { 
 230   4                                      exit = 1;
 231   4                                      break;
 232   4                              } 
 233   3                      }
 234   2                      if(exit == 1)
 235   2                      {
 236   3                              break;
 237   3                      }
 238   2              }
 239   1              sendBuf[0] = localAddr;
C51 COMPILER V9.59.0.0   SLAVEMODBUS                                                       12/17/2018 23:24:15 PAGE 5   

 240   1              sendBuf[1] = 0x02; 
 241   1              sendBuf[2] = byteCount;
 242   1              byteCount += 3;
 243   1              crcData = crc16(sendBuf,byteCount); 
 244   1              sendBuf[byteCount] = crcData & 0xff;
 245   1              byteCount++;
 246   1              sendBuf[byteCount] = crcData >> 8;
 247   1              sendCounter = byteCount + 1;
 248   1              beginSend();   
 249   1      }
 250          static void readRegisters(void)
 251          {//function code : 03，读取多个保持寄存器值
 252   1              uint16_t addr;
 253   1              uint16_t tempAddr;
 254   1              uint16_t crcData;
 255   1              uint16_t readCount;
 256   1              uint16_t byteCount;
 257   1              uint16_t i;
 258   1              uint16_t tempData = 0; 
 259   1              addr = (receBuf[2]<<8) + receBuf[3]; 
 260   1              tempAddr = addr+40000;      //+40000,保持寄存器偏移地址
 261   1              readCount = (receBuf[4]<<8) + receBuf[5]; //要读的个数 ,整型
 262   1              byteCount = readCount * 2;                  //每个寄存器内容占高，低两个字节
 263   1              for(i=0;i<byteCount;i+=2,tempAddr++)
 264   1              {
 265   2                      getRegisterVal(tempAddr,&tempData);    
 266   2                      sendBuf[i+3] = tempData >> 8;        
 267   2                      sendBuf[i+4] = tempData & 0xff;  
 268   2              }
 269   1              sendBuf[0] = localAddr;
 270   1              sendBuf[1] = 3;  //function code : 03
 271   1              sendBuf[2] = byteCount;
 272   1              byteCount += 3;             //加上前面的地址，功能码，地址 共3+byteCount个字节
 273   1              crcData = crc16(sendBuf,byteCount);
 274   1              sendBuf[byteCount] = crcData & 0xff;   // CRC代码低位在前
 275   1              byteCount++;
 276   1              sendBuf[byteCount] = crcData >> 8 ;        //高位在后
 277   1              sendCounter = byteCount + 1;                    //例如byteCount=49，则sendBuf[]中实际上有49+1个元素待发
 278   1              beginSend();
 279   1      }
 280          static void readInPutRegisters(void)
 281          {//fuction 04:读取输入寄存器
 282   1              uint16_t addr;
 283   1              uint16_t tempAddr;
 284   1              uint16_t crcData;
 285   1              uint16_t readCount;
 286   1              uint16_t byteCount;
 287   1              uint16_t i;
 288   1              uint16_t tempData = 0; 
 289   1              addr = (receBuf[2]<<8) + receBuf[3]; 
 290   1              tempAddr = addr+30000;  //+输入寄存器偏移地址：30000
 291   1              readCount = (receBuf[4]<<8) + receBuf[5]; //要读的个数 ,整型
 292   1              byteCount = readCount * 2;                  //每个寄存器内容占高，低两个字节
 293   1              for(i=0;i<byteCount;i+=2,tempAddr++)
 294   1              {
 295   2                      getRegisterVal(tempAddr,&tempData);    
 296   2                      sendBuf[i+3] = tempData >> 8;        
 297   2                      sendBuf[i+4] = tempData & 0xff;  
 298   2              }
 299   1              sendBuf[0] = localAddr;
 300   1              sendBuf[1] = 4;  //function code : 04
 301   1              sendBuf[2] = byteCount;
C51 COMPILER V9.59.0.0   SLAVEMODBUS                                                       12/17/2018 23:24:15 PAGE 6   

 302   1              byteCount += 3;             //加上前面的地址，功能码，地址 共3+byteCount个字节
 303   1              crcData = crc16(sendBuf,byteCount);
 304   1              sendBuf[byteCount] = crcData & 0xff;   // CRC代码低位在前
 305   1              byteCount++;
 306   1              sendBuf[byteCount] = crcData >> 8 ;        //高位在后
 307   1              sendCounter = byteCount + 1;                    //例如byteCount=49，则sendBuf[]中实际上有49+1个元素待发
 308   1              beginSend();
 309   1      }
 310          static void forceSingleCoil(void)
 311          {//fuction:05 ,强制单个线圈
 312   1              uint16_t addr;
 313   1              uint16_t tempAddr;
 314   1              uint16_t tempData;
 315   1              uint16_t  onOff;
 316   1              uint8_t i;
 317   1              addr = (receBuf[2]<<8) + receBuf[3]; 
 318   1              tempAddr = addr;
 319   1              onOff = (receBuf[4]<<8) + receBuf[5]; 
 320   1              if(onOff == 0xff00)
 321   1              { 
 322   2                      tempData = 1;//设为ON
 323   2              } 
 324   1              else if(onOff == 0x0000)//设为OFF
 325   1              { 
 326   2                      tempData = 0;
 327   2              }
 328   1              setCoilVal(tempAddr, tempData); 
 329   1              for(i=0;i<receCounter; i++)
 330   1              {
 331   2                      sendBuf[i] = receBuf[i];
 332   2              }
 333   1              sendCounter = receCounter;
 334   1              beginSend(); 
 335   1      }
 336          
 337          static void presetSingleRegister(void)
 338          {//fuction:06设置单个寄存器
 339   1              uint16_t addr;
 340   1              uint16_t tempAddr;
 341   1              uint16_t tempData;
 342   1              uint16_t crcData;
 343   1              addr = (receBuf[2]<<8) + receBuf[3];
 344   1              tempAddr = (addr+40000);
 345   1              tempData = (receBuf[4]<<8) + receBuf[5];
 346   1              setRegisterVal(tempAddr,tempData);  
 347   1              sendBuf[0] = localAddr;
 348   1              sendBuf[1] = 6;    //function code : 16
 349   1              sendBuf[2] = addr >> 8;  //寄存器地址高位
 350   1              sendBuf[3] = addr & 0xff;//寄存器地址低位
 351   1              sendBuf[4] =receBuf[4];
 352   1              sendBuf[5] =receBuf[5];
 353   1              crcData = crc16(sendBuf,6);//生成CRC校验码
 354   1              sendBuf[6] = crcData & 0xff;  //CRC代码低位在前
 355   1              sendBuf[7] = crcData >> 8;        //高位在后
 356   1              sendCounter = 8;
 357   1              beginSend(); 
 358   1      }
 359          
 360          static void forceMultipleCoils(void)
 361          {//function code : 15，强置多线圈值
 362   1              uint16_t addr;
 363   1              uint16_t tempAddr;
C51 COMPILER V9.59.0.0   SLAVEMODBUS                                                       12/17/2018 23:24:15 PAGE 7   

 364   1              uint16_t byteCount;
 365   1              uint16_t  bitCount;
 366   1              uint16_t crcData;
 367   1              uint16_t tempData;
 368   1              uint16_t  i,k;
 369   1              uint8_t  exit = 0;
 370   1              addr = (receBuf[2] << 8) + receBuf[3];
 371   1              tempAddr = addr;
 372   1              bitCount = (receBuf[4] << 8) + receBuf[5];
 373   1              byteCount = bitCount / 8;    //字节个数
 374   1              if(bitCount%8 != 0)
 375   1              {
 376   2                      byteCount++;
 377   2              }               
 378   1              for(k = 0;k < byteCount;k ++)//字节位置
 379   1              {
 380   2                      for(i = 0;i < 8;i ++)
 381   2                      {
 382   3                              tempData = (receBuf[k + 7] >> i) & 0x01;//对应位 位置  
 383   3                              setCoilVal(tempAddr, tempData); 
 384   3                              tempAddr++;
 385   3                              if(tempAddr >= addr + bitCount)//读完
 386   3                              { 
 387   4                                      exit = 1;
 388   4                                      break;
 389   4                              } 
 390   3                      }
 391   2                      if(exit == 1)
 392   2                      break;
 393   2              }
 394   1              sendBuf[0] = localAddr;
 395   1              sendBuf[1] = 15;    //function code : 16
 396   1              sendBuf[2] = addr >> 8;  //寄存器地址高位
 397   1              sendBuf[3] = addr & 0xff;//寄存器地址低位
 398   1              sendBuf[4] = bitCount >> 8;//待设置寄存器数量高位
 399   1              sendBuf[5] = bitCount & 0xff;//待设置寄存器数量低位
 400   1              crcData = crc16(sendBuf, 6);//生成CRC校验码
 401   1              sendBuf[6] = crcData & 0xff;  //CRC代码低位在前
 402   1              sendBuf[7] = crcData >> 8;        //高位在后
 403   1              sendCounter = 8;
 404   1              beginSend(); 
 405   1      }
 406          
 407          static void presetMultipleRegisters(void)
 408          {//function code : 16，设置多个寄存器值
 409   1              uint16_t addr;
 410   1              uint16_t tempAddr;
 411   1              uint16_t setCount;
 412   1              uint16_t crcData;
 413   1              uint16_t tempData;
 414   1              uint8_t i;
 415   1              addr = (receBuf[2]<<8) + receBuf[3];
 416   1              tempAddr = addr + 40000;
 417   1              setCount = (receBuf[4] << 8) + receBuf[5]; 
 418   1              for(i = 0;i < setCount;i ++,tempAddr ++)
 419   1              {
 420   2                      tempData = (receBuf[i*2+7]<<8) + receBuf[i*2+8];//待设置寄存器值
 421   2                      setRegisterVal(tempAddr,tempData);  
 422   2              }
 423   1              sendBuf[0] = localAddr;
 424   1              sendBuf[1] = 16;    //function code : 16
 425   1              sendBuf[2] = addr >> 8;  //寄存器地址高位
C51 COMPILER V9.59.0.0   SLAVEMODBUS                                                       12/17/2018 23:24:15 PAGE 8   

 426   1              sendBuf[3] = addr & 0xff;//寄存器地址低位
 427   1              sendBuf[4] = setCount >> 8;//待设置寄存器数量高位
 428   1              sendBuf[5] = setCount & 0xff;//待设置寄存器数量低位
 429   1              crcData = crc16(sendBuf,6);//生成CRC校验码
 430   1              sendBuf[6] = crcData & 0xff;  //CRC代码低位在前
 431   1              sendBuf[7] = crcData >> 8;        //高位在后
 432   1              sendCounter = 8;
 433   1              beginSend(); 
 434   1      }
 435          /*************************查询uart接收的数据包内容函数 **************************/
 436          ////函数功能：丛机根据串口接收到的数据包receBuf[1]里面的内容，即function code执行相应的命令
 437          /********************************************************************************/
 438          static void checkComm0Modbus(void)                 //10ms内必须响应接收数据
 439          {
 440   1              uint16_t crcData;
 441   1              uint16_t tempData;
 442   1              uint16_t temp;
 443   1              //关闭串口接收中断
 444   1              if(receCounter > 4)              
 445   1              {//如果接收到数据        
 446   2                      switch(receBuf[1])
 447   2                      {
 448   3                              case 1:                                                         
 449   3                              {//读取寄存器(一个或多个)        
 450   4                                      
 451   4                                      if(receCounter >= 8)  //从询问数据包格式可知，receCounter应该等于8      ，接收完成一组数据应该关闭接收中断
 452   4                                      {                
 453   5                                              if(receBuf[0] == localAddr)//核对地址
 454   5                                              {        
 455   6                                                      crcData = crc16(receBuf, 6);//核对校验码
 456   6                                                      temp = receBuf[7];
 457   6                                                      temp = (temp << 8) + receBuf[6];
 458   6                                                      if(crcData == temp)
 459   6                                                      {
 460   7                                                              readCoils();//读取线圈输出状态(一个或多个) 
 461   7                                                      }
 462   6                                                      receCounter = 0;                                                                          
 463   6                                              }                                       
 464   5                                      }      
 465   4                                      break;
 466   4                              }
 467   3                              case 2:                                                         
 468   3                              {//读取寄存器(一个或多个)        
 469   4                                      if(receCounter >= 8)  
 470   4                                      {//从询问数据包格式可知，receCounter应该等于8   ，接收完成一组数据应该关闭接收中断       
 471   5                                              if(receBuf[0] == localAddr)  
 472   5                                              {//核对地址      
 473   6                                                      crcData = crc16(receBuf,6);                     //核对校验码
 474   6                                                      temp=receBuf[7];
 475   6                                                      temp=(temp<<8)+receBuf[6];
 476   6                                                      if(crcData == temp)
 477   6                                                      {
 478   7                                                              readInPutCoils();                       //读取线圈输入状态(一个或多个) 
 479   7                                                      }
 480   6                                                      receCounter = 0;                                                                          
 481   6                                              }                               
 482   5                                      }      
 483   4                                      break;
 484   4                              }                       
 485   3                              case 3:
 486   3                              {//读取寄存器(一个或多个)        
 487   4                                      if(receCounter >= 8)  
C51 COMPILER V9.59.0.0   SLAVEMODBUS                                                       12/17/2018 23:24:15 PAGE 9   

 488   4                                      {//从询问数据包格式可知，receCounter应该等于8 接收完成一组数据应该关闭接收中断
 489   5                                              if(receBuf[0]==localAddr)   
 490   5                                              {//核对地址      
 491   6                                                      crcData = crc16(receBuf,6);                     //核对校验码
 492   6                                                      temp=receBuf[7];
 493   6                                                      temp=(temp<<8)+receBuf[6];
 494   6                                                      if(crcData == temp)
 495   6                                                      {
 496   7                                                              readRegisters();//读取保持寄存器(一个或多个)                                              
 497   7                                                      }       
 498   6                                                      receCounter = 0;                                
 499   6                                              }
 500   5                                      }                                       
 501   4                                      break;
 502   4                              }
 503   3                              case 4:                                                         
 504   3                              {//读取寄存器(一个或多个)        
 505   4                                      if(receCounter >= 8)  
 506   4                                      {//从询问数据包格式可知，receCounter应该等于8 接收完成一组数据应该关闭接收中断                                          
 507   5                                              if(receBuf[0]==localAddr)   //核对地址
 508   5                                              {        
 509   6                                                      crcData = crc16(receBuf,6);                     //核对校验码
 510   6                                                      temp=receBuf[7];
 511   6                                                      temp=(temp<<8)+receBuf[6];
 512   6                                                      if(crcData == temp)
 513   6                                                      { 
 514   7                                                              readInPutRegisters();//读取输入寄存器(一个或多个) 
 515   7                                                      }
 516   6                                                      receCounter = 0;                                                                          
 517   6                                              }       
 518   5                                      }      
 519   4                                      break;
 520   4                              }
 521   3                              case 5:                                                         
 522   3                              {//读取寄存器(一个或多个)        
 523   4                                      if(receCounter >= 8)  
 524   4                                      {//从询问数据包格式可知 receCounter应该等于8 接收完成一组数据应该关闭接收中断                   
 525   5                                              if(receBuf[0] == localAddr)   
 526   5                                              {//核对地址      
 527   6                                                      crcData = crc16(receBuf, 6);//核对校验码
 528   6                                                      temp = receBuf[7];
 529   6                                                      temp = (temp<<8) + receBuf[6];
 530   6                                                      if(crcData == temp)
 531   6                                                      { 
 532   7                                                              forceSingleCoil();//强置单个线圈 状态
 533   7                                                      }
 534   6                                                      receCounter = 0;                                                                          
 535   6                                              }
 536   5                                      }      
 537   4                                      break;
 538   4                              }
 539   3                              case 6: 
 540   3                              {//写单个保持寄存器     
 541   4                                      if(receCounter >= 8)
 542   4                                      {//预设单个保持寄存器    
 543   5                                              if(receBuf[0]==localAddr)
 544   5                                              {
 545   6                                                      crcData = crc16(receBuf, 6);
 546   6                                                      temp = receBuf[7];
 547   6                                                      temp = (temp<<8) + receBuf[6];
 548   6                                                      if(crcData == temp)
 549   6                                                      { 
C51 COMPILER V9.59.0.0   SLAVEMODBUS                                                       12/17/2018 23:24:15 PAGE 10  

 550   7                                                              presetSingleRegister();      //预置单个保持寄存器
 551   7                                                              //可选保存设置数据到EPROM  
 552   7                                                      } 
 553   6                                              receCounter = 0;                                                                                     
             -                                                    
 554   6                                              }
 555   5                                      }
 556   4                                      break;
 557   4                              }
 558   3                              case 15:
 559   3                              {//设置多个线圈
 560   4                                      tempData = receBuf[6]; 
 561   4                                      tempData += 9; //数据个数
 562   4                                      if(receCounter >= tempData)
 563   4                                      {
 564   5                                              if(receBuf[0] == localAddr )
 565   5                                              {
 566   6                                                      crcData = crc16(receBuf, tempData - 2);
 567   6                                                      if(crcData == (receBuf[tempData-1] << 8)+ receBuf[tempData - 2])//更改了？？
 568   6                                                      {
 569   7                                                              forceMultipleCoils();  
 570   7                                                              //可选保存设置数据到EPROM  
 571   7                                                      }
 572   6                                              } 
 573   5                                              receCounter = 0;
 574   5                                      }
 575   4                                      break;
 576   4                              }                               
 577   3                              case 16:
 578   3                              {//设置多个寄存器
 579   4                                      tempData = (receBuf[4]<<8) + receBuf[5];//设置寄存器个数
 580   4                                      tempData = tempData * 2;//数据个数=     寄存器*2
 581   4                                      tempData += 9;       //从询问数据包格式可知，receCounter应该等于9+byteCount
 582   4                                      if(receCounter >= tempData)
 583   4                                      {       
 584   5                                              if(receBuf[0]==localAddr )      //核对地址
 585   5                                              {        
 586   6                                                      crcData = crc16(receBuf, tempData - 2);
 587   6                                                      temp = receBuf[tempData - 1];
 588   6                                                      temp=(temp << 8) + receBuf[tempData - 2]; 
 589   6                                                      if(crcData == temp)
 590   6                                                      {  
 591   7                                                              presetMultipleRegisters();  
 592   7                                                              //可选保存设置数据到EPROM  
 593   7                                                      }
 594   6                                              } 
 595   5                                              receCounter = 0;
 596   5                                      }
 597   4                                      break;  
 598   4                              }   
 599   3                              default: break;  
 600   3                      }
 601   2              }
 602   1              //打开串口接收中断
 603   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3320    ----
   CONSTANT SIZE    =    512    ----
   XDATA SIZE       =    257      73
   PDATA SIZE       =   ----    ----
C51 COMPILER V9.59.0.0   SLAVEMODBUS                                                       12/17/2018 23:24:15 PAGE 11  

   DATA SIZE        =      8       4
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
