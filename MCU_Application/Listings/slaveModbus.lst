C51 COMPILER V9.59.0.0   SLAVEMODBUS                                                       12/19/2018 21:12:49 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE SLAVEMODBUS
OBJECT MODULE PLACED IN .\Objects\slaveModbus.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Modbus\slaveModbus.c OPTIMIZE(8,SPEED) REGFILE(.\Objects\dwLaser_F020.OR
                    -C) BROWSE ORDER INCDIR(.\Lib;.\Driver;.\MainApp;.\Modbus) DEFINE(C8051F020) DEBUG OBJECTEXTEND PRINT(.\Listings\slaveMod
                    -bus.lst) OBJECT(.\Objects\slaveModbus.obj)

line level    source

   1          #include "slaveModbus.h"
   2          /*****************************************************************************/
   3          #define RTU_IDLE                                0
   4          #define RTU_FRAME_STX                   1
   5          #define RTU_FRAME_DATA                  2
   6          #define RTU_FRAME_EXT                   3
   7          #define RTU_FRAME_PROCESS               4
   8          #define RTU_FRAME_OVER                  5
   9          
  10          typedef modbusRtu_t{
*** ERROR C129 IN LINE 10 OF Modbus\slaveModbus.c: missing ';' before '{'
  11                  uint8_t localAddr; //单片机控制板的地址
  12                  uint8_t state;//状态
  13                  uint8_t rxCounter;//接收计时器
  14                  uint8_t rxOverTime;//超时1.5T
  15                  uint8_t indexTx;//发送字节个数
  16                  uint8_t indexRx;//接收到的字节个数
  17                  uint8_t rxBuf[256];
  18                  uint8_t txBuf[256];
  19          };
  20          modbusRtu_t modbusRtu0;
  21          
  22          static void timeProc(void);
  23          static void checkComm0Modbus(void);
  24          /* CRC 高位字节值表 */ 
  25          uint8_t code auchCRCHi[] = 
  26          { 
  27                  0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 
  28                  0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 
  29                  0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 
  30                  0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 
  31                  0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 
  32                  0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 
  33                  0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 
  34                  0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 
  35                  0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 
  36                  0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 
  37                  0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 
  38                  0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 
  39                  0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 
  40                  0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 
  41                  0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 
  42                  0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 
  43                  0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 
  44                  0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 
  45                  0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 
  46                  0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 
  47                  0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 
  48                  0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 
  49                  0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 
  50                  0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 
  51                  0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 
  52                  0x80, 0x41, 0x00, 0xC1, 0x81, 0x40 
C51 COMPILER V9.59.0.0   SLAVEMODBUS                                                       12/19/2018 21:12:49 PAGE 2   

  53          } ; 
  54          /* CRC低位字节值表*/ 
  55          uint8_t code auchCRCLo[] = 
  56          {       
  57                  0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06, 
  58                  0x07, 0xC7, 0x05, 0xC5, 0xC4, 0x04, 0xCC, 0x0C, 0x0D, 0xCD, 
  59                  0x0F, 0xCF, 0xCE, 0x0E, 0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09,               
  60                  0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9, 0x1B, 0xDB, 0xDA, 0x1A, 
  61                  0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 0x1D, 0x1C, 0xDC, 0x14, 0xD4, 
  62                  0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3, 
  63                  0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 
  64                  0xF2, 0x32, 0x36, 0xF6, 0xF7, 0x37, 0xF5, 0x35, 0x34, 0xF4, 
  65                  0x3C, 0xFC, 0xFD, 0x3D, 0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A, 
  66                  0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38, 0x28, 0xE8, 0xE9, 0x29, 
  67                  0xEB, 0x2B, 0x2A, 0xEA, 0xEE, 0x2E, 0x2F, 0xEF, 0x2D, 0xED, 
  68                  0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26, 
  69                  0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60, 
  70                  0x61, 0xA1, 0x63, 0xA3, 0xA2, 0x62, 0x66, 0xA6, 0xA7, 0x67, 
  71                  0xA5, 0x65, 0x64, 0xA4, 0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F, 
  72                  0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB, 0x69, 0xA9, 0xA8, 0x68, 
  73                  0x78, 0xB8, 0xB9, 0x79, 0xBB, 0x7B, 0x7A, 0xBA, 0xBE, 0x7E, 
  74                  0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5, 
  75                  0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 
  76                  0x70, 0xB0, 0x50, 0x90, 0x91, 0x51, 0x93, 0x53, 0x52, 0x92, 
  77                  0x96, 0x56, 0x57, 0x97, 0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C, 
  78                  0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B, 
  79                  0x99, 0x59, 0x58, 0x98, 0x88, 0x48, 0x49, 0x89, 0x4B, 0x8B, 
  80                  0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C, 
  81                  0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 
  82                  0x43, 0x83, 0x41, 0x81, 0x80, 0x40 
  83          } ;
  84          
  85          
  86          
  87          void presetSingleRegister(void);
  88          uint16_t setCoilVal(uint16_t addr,uint16_t tempData);
  89          uint16_t getCoilVal(uint16_t addr,uint16_t *tempData);
  90          uint16_t getRegisterVal(uint16_t addr,uint16_t *tempData);
  91          uint16_t setRegisterVal(uint16_t addr,uint16_t tempData);
  92          
  93          /*****************************************************************************/
  94          void InitModbusHardware(uint32_t baudrate)
  95          {//初始化MODBUS硬件
  96                  InitModbusTimer();//初始化计时器
  97                  InitModbusSerial(baudrate);//初始化串口
  98          }
  99          void modbusTimerHandle(void)
 100          {//计时器中断
 101                  //bt1ms = 1;
 102                  if(modbusRtu0.rxCounter < modbusRtu0.rxOverTime){
 103                          receTimeCounter ++;
 104                  }
 105                  if(receTimeCounter < receTime1T5){
 106                          receTimeCounter ++;
 107                  }
 108                  else{
 109                          receTimeCounter = 0;
 110                          TR2 = 0;
 111                          
 112                  }
 113          }
 114          void modbusSerialRxHandle(void)
C51 COMPILER V9.59.0.0   SLAVEMODBUS                                                       12/19/2018 21:12:49 PAGE 3   

 115          {//串口接收中断
 116                  data uint8_t ctemp;
 117                  //receTimeOut = MB_CONFIG_RECE_TIMEOUT;//通讯超时值这个地方很重要       10ms
 118                  ctemp = SBUF0;
 119                  if(receCount < sizeof(receBuf)){
 120                  receBuf[receCount] = ctemp;
 121                  receCount++;          //接收地址偏移寄存器加1
 122                  }
 123                  else 
 124                  {
 125                          receCount = 0;
 126                          receTimeCounter = 0;
 127                          TR2 = 0;
 128                  }
 129          }
 130          void modbusSerialTxHandle(void)
 131          {//串口发射中断
 132          }
 133          void modbusPoll(void)
 134          {
 135                  timeProc();
 136                  checkComm0Modbus();     
 137          }
 138          void setModbusSlaveAddr(uint8_t addr)
 139          {//设置从机地址
 140                  localAddr = addr;
 141          }
 142          uint8_t getModbusSlaveAddr(void)
 143          {//获取从机地址
 144                  return localAddr;
 145          }
 146          /*****************************************************************************/
 147          
 148          static void timeProc(void)
 149          {//定时处理
 150                  if(receTimeCounter == 0)
 151                  {
 152                          receCount = 0;
 153                          TR2 = 1;
 154                  }
 155          //      if(bt1ms)
 156          //      {
 157          //              bt1ms = 0;
 158          //              if(receTimeOut > 0)
 159          //              { 
 160          //                      receTimeOut --;
 161          //                      if(receTimeOut == 0 && receCount>0)   //判断通讯接收是否超时
 162          //                      {
 163          //                              RS485_DIRECTION_RXD;//将485置为接收状态                                                             
             -                                                                                                 
 164          //                              receCount = 0;//      //将接收地址偏移寄存器清零
 165          //                       }
 166          //               }
 167          //      }
 168          }
 169          static uint16_t crc16(uint8_t *puchMsg, uint16_t usDataLen) 
 170          {//CRC16生成器 
 171                  data uint8_t uchCRCHi = 0xFF ; /* 高CRC字节初始化 */ 
 172                  data uint8_t uchCRCLo = 0xFF ; /* 低CRC 字节初始化 */ 
 173                  data uint16_t uIndex ; /* CRC循环中的索引 */ 
 174                  while (usDataLen--) /* 传输消息缓冲区 */ 
 175                  { 
C51 COMPILER V9.59.0.0   SLAVEMODBUS                                                       12/19/2018 21:12:49 PAGE 4   

 176                          uIndex = uchCRCHi ^ *puchMsg++ ; /* 计算CRC */ 
 177                          uchCRCHi = uchCRCLo ^ auchCRCHi[uIndex] ; 
 178                          uchCRCLo = auchCRCLo[uIndex] ; 
 179                  } 
 180                  return (uchCRCLo << 8 | uchCRCHi) ; 
 181          }               
 182          static void beginSend(void)
 183          {//发送数据
 184                  RS485_DIRECTION_TXD;//处于发送
 185                  //modbusDelayUs(MB_CONFIG_RS485_SWITCH_DELAY);//延时100uS等待发送指示功能稳定
 186                  modbusSerialSendBuffer(sendBuf, sendCount);
 187                  //modbusDelayUs(MB_CONFIG_RS485_SWITCH_DELAY);
 188                  RS485_DIRECTION_RXD;//发送完后将485置于接收状态
 189              receCount = 0;   //清接收地址偏移寄存器
 190          }
 191          static void readCoils(void)
 192          {//fuction:01 读单个或多个线圈状态
 193                  data uint16_t addr;
 194                  data uint16_t tempAddr;
 195                  data uint16_t byteCount;
 196                  data uint16_t bitCount;
 197                  data uint16_t crcData;
 198                  data uint16_t position;
 199                  data uint16_t i, k;
 200                  data uint16_t tempData;
 201                  data uint8_t exit = 0;
 202                  addr = (receBuf[2]<<8) + receBuf[3]; 
 203                  tempAddr = addr;
 204                  bitCount = (receBuf[4]<<8) + receBuf[5]; //读取的位个数
 205                  byteCount = bitCount / 8;    //字节个数
 206                  if(bitCount%8 != 0)
 207                  {
 208                    byteCount++;
 209                  }               
 210                  for(k = 0; k < byteCount; k ++)//字节位置
 211                  {
 212                          position = k + 3;
 213                          sendBuf[position] = 0;
 214                          for(i = 0; i < 8; i ++)
 215                          {
 216                                  getCoilVal(tempAddr, &tempData);
 217                                  sendBuf[position] |= tempData << i;
 218                                  tempAddr++;
 219                                  if(tempAddr >= addr + bitCount)//读完
 220                                  { 
 221                                          exit = 1;
 222                                          break;
 223                                  } 
 224                          }
 225                          if(exit == 1)
 226                          break;
 227                  }
 228                  sendBuf[0] = localAddr;
 229                  sendBuf[1] = 0x01; 
 230                  sendBuf[2] = byteCount;
 231                  byteCount += 3;
 232                  crcData = crc16(sendBuf,byteCount); 
 233                  sendBuf[byteCount] = crcData & 0xff;
 234                  byteCount++;
 235                  sendBuf[byteCount] = crcData >> 8;
 236                  sendCount = byteCount + 1;
 237                  beginSend();   
C51 COMPILER V9.59.0.0   SLAVEMODBUS                                                       12/19/2018 21:12:49 PAGE 5   

 238          }
 239          static void readInPutCoils(void)
 240          {//fuction:02 读取线圈输入（只读寄存器）状态
 241                  data uint16_t addr;
 242                  data uint16_t tempAddr;
 243                  data uint16_t byteCount;
 244                  data uint16_t  bitCount;
 245                  data uint16_t crcData;
 246                  data uint16_t  position;
 247                  data uint16_t  i,k;
 248                  data uint16_t tempData;
 249                  data uint8_t  exit = 0;
 250                  addr = (receBuf[2]<<8) + receBuf[3]; 
 251                  tempAddr = addr +10000;        //只读线圈寄存器偏移地址10000
 252                  bitCount = (receBuf[4]<<8) + receBuf[5]; //读取的位个数
 253                  byteCount = bitCount / 8;    //字节个数
 254                  if(bitCount%8 != 0)
 255                  {
 256                          byteCount++;
 257                  }               
 258                  for(k=0;k<byteCount;k++)//字节位置
 259                  {
 260                          position = k + 3;
 261                          sendBuf[position] = 0;
 262                          for(i=0;i<8;i++)
 263                          {
 264                                  getCoilVal(tempAddr,&tempData);
 265                                  sendBuf[position] |= tempData << i;
 266                                  tempAddr++;
 267                                  if(tempAddr >= addr+bitCount)//读完
 268                                  { 
 269                                          exit = 1;
 270                                          break;
 271                                  } 
 272                          }
 273                          if(exit == 1)
 274                          {
 275                                  break;
 276                          }
 277                  }
 278                  sendBuf[0] = localAddr;
 279                  sendBuf[1] = 0x02; 
 280                  sendBuf[2] = byteCount;
 281                  byteCount += 3;
 282                  crcData = crc16(sendBuf,byteCount); 
 283                  sendBuf[byteCount] = crcData & 0xff;
 284                  byteCount++;
 285                  sendBuf[byteCount] = crcData >> 8;
 286                  sendCount = byteCount + 1;
 287                  beginSend();   
 288          }
 289          static void readRegisters(void)
 290          {//function code : 03，读取多个寄存器值
 291                  data uint16_t addr;
 292                  data uint16_t tempAddr;
 293                  data uint16_t crcData;
 294                  data uint16_t readCount;
 295                  data uint16_t byteCount;
 296                  data uint16_t i;
 297                  data uint16_t tempData = 0; 
 298                  addr = (receBuf[2]<<8) + receBuf[3]; 
 299                  tempAddr = addr+40000;      //+40000,保持寄存器偏移地址
C51 COMPILER V9.59.0.0   SLAVEMODBUS                                                       12/19/2018 21:12:49 PAGE 6   

 300                  readCount = (receBuf[4]<<8) + receBuf[5]; //要读的个数 ,整型
 301                  byteCount = readCount * 2;                  //每个寄存器内容占高，低两个字节
 302                  for(i=0;i<byteCount;i+=2,tempAddr++)
 303                  {
 304                          getRegisterVal(tempAddr,&tempData);    
 305                          sendBuf[i+3] = tempData >> 8;        
 306                          sendBuf[i+4] = tempData & 0xff;  
 307                  }
 308                  sendBuf[0] = localAddr;
 309                  sendBuf[1] = 3;  //function code : 03
 310                  sendBuf[2] = byteCount;
 311                  byteCount += 3;             //加上前面的地址，功能码，地址 共3+byteCount个字节
 312                  crcData = crc16(sendBuf,byteCount);
 313                  sendBuf[byteCount] = crcData & 0xff;   // CRC代码低位在前
 314                  byteCount++;
 315                  sendBuf[byteCount] = crcData >> 8 ;        //高位在后
 316                  sendCount = byteCount + 1;                      //例如byteCount=49，则sendBuf[]中实际上有49+1个元素待发
 317                  beginSend();
 318          }
 319          static void readInPutRegisters(void)
 320          {//fuction 04:读取输入寄存器
 321                  uint16_t addr;
 322                  uint16_t tempAddr;
 323                  uint16_t crcData;
 324                  uint16_t readCount;
 325                  uint16_t byteCount;
 326                  uint16_t i;
 327                  uint16_t tempData = 0; 
 328                  addr = (receBuf[2]<<8) + receBuf[3]; 
 329                  tempAddr = addr+30000;  //+输入寄存器偏移地址：30000
 330                  readCount = (receBuf[4]<<8) + receBuf[5]; //要读的个数 ,整型
 331                  byteCount = readCount * 2;                  //每个寄存器内容占高，低两个字节
 332                  for(i=0;i<byteCount;i+=2,tempAddr++)
 333                  {
 334                          getRegisterVal(tempAddr,&tempData);    
 335                          sendBuf[i+3] = tempData >> 8;        
 336                          sendBuf[i+4] = tempData & 0xff;  
 337                  }
 338                  sendBuf[0] = localAddr;
 339                  sendBuf[1] = 4;  //function code : 04
 340                  sendBuf[2] = byteCount;
 341                  byteCount += 3;             //加上前面的地址，功能码，地址 共3+byteCount个字节
 342                  crcData = crc16(sendBuf,byteCount);
 343                  sendBuf[byteCount] = crcData & 0xff;   // CRC代码低位在前
 344                  byteCount++;
 345                  sendBuf[byteCount] = crcData >> 8 ;        //高位在后
 346                  sendCount = byteCount + 1;                      //例如byteCount=49，则sendBuf[]中实际上有49+1个元素待发
 347                  beginSend();
 348          }
 349          static void forceSingleCoil(void)
 350          {//fuction:05 ,强制单个线圈
 351                  uint16_t addr;
 352                  uint16_t tempAddr;
 353                  uint16_t tempData;
 354                  uint16_t  onOff;
 355                  uint8_t i;
 356                  addr = (receBuf[2]<<8) + receBuf[3]; 
 357                  tempAddr = addr;
 358                  onOff = (receBuf[4]<<8) + receBuf[5]; 
 359                  if(onOff == 0xff00)
 360                  { 
 361                          tempData = 1;//设为ON
C51 COMPILER V9.59.0.0   SLAVEMODBUS                                                       12/19/2018 21:12:49 PAGE 7   

 362                  } 
 363                  else if(onOff == 0x0000)//设为OFF
 364                  { 
 365                          tempData = 0;
 366                  }
 367                  setCoilVal(tempAddr,tempData); 
 368                  for(i=0;i<receCount;i++)
 369                  {
 370                          sendBuf[i] = receBuf[i];
 371                  }
 372                  sendCount = receCount;
 373                  beginSend(); 
 374          }
 375          
 376          static void presetSingleRegister(void)
 377          {//fuction:06设置单个寄存器
 378                  data uint16_t addr;
 379                  data uint16_t tempAddr;
 380                  data uint16_t tempData;
 381                  data uint16_t crcData;
 382                  addr = (receBuf[2]<<8) + receBuf[3];
 383                  tempAddr = (addr+40000);
 384                  tempData = (receBuf[4]<<8) + receBuf[5];
 385                  setRegisterVal(tempAddr,tempData);  
 386                  sendBuf[0] = localAddr;
 387                  sendBuf[1] = 6;    //function code : 16
 388                  sendBuf[2] = addr >> 8;  //寄存器地址高位
 389                  sendBuf[3] = addr & 0xff;//寄存器地址低位
 390                  sendBuf[4] =receBuf[4];
 391                  sendBuf[5] =receBuf[5];
 392                  crcData = crc16(sendBuf,6);//生成CRC校验码
 393                  sendBuf[6] = crcData & 0xff;  //CRC代码低位在前
 394                  sendBuf[7] = crcData >> 8;        //高位在后
 395                  sendCount = 8;
 396                  beginSend(); 
 397          }
 398          
 399          static void forceMultipleCoils(void)
 400          {//function code : 15，强置多线圈值
 401                  data uint16_t addr;
 402                  data uint16_t tempAddr;
 403                  data uint16_t byteCount;
 404                  data uint16_t  bitCount;
 405                  data uint16_t crcData;
 406                  data uint16_t tempData;
 407                  data uint16_t  i,k;
 408                  data uint8_t  exit = 0;
 409                  addr = (receBuf[2] << 8) + receBuf[3];
 410                  tempAddr = addr;
 411                  bitCount = (receBuf[4] << 8) + receBuf[5];
 412                  byteCount = bitCount / 8;    //字节个数
 413                  if(bitCount%8 != 0)
 414                  {
 415                          byteCount++;
 416                  }               
 417                  for(k = 0;k < byteCount;k ++)//字节位置
 418                  {
 419                          for(i = 0;i < 8;i ++)
 420                          {
 421                                  tempData = (receBuf[k + 7] >> i) & 0x01;//对应位 位置  
 422                                  setCoilVal(tempAddr, tempData); 
 423                                  tempAddr++;
C51 COMPILER V9.59.0.0   SLAVEMODBUS                                                       12/19/2018 21:12:49 PAGE 8   

 424                                  if(tempAddr >= addr + bitCount)//读完
 425                                  { 
 426                                          exit = 1;
 427                                          break;
 428                                  } 
 429                          }
 430                          if(exit == 1)
 431                          break;
 432                  }
 433                  sendBuf[0] = localAddr;
 434                  sendBuf[1] = 15;    //function code : 16
 435                  sendBuf[2] = addr >> 8;  //寄存器地址高位
 436                  sendBuf[3] = addr & 0xff;//寄存器地址低位
 437                  sendBuf[4] = bitCount >> 8;//待设置寄存器数量高位
 438                  sendBuf[5] = bitCount & 0xff;//待设置寄存器数量低位
 439                  crcData = crc16(sendBuf, 6);//生成CRC校验码
 440                  sendBuf[6] = crcData & 0xff;  //CRC代码低位在前
 441                  sendBuf[7] = crcData >> 8;        //高位在后
 442                  sendCount = 8;
 443                  beginSend(); 
 444          }
 445          
 446          static void presetMultipleRegisters(void)
 447          {//function code : 16，设置多个寄存器值
 448                  data uint16_t addr;
 449                  data uint16_t tempAddr;
 450                  data uint16_t setCount;
 451                  data uint16_t crcData;
 452                  data uint16_t tempData;
 453                  data uint8_t i;
 454                  addr = (receBuf[2]<<8) + receBuf[3];
 455                  tempAddr = addr + 40000;
 456                  setCount = (receBuf[4] << 8) + receBuf[5]; 
 457                  for(i = 0;i < setCount;i ++,tempAddr ++)
 458                  {
 459                          tempData = (receBuf[i*2+7]<<8) + receBuf[i*2+8];//待设置寄存器值
 460                          setRegisterVal(tempAddr,tempData);  
 461                  }
 462                  sendBuf[0] = localAddr;
 463                  sendBuf[1] = 16;    //function code : 16
 464                  sendBuf[2] = addr >> 8;  //寄存器地址高位
 465                  sendBuf[3] = addr & 0xff;//寄存器地址低位
 466                  sendBuf[4] = setCount >> 8;//待设置寄存器数量高位
 467                  sendBuf[5] = setCount & 0xff;//待设置寄存器数量低位
 468                  crcData = crc16(sendBuf,6);//生成CRC校验码
 469                  sendBuf[6] = crcData & 0xff;  //CRC代码低位在前
 470                  sendBuf[7] = crcData >> 8;        //高位在后
 471                  sendCount = 8;
 472                  beginSend(); 
 473          }
 474          /*************************查询uart接收的数据包内容函数 **************************/
 475          ////函数功能：丛机根据串口接收到的数据包receBuf[1]里面的内容，即function code执行相应的命令
 476          /********************************************************************************/
 477          static void checkComm0Modbus(void)                 //10ms内必须响应接收数据
 478          {
 479                  data uint16_t crcData;
 480                  data uint16_t tempData;
 481                  data uint16_t temp;
 482                  if(receCount > 4)                
 483                  {//如果接收到数据        
 484                          switch(receBuf[1])
 485                          {
C51 COMPILER V9.59.0.0   SLAVEMODBUS                                                       12/19/2018 21:12:49 PAGE 9   

 486                                  case 1:                                                         
 487                                  {//读取寄存器(一个或多个)        
 488                                          
 489                                          if(receCount >= 8)  //从询问数据包格式可知，receCount应该等于8  ，接收完成一组数据应该关闭接收中断
 490                                          {                
 491                                                  DISABLE_MODBUS_INT;
 492                                                  if(receBuf[0] == localAddr)//核对地址
 493                                                  {        
 494                                                          crcData = crc16(receBuf, 6);//核对校验码
 495                                                          temp=receBuf[7];
 496                                                          temp=(temp<<8)+receBuf[6];
 497                                                          if(crcData == temp)
 498                                                          {
 499                                                                  readCoils();//读取线圈输出状态(一个或多个) 
 500                                                          }
 501                                                          receCount = 0;                                                                    
 502                                                  }
 503                                                  ENABLE_MODBUS_INT;                                      
 504                                          }      
 505                                          break;
 506                                  }
 507                                  case 2:                                                         
 508                                  {//读取寄存器(一个或多个)        
 509                                          if(receCount >= 8)  
 510                                          {//从询问数据包格式可知，receCount应该等于8     ，接收完成一组数据应该关闭接收中断       
 511                                                  DISABLE_MODBUS_INT;
 512                                                  if(receBuf[0] == localAddr)  
 513                                                  {//核对地址      
 514                                                          crcData = crc16(receBuf,6);                     //核对校验码
 515                                                          temp=receBuf[7];
 516                                                          temp=(temp<<8)+receBuf[6];
 517                                                          if(crcData == temp)
 518                                                          {
 519                                                                  readInPutCoils();                       //读取线圈输入状态(一个或多个) 
 520                                                          }
 521                                                          receCount = 0;                                                                    
 522                                                  }
 523                                                  ENABLE_MODBUS_INT;                              
 524                                          }      
 525                                          break;
 526                                  }
 527                                  
 528                                  case 3:
 529                                  {//读取寄存器(一个或多个)        
 530                                          if(receCount >= 8)  
 531                                          {//从询问数据包格式可知，receCount应该等于8 接收完成一组数据应该关闭接收中断
 532                                                  DISABLE_MODBUS_INT;
 533                                                  if(receBuf[0]==localAddr)   
 534                                                  {//核对地址      
 535                                                          crcData = crc16(receBuf,6);                     //核对校验码
 536                                                          temp=receBuf[7];
 537                                                          temp=(temp<<8)+receBuf[6];
 538                                                          if(crcData == temp)
 539                                                          {
 540                                                                  readRegisters();//读取保持寄存器(一个或多个)                                              
 541                                                          }       
 542                                                          receCount = 0;                          
 543                                                  }
 544                                                  ENABLE_MODBUS_INT;
 545                                          }                                       
 546                                          break;
 547                                  }
C51 COMPILER V9.59.0.0   SLAVEMODBUS                                                       12/19/2018 21:12:49 PAGE 10  

 548                                  case 4:                                                         
 549                                  {//读取寄存器(一个或多个)        
 550                                          if(receCount >= 8)  
 551                                          {//从询问数据包格式可知，receCount应该等于8 接收完成一组数据应该关闭接收中断   
 552                                                  DISABLE_MODBUS_INT;                                     
 553                                                  if(receBuf[0]==localAddr)   //核对地址
 554                                                  {        
 555                                                          crcData = crc16(receBuf,6);                     //核对校验码
 556                                                          temp=receBuf[7];
 557                                                          temp=(temp<<8)+receBuf[6];
 558                                                          if(crcData == temp)
 559                                                          { 
 560                                                                  readInPutRegisters();//读取输入寄存器(一个或多个) 
 561                                                          }
 562                                                          receCount = 0;                                                                    
 563                                                  }       
 564                                                  ENABLE_MODBUS_INT;
 565                                          }      
 566                                          break;
 567                                  }
 568                                  case 5:                                                         
 569                                  {//读取寄存器(一个或多个)        
 570                                          if(receCount >= 8)  
 571                                          {//从询问数据包格式可知 receCount应该等于8 接收完成一组数据应该关闭接收中断   
 572                                                  DISABLE_MODBUS_INT;             
 573                                                  if(receBuf[0] == localAddr)   
 574                                                  {//核对地址      
 575                                                          crcData = crc16(receBuf, 6);//核对校验码
 576                                                          temp = receBuf[7];
 577                                                          temp = (temp<<8) + receBuf[6];
 578                                                          if(crcData == temp)
 579                                                          { 
 580                                                                  forceSingleCoil();//强置单个线圈 状态
 581                                                          }
 582                                                          receCount = 0;                                                                    
 583                                                  }
 584                                                  ENABLE_MODBUS_INT;
 585                                          }      
 586                                          break;
 587                                  }
 588                                  case 6: 
 589                                  {//写单个保持寄存器     
 590                                          if(receCount >= 8)
 591                                          {//预设单个保持寄存器    
 592                                                  DISABLE_MODBUS_INT;
 593                                                  if(receBuf[0]==localAddr)
 594                                                  {
 595                                                          crcData = crc16(receBuf, 6);
 596                                                          temp = receBuf[7];
 597                                                          temp = (temp<<8) + receBuf[6];
 598                                                          if(crcData == temp)
 599                                                          { 
 600                                                                  presetSingleRegister();      //预置单个保持寄存器
 601                                                                  //可选保存设置数据到EPROM  
 602                                                          } 
 603                                                  receCount = 0;                                                                                       
             -                                                  
 604                                                  }
 605                                                  ENABLE_MODBUS_INT;
 606                                          }
 607                                          break;
 608                                  }
C51 COMPILER V9.59.0.0   SLAVEMODBUS                                                       12/19/2018 21:12:49 PAGE 11  

 609                                  case 15:
 610                                  {//设置多个线圈
 611                                          DISABLE_MODBUS_INT;
 612                                          tempData = receBuf[6]; 
 613                                          tempData += 9; //数据个数
 614                                          if(receCount >= tempData)
 615                                          {
 616                                                  if(receBuf[0] == localAddr )
 617                                                  {
 618                                                          crcData = crc16(receBuf, tempData - 2);
 619                                                          if(crcData == (receBuf[tempData-1] << 8)+ receBuf[tempData - 2])//更改了？？
 620                                                          {
 621                                                                  forceMultipleCoils();  
 622                                                                  //可选保存设置数据到EPROM  
 623                                                          }
 624                                                  } 
 625                                                  receCount = 0;
 626                                          }
 627                                          ENABLE_MODBUS_INT;
 628                                          break;
 629                                  }                               
 630                                  case 16:
 631                                  {//设置多个寄存器
 632                                          DISABLE_MODBUS_INT;
 633                                          tempData = (receBuf[4]<<8) + receBuf[5];//设置寄存器个数
 634                                          tempData = tempData * 2;//数据个数=     寄存器*2
 635                                          tempData += 9;       //从询问数据包格式可知，receCount应该等于9+byteCount
 636                                          if(receCount >= tempData)
 637                                          {       
 638                                                  if(receBuf[0]==localAddr )      //核对地址
 639                                                  {        
 640                                                          crcData = crc16(receBuf, tempData - 2);
 641                                                          temp = receBuf[tempData - 1];
 642                                                          temp=(temp << 8) + receBuf[tempData - 2]; 
 643                                                          if(crcData == temp)
 644                                                          {  
 645                                                                  presetMultipleRegisters();  
 646                                                                  //可选保存设置数据到EPROM  
 647                                                          }
 648                                                  } 
 649                                                  receCount = 0;
 650                                          }
 651                                          ENABLE_MODBUS_INT;
 652                                          break;  
 653                                  }   
 654                                  default: break;  
 655                          }
 656                  }
 657          }

C51 COMPILATION COMPLETE.  0 WARNING(S),  1 ERROR(S)
