C51 COMPILER V9.56.0.0   MODBUSPORT                                                        12/21/2018 17:57:45 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE MODBUSPORT
OBJECT MODULE PLACED IN .\Objects\ModbusPort.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Modbus\ModbusPort.c COMPACT OPTIMIZE(8,SPEED) REGFILE(.\Objects\dwLaser_
                    -F020.ORC) BROWSE ORDER INCDIR(.\Lib;.\Driver;.\MainApp;.\Modbus) DEFINE(C8051F020) DEBUG OBJECTEXTEND PRINT(.\Listings\M
                    -odbusPort.lst) PREPRINT(.\Listings\ModbusPort.i) OBJECT(.\Objects\ModbusPort.obj)

line level    source

   1          #include "modbusPort.h"
   2          /*****************************************************************************/
   3          volatile uint16_t modbusTimerValue;
   4          extern volatile uint8_t modbusReceiveCounter;
   5          volatile uint8_t modbusReceiveBuffer[];
   6          /*****************************************************************************/
   7          void initModbusSerial(int32_t baudrate)
   8          {//初始化MODBUS串口
   9   1              uint32_t temp;
  10   1              temp = (uint32_t)(CONFIG_SYSCLK / 32 / baudrate);
  11   1              temp = 65536 - temp;            
  12   1              T2CON &= 1 << 4;//Timer 1 overflows used for transmit clock.
  13   1              T2CON &= 1 << 5;//Timer 1 overflows used for receive clock.     
  14   1              TMOD &= 0x0F;
  15   1              TMOD |= 1 << 5;//Mode 2: 8-bit counter/timer with auto-reload
  16   1              TH1 = (uint8_t)(temp & 0xff);
  17   1              TL1 = (uint8_t)(temp & 0xff);
  18   1              TR1 = 1;
  19   1              T2CON |= 1 << 2;//Timer 2 enabled
  20   1              //RS485_DIRECTION_RXD;//接收状态
  21   1              ES0 = 1;
  22   1              TI0 = 0;//清除发送完成            
  23   1              RI0 = 0;//清除接收完成                    
  24   1      }
  25          void initModbusTimer(void){//初始化MODBUS计时器 1mS TIMER2
  26   1              uint16_t temp;
  27   1              temp = (uint16_t)(65536 - (CONFIG_SYSCLK / 1000));
  28   1              T2CON = 0x0;//RCLK0=0,TCLK0=0
  29   1          RCAP2L = (uint8_t)(temp & 0xFF);
  30   1              RCAP2H = (uint8_t)((temp >> 8) & 0xFF);
  31   1              TF2 = 0;
  32   1              TR2 = 1;        
  33   1              ET2 = 1; //开中断T0
  34   1      }
  35          static void modbusSerialSendbyte(uint8_t *dt){//串口发送一个字节
  36   1              ES0 = 0;
  37   1              TI0 = 0;
  38   1              SBUF0 = *dt;
  39   1              while( !TI0 );
  40   1              TI0 = 0;
  41   1              ES0 = 1;
  42   1      }
  43          void modBusUartInitialise(uint32_t baudrate){// UART Initialize for Microconrollers, yes you can use anoth
             -er phsycal layer!
  44   1          initModbusSerial(baudrate);
  45   1      }
  46          void modBusTimerInitialise(void){// Timer Initialize for Petit Modbus, 1ms Timer will be good for us!
  47   1          initModbusTimer();
  48   1      }
  49          void modBusUartPutch(uint8_t c){// This is used for send one character
  50   1              modbusSerialSendbyte(&c);
  51   1      }
  52          uint8_t modBusUartString(uint8_t *s, uint16_t  Length){// This is used for send string, better to use DMA 
C51 COMPILER V9.56.0.0   MODBUSPORT                                                        12/21/2018 17:57:45 PAGE 2   

             -for it ;)
  53   1          uint16_t DummyCounter;
  54   1          for(DummyCounter=0; DummyCounter < Length; DummyCounter ++){
  55   2              modBusUartPutch(s[DummyCounter]);
  56   2          }
  57   1          return TRUE;
  58   1      }
  59          void receiveInterrupt(uint8_t Data){//Call this function into your UART Interrupt. Collect data from it!
  60   1          modbusReceiveBuffer[modbusReceiveCounter] = Data;
  61   1          modbusReceiveCounter ++;
  62   1          if(modbusReceiveCounter > CONFIG_MODBUS_SLAVE_BUFFER_SIZE){  
  63   2              modbusReceiveCounter = 0;
  64   2              }
  65   1          modbusTimerValue = 0;
  66   1      }
  67          
  68          
  69          void modBusTimerValues(void){//Call this function into 1ms Interrupt or Event!
  70   1          modbusTimerValue ++;
  71   1      }
  72          /******************************************************************************/
  73          static void modbusHandle() interrupt INTERRUPT_TIMER2
  74          {//硬件计时器TIMER1中断函数 1mS
  75   1              TF2 = 0;
  76   1              modBusTimerValues();
  77   1      } 
  78          
  79          static void serialHandle() interrupt INTERRUPT_UART0
  80          {//UART0 串口中断程序
  81   1              uint8_t ctemp;
  82   1              if(RI0){
  83   2                      RI0 = 0;
  84   2                      ctemp = SBUF0;          
  85   2                      receiveInterrupt(ctemp);
  86   2                      if(RI0)
  87   2                      {
  88   3                              RI0 = 0;
  89   3                      }
  90   2              }
  91   1              if(TI0){
  92   2                      TI0 = 0;
  93   2                      //modbusSerialTxHandle();
  94   2              }
  95   1      } 


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    312    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =      2      10
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
