C51 COMPILER V9.59.0.0   MODBUS                                                            12/22/2018 00:24:03 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MODBUS
OBJECT MODULE PLACED IN .\Objects\Modbus.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Modbus\Modbus.c COMPACT OPTIMIZE(8,SPEED) REGFILE(.\Objects\dwLaser_F020
                    -.ORC) BROWSE ORDER INCDIR(.\Lib;.\Driver;.\MainApp;.\Modbus) DEFINE(C8051F020) DEBUG OBJECTEXTEND PRINT(.\Listings\Modbu
                    -s.lst) PREPRINT(.\Listings\Modbus.i) OBJECT(.\Objects\Modbus.obj)

line level    source

   1          #include "modbus.h"
   2          /*******************************ModBus Functions*******************************/
   3          #define MODBUS_READ_COILS                                               1
   4          #define MODBUS_READ_DISCRETE_INPUTS                                     2
   5          #define MODBUS_READ_HOLDING_REGISTERS                                   3
   6          #define MODBUS_READ_INPUT_REGISTERS                                     4
   7          #define MODBUS_WRITE_SINGLE_COIL                                        5
   8          #define MODBUS_WRITE_SINGLE_REGISTER                                    6
   9          #define MODBUS_WRITE_MULTIPLE_COILS                                     15
  10          #define MODBUS_WRITE_MULTIPLE_REGISTERS                                 16
  11          /****************************End of ModBus Functions***************************/
  12          #define FALSE_FUNCTION                                                  0
  13          #define FALSE_SLAVE_ADDRESS                                             1
  14          #define DATA_NOT_READY                                                  2
  15          #define DATA_READY                                                      3
  16          #define ERROR_CODE_01                                                   0x01// function code is not supported
  17          #define ERROR_CODE_02                                                   0x02// Register address is not allowed or write-protected
  18          #define ERROR_CODE_03                                                   0x03//Some data values are out of range, invalid number of r
             -egister
  19          /*****************************************************************************/
  20          typedef enum{
  21              RXTX_IDLE,
  22              RXTX_START,
  23              RXTX_DATABUF,
  24              RXTX_WAIT_ANSWER,
  25              RXTX_TIMEOUT
  26          }MODBUS_RXTX_STATE;
  27          typedef struct{
  28            uint8_t address;
  29            uint8_t function;
  30            uint8_t dataBuf[CONFIG_MODBUS_SLAVE_BUFFER_SIZE];
  31            uint16_t dataLen;
  32          }modbusRxTxData_t;
  33          /**********************Slave Transmit and Receive Variables********************/
  34          data uint8_t ModbusSlaveAddress = 1;
  35          xdata modbusRxTxData_t Tx_Data;
  36          data uint32_t Tx_Current = 0;
  37          data uint32_t Tx_CRC16 = 0xFFFF;
  38          data MODBUS_RXTX_STATE Tx_State = RXTX_IDLE;
  39          xdata uint8_t Tx_Buf[CONFIG_MODBUS_SLAVE_BUFFER_SIZE];
  40          data uint32_t Tx_Buf_Size = 0;
  41          /*****************************************************************************/
  42          xdata modbusRxTxData_t Rx_Data;
  43          data uint32_t Rx_CRC16 = 0xFFFF;
  44          data MODBUS_RXTX_STATE Rx_State = RXTX_IDLE;
  45          data uint8_t Rx_Data_Available = FALSE;
  46          /*****************************************************************************/
  47          xdata volatile uint16_t modbusTimerValue = 0;
  48          xdata volatile uint8_t modbusReceiveCounter = 0;// Collected data number
  49          xdata volatile uint8_t modbusReceiveBuffer[CONFIG_MODBUS_SLAVE_BUFFER_SIZE];// Buffer to collect data from
             - hardware
  50          /*****************************************************************************/
  51          void modbusCrc16(const uint8_t Data, uint32_t* CRC){
C51 COMPILER V9.59.0.0   MODBUS                                                            12/22/2018 00:24:03 PAGE 2   

  52   1          data uint32_t i;
  53   1          *CRC = *CRC ^(uint32_t) Data;
  54   1          for (i = 8; i > 0; i--){
  55   2              if (*CRC & 0x0001)
  56   2                  *CRC = (*CRC >> 1) ^ 0xA001;
  57   2              else
  58   2                  *CRC >>= 1;
  59   2          }
  60   1      }
  61          uint8_t DoSlaveTX(void){//It is used for send data package over physical layer
  62   1          modBusUartString(Tx_Buf, Tx_Buf_Size);
  63   1          Tx_Buf_Size = 0;
  64   1          return TRUE;
  65   1      }
  66          uint8_t SendMessage(void){//This function start to sending messages
  67   1          if (Tx_State != RXTX_IDLE){
  68   2              return FALSE;
  69   2              }
  70   1          Tx_Current  =0;
  71   1          Tx_State    =RXTX_START;
  72   1          return TRUE;
  73   1      }
  74          void HandleModbusError(char ErrorCode){// Initialise the output buffer. The first byte in the buffer says 
             -how many registers we have read
  75   1          Tx_Data.function = ErrorCode | 0x80;
  76   1          Tx_Data.address = ModbusSlaveAddress;
  77   1          Tx_Data.dataLen = 0;
  78   1          SendMessage();
  79   1      }
  80          void HandleModbusReadHoldingRegisters(void){//Modbus function 03 - Read holding registers
  81   1          data uint16_t startAddress, numberOfRegisters, i, currentData;
  82   1              // The message contains the requested start address and number of registers
  83   1          startAddress = ((uint16_t) (Rx_Data.dataBuf[0]) << 8) + (uint16_t) (Rx_Data.dataBuf[1]);
  84   1          numberOfRegisters = ((uint16_t) (Rx_Data.dataBuf[2]) << 8) + (uint16_t) (Rx_Data.dataBuf[3]);
  85   1              if((startAddress + numberOfRegisters) > CONFIG_NVRAM_SIZE){//If it is bigger than RegisterNumber return e
             -rror to Modbus Master
  86   2              HandleModbusError(ERROR_CODE_02);
  87   2              }
  88   1          else{//Initialise the output buffer. The first byte in the buffer says how many registers we have read
  89   2              Tx_Data.function = MODBUS_READ_HOLDING_REGISTERS;
  90   2              Tx_Data.address = ModbusSlaveAddress;
  91   2              Tx_Data.dataLen = 1;
  92   2              Tx_Data.dataBuf[0] = 0;
  93   2              for (i = 0;i < numberOfRegisters;i ++){
  94   3                  currentData = (uint16_t)NVRAM0[startAddress + i];
  95   3                  Tx_Data.dataBuf[Tx_Data.dataLen] = (uint8_t)((currentData & 0xFF00) >> 8);
  96   3                  Tx_Data.dataBuf[Tx_Data.dataLen + 1] = (uint8_t)(currentData & 0x00FF);
  97   3                  Tx_Data.dataLen += 2;
  98   3                  Tx_Data.dataBuf[0] = Tx_Data.dataLen - 1;
  99   3              }
 100   2              SendMessage();
 101   2          }
 102   1      }
 103          void HandleModbusWriteSingleRegister(void){//Modbus function 06 - Write single register
 104   1          data uint16_t address, value,i;
 105   1          // The message contains the requested start address and number of registers
 106   1          address = ((uint16_t) (Rx_Data.dataBuf[0]) << 8) + (uint16_t)(Rx_Data.dataBuf[1]);
 107   1          value = ((uint16_t) (Rx_Data.dataBuf[2]) << 8) + (uint16_t)(Rx_Data.dataBuf[3]);
 108   1          // Initialise the output buffer. The first byte in the buffer says how many registers we have read
 109   1          Tx_Data.function = MODBUS_WRITE_SINGLE_REGISTER;
 110   1          Tx_Data.address = ModbusSlaveAddress;
 111   1          Tx_Data.dataLen = 4;
C51 COMPILER V9.59.0.0   MODBUS                                                            12/22/2018 00:24:03 PAGE 3   

 112   1          if(address >= CONFIG_NVRAM_SIZE){
 113   2              HandleModbusError(ERROR_CODE_03);
 114   2              }
 115   1          else{
 116   2                      NVRAM0[address] = (int16_t)value;
 117   2              // Output data buffer is exact copy of input buffer
 118   2              for (i = 0; i < 4; ++i){
 119   3                  Tx_Data.dataBuf[i] = Rx_Data.dataBuf[i];
 120   3                      }
 121   2          }
 122   1          SendMessage();
 123   1      }
 124          void HandleModbusWriteMultipleRegisters(void){//Modbus function 16 - Write multiple registers
 125   1          // Write single numerical output
 126   1          data uint16_t startAddress, numberOfRegisters, value;
 127   1          data uint8_t byteCount , i;
 128   1          // The message contains the requested start address and number of registers
 129   1          startAddress = ((uint16_t)(Rx_Data.dataBuf[0]) << 8) + (uint16_t)(Rx_Data.dataBuf[1]);
 130   1          numberOfRegisters = ((uint16_t)(Rx_Data.dataBuf[2]) << 8) + (uint16_t)(Rx_Data.dataBuf[3]);
 131   1          byteCount = Rx_Data.dataBuf[4];
 132   1          // If it is bigger than RegisterNumber return error to Modbus Master
 133   1          if((startAddress+numberOfRegisters) > CONFIG_NVRAM_SIZE){
 134   2              HandleModbusError(ERROR_CODE_03);
 135   2              }
 136   1          else{
 137   2              // Initialise the output buffer. The first byte in the buffer says how many outputs we have set
 138   2              Tx_Data.function = MODBUS_WRITE_MULTIPLE_REGISTERS;
 139   2              Tx_Data.address = ModbusSlaveAddress;
 140   2              Tx_Data.dataLen = 4;
 141   2              Tx_Data.dataBuf[0] = Rx_Data.dataBuf[0];
 142   2              Tx_Data.dataBuf[1] = Rx_Data.dataBuf[1];
 143   2              Tx_Data.dataBuf[2] = Rx_Data.dataBuf[2];
 144   2              Tx_Data.dataBuf[3] = Rx_Data.dataBuf[3];
 145   2              // Output data buffer is exact copy of input buffer
 146   2              for (i = 0;i < numberOfRegisters;i ++){
 147   3                  value = (uint16_t)((Rx_Data.dataBuf[5 + 2 * i] << 8) & 0xFF00) + (uint16_t)((Rx_Data.dataBuf[6
             - + 2 * i]) & 0x00FF);
 148   3                  NVRAM0[startAddress + i] = (int16_t)value;
 149   3              }
 150   2              SendMessage();
 151   2          }
 152   1      }
 153          uint8_t RxDataAvailable(void){//RxDataAvailable
 154   1          uint8_t Result = Rx_Data_Available;   
 155   1          Rx_Data_Available = FALSE;
 156   1          return Result;
 157   1      }
 158          uint8_t CheckRxTimeout(void){//CheckRxTimeout
 159   1          // A return value of true indicates there is a timeout    
 160   1          if (modbusTimerValue >= CONFIG_MODBUS_SLAVE_TIMEOUT){
 161   2              modbusTimerValue   =0;
 162   2              modbusReceiveCounter     =0;
 163   2              return true;
 164   2          }
 165   1          return false;
 166   1      }
 167          uint8_t checkModbusBufferComplete(void){//CheckBufferComplete
 168   1          data int32_t expectedReceiveCount=0;
 169   1          if(modbusReceiveCounter>4)
 170   1          {
 171   2              if(modbusReceiveBuffer[0]==ModbusSlaveAddress)
 172   2              {
C51 COMPILER V9.59.0.0   MODBUS                                                            12/22/2018 00:24:03 PAGE 4   

 173   3                  if(modbusReceiveBuffer[1]==0x01 || modbusReceiveBuffer[1]==0x02 || modbusReceiveBuffer[1]==0x0
             -3 || modbusReceiveBuffer[1]==0x04 || modbusReceiveBuffer[1]==0x05 || modbusReceiveBuffer[1]==0x06)  // RHR
 174   3                  {
 175   4                      expectedReceiveCount    =8;
 176   4                  }
 177   3                  else if(modbusReceiveBuffer[1]==0x0F || modbusReceiveBuffer[1]==0x10)
 178   3                  {
 179   4                      expectedReceiveCount=modbusReceiveBuffer[6]+9;
 180   4                  }
 181   3                  else
 182   3                  {
 183   4                      modbusReceiveCounter=0;
 184   4                      return FALSE_FUNCTION;
 185   4                  }
 186   3              }
 187   2              else
 188   2              {
 189   3                  modbusReceiveCounter=0;
 190   3                  return FALSE_SLAVE_ADDRESS;
 191   3              }
 192   2          }
 193   1          else
 194   1              return DATA_NOT_READY;
 195   1      
 196   1          if(modbusReceiveCounter==expectedReceiveCount)
 197   1          {
 198   2              return DATA_READY;
 199   2          }
 200   1      
 201   1          return DATA_NOT_READY;
 202   1      }
 203          void RxRTU(void){//Check for data ready, if it is good return answer
 204   1          uint8_t i;
 205   1          uint8_t receiveBufferControl=0;
 206   1          receiveBufferControl = checkModbusBufferComplete();
 207   1          if(receiveBufferControl == DATA_READY){
 208   2              Rx_Data.address               =modbusReceiveBuffer[0];
 209   2              Rx_CRC16                      = 0xffff;
 210   2              modbusCrc16(Rx_Data.address, &Rx_CRC16);
 211   2              Rx_Data.function              =modbusReceiveBuffer[1];
 212   2              modbusCrc16(Rx_Data.function, &Rx_CRC16);
 213   2      
 214   2              Rx_Data.dataLen=0;
 215   2      
 216   2              for(i=2;i<modbusReceiveCounter;i++)
 217   2                  Rx_Data.dataBuf[Rx_Data.dataLen++]=modbusReceiveBuffer[i];
 218   2      
 219   2              Rx_State =RXTX_DATABUF;
 220   2      
 221   2              modbusReceiveCounter=0;
 222   2          }
 223   1      
 224   1          CheckRxTimeout();
 225   1      
 226   1          if ((Rx_State == RXTX_DATABUF) && (Rx_Data.dataLen >= 2))
 227   1          {
 228   2              // Finish off our CRC check
 229   2              Rx_Data.dataLen -= 2;
 230   2              for (i = 0; i < Rx_Data.dataLen; ++i)
 231   2              {
 232   3                  modbusCrc16(Rx_Data.dataBuf[i], &Rx_CRC16);
 233   3              }
C51 COMPILER V9.59.0.0   MODBUS                                                            12/22/2018 00:24:03 PAGE 5   

 234   2              
 235   2              if (((uint32_t) Rx_Data.dataBuf[Rx_Data.dataLen] + ((uint32_t) Rx_Data.dataBuf[Rx_Data.dataLen + 1
             -] << 8)) == Rx_CRC16)
 236   2              {
 237   3                  // Valid message!
 238   3                  Rx_Data_Available = TRUE;
 239   3              }
 240   2      
 241   2              Rx_State = RXTX_IDLE;
 242   2          }
 243   1      }
 244          void TxRTU(void){//If it is ready send answers!
 245   1          Tx_CRC16 = 0xFFFF;
 246   1          Tx_Buf_Size = 0;
 247   1          Tx_Buf[Tx_Buf_Size++] = Tx_Data.address;
 248   1          modbusCrc16(Tx_Data.address, &Tx_CRC16);
 249   1          Tx_Buf[Tx_Buf_Size++] = Tx_Data.function;
 250   1          modbusCrc16(Tx_Data.function, &Tx_CRC16);
 251   1          for(Tx_Current=0; Tx_Current < Tx_Data.dataLen; Tx_Current++){
 252   2              Tx_Buf[Tx_Buf_Size++] = Tx_Data.dataBuf[Tx_Current];
 253   2              modbusCrc16(Tx_Data.dataBuf[Tx_Current], &Tx_CRC16);
 254   2          }
 255   1          Tx_Buf[Tx_Buf_Size++] = Tx_CRC16 & 0x00FF;
 256   1          Tx_Buf[Tx_Buf_Size++] = (Tx_CRC16 & 0xFF00) >> 8;
 257   1          DoSlaveTX();
 258   1          Tx_State = RXTX_IDLE;
 259   1      }
 260          void ProcessModbus(void){//ModBus main core! Call this function into main!
 261   1          if (Tx_State != RXTX_IDLE){                                      // If answer is ready, send it!
 262   2              TxRTU();
 263   2              }
 264   1          RxRTU();                                                              // Call this function every cycl
             -e
 265   1          if (RxDataAvailable()){
 266   2              if (Rx_Data.address == ModbusSlaveAddress){
 267   3                  switch (Rx_Data.function)                                     // Data is for us but which func
             -tion?
 268   3                  {
 269   4                      case MODBUS_READ_HOLDING_REGISTERS:{
 270   5                                              HandleModbusReadHoldingRegisters();
 271   5                                              break;  
 272   5                                      }
 273   4                      case MODBUS_WRITE_SINGLE_REGISTER:{
 274   5                                              HandleModbusWriteSingleRegister();
 275   5                                              break;
 276   5                                      }
 277   4                      case MODBUS_WRITE_MULTIPLE_REGISTERS:{
 278   5                                              HandleModbusWriteMultipleRegisters();
 279   5                                              break;
 280   5                                      }
 281   4                      default:{
 282   5                                              HandleModbusError(ERROR_CODE_01);
 283   5                                              break;
 284   5                                      }
 285   4                  }
 286   3              }
 287   2          }
 288   1      }
 289          void InitModbus(uint8_t modbusSlaveAddress, uint32_t baudrate){//ModBus slave initialize
 290   1          ModbusSlaveAddress = modbusSlaveAddress;
 291   1          modBusUartInitialise(baudrate);
 292   1          modBusTimerInitialise();
C51 COMPILER V9.59.0.0   MODBUS                                                            12/22/2018 00:24:03 PAGE 6   

 293   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1572    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   1163    ----
   PDATA SIZE       =   ----       9
   DATA SIZE        =     20      30
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
