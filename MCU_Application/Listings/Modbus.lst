C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MODBUS
OBJECT MODULE PLACED IN .\Objects\Modbus.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Modbus\Modbus.c OPTIMIZE(9,SPEED) REGFILE(.\Objects\dwLaser_F020.ORC) BR
                    -OWSE ORDER INCDIR(.\Lib;.\Driver;.\MainApp;.\Modbus) DEFINE(C8051F020) DEBUG OBJECTEXTEND CODE LISTINCLUDE SYMBOLS PRINT
                    -(.\Listings\Modbus.lst) PREPRINT(.\Listings\Modbus.i) OBJECT(.\Objects\Modbus.obj)

line level    source

   1          #include "modbus.h"
   1      =1  #ifndef __MODBUS__H__
   2      =1  #define __MODBUS__H__
   3      =1  /*****************************************************************************/
   4      =1  #include "appConfig.h"
   1      =2  #ifndef __APPCONFIG_H__
   2      =2  #define __APPCONFIG_H__
   3      =2  /*****************************************************************************/
   4      =2  #define CONFIG_SYSCLK                       (22118400L)
   5      =2  #ifdef C8051F020
   6      =2  #define SAR_CLK                                                 2000000L//ADC0时钟 <2.5MHz
   7      =2  #endif
   8      =2  #define CONFIG_DEBUG                        0//调试功能
   9      =2  #define CONFIG_USING_WDT                                        0//使能看门狗
  10      =2  #define CONFIG_USING_RESET                                      0//使能PLC复位MCU功能
  11      =2  #define CONFIG_LADDER_SECTORS_START                     64//指令起始地址
  12      =2  #define CONFIG_LADDER_SECTORS_END                       128//指令结束地址
  13      =2  #define CONFIG_LASERTIMER_OVERFLOW_US           1000L//定时器周期 1mS
  14      =2  #define CONFIG_VERSION                                          0x0001
  15      =2  #define CONFIG_CHECK_CODE                                       0x5A00
  16      =2  
  17      =2  /*****************************************************************************/
  18      =2  #define CONFIG_UART0_BAUDRATE                           57600//串口波特率
  19      =2  #define CONFIG_UART0_PARITY                                     NONE
  20      =2  #define CONFIG_UART0_STOPBIT                            1
  21      =2  #define CONFIG_UART0_DATABIT                            8
  22      =2  
  23      =2  #define CONFIG_UART1_BAUDRATE                           115200//串口波特率
  24      =2  #define CONFIG_UART1_PARITY                                     NONE
  25      =2  #define CONFIG_UART1_STOPBIT                            1
  26      =2  #define CONFIG_UART1_DATABIT                            8
  27      =2  /*****************************************************************************/
  28      =2  #define CONFIG_I2C0_FREQ                                        (100000L)               
  29      =2  #define CONFIG_I2C1_FREQ                                        (100000L)
  30      =2  #define CONFIG_I2C2_FREQ                                        (100000L)
  31      =2  #define CONFIG_I2C3_FREQ                                        (100000L)
  32      =2  #define CONFIG_I2C4_FREQ                                        (100000L)
  33      =2  /*****************************************************************************/
  34      =2  #define CONFIG_EPROM_SIZE                                       CONFIG_AT24C64_SIZE
  35      =2  #define CONFIG_AT24C02_SIZE                             256
  36      =2  #define CONFIG_AT24C04_SIZE                             512
  37      =2  #define CONFIG_AT24C08_SIZE                             1024
  38      =2  #define CONFIG_AT24C16_SIZE                             2048
  39      =2  #define CONFIG_AT24C32_SIZE                             4096
  40      =2  #define CONFIG_AT24C64_SIZE                                     8192
  41      =2  #define CONFIG_AT24C128_SIZE                            16384
  42      =2  #define CONFIG_AT24C256_SIZE                            32768
  43      =2  #define CONFIG_EPROM_ADDRESS                            0x50
  44      =2  #define CONFIG_EPROM_FRAM                                       0//铁电存储体无写入等待
  45      =2  #define CONFIG_EPROM_FREQ                                       1//
  46      =2  /*****************************************************************************/
  47      =2  #define CONFIG_USE_IPID                                         1//使能IPID温度控制
  48      =2  /*****************************************************************************/
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 2   

  49      =2  #define CONFIG_USE_HWVER_SHOW                           1//使能固件版本显示
  50      =2  #define CONFIG_USE_MPD1_SHOW                            1//使能MPD1测量显示
  51      =2  #define CONFIG_USE_MPD2_SHOW                            1//使能MPD2测量显示
  52      =2  #define CONFIG_USE_FBS1                                         1//使能FBS1检测
  53      =2  #define CONFIG_USE_FBS2                                         1//使能FBS2检测
  54      =2  #define CONFIG_USE_LASER_TEMP                           1//使能激光器温度显示
  55      =2  #define CONFIG_USE_RADIATOR_TEMP                        1//使能散热器温度显示
  56      =2  #define CONFIG_USE_ENVI_TEMP                            1//使能环境温度显示
  57      =2  #define CONFIG_USE_IPID_UPDATE                          1//使能IPID参数更新功能
  58      =2  #define CONFIG_USE_IPID_OUTSHOW                         1//使能IPID输出显示
  59      =2  /*****************************************************************************/
  60      =2  //SPLC设置
  61      =2  #define CONFIG_SPLC_IO_INPUT_NUM                        16//硬件输入点数
  62      =2  #define CONFIG_SPLC_IO_OUTPUT_NUM                       16//硬件输出点数
  63      =2  #define CONFIG_SOFTPLC_HWTIME                           1000L//1mS
  64      =2  #define CONFIG_INPUT_FILTER_TIME                        3//输入数字滤波扫描周期 1mS * N
  65      =2  #define CONFIG_IPID_RUN_CYCLE                           40//IPID运行周期 默认 40 * 100mS
  66      =2  #define CONFIG_IPID_PWM_CYCLE                           20//IPID输出周期 默认 20 * 100mS
  67      =2  /*****************************************************************************/
  68      =2  #define CONFIG_SPLC_USING_WDT                           0//看门狗启用
  69      =2  /*****************************************************************************/
  70      =2  #define CONFIG_SPLC_USING_IO_INPUT                      1//输入IO刷新启用
  71      =2  /*****************************************************************************/
  72      =2  #define CONFIG_SPLC_USING_IO_OUTPUT                     1//输出IO刷新启用
  73      =2  /*****************************************************************************/
  74      =2  #define CONFIG_SPLC_USING_EPROM                         1//EPROM掉电存储启用
  75      =2  /*****************************************************************************/
  76      =2  #define CONFIG_SPLC_USING_ADC                           1//使能ADC模块
  77      =2  #define CONFIG_SPLC_ADC_FILTER_TAP                      18//ADC位移滤波次数
  78      =2  #define CONFIG_SPLC_ADC_CHANNLE                         50//ADC通道数
  79      =2  #define CONFIG_SPLC_ADC_TEMP_SENSOR_GAIN    3330L// Temp Sensor Gain in (uV / degC)
  80      =2  #define CONFIG_SPLC_ADC_TEMP_SENSOR_OFFSET  856L// Temp Sensor Offset in mV
  81      =2  #define CONFIG_SPLC_ADC_INTERNAL_VREF           2200L// ADC Voltage Reference (mV)
  82      =2  #define CONFIG_SPLC_ADC_AMBIENT             25L// Ambient temp in deg C
  83      =2  /*****************************************************************************/
  84      =2  #define CONFIG_SPLC_USING_DAC                           1//是能DAC模块
  85      =2  /*****************************************************************************/
  86      =2  #define CONFIG_SPLC_USING_MB_RTU_SLAVE          1//是能MODBUS RTU从站
  87      =2  #define CONFIG_MB_RTU_SLAVE_TIMER                       1000L//1000uS
  88      =2  #define CONFIG_MB_RTU_SLAVE_ADDRESS                     0x01//从设备地址
  89      =2  #define CONFIG_MB_RTU_SLAVE_BUFFER_SIZE         256//发送接收缓冲区
  90      =2  #define CONFIG_MB_RTU_SLAVE_TIMEOUT                     100//接收通讯超时 10mS
  91      =2  #define CONFIG_MB_RTU_SLAVE_IO_DELAY            1//RX TX切换延时
  92      =2  /*****************************************************************************/
  93      =2  
  94      =2  /*****************************************************************************/
  95      =2  #define ID_ONLY_1_CHANNEL                                       4321
  96      =2  #define ID_ONLY_2_CHANNEL                                       8765
  97      =2  #define ID_BOTH_CHANNEL                                         9431
  98      =2  #define ID_LASER_MODE_CW                                        7631
  99      =2  #define ID_LASER_MODE_SP                                        8934
 100      =2  #define ID_LASER_MODE_MP                                        2453
 101      =2  #define ID_LASER_MODE_GP                                        3876
 102      =2  /*****************************************************************************/
 103      =2  #define FBS1_IN_PORT                                            3
 104      =2  #define FBS2_IN_PORT                                            2
 105      =2  #define COOLON_OUT_PORT                                         (1 * 8 + 3)
 106      =2  /*****************************************************************************/
 107      =2  //PID FUZZY 模糊PID配置
 108      =2  #define CONFIG_TECOUT_CYCLE                                     4000//PID输出转PWM周期
 109      =2  /*****************************************************************************/
 110      =2  /*****************************************************************************/
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 3   

 111      =2  #define DISABLE_MODBUS_SERIAL_INTERRUPT         ES0 = 0;
 112      =2  #define ENABLE_MODBUS_SERIAL_INTERRUPT          ES0 = 1;
 113      =2  #define DISABLE_INTERRUPT                                       EA = 0;
 114      =2  #define ENABLE_INTERRUPT                                        EA = 1;
 115      =2  /*****************************************************************************/
 116      =2  #include "stdint.h"
   1      =3  /**************************************************************************//**
   2      =3   * Copyright (c) 2015 by Silicon Laboratories Inc. All rights reserved.
   3      =3   *
   4      =3   * http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   5      =3   *****************************************************************************/
   6      =3  
   7      =3  #ifndef STDINT_H
   8      =3  #define STDINT_H
   9      =3  
  10      =3  #if defined __C51__
  11      =3  
  12      =3  typedef unsigned char uint8_t;
  13      =3  typedef unsigned short uint16_t;
  14      =3  typedef unsigned long uint32_t;
  15      =3  typedef uint32_t uint64_t[2];
  16      =3  
  17      =3  typedef signed char int8_t;
  18      =3  typedef short int16_t;
  19      =3  typedef long int32_t;
  20      =3  typedef int32_t int64_t[2];
  21      =3  typedef float fp32_t;
  22      =3  typedef double fp64_t;
  23      =3  
  24      =3  #elif defined __ICC8051__
           =3 
           =3 /* Fixed size types. These are all optional. */
           =3 #ifdef __INT8_T_TYPE__
           =3   typedef __INT8_T_TYPE__   int8_t;
           =3   typedef __UINT8_T_TYPE__ uint8_t;
           =3 #endif /* __INT8_T_TYPE__ */
           =3 
           =3 #ifdef __INT16_T_TYPE__
           =3   typedef __INT16_T_TYPE__   int16_t;
           =3   typedef __UINT16_T_TYPE__ uint16_t;
           =3 #endif /* __INT16_T_TYPE__ */
           =3 
           =3 #ifdef __INT32_T_TYPE__
           =3   typedef __INT32_T_TYPE__   int32_t;
           =3   typedef __UINT32_T_TYPE__ uint32_t;
           =3 #endif /* __INT32_T_TYPE__ */
           =3 
           =3 #ifdef __INT64_T_TYPE__
           =3   #pragma language=save
           =3   #pragma language=extended
           =3   typedef __INT64_T_TYPE__   int64_t;
           =3   typedef __UINT64_T_TYPE__ uint64_t;
           =3   #pragma language=restore
           =3 #endif /* __INT64_T_TYPE__ */
           =3 
           =3 #endif
  51      =3  
  52      =3  #endif
 117      =2  #include "stdbool.h"
   1      =3  /**************************************************************************//**
   2      =3   * Copyright (c) 2015 by Silicon Laboratories Inc. All rights reserved.
   3      =3   *
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 4   

   4      =3   * http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   5      =3   *****************************************************************************/
   6      =3  
   7      =3  #ifndef STDBOOL_H
   8      =3  #define STDBOOL_H
   9      =3  
  10      =3  #if defined __C51__
  11      =3  
  12      =3  typedef bit bool;
  13      =3  enum{
  14      =3    false = 0,
  15      =3    true = 1,
  16      =3  };
  17      =3  
  18      =3  #elif defined __ICC8051__
           =3 
           =3 #ifndef _SYSTEM_BUILD
           =3   #pragma system_include
           =3 #endif
           =3 
           =3 #ifndef __cplusplus
           =3 
           =3 #define bool _Bool
           =3 #define true 1
           =3 #define false 0
           =3 
           =3 #define __bool_true_false_are_defined 1
           =3 
           =3 #endif /* !__cplusplus */
           =3 
           =3 #else  // __SLS_IDE__ : Macros defined to remove syntax errors within Simplicity Studio
           =3 
           =3 typedef bit bool;
           =3 enum{
           =3   false = 0,
           =3   true = 1,
           =3 };
           =3 
           =3 #endif
  43      =3  
  44      =3  #endif //STDBOOL_H
  45      =3  
 118      =2  #include "endian.h"
   1      =3  /**************************************************************************//**
   2      =3   * Copyright (c) 2015 by Silicon Laboratories Inc. All rights reserved.
   3      =3   *
   4      =3   * http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   5      =3   *****************************************************************************/
   6      =3  
   7      =3  #ifndef __ENDIAN_H__
   8      =3  #define __ENDIAN_H__
   9      =3  
  10      =3  #define bswapu16(x) (((x) >> 8) | ((x) << 8))
  11      =3  #define bswapu32(x) (((x) >> 24) | (((x) & 0x00FF0000) >> 8) \
  12      =3                    | (((x) & 0x0000FF00) << 8) | ((x) << 24))
  13      =3  
  14      =3  #define bswap16(x) bswapu16((uint16_t)(x))
  15      =3  #define bswap32(x) bswapu32((uint32_t)(x))
  16      =3  
  17      =3  // Big Endian Compilers
  18      =3  #if ((defined __C51__) || (defined __RC51__) || (defined _CC51))
  19      =3  
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 5   

  20      =3  #define htobe16(x) (x)
  21      =3  #define htobe32(x) (x)
  22      =3  #define be16toh(x) (x)
  23      =3  #define be32toh(x) (x)
  24      =3  
  25      =3  #define htole16(x) bswap16(x)
  26      =3  #define htole32(x) bswap32(x)
  27      =3  #define le16toh(x) bswap16(x)
  28      =3  #define le32toh(x) bswap32(x)
  29      =3  
  30      =3  #elif ((defined SDCC) || (defined HI_TECH_C) || (defined __ICC8051__))
           =3 
           =3 #define htobe16(x) bswap16(x)
           =3 #define htobe32(x) bswap32(x)
           =3 #define be16toh(x) bswap16(x)
           =3 #define be32toh(x) bswap32(x)
           =3 
           =3 #define htole16(x) (x)
           =3 #define htole32(x) (x)
           =3 #define le16toh(x) (x)
           =3 #define le32toh(x) (x)
           =3 
           =3 #else
           =3 
           =3 #define htobe16(x) (x)
           =3 #define htobe32(x) (x)
           =3 #define be16toh(x) (x)
           =3 #define be32toh(x) (x)
           =3 
           =3 #define htole16(x) (x)
           =3 #define htole32(x) (x)
           =3 #define le16toh(x) (x)
           =3 #define le32toh(x) (x)
           =3 
           =3 #endif  // Compiler Definitions
  55      =3  
  56      =3  #endif  // __ENDIAN_H__
 119      =2  #include "si_toolchain.h"
   1      =3  /******************************************************************************
   2      =3   * Copyright (c) 2015 by Silicon Laboratories Inc. All rights reserved.
   3      =3   *
   4      =3   * http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   5      =3   *****************************************************************************/
   6      =3  
   7      =3  #ifndef __SI_TOOLCHAIN_H__
   8      =3  #define __SI_TOOLCHAIN_H__
   9      =3  
  10      =3  #include <stdint.h>
   1      =4  /**************************************************************************//**
   2      =4   * Copyright (c) 2015 by Silicon Laboratories Inc. All rights reserved.
   3      =4   *
   4      =4   * http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   5      =4   *****************************************************************************/
   6      =4  
   7      =4  #ifndef STDINT_H
           =4 #define STDINT_H
           =4 
           =4 #if defined __C51__
           =4 
           =4 typedef unsigned char uint8_t;
           =4 typedef unsigned short uint16_t;
           =4 typedef unsigned long uint32_t;
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 6   

           =4 typedef uint32_t uint64_t[2];
           =4 
           =4 typedef signed char int8_t;
           =4 typedef short int16_t;
           =4 typedef long int32_t;
           =4 typedef int32_t int64_t[2];
           =4 typedef float fp32_t;
           =4 typedef double fp64_t;
           =4 
           =4 #elif defined __ICC8051__
           =4 
           =4 /* Fixed size types. These are all optional. */
           =4 #ifdef __INT8_T_TYPE__
           =4   typedef __INT8_T_TYPE__   int8_t;
           =4   typedef __UINT8_T_TYPE__ uint8_t;
           =4 #endif /* __INT8_T_TYPE__ */
           =4 
           =4 #ifdef __INT16_T_TYPE__
           =4   typedef __INT16_T_TYPE__   int16_t;
           =4   typedef __UINT16_T_TYPE__ uint16_t;
           =4 #endif /* __INT16_T_TYPE__ */
           =4 
           =4 #ifdef __INT32_T_TYPE__
           =4   typedef __INT32_T_TYPE__   int32_t;
           =4   typedef __UINT32_T_TYPE__ uint32_t;
           =4 #endif /* __INT32_T_TYPE__ */
           =4 
           =4 #ifdef __INT64_T_TYPE__
           =4   #pragma language=save
           =4   #pragma language=extended
           =4   typedef __INT64_T_TYPE__   int64_t;
           =4   typedef __UINT64_T_TYPE__ uint64_t;
           =4   #pragma language=restore
           =4 #endif /* __INT64_T_TYPE__ */
           =4 
           =4 #endif
           =4 
           =4 #endif
  11      =3  #include <stdbool.h>
   1      =4  /**************************************************************************//**
   2      =4   * Copyright (c) 2015 by Silicon Laboratories Inc. All rights reserved.
   3      =4   *
   4      =4   * http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   5      =4   *****************************************************************************/
   6      =4  
   7      =4  #ifndef STDBOOL_H
           =4 #define STDBOOL_H
           =4 
           =4 #if defined __C51__
           =4 
           =4 typedef bit bool;
           =4 enum{
           =4   false = 0,
           =4   true = 1,
           =4 };
           =4 
           =4 #elif defined __ICC8051__
           =4 
           =4 #ifndef _SYSTEM_BUILD
           =4   #pragma system_include
           =4 #endif
           =4 
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 7   

           =4 #ifndef __cplusplus
           =4 
           =4 #define bool _Bool
           =4 #define true 1
           =4 #define false 0
           =4 
           =4 #define __bool_true_false_are_defined 1
           =4 
           =4 #endif /* !__cplusplus */
           =4 
           =4 #else  // __SLS_IDE__ : Macros defined to remove syntax errors within Simplicity Studio
           =4 
           =4 typedef bit bool;
           =4 enum{
           =4   false = 0,
           =4   true = 1,
           =4 };
           =4 
           =4 #endif
           =4 
           =4 #endif //STDBOOL_H
  45      =4  
  12      =3  
  13      =3  /**************************************************************************//**
  14      =3   *
  15      =3   * @addtogroup toolchain_group Toolchain Abstraction
  16      =3   *
  17      =3   * @brief Macros for toolchain abstraction.
  18      =3   *
  19      =3   * # Introduction #
  20      =3   *
  21      =3   * This header file contains macros that are used to provide an abstraction
  22      =3   * for toolchain use in source code.  The 8051 compiler requires C-language
  23      =3   * extensions in order to fully use features of the 8051 architecture.  All
  24      =3   * compilers for 8051 implement a set of extensions but use different names
  25      =3   * and ways of implementing those extensions.  This header file provides
  26      =3   * macros that are defined for each supported toolchain and can be used in
  27      =3   * the source code.  This allows the source code to use 8051 extensions and
  28      =3   * remain independent of which toolchain is used for compilation.
  29      =3   *
  30      =3   * ## Variable and Pointer Declarations ##
  31      =3   *
  32      =3   * It is often useful to specify the memory area (or segment) of a variable,
  33      =3   * pointer, or pointer target.  For example, you may wish to place all
  34      =3   * variables in XDATA by default, but for variables used in time-sensitive
  35      =3   * code you use DATA for efficient access.  In this case you declare the
  36      =3   * XDATA variable in the normal C way, but declare the variables to be located
  37      =3   * in the DATA segment using @ref SI_SEGMENT_VARIABLE.
  38      =3   *
  39      =3   * Pointers are more complicated because there are two memory spaces
  40      =3   * associated with a pointer, the pointer target, and the pointer variable
  41      =3   * itself.  When using default memory segment for the pointer location and
  42      =3   * target, then no special macro is needed.  But if you wish to specify the
  43      =3   * pointer variable location, or target memory segment, then you can use one
  44      =3   * of the following macros to do this in a toolchain-independent way.
  45      =3   *
  46      =3   * |Pointer segment|Target segment|Macro                                   |
  47      =3   * |---------------|--------------|----------------------------------------|
  48      =3   * |default        |generic       |None                                    |
  49      =3   * |default        |specific      |@ref SI_VARIABLE_SEGMENT_POINTER        |
  50      =3   * |specific       |generic       |@ref SI_SEGMENT_POINTER                 |
  51      =3   * |specific       |specific      |@ref SI_SEGMENT_VARIABLE_SEGMENT_POINTER|
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 8   

  52      =3   *
  53      =3   * ## Prior Toolchain Abstraction Header File ##
  54      =3   *
  55      =3   * This file supercedes an earlier header file named `compiler_defs.h`.  We
  56      =3   * are deprecating the use of compiler_defs.h, however it will remain for
  57      =3   * backwards compatibility.  This file was created to normalize macro names,
  58      =3   * remove unused macros, and to provide documentation.
  59      =3   *
  60      =3   * ## Supported Toolchains ##
  61      =3   *
  62      =3   * - Keil/ARM C51
  63      =3   *
  64      =3   * @{
  65      =3   *
  66      =3   *****************************************************************************/
  67      =3  
  68      =3  // Make sure there is a NULL defined if the toolchain does not provide it.
  69      =3  #ifndef NULL
  70      =3  #define NULL ((void *)0)
  71      =3  #endif
  72      =3  
  73      =3  // -------------------------------
  74      =3  // Keil/ARM C51
  75      =3  //
  76      =3  #if defined(__C51__)
  77      =3  
  78      =3  /// Used with pointers, declares a generic pointer.  Generic pointers
  79      =3  /// work with any memory space but are inefficient.
  80      =3  #define SI_SEG_GENERIC
  81      =3  
  82      =3  /// Declares a variable to be located in 8051 DATA space.
  83      =3  #define SI_SEG_DATA data
  84      =3  
  85      =3  /// Declares a variable to be located in 8051 IDATA space.
  86      =3  #define SI_SEG_IDATA idata
  87      =3  
  88      =3  /// Declares a variable to be located in 8051 XDATA space.
  89      =3  #define SI_SEG_XDATA xdata
  90      =3  
  91      =3  /// Declares a variable to be located in 8051 PDATA space.
  92      =3  #define SI_SEG_PDATA pdata
  93      =3  
  94      =3  /// Declares a variable to be located in 8051 BDATA (bit-addressable) space.
  95      =3  #define SI_SEG_BDATA bdata
  96      =3  
  97      =3  /// Declares a variable to be located in 8051 CODE space.
  98      =3  #define SI_SEG_CODE code
  99      =3  
 100      =3  /**************************************************************************//**
 101      =3   * Declares a bit variable in a bit-addressable memory space.
 102      =3   *
 103      =3   * @param name The name of the bit variable.
 104      =3   *****************************************************************************/
 105      =3  #define SI_BIT(name) bit name
 106      =3  
 107      =3  /**************************************************************************//**
 108      =3   * Declares a bit variable in a bit-addressable SFR or memory space.
 109      =3   *
 110      =3   * @param name The name of the bit variable.
 111      =3   * @param address The address of the byte containing the bit.
 112      =3   * @param bitnum The bit number (0-7) within the byte.
 113      =3   *
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 9   

 114      =3   * This cannot be used to make any arbitrary SFR or variable into
 115      =3   * a bit variable.  The underlying memory must support bit-addressability.
 116      =3   *****************************************************************************/
 117      =3  #define SI_SBIT(name, address, bitnum) sbit name = address^bitnum
 118      =3  
 119      =3  /**************************************************************************//**
 120      =3   * Declares an 8-bit special function register (SFR) variable.
 121      =3   *
 122      =3   * @param name The name of the SFR variable.
 123      =3   * @param address The address of the SFR.
 124      =3   *
 125      =3   * This creates a C variable (8-bit) that maps to a physical special function
 126      =3   * register of the 8051.  This cannot be used to make any arbitrary memory
 127      =3   * location into an SFR.  The _address_ must map to a real SFR in the memory
 128      =3   * map.
 129      =3   *****************************************************************************/
 130      =3  #define SI_SFR(name, address) sfr name = address
 131      =3  
 132      =3  /**************************************************************************//**
 133      =3   * Declares a 16-bit special function register (SFR) variable.
 134      =3   *
 135      =3   * @param name The name of the SFR variable.
 136      =3   * @param address The address of the 16-bit SFR.
 137      =3   *
 138      =3   * This creates a C variable (16-bit) that maps to a physical special function
 139      =3   * register of the 8051.  This cannot be used to make any arbitrary memory
 140      =3   * location into an SFR.  The _address_ must map to a real 16-bit SFR in the
 141      =3   * memory map.
 142      =3   *****************************************************************************/
 143      =3  #define SI_SFR16(name, address) sfr16 name = address
 144      =3  
 145      =3  #ifndef __SLS_IDE__
 146      =3  /**************************************************************************//**
 147      =3   * Define an interrupt handler function for an interrupt vector.
 148      =3   *
 149      =3   * @param name The name of the interrupt handler function.
 150      =3   * @param vector The interrupt vector number.
 151      =3   *
 152      =3   * This macro defines a function to be an interrupt handler.  The _vector_
 153      =3   * parameter is the 8051 interrupt vector number, not the address.  This
 154      =3   * will cause the compiler to treat the function as the interrupt handler
 155      =3   * and generate the appropriate prolog/epilog code.
 156      =3   *
 157      =3   * @note This macro is used to define the function implementation.  To declare
 158      =3   * the interrupt function prototype, use @ref SI_INTERRUPT_PROTO.
 159      =3   *****************************************************************************/
 160      =3  #define SI_INTERRUPT(name, vector) void name (void) interrupt vector
 161      =3  
 162      =3  /**************************************************************************//**
 163      =3   * Define an interrupt handler function using a specific register bank.
 164      =3   *
 165      =3   * @param name The name of the interrupt handler function.
 166      =3   * @param vector The interrupt vector number.
 167      =3   * @param regnum The register bank number (0-3).
 168      =3   *
 169      =3   * This macro defines a function to be an interrupt handler, using a specific
 170      =3   * register bank for the interrupt code.  The _vector_ parameter is the 8051
 171      =3   * interrupt vector number, not the address.  The _regnum_ parameter is the
 172      =3   * register bank number (0-3) that will be used as general purpose registers
 173      =3   * for the instructions in the compiled code.  Using dedicated register banks
 174      =3   * for interrupt handlers allows the prolog code to just switch banks instead
 175      =3   * of saving and restoring all the general purpose registers.  This can make
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 10  

 176      =3   * interrupt entry/exit faster but requires dedicating a register bank for
 177      =3   * the interrupt handler.
 178      =3   *
 179      =3   * @note This macro is used to define the function implementation.  To declare
 180      =3   * the interrupt function prototype, use @ref SI_INTERRUPT_PROTO_USING.
 181      =3   *****************************************************************************/
 182      =3  #define SI_INTERRUPT_USING(name, vector, regnum)                             \
 183      =3               void name (void) interrupt vector using regnum
 184      =3  
 185      =3  /**************************************************************************//**
 186      =3   * Declare an interrupt handler prototype for an interrupt vector.
 187      =3   *
 188      =3   * @param name The name of the interrupt handler function.
 189      =3   * @param vector The interrupt vector number.
 190      =3   *
 191      =3   * This macro declares a function prototype for an interrupt handler.  The
 192      =3   * _vector_ parameter is the 8051 interrupt vector number, not the address.
 193      =3   * Declaring the function prototype this way will cause the compiler to
 194      =3   * recognize that the function is an interrupt handler and not a normal C
 195      =3   * function.
 196      =3   *
 197      =3   * @note This macro is used to declare a prototype for the interrupt function.
 198      =3   * To define the interrupt function implementation, use @ref SI_INTERRUPT.
 199      =3   *****************************************************************************/
 200      =3  #define SI_INTERRUPT_PROTO(name, vector) void name (void)
 201      =3  
 202      =3  /**************************************************************************//**
 203      =3   * Declare an interrupt handler prototype using a specific register bank.
 204      =3   *
 205      =3   * @param name The name of the interrupt handler function.
 206      =3   * @param vector The interrupt vector number.
 207      =3   * @param regnum The register bank number (0-3).
 208      =3   *
 209      =3   * This macro declares a function prototype for an interrupt handler, for a
 210      =3   * function that uses a specific register bank for the interrupt code.  The
 211      =3   * _vector_ parameter is the 8051 interrupt vector number, not the address.
 212      =3   * The _regnum_ parameter is the register bank number (0-3) that will be used
 213      =3   * as general purpose registers in the function.  Declaring the function
 214      =3   * prototype this way will cause the compiler to recognize that the function
 215      =3   * is an interrupt handler and is not a normal C function.
 216      =3   *
 217      =3   * @note This macro is used to declare a prototype for the interrupt function.
 218      =3   * To define the interrupt function implementation,
 219      =3   * use @ref SI_INTERRUPT_USING.
 220      =3   *****************************************************************************/
 221      =3  #define SI_INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
 222      =3  
 223      =3  /**************************************************************************//**
 224      =3   * Define a function to be reentrant (store local variables on the stack).
 225      =3   *
 226      =3   * @param name The name of the function.
 227      =3   * @param return_type The data type of the function return value
 228      =3   * (void, int, etc).
 229      =3   * @param parameter One C function parameter (or "void") (type and name).
 230      =3   *
 231      =3   * This macro defines a function to be reentrant.
 232      =3   *
 233      =3   * You must specify the _return_type_ which is the type of the function.  It
 234      =3   * can be `void` or any other C type or typedef.  The _parameters_ argument
 235      =3   * is the list of function parameters.  It can be `void` or else it must be
 236      =3   * a parameter data type and name.  It can also be multiple parameters but
 237      =3   * they must be enclosed in parentheses and separated by commas.
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 11  

 238      =3   *
 239      =3   * __Example__
 240      =3   *
 241      =3   * ~~~~~~~~.c
 242      =3   * // The following is used to implement a function with the following
 243      =3   * // signature...
 244      =3   * uint16_t myFunction(uint8_t parm1, uint8_t parm2);
 245      =3   *
 246      =3   * SI_REENTRANT_FUNCTION(myFunction, uint16_t, (uint8_t parm1, uint8_t parm2))
 247      =3   * {
 248      =3   *   // Function implementation body
 249      =3   * }
 250      =3   * ~~~~~~~~
 251      =3   *
 252      =3   * @note This macro is used to define the function implementation.  To declare
 253      =3   * the function prototype, use @ref SI_REENTRANT_FUNCTION_PROTO.
 254      =3   *****************************************************************************/
 255      =3  #define SI_REENTRANT_FUNCTION(name, return_type, parameter) \
 256      =3    return_type name parameter reentrant
 257      =3  
 258      =3  /**************************************************************************//**
 259      =3   * Declare a function to be reentrant (store local variables on the stack).
 260      =3   *
 261      =3   * @param name The name of the function.
 262      =3   * @param return_type The data type of the function return value
 263      =3   * (void, int, etc).
 264      =3   * @param parameter One C function parameter (or "void") (type and name).
 265      =3   *
 266      =3   * This macro declares a function prototype for a C function that is reentrant.
 267      =3   * See the documentation for @ref SI_REENTRANT_FUNCTION for an explanation of
 268      =3   * the macro arguments.  This is an advanced feature.
 269      =3   *
 270      =3   * @note This macro is used to declare a prototype for the function.  To
 271      =3   * define the function implementation, use @ref SI_REENTRANT_FUNCTION.
 272      =3   *****************************************************************************/
 273      =3  #define SI_REENTRANT_FUNCTION_PROTO(name, return_type, parameter) \
 274      =3    return_type name parameter reentrant
 275      =3                 
 276      =3  /**************************************************************************//**
 277      =3   * Define a function to use a specific register bank.
 278      =3   *
 279      =3   * @param name The name of the function.
 280      =3   * @param return_value The data type of the function return value
 281      =3   * (void, int, etc).
 282      =3   * @param parameter One C function parameter (or "void") (type and name).
 283      =3   * @param regnum The register bank number (0-3).
 284      =3   *
 285      =3   * This macro defines a function that uses a specific register bank.  The
 286      =3   * _regnum_ parameter is the register bank number (0-3) that will be used as
 287      =3   * general purpose registers for the instructions in the compiled function
 288      =3   * code.  Using dedicated register banks for a function can reduce the amount
 289      =3   * of registers saving and restoring needed on entry and exit to the
 290      =3   * function.  However, this is an advanced feature and you should not use it
 291      =3   * unless you fully understand how and when to use register banking.
 292      =3   *
 293      =3   * You must specify the _return_value_ which is the type of the function.  It
 294      =3   * can be `void` or any other C type or typedef.  The _parameters_ argument
 295      =3   * is the list of function parameters.  It can be `void` or else it must be
 296      =3   * a parameter data type and name.  It can also be multiple parameters but
 297      =3   * they must be enclosed in parentheses and separated by commas.
 298      =3   *
 299      =3   * __Example__
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 12  

 300      =3   *
 301      =3   * ~~~~~~~~.c
 302      =3   * // The following is used to implement a function with the following
 303      =3   * // signature, and that uses register bank 3 ...
 304      =3   * uint16_t myFunction(uint8_t parm1, uint8_t parm2);
 305      =3   *
 306      =3   * SI_FUNCTION_USING(myFunction, uint16_t, (uint8_t parm1, uint8_t parm2), 3)
 307      =3   * {
 308      =3   *   // Function implementation body
 309      =3   * }
 310      =3   * ~~~~~~~~
 311      =3   *
 312      =3   * @note This macro is used to define the function implementation.  To declare
 313      =3   * the function prototype, use @ref SI_FUNCTION_PROTO_USING.
 314      =3   *****************************************************************************/
 315      =3  #define SI_FUNCTION_USING(name, return_value, parameter, regnum)              \
 316      =3               return_value name parameter using regnum
 317      =3  
 318      =3  /**************************************************************************//**
 319      =3   * Declare a function that uses a specific register bank.
 320      =3   *
 321      =3   * @param name The name of the function.
 322      =3   * @param return_value The data type of the function return value
 323      =3   * (void, int, etc).
 324      =3   * @param parameter One C function parameter (or "void") (type and name).
 325      =3   * @param regnum The register bank number (0-3).
 326      =3   *
 327      =3   * This macro declares a function prototype for a C function that uses a
 328      =3   * specific register its working registers.  See the documentation for
 329      =3   * @ref SI_FUNCTION_USING for an explanation of the macro arguments.  This is
 330      =3   * an advanced feature.
 331      =3   *
 332      =3   * @note This macro is used to declare a prototype for the function.  To
 333      =3   * define the function implementation, use @ref SI_FUNCTION_USING.
 334      =3   *****************************************************************************/
 335      =3  #define SI_FUNCTION_PROTO_USING(name, return_value, parameter, regnum)        \
 336      =3               return_value name parameter
 337      =3  
 338      =3  /**************************************************************************//**
 339      =3   * Declare a variable to be located in a specific memory segment.
 340      =3   *
 341      =3   * @param name The variable name.
 342      =3   * @param vartype The variable data type.* @param memseg The memory segment to use for the variable.
 343      =3   *
 344      =3   * This macro declares a variable to be located in a specific memory area
 345      =3   * (or segment) of the 8051 memory space.  It is only necessary to use this
 346      =3   * macro if you want to force the variable into a specific memory space instead
 347      =3   * of the default memory space used by the compiler.  The segment can be
 348      =3   * one of the following:
 349      =3   *
 350      =3   * - @ref SI_SEG_DATA
 351      =3   * - @ref SI_SEG_IDATA
 352      =3   * - @ref SI_SEG_BDATA
 353      =3   * - @ref SI_SEG_PDATA
 354      =3   * - @ref SI_SEG_XDATA
 355      =3   * - @ref SI_SEG_CODE
 356      =3   *
 357      =3   * __Example__
 358      =3   *
 359      =3   * ~~~~~~~~.c
 360      =3   * // The following macro can be used to create a variable located in
 361      =3   * // XDATA with the following signature:
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 13  

 362      =3   * uint8_t myVar;
 363      =3   *
 364      =3   * SI_SEGMENT_VARIABLE(myVar, uint8_t, SEG_XDATA);
 365      =3   * ~~~~~~~~
 366      =3   *****************************************************************************/
 367      =3  #define SI_SEGMENT_VARIABLE(name, vartype, memseg) vartype memseg name
 368      =3  
 369      =3  /**************************************************************************//**
 370      =3   * Declare a memory segment specific pointer variable.
 371      =3   *
 372      =3   * @param name The pointer variable name.
 373      =3   * @param vartype The pointer data type.
 374      =3   * @param targseg The target memory segment for the pointer.
 375      =3   *
 376      =3   * This macro declares a pointer that points at a specific memory area
 377      =3   * (or segment).  The memory segment of the pointer variable itself is not
 378      =3   * specified and the default is used.  The segment can be one of the following:
 379      =3   *
 380      =3   * - @ref SI_SEG_DATA
 381      =3   * - @ref SI_SEG_IDATA
 382      =3   * - @ref SI_SEG_BDATA
 383      =3   * - @ref SI_SEG_PDATA
 384      =3   * - @ref SI_SEG_XDATA
 385      =3   * - @ref SI_SEG_CODE
 386      =3   *
 387      =3   * __Example__
 388      =3   *
 389      =3   * ~~~~~~~~.c
 390      =3   * // The following macro can be used to create a pointer that points to
 391      =3   * // a location in XDATA with the following signature:
 392      =3   * uint8_t *pVar; // where pVar is pointing at XDATA
 393      =3   *
 394      =3   * SI_VARIABLE_SEGMENT_POINTER(pVar, uint8_t, SEG_XDATA);
 395      =3   * ~~~~~~~~
 396      =3   *****************************************************************************/
 397      =3  #define SI_VARIABLE_SEGMENT_POINTER(name, vartype, targseg)                  \
 398      =3               vartype targseg * name
 399      =3  
 400      =3  /**************************************************************************//**
 401      =3   * Declare a memory segment specific pointer variable, in a specific segment.
 402      =3   *
 403      =3   * @param name The pointer variable name.
 404      =3   * @param vartype The pointer data type.
 405      =3   * @param targseg The target memory segment for the pointer.
 406      =3   * @param memseg The memory segment to use for the pointer variable.
 407      =3   *
 408      =3   * This macro declares a pointer that points at a specific memory area
 409      =3   * (or segment).  The pointer variable itself is also located in a specified
 410      =3   * memory segment by _memseg_.  The arguments _targseg_ and _memseg_ can be
 411      =3   * one of the following:
 412      =3   *
 413      =3   * - @ref SI_SEG_DATA
 414      =3   * - @ref SI_SEG_IDATA
 415      =3   * - @ref SI_SEG_BDATA
 416      =3   * - @ref SI_SEG_PDATA
 417      =3   * - @ref SI_SEG_XDATA
 418      =3   * - @ref SI_SEG_CODE
 419      =3   *
 420      =3   * __Example__
 421      =3   *
 422      =3   * ~~~~~~~~.c
 423      =3   * // The following macro can be used to create a pointer that points to
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 14  

 424      =3   * // a location in XDATA while the pointer itself is located in DATA, with
 425      =3   * // the following signature:
 426      =3   * uint8_t *pVar; // where pVar is located in DATA and is pointing at XDATA
 427      =3   *
 428      =3   * SI_SEGMENT_VARIABLE_SEGMENT_POINTER(pVar, uint8_t, SEG_XDATA, SEG_DATA);
 429      =3   * ~~~~~~~~
 430      =3   *****************************************************************************/
 431      =3  #define SI_SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targseg, memseg)  \
 432      =3               vartype targseg * memseg name
 433      =3  
 434      =3  /**************************************************************************//**
 435      =3   * Declare a generic pointer variable that is located in a specific segment.
 436      =3   *
 437      =3   * @param name The pointer variable name.
 438      =3   * @param vartype The pointer data type.
 439      =3   * @param memseg The memory segment to use for the pointer variable.
 440      =3   *
 441      =3   * This macro declares a pointer that is a generic pointer.  This means it can
 442      =3   * point at any kind of memory location.  However the pointer variable itself
 443      =3   * is located in a specific memory segment by _memseg_, which can be one of
 444      =3   * the following:
 445      =3   *
 446      =3   * - @ref SI_SEG_DATA
 447      =3   * - @ref SI_SEG_IDATA
 448      =3   * - @ref SI_SEG_BDATA
 449      =3   * - @ref SI_SEG_PDATA
 450      =3   * - @ref SI_SEG_XDATA
 451      =3   * - @ref SI_SEG_CODE
 452      =3   *
 453      =3   * __Example__
 454      =3   *
 455      =3   * ~~~~~~~~.c
 456      =3   * // The following macro can be used to create a generic pointer that
 457      =3   * // is located in DATA and points at any memory type, with the
 458      =3   * // following signature:
 459      =3   * uint8_t *pVar; // where pVar is located in DATA and is a generic pointer
 460      =3   *
 461      =3   * SI_SEGMENT_POINTER(pVar, uint8_t, SEG_DATA);
 462      =3   * ~~~~~~~~
 463      =3   *****************************************************************************/
 464      =3  #define SI_SEGMENT_POINTER(name, vartype, memseg) vartype * memseg name
 465      =3  
 466      =3  /**************************************************************************//**
 467      =3   * Declare an uninitialized variable that is located at a specific address.
 468      =3   *
 469      =3   * @param name The variable name.
 470      =3   * @param vartype The variable data type.
 471      =3   * @param memseg The memory segment to use for the variable.
 472      =3   * @param address The memory address of the variable.
 473      =3   *
 474      =3   * This macro allows declaring a variable that can be placed at a specific
 475      =3   * location in memory.  This can only be used for variables that do not need
 476      =3   * initializers.  The _address_ is the memory address within the specified
 477      =3   * segment.  The memory segment, _memseg_, can be one of the following:
 478      =3   *
 479      =3   * - @ref SI_SEG_DATA
 480      =3   * - @ref SI_SEG_IDATA
 481      =3   * - @ref SI_SEG_BDATA
 482      =3   * - @ref SI_SEG_PDATA
 483      =3   * - @ref SI_SEG_XDATA
 484      =3   * - @ref SI_SEG_CODE
 485      =3   *
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 15  

 486      =3   * __Example__
 487      =3   *
 488      =3   * ~~~~~~~~.c
 489      =3   * // The following declares a variable located at 0x4000 in XDATA with
 490      =3   * // the following signature:
 491      =3   * uint8_t myMemVar;
 492      =3   *
 493      =3   * SI_LOCATED_VARIABLE_NO_INIT(myMemVar, uint8_t, SEG_DATA, 0x4000);
 494      =3   * ~~~~~~~~
 495      =3   *****************************************************************************/
 496      =3  #define SI_LOCATED_VARIABLE_NO_INIT(name, vartype, memseg, address)          \
 497      =3               vartype memseg name _at_ address
 498      =3  
 499      =3  
 500      =3  #else  // __SLS_IDE__ : Macros defined to remove syntax errors within Simplicity Studio
           =3 #define SI_INTERRUPT(name, vector) void name (void)
           =3 #define SI_INTERRUPT_USING(name, vector, regnum) void name (void)
           =3 #define SI_INTERRUPT_PROTO(name, vector) void name (void)
           =3 #define SI_INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
           =3 
           =3 #define SI_REENTRANT_FUNCTION(name, return_value, parameter, regnum) return_value name (parameter)
           =3 #define SI_REENTRANT_FUNCTION_PROTO(name, return_value, parameter, regnum) return_value name (parameter)
           =3 
           =3 #define SI_FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =3 #define SI_FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =3 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =3 
           =3 #define SI_SEGMENT_VARIABLE(name, vartype, locsegment) vartype name
           =3 #define SI_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype * name
           =3 #define SI_SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype * name
           =3 #define SI_SEGMENT_POINTER(name, vartype, locsegment) vartype * name
           =3 #define SI_LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) vartype name
           =3 #endif // __SLS_IDE__
 519      =3  
 520      =3  // The following are used for byte ordering when referring to individual
 521      =3  // bytes within a SI_UU32_t.  B0 is the least significant byte.
 522      =3  #define B0 3 ///< Least significant byte of a 4 byte word
 523      =3  #define B1 2 ///< Byte 1 of a 4-byte word, where byte 0 is LSB
 524      =3  #define B2 1 ///< Byte 2 of a 4-byte word, where byte 0 is LSB
 525      =3  #define B3 0 ///< Most significant byte of a 4-byte word
 526      =3  
 527      =3  #define LSB 1 ///< Index to least significant bit of a 2 byte word
 528      =3  #define MSB 0 ///< Index to most significant bit of a 2 byte word
 529      =3  
 530      =3  /// A union type to make it easier to access individual bytes of a 16-bit
 531      =3  /// word, and to use as signed or unsigned type.
 532      =3  typedef union SI_UU16
 533      =3  {
 534      =3    uint16_t u16;   ///< The two byte value as a 16-bit unsigned integer.
 535      =3    int16_t s16;    ///< The two byte value as a 16-bit signed integer.
 536      =3    uint8_t u8[2];  ///< The two byte value as two unsigned 8-bit integers.
 537      =3    int8_t s8[2];   ///< The two byte value as two signed 8-bit integers.
 538      =3  } SI_UU16_t;
 539      =3  
 540      =3  /// A union type to make it easier to access individual bytes within a
 541      =3  /// 32-bit word, or to access it as variations of 16-bit words, or to
 542      =3  /// use as signed or unsigned type.
 543      =3  typedef union SI_UU32
 544      =3  {
 545      =3    uint32_t u32;       ///< The 4-byte value as a 32-bit unsigned integer.
 546      =3    int32_t s32;        ///< The 4-byte value as a 32-bit signed integer.
 547      =3    SI_UU16_t uu16[2];  ///< The 4-byte value as a SI_UU16_t.
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 16  

 548      =3    uint16_t u16[2];    ///< The 4-byte value as two unsigned 16-bit integers.
 549      =3    int16_t s16[2];     ///< The 4-byte value as two signed 16-bit integers.
 550      =3    uint8_t u8[4];      ///< The 4-byte value as 4 unsigned 8-bit integers.
 551      =3    int8_t s8[4];       ///< The 4-byte value as 4 signed 8-bit integers.
 552      =3  } SI_UU32_t;
 553      =3  
 554      =3  // Generic pointer memory segment constants.
 555      =3  #define SI_GPTR                   ///< Generic pointer indeterminate type.
 556      =3  #define SI_GPTR_MTYPE_DATA  0x00  ///< Generic pointer for DATA segment.
 557      =3  #define SI_GPTR_MTYPE_IDATA 0x00  ///< Generic pointer for IDATA segment.
 558      =3  #define SI_GPTR_MTYPE_BDATA 0x00  ///< Generic pointer for BDATA segment.
 559      =3  #define SI_GPTR_MTYPE_PDATA 0xFE  ///< Generic pointer for PDATA segment.
 560      =3  #define SI_GPTR_MTYPE_XDATA 0x01  ///< Generic pointer for XDATA segment.
 561      =3  #define SI_GPTR_MTYPE_CODE  0xFF  ///< Generic pointer for CODE segment.
 562      =3  
 563      =3  /// Generic pointer structure containing the type and address.
 564      =3  typedef struct
 565      =3  {
 566      =3    uint8_t memtype;    ///< The type of memory of the generic pointer.
 567      =3    SI_UU16_t address;  ///< The address of the generic pointer.
 568      =3  } GPTR_t;
 569      =3  
 570      =3  /// A union type to allow access to the fields of a generic pointer.
 571      =3  /// A generic pointer has a field indicating the type of memory and an
 572      =3  /// address within the memory.
 573      =3  typedef union SI_GEN_PTR
 574      =3  {
 575      =3    uint8_t u8[3];    ///< 3-byte generic pointer as 3 unsigned 8-bit integers.
 576      =3    GPTR_t gptr;      ///< 3-byte generic pointer as pointer structure
 577      =3  } SI_GEN_PTR_t;
 578      =3  
 579      =3  // Declaration of Keil intrinisc
 580      =3  extern void _nop_(void);
 581      =3  /// Macro to insert a no-operation (NOP) instruction.
 582      =3  #define NOP() _nop_()
 583      =3  
 584      =3  // -------------------------------
 585      =3  // GCC for ARM Cortex-M
 586      =3  // Provides support for code that can be compiled for 8 or 32-bit
 587      =3  //
 588      =3  #elif defined (__GNUC__)
           =3 #if defined(__ARMEL__) && ((__ARMEL__ == 1) && ((__ARM_ARCH == 6) || (__ARM_ARCH == 7)))
           =3 
           =3 // these ignore any memory segment directives
           =3 #define SI_SEG_GENERIC
           =3 #define SI_SEG_DATA
           =3 #define SI_SEG_IDATA
           =3 #define SI_SEG_XDATA
           =3 #define SI_SEG_PDATA
           =3 #define SI_SEG_BDATA
           =3 #define SI_SEG_CODE
           =3 
           =3 // the following create a variable of the specified name but ignore the
           =3 // address and bit number.  If the using-code cares about the actual
           =3 // address or bit number, this probably will break it
           =3 #define SI_SBIT(name, address, bitnum) uint8_t name
           =3 #define SI_SFR(name, address) uint8_t name
           =3 #define SI_SFR16(name, address) uint16_t name
           =3 
           =3 // the following create function and variable names of the specified types
           =3 // but the 8051-specific aspects (like memory segment) are ignored
           =3 #define SI_INTERRUPT(name, vector) void name (void)
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 17  

           =3 #define SI_INTERRUPT_USING(name, vector, regnum) void name (void)
           =3 #define SI_INTERRUPT_PROTO(name, vector) void name (void)
           =3 #define SI_INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
           =3 #define SI_FUNCTION_USING(name, return_value, parameter, regnum)              \
           =3              return_value name (parameter)
           =3 #define SI_FUNCTION_PROTO_USING(name, return_value, parameter, regnum)        \
           =3              return_value name (parameter)
           =3 #define SI_SEGMENT_VARIABLE(name, vartype, memseg) vartype name
           =3 #define SI_VARIABLE_SEGMENT_POINTER(name, vartype, targseg)                  \
           =3              vartype * name
           =3 #define SI_SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targseg, memseg)  \
           =3              vartype * name
           =3 #define SI_SEGMENT_POINTER(name, vartype, memseg) vartype * name
           =3 #define SI_LOCATED_VARIABLE_NO_INIT(name, vartype, memseg, address)          \
           =3              vartype name
           =3 
           =3 #define B0 0
           =3 #define B1 1
           =3 #define B2 2
           =3 #define B3 3
           =3 #define LSB 0
           =3 #define MSB 1
           =3 typedef union SI_UU16
           =3 {
           =3   uint16_t u16;
           =3   int16_t s16;
           =3   uint8_t u8[2];
           =3   int8_t s8[2];
           =3 } SI_UU16_t;
           =3 
           =3 typedef union SI_UU32
           =3 {
           =3   uint32_t u32;
           =3   int32_t s32;
           =3   SI_UU16_t uu16[2];
           =3   uint16_t u16[2];
           =3   int16_t s16[2];
           =3   uint8_t u8[4];
           =3   int8_t s8[4];
           =3 } SI_UU32_t;
           =3 
           =3 // Generic pointer stuff is left out because if you are accessing
           =3 // generic pointer fields then it will need to be rewritten for 32-bit
           =3 
           =3 // __NOP should be declared in cmsis header core_cmInstr.h
           =3 extern void __NOP(void);
           =3 /// Macro to insert a no-operation (NOP) instruction.
           =3 #define NOP() __NOP()
           =3 
           =3 #else // ARM_ARCH 6 | 7
           =3 #error unsupported ARM arch
           =3 #endif
           =3 
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 // IAR 8051
           =3 // http://www.iar.com
           =3 #elif defined __ICC8051__
           =3 
           =3 #include <intrinsics.h>
           =3 
           =3 #define SI_BIT(name)              __no_init bool __bit name
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 18  

           =3 #define SI_SBIT(name, addr, bit)  __bit __no_init volatile bool name @ (addr+bit)
           =3 #define SI_SFR(name, addr)        __sfr __no_init volatile unsigned char name @ addr
           =3 #define SI_SFR16(name, addr)      __sfr __no_init volatile unsigned int  name @ addr
           =3 
           =3 #define SI_SEG_GENERIC __generic
           =3 #define SI_SEG_FAR  __xdata
           =3 #define SI_SEG_DATA __data
           =3 #define SI_SEG_NEAR __data
           =3 #define SI_SEG_IDATA __idata
           =3 #define SI_SEG_XDATA __xdata
           =3 #define SI_SEG_PDATA __pdata
           =3 #define SI_SEG_CODE  __code
           =3 #define SI_SEG_BDATA __bdata
           =3 
           =3 #define _PPTOSTR_(x) #x
           =3 #define _PPARAM_(address) _PPTOSTR_(vector=address * 8 + 3)
           =3 #define _PPARAM2_(regbank) _PPTOSTR_(register_bank=regbank)
           =3 #define SI_INTERRUPT(name, vector) _Pragma(_PPARAM_(vector)) __interrupt void name(void)
           =3 #define SI_INTERRUPT_PROTO(name, vector)  __interrupt void name(void)
           =3 #define SI_INTERRUPT_USING(name, vector, regnum) _Pragma(_PPARAM2_(regnum)) _Pragma(_PPARAM_(vector)) __in
             -terrupt void name(void)
           =3 #define SI_INTERRUPT_PROTO_USING(name, vector, regnum) __interrupt void name(void)
           =3 
           =3 #if (__DATA_MODEL__ == 0) /* TINY */ || \
           =3     (__DATA_MODEL__ == 1) /* SMALL */
           =3 #define SI_REENTRANT_FUNCTION(name, return_type, parameter) \
           =3   __idata_reentrant return_type name parameter
           =3 #define SI_REENTRANT_FUNCTION_PROTO(name, return_type, parameter) \
           =3   __idata_reentrant return_type name parameter
           =3 #elif (__DATA_MODEL__ == 2) /* LARGE */ || \
           =3       (__DATA_MODEL__ == 3) /* GENERIC */ || \
           =3       (__DATA_MODEL__ == 4) /* FAR */
           =3 #define SI_REENTRANT_FUNCTION(name, return_type, parameter) \
           =3   __xdata_reentrant return_type name parameter
           =3 #define SI_REENTRANT_FUNCTION_PROTO(name, return_type, parameter) \
           =3   __xdata_reentrant return_type name (parameter)
           =3 #else
           =3 #error "Illegal memory model setting."
           =3 #endif
           =3 
           =3 // Note: IAR does not support functions using different register banks. Register
           =3 //       banks can only be specified in interrupts. If a function is called from
           =3 //       inside an interrupt, it will use the same register bank as the interrupt.
           =3 #define SI_FUNCTION_USING(name, return_value, parameter, regnum)              \
           =3              return_value name parameter
           =3 #define SI_FUNCTION_PROTO_USING(name, return_value, parameter, regnum)        \
           =3              return_value name parameter
           =3 
           =3 #define SI_SEGMENT_VARIABLE(name, vartype, locsegment)  vartype locsegment name
           =3 #define SI_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment  * name
           =3 #define SI_SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * 
             -locsegment name
           =3                
           =3 #define SI_SEGMENT_POINTER(name, vartype, ptrseg) vartype __generic * ptrseg name
           =3 
           =3 #define SI_LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment __no_init vartype name @ add
             -r
           =3 
           =3 #define SI_LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) locsegment __no_init vartype name @ a
             -ddr
           =3 
           =3 // The following are used for byte ordering when referring to individual
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 19  

           =3 // bytes within a SI_UU32_t.  B0 is the least significant byte.
           =3 #define B0 0 ///< Least significant byte of a 4 byte word
           =3 #define B1 1 ///< Byte 1 of a 4-byte word, where byte 0 is LSB
           =3 #define B2 2 ///< Byte 2 of a 4-byte word, where byte 0 is LSB
           =3 #define B3 3 ///< Most significant byte of a 4-byte word
           =3 
           =3 #define LSB 0 ///< Index to least significant bit of a 2 byte word
           =3 #define MSB 1 ///< Index to most significant bit of a 2 byte word
           =3 
           =3 /// A union type to make it easier to access individual bytes of a 16-bit
           =3 /// word, and to use as signed or unsigned type.
           =3 typedef union SI_UU16
           =3 {
           =3   uint16_t u16;   ///< The two byte value as a 16-bit unsigned integer.
           =3   int16_t s16;    ///< The two byte value as a 16-bit signed integer.
           =3   uint8_t u8[2];  ///< The two byte value as two unsigned 8-bit integers.
           =3   int8_t s8[2];   ///< The two byte value as two signed 8-bit integers.
           =3 } SI_UU16_t;
           =3 
           =3 /// A union type to make it easier to access individual bytes within a
           =3 /// 32-bit word, or to access it as variations of 16-bit words, or to
           =3 /// use as signed or unsigned type.
           =3 typedef union SI_UU32
           =3 {
           =3   uint32_t u32;       ///< The 4-byte value as a 32-bit unsigned integer.
           =3   int32_t s32;        ///< The 4-byte value as a 32-bit signed integer.
           =3   SI_UU16_t uu16[2];  ///< The 4-byte value as a SI_UU16_t.
           =3   uint16_t u16[2];    ///< The 4-byte value as two unsigned 16-bit integers.
           =3   int16_t s16[2];     ///< The 4-byte value as two signed 16-bit integers.
           =3   uint8_t u8[4];      ///< The 4-byte value as 4 unsigned 8-bit integers.
           =3   int8_t s8[4];       ///< The 4-byte value as 4 signed 8-bit integers.
           =3 } SI_UU32_t;
           =3 
           =3 // Generic pointer memory segment constants.
           =3 #define SI_GPTR                   ///< Generic pointer indeterminate type.
           =3 #define SI_GPTR_MTYPE_DATA  0x01  ///< Generic pointer for DATA segment.
           =3 #define SI_GPTR_MTYPE_IDATA 0x01  ///< Generic pointer for IDATA segment.
           =3 #define SI_GPTR_MTYPE_BDATA 0x01  ///< Generic pointer for BDATA segment.
           =3 #define SI_GPTR_MTYPE_PDATA 0x00  ///< Generic pointer for PDATA segment.
           =3 #define SI_GPTR_MTYPE_XDATA 0x00  ///< Generic pointer for XDATA segment.
           =3 #define SI_GPTR_MTYPE_CODE  0x80  ///< Generic pointer for CODE segment.
           =3 
           =3 /// Generic pointer structure containing the type and address.
           =3 typedef struct
           =3 {
           =3   SI_UU16_t address;  ///< The address of the generic pointer.
           =3   uint8_t memtype;    ///< The type of memory of the generic pointer.  
           =3 } GPTR_t;
           =3 
           =3 /// A union type to allow access to the fields of a generic pointer.
           =3 /// A generic pointer has a field indicating the type of memory and an
           =3 /// address within the memory.
           =3 typedef union SI_GEN_PTR
           =3 {
           =3   uint8_t u8[3];    ///< 3-byte generic pointer as 3 unsigned 8-bit integers.
           =3   GPTR_t gptr;      ///< 3-byte generic pointer as pointer structure
           =3 } SI_GEN_PTR_t;
           =3 
           =3 /// Macro to insert a no-operation (NOP) instruction.
           =3 #define NOP() __no_operation()
           =3 
           =3 #else // unknown toolchain
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 20  

           =3 #error Unrecognized toolchain in si_toolchain.h
           =3 #endif
 794      =3  
 795      =3  /** @} */
 796      =3  
 797      =3  #endif
 120      =2  #include "compiler_defs.h"
   1      =3  //-----------------------------------------------------------------------------
   2      =3  // compiler_defs.h
   3      =3  //-----------------------------------------------------------------------------
   4      =3  // Portions of this file are copyright Maarten Brock
   5      =3  // http://sdcc.sourceforge.net
   6      =3  // Portions of this file are Copyright 2014 Silicon Laboratories, Inc.
   7      =3  // http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   8      =3  //
   9      =3  // GNU LGPL boilerplate:
  10      =3  /** This library is free software; you can redistribute it and/or
  11      =3    * modify it under the terms of the GNU Lesser General Public
  12      =3    * License as published by the Free Software Foundation; either
  13      =3    * version 2.1 of the License, or (at your option) any later version.
  14      =3    *
  15      =3    * This library is distributed in the hope that it will be useful,
  16      =3    * but WITHOUT ANY WARRANTY; without even the implied warranty of
  17      =3    * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
  18      =3    * Lesser General Public License for more details.
  19      =3    *
  20      =3    * You should have received a copy of the GNU Lesser General Public
  21      =3    * License along with this library; if not, write to the Free Software
  22      =3    * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  23      =3    *
  24      =3    * In other words, you are welcome to use, share and improve this program.
  25      =3    * You are forbidden to forbid anyone else to use, share and improve
  26      =3    * what you give them. Help stamp out software-hoarding!
  27      =3  **/
  28      =3  // Program Description:
  29      =3  //
  30      =3  // **Important Note**: This header file should be included before including
  31      =3  // a device-specific header file such as C8051F300_defs.h.
  32      =3  //
  33      =3  // Macro definitions to accomodate 8051 compiler differences in specifying
  34      =3  // special function registers and other 8051-specific features such as NOP
  35      =3  // generation, and locating variables in memory-specific segments.  The
  36      =3  // compilers are identified by their unique predefined macros. See also:
  37      =3  // http://predef.sourceforge.net/precomp.html
  38      =3  //
  39      =3  // SBIT and SFR define special bit and special function registers at the given
  40      =3  // address. SFR16 and SFR32 define sfr combinations at adjacent addresses in
  41      =3  // little-endian format. SFR16E and SFR32E define sfr combinations without
  42      =3  // prerequisite byte order or adjacency. None of these multi-byte sfr
  43      =3  // combinations will guarantee the order in which they are accessed when read
  44      =3  // or written.
  45      =3  //
  46      =3  // SFR16X and SFR32X for 16 bit and 32 bit xdata registers are not defined
  47      =3  // to avoid portability issues because of compiler endianness.
  48      =3  //
  49      =3  // Example:
  50      =3  // // my_mcu.c: main 'c' file for my mcu
  51      =3  // #include <compiler_defs.h>  // this file
  52      =3  // #include <C8051xxxx_defs.h> // SFR definitions for specific MCU target
  53      =3  //
  54      =3  // SBIT  (P0_1, 0x80, 1);      // Port 0 pin 1
  55      =3  // SFR   (P0, 0x80);           // Port 0
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 21  

  56      =3  // SFRX  (CPUCS, 0xE600);      // Cypress FX2 Control and Status register in
  57      =3  //                             // xdata memory at 0xE600
  58      =3  // SFR16 (TMR2, 0xCC);         // Timer 2, lsb at 0xCC, msb at 0xCD
  59      =3  // SFR16E(TMR0, 0x8C8A);       // Timer 0, lsb at 0x8A, msb at 0x8C
  60      =3  // SFR32 (MAC0ACC, 0x93);      // SiLabs C8051F120 32 bits MAC0 Accumulator,
  61      =3  //                             // lsb at 0x93, msb at 0x96
  62      =3  // SFR32E(SUMR, 0xE5E4E3E2);   // TI MSC1210 SUMR 32 bits Summation register,
  63      =3  //                             // lsb at 0xE2, msb at 0xE5
  64      =3  //
  65      =3  // Target:         C8051xxxx
  66      =3  // Tool chain:     Generic
  67      =3  // Command Line:   None
  68      =3  // 
  69      =3  // Release 2.7 - 25 JUN 2014 (JM)
  70      =3  //    -Added SI_GENERIC_PTR struct for accessing generic pointers
  71      =3  //    -Added SI_GPTR_MTYPE_XXXX definitions for determining the memory type
  72      =3  //     pointed at by a generic poitner
  73      =3  // Release 2.6 - 14 DEC 2012 (GO)
  74      =3  //        -Added define for deprecated SDCC keyword 'at'
  75      =3  // Release 2.5 - 12 SEP 2012 (TP)
  76      =3  //    -Added defines for deprecated SDCC keywords bit and code
  77      =3  // Release 2.4 - 27 AUG 2012 (TP)
  78      =3  //    -Added defines for deprecated SDCC keywords interrupt, _asm, and _endasm
  79      =3  // Release 2.3 - 27 MAY 2010 (DM)
  80      =3  //    -Removed 'LOCATED_VARIABLE' pragma from Keil because it is not supported
  81      =3  // Release 2.2 - 06 APR 2010 (ES)
  82      =3  //    -Removed 'PATHINCLUDE' pragma from Raisonance section
  83      =3  // Release 2.1 - 16 JUL 2009 (ES)
  84      =3  //    -Added SEGMENT_POINTER macro definitions for SDCC, Keil, and Raisonance
  85      =3  //    -Added LOCATED_VARIABLE_NO_INIT macro definitions for Raisonance
  86      =3  // Release 2.0 - 19 MAY 2009 (ES)
  87      =3  //    -Added LOCATED_VARIABLE_NO_INIT macro definitions for SDCC and Keil
  88      =3  // Release 1.9 - 23 OCT 2008 (ES)
  89      =3  //    -Updated Hi-Tech INTERRUPT and INTERRUPT_USING macro definitions
  90      =3  //    -Added SFR16 macro defintion for Hi-Tech
  91      =3  // Release 1.8 - 31 JUL 2008 (ES)
  92      =3  //    -Added INTERRUPT_USING and FUNCTION_USING macro's
  93      =3  //    -Added macro's for IAR
  94      =3  //    -Corrected Union definitions for Hi-Tech and added SFR16 macro defintion
  95      =3  // Release 1.7 - 11 SEP 2007 (BW)
  96      =3  //    -Added support for Raisonance EVAL 03.03.42 and Tasking Eval 7.2r1
  97      =3  // Release 1.6 - 27 AUG 2007 (BW)
  98      =3  //    -Updated copyright notice per agreement with Maartin Brock
  99      =3  //    -Added SDCC 2.7.0 "compiler.h" bug fixes
 100      =3  //    -Added memory segment defines (SEG_XDATA, for example)
 101      =3  // Release 1.5 - 24 AUG 2007 (BW)
 102      =3  //    -Added support for NOP () macro
 103      =3  //    -Added support for Hi-Tech ver 9.01
 104      =3  // Release 1.4 - 07 AUG 2007 (PKC)
 105      =3  //    -Removed FID and fixed formatting.
 106      =3  // Release 1.3 - 30 SEP 2007 (TP)
 107      =3  //    -Added INTERRUPT_PROTO_USING to properly support ISR context switching
 108      =3  //     under SDCC.
 109      =3  // Release 1.2 - (BW)
 110      =3  //    -Added support for U8,U16,U32,S8,S16,S32,UU16,UU32 data types
 111      =3  // Release 1.1 - (BW)
 112      =3  //    -Added support for INTERRUPT, INTERRUPT_USING, INTERRUPT_PROTO,
 113      =3  //     SEGMENT_VARIABLE, VARIABLE_SEGMENT_POINTER,
 114      =3  //     SEGMENT_VARIABLE_SEGMENT_POINTER, and LOCATED_VARIABLE
 115      =3  // Release 1.0 - 29 SEP 2006 (PKC)
 116      =3  //    -Initial revision
 117      =3  
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 22  

 118      =3  //-----------------------------------------------------------------------------
 119      =3  // Header File Preprocessor Directive
 120      =3  //-----------------------------------------------------------------------------
 121      =3  
 122      =3  #ifndef COMPILER_DEFS_H
 123      =3  #define COMPILER_DEFS_H
 124      =3  
 125      =3  #include "stdbool.h"
   1      =4  /**************************************************************************//**
   2      =4   * Copyright (c) 2015 by Silicon Laboratories Inc. All rights reserved.
   3      =4   *
   4      =4   * http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   5      =4   *****************************************************************************/
   6      =4  
   7      =4  #ifndef STDBOOL_H
           =4 #define STDBOOL_H
           =4 
           =4 #if defined __C51__
           =4 
           =4 typedef bit bool;
           =4 enum{
           =4   false = 0,
           =4   true = 1,
           =4 };
           =4 
           =4 #elif defined __ICC8051__
           =4 
           =4 #ifndef _SYSTEM_BUILD
           =4   #pragma system_include
           =4 #endif
           =4 
           =4 #ifndef __cplusplus
           =4 
           =4 #define bool _Bool
           =4 #define true 1
           =4 #define false 0
           =4 
           =4 #define __bool_true_false_are_defined 1
           =4 
           =4 #endif /* !__cplusplus */
           =4 
           =4 #else  // __SLS_IDE__ : Macros defined to remove syntax errors within Simplicity Studio
           =4 
           =4 typedef bit bool;
           =4 enum{
           =4   false = 0,
           =4   true = 1,
           =4 };
           =4 
           =4 #endif
           =4 
           =4 #endif //STDBOOL_H
  45      =4  
 126      =3  #include "stdint.h"
   1      =4  /**************************************************************************//**
   2      =4   * Copyright (c) 2015 by Silicon Laboratories Inc. All rights reserved.
   3      =4   *
   4      =4   * http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   5      =4   *****************************************************************************/
   6      =4  
   7      =4  #ifndef STDINT_H
           =4 #define STDINT_H
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 23  

           =4 
           =4 #if defined __C51__
           =4 
           =4 typedef unsigned char uint8_t;
           =4 typedef unsigned short uint16_t;
           =4 typedef unsigned long uint32_t;
           =4 typedef uint32_t uint64_t[2];
           =4 
           =4 typedef signed char int8_t;
           =4 typedef short int16_t;
           =4 typedef long int32_t;
           =4 typedef int32_t int64_t[2];
           =4 typedef float fp32_t;
           =4 typedef double fp64_t;
           =4 
           =4 #elif defined __ICC8051__
           =4 
           =4 /* Fixed size types. These are all optional. */
           =4 #ifdef __INT8_T_TYPE__
           =4   typedef __INT8_T_TYPE__   int8_t;
           =4   typedef __UINT8_T_TYPE__ uint8_t;
           =4 #endif /* __INT8_T_TYPE__ */
           =4 
           =4 #ifdef __INT16_T_TYPE__
           =4   typedef __INT16_T_TYPE__   int16_t;
           =4   typedef __UINT16_T_TYPE__ uint16_t;
           =4 #endif /* __INT16_T_TYPE__ */
           =4 
           =4 #ifdef __INT32_T_TYPE__
           =4   typedef __INT32_T_TYPE__   int32_t;
           =4   typedef __UINT32_T_TYPE__ uint32_t;
           =4 #endif /* __INT32_T_TYPE__ */
           =4 
           =4 #ifdef __INT64_T_TYPE__
           =4   #pragma language=save
           =4   #pragma language=extended
           =4   typedef __INT64_T_TYPE__   int64_t;
           =4   typedef __UINT64_T_TYPE__ uint64_t;
           =4   #pragma language=restore
           =4 #endif /* __INT64_T_TYPE__ */
           =4 
           =4 #endif
           =4 
           =4 #endif
 127      =3  
 128      =3  //-----------------------------------------------------------------------------
 129      =3  // Macro definitions
 130      =3  //-----------------------------------------------------------------------------
 131      =3  
 132      =3  //SDK Version
 133      =3  #define SDK_VERSION   2
 134      =3  
 135      =3  #ifndef NULL
           =3 #define NULL ((void*) 0)
           =3 #endif
 138      =3  
 139      =3  
 140      =3  // SDCC - Small Device C Compiler
 141      =3  // http://sdcc.sourceforge.net
 142      =3  
 143      =3  #if defined SDCC
           =3 
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 24  

           =3 #if (SDCC >= 300)
           =3 
           =3 #define interrupt __interrupt
           =3 #define _asm __asm
           =3 #define _endasm __endasm
           =3 #define bit __bit
           =3 #define code __code
           =3 #define at __at
           =3 
           =3 #endif
           =3 
           =3 # define SEG_GENERIC
           =3 # define SEG_FAR   __xdata
           =3 # define SEG_DATA  __data
           =3 # define SEG_NEAR  __data
           =3 # define SEG_IDATA __idata
           =3 # define SEG_XDATA __xdata
           =3 # define SEG_PDATA __pdata
           =3 # define SEG_CODE  __code
           =3 # define SEG_BDATA __bdata
           =3 
           =3 # define SBIT(name, addr, bit)  __sbit  __at(addr+bit)                  name
           =3 # define SFR(name, addr)        __sfr   __at(addr)                      name
           =3 # define SFRX(name, addr)       xdata volatile unsigned char __at(addr) name
           =3 # define SFR16(name, addr)      __sfr16 __at(((addr+1U)<<8) | addr)     name
           =3 # define SFR16E(name, fulladdr) __sfr16 __at(fulladdr)                  name
           =3 # define SFR32(name, addr)      __sfr32 __at(((addr+3UL)<<24) | ((addr+2UL)<<16) | ((addr+1UL)<<8) | addr)
             - name
           =3 # define SFR32E(name, fulladdr) __sfr32 __at(fulladdr)                  name
           =3 
           =3 # define INTERRUPT(name, vector) void name (void) interrupt (vector)
           =3 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt (vector) using (regnum)
           =3 # define INTERRUPT_PROTO(name, vector) void name (void) interrupt (vector)
           =3 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void) interrupt (vector) using (regnum)
           =3 
           =3 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using (regnum
             -)
           =3 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter) using (
             -regnum)
           =3 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =3 
           =3 # define SEGMENT_VARIABLE(name, vartype, locsegment) locsegment vartype name
           =3 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) targsegment vartype * name
           =3 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) targsegment vartype * lo
             -csegment name
           =3 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
           =3 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment at (addr) vartype name = init
           =3 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) locsegment at (addr) vartype name
           =3 
           =3 // used with UU16
           =3 # define LSB 0
           =3 # define MSB 1
           =3 
           =3 // used with UU32 (b0 is least-significant byte)
           =3 # define b0 0
           =3 # define b1 1
           =3 # define b2 2
           =3 # define b3 3
           =3 
           =3 typedef unsigned char U8;
           =3 typedef unsigned int U16;
           =3 typedef unsigned long U32;
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 25  

           =3 
           =3 typedef signed char S8;
           =3 typedef signed int S16;
           =3 typedef signed long S32;
           =3 
           =3 typedef union UU16
           =3 {
           =3    U16 U16;
           =3    S16 S16;
           =3    U8 U8[2];
           =3    S8 S8[2];
           =3 } UU16;
           =3 
           =3 typedef union UU32
           =3 {
           =3    U32 U32;
           =3    S32 S32;
           =3    UU16 UU16[2];
           =3    U16 U16[2];
           =3    S16 S16[2];
           =3    U8 U8[4];
           =3    S8 S8[4];
           =3 } UU32;
           =3 
           =3 // NOP () macro support
           =3 #define NOP() _asm NOP _endasm
           =3 
           =3 // generic pointer memory type specifiers
           =3 #define SI_GPTR
           =3 #define SI_GPTR_MTYPE_DATA       0x40
           =3 #define SI_GPTR_MTYPE_IDATA      0x40
           =3 #define SI_GPTR_MTYPE_BDATA      0x40
           =3 #define SI_GPTR_MTYPE_PDATA      0x60
           =3 #define SI_GPTR_MTYPE_XDATA      0x00
           =3 #define SI_GPTR_MTYPE_CODE       0x80
           =3 
           =3 // generic pointer access struct
           =3 typedef union SI_GENERIC_PTR
           =3 {
           =3     U8 U8[3];
           =3     struct
           =3     {
           =3         UU16 ADDR;
           =3         U8 MTYPE;
           =3     } GPTR;
           =3 } SI_GENERIC_PTR;
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 // Raisonance (must be placed before Keil C51)
           =3 // http://www.raisonance.com
           =3 
           =3 #elif defined __RC51__
           =3 
           =3 //#error Raisonance C51 detected.
           =3 
           =3 # define SEG_GENERIC generic     //SEG_GENERIC only applies to pointers in Raisonance, not variables.
           =3 # define SEG_FAR   xdata
           =3 # define SEG_DATA  data
           =3 # define SEG_NEAR  data
           =3 # define SEG_IDATA idata
           =3 # define SEG_XDATA xdata
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 26  

           =3 # define SEG_PDATA pdata
           =3 # define SEG_CODE  code
           =3 # define SEG_BDATA bdata
           =3 
           =3 # define SBIT(name, addr, bit)  at (addr+bit) sbit         name
           =3 # define SFR(name, addr)        sfr at addr                name
           =3 # define SFR16(name, addr)      sfr16 at addr              name
           =3 # define SFR16E(name, fulladdr) /* not supported */
           =3 # define SFR32(name, fulladdr)  /* not supported */
           =3 # define SFR32E(name, fulladdr) /* not supported */
           =3 
           =3 # define INTERRUPT(name, vector) void name (void) interrupt vector
           =3 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
           =3 # define INTERRUPT_PROTO(name, vector) void name (void)
           =3 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
           =3 
           =3 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using regnum
           =3 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =3 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =3 
           =3 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =3 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =3 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =3 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
           =3 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) at addr locsegment vartype name
           =3 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) at addr locsegment vartype name
           =3 
           =3 
           =3 // used with UU16
           =3 # define LSB 1
           =3 # define MSB 0
           =3 
           =3 // used with UU32 (b0 is least-significant byte)
           =3 # define b0 3
           =3 # define b1 2
           =3 # define b2 1
           =3 # define b3 0
           =3 
           =3 typedef unsigned char U8;
           =3 typedef unsigned int U16;
           =3 typedef unsigned long U32;
           =3 
           =3 typedef signed char S8;
           =3 typedef signed int S16;
           =3 typedef signed long S32;
           =3 
           =3 typedef union UU16
           =3 {
           =3    U16 U16;
           =3    S16 S16;
           =3    U8 U8[2];
           =3    S8 S8[2];
           =3 } UU16;
           =3 
           =3 typedef union UU32
           =3 {
           =3    U32 U32;
           =3    S32 S32;
           =3    UU16 UU16[2];
           =3    U16 U16[2];
           =3    S16 S16[2];
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 27  

           =3    U8 U8[4];
           =3    S8 S8[4];
           =3 } UU32;
           =3 
           =3 // NOP () macro support -- NOP is opcode 0x00
           =3 #define NOP() asm { 0x00 }
           =3 
           =3 // generic pointer memory type specifiers
           =3 #define SI_GPTR
           =3 #define SI_GPTR_MTYPE_DATA       0x04
           =3 #define SI_GPTR_MTYPE_IDATA      0x01
           =3 #define SI_GPTR_MTYPE_BDATA      0x04
           =3 #define SI_GPTR_MTYPE_PDATA      0x03
           =3 #define SI_GPTR_MTYPE_XDATA      0x02
           =3 #define SI_GPTR_MTYPE_CODE       0x05
           =3 
           =3 // generic pointer access struct
           =3 typedef union SI_GENERIC_PTR
           =3 {
           =3     U8 U8[3];
           =3     struct
           =3     {
           =3         U8 MTYPE;
           =3         UU16 ADDR;
           =3     } GPTR;
           =3 } SI_GENERIC_PTR;
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 
           =3 // Keil C51
           =3 // http://www.keil.com
           =3 
           =3 #elif defined __C51__
 360      =3  
 361      =3  //#error Keil C51 detected.
 362      =3  
 363      =3  # define SEG_GENERIC
 364      =3  # define SEG_FAR   xdata
 365      =3  # define SEG_DATA  data
 366      =3  # define SEG_NEAR  data
 367      =3  # define SEG_IDATA idata
 368      =3  # define SEG_XDATA xdata
 369      =3  # define SEG_PDATA pdata
 370      =3  # define SEG_CODE  code
 371      =3  # define SEG_BDATA bdata
 372      =3  
 373      =3  # define SBIT(name, addr, bit)  sbit  name = addr^bit
 374      =3  # define SFR(name, addr)        sfr   name = addr
 375      =3  # define SFR16(name, addr)      sfr16 name = addr
 376      =3  # define SFR16E(name, fulladdr) /* not supported */
 377      =3  # define SFR32(name, fulladdr)  /* not supported */
 378      =3  # define SFR32E(name, fulladdr) /* not supported */
 379      =3  
 380      =3  # ifndef __SLS_IDE__
 381      =3  
 382      =3  # define INTERRUPT(name, vector) void name (void) interrupt vector
 383      =3  # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
 384      =3  # define INTERRUPT_PROTO(name, vector) void name (void)
 385      =3  # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
 386      =3  
 387      =3  # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using regnum
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 28  

 388      =3  # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter)
 389      =3  // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
 390      =3  
 391      =3  # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
 392      =3  # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
 393      =3  # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
 394      =3  # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
 395      =3  # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) vartype locsegment name _at_ addr
 396      =3  
 397      =3  # else  // __SLS_IDE__
           =3 
           =3 # define INTERRUPT(name, vector) void name (void)
           =3 # define INTERRUPT_USING(name, vector, regnum) void name (void)
           =3 # define INTERRUPT_PROTO(name, vector) void name (void)
           =3 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
           =3 
           =3 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =3 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =3 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =3 
           =3 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype name
           =3 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype * name
           =3 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype * name
           =3 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * name
           =3 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) vartype name
           =3 
           =3 # endif // __SLS_IDE__
 415      =3  
 416      =3  // used with UU16
 417      =3  # define LSB 1
 418      =3  # define MSB 0
 419      =3  
 420      =3  // used with UU32 (b0 is least-significant byte)
 421      =3  # define b0 3
 422      =3  # define b1 2
 423      =3  # define b2 1
 424      =3  # define b3 0
 425      =3  
 426      =3  typedef unsigned char U8;
 427      =3  typedef unsigned int U16;
 428      =3  typedef unsigned long U32;
 429      =3  
 430      =3  typedef signed char S8;
 431      =3  typedef signed int S16;
 432      =3  typedef signed long S32;
 433      =3  
 434      =3  typedef union UU16
 435      =3  {
 436      =3     U16 U16;
 437      =3     S16 S16;
 438      =3     U8 U8[2];
 439      =3     S8 S8[2];
 440      =3  } UU16;
 441      =3  
 442      =3  typedef union UU32
 443      =3  {
 444      =3     U32 U32;
 445      =3     S32 S32;
 446      =3     UU16 UU16[2];
 447      =3     U16 U16[2];
 448      =3     S16 S16[2];
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 29  

 449      =3     U8 U8[4];
 450      =3     S8 S8[4];
 451      =3  } UU32;
 452      =3  
 453      =3  // NOP () macro support
 454      =3  extern void _nop_ (void);
 455      =3  #define NOP() _nop_()
 456      =3  
 457      =3  // generic pointer memory type specifiers
 458      =3  #define SI_GPTR
 459      =3  #define SI_GPTR_MTYPE_DATA      0x00
 460      =3  #define SI_GPTR_MTYPE_IDATA     0x00
 461      =3  #define SI_GPTR_MTYPE_BDATA     0x00
 462      =3  #define SI_GPTR_MTYPE_PDATA     0xFE
 463      =3  #define SI_GPTR_MTYPE_XDATA     0x01
 464      =3  #define SI_GPTR_MTYPE_CODE      0xFF
 465      =3  
 466      =3  // generic pointer access struct
 467      =3  typedef union SI_GENERIC_PTR
 468      =3  {
 469      =3      U8 U8[3];
 470      =3      struct
 471      =3      {
 472      =3          U8 MTYPE;
 473      =3          UU16 ADDR;
 474      =3      } GPTR;
 475      =3  } SI_GENERIC_PTR;
 476      =3  
 477      =3  //-----------------------------------------------------------------------------
 478      =3  
 479      =3  // Hi-Tech 8051
 480      =3  // http://www.htsoft.com
 481      =3  
 482      =3  #elif defined HI_TECH_C
           =3 
           =3 # define SEG_GENERIC
           =3 # define SEG_FAR   far
           =3 # define SEG_DATA  data
           =3 # define SEG_NEAR  near
           =3 # define SEG_IDATA idata
           =3 # define SEG_XDATA xdata
           =3 # define SEG_PDATA pdata
           =3 # define SEG_CODE  code
           =3 # define SEG_BDATA bdata
           =3 
           =3 
           =3 # define SBIT(name, addr, thebit) static volatile bit name @ (addr + thebit)
           =3 # define SFR(name, addr)          static volatile unsigned char name @ addr
           =3 # define SFR16(name, addr)        static volatile unsigned int name @ addr
           =3 # define SFR16E(name, fulladdr) /* not supported */
           =3 # define SFR32(name, fulladdr)  /* not supported */
           =3 # define SFR32E(name, fulladdr) /* not supported */
           =3 
           =3 # define INTERRUPT(name, vector)       void name (void) interrupt vector
           =3 # define INTERRUPT_PROTO(name, vector)
           =3 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
           =3 # define INTERRUPT_PROTO_USING(name, vector, regnum)
           =3 
           =3 # define FUNCTION_USING(name, return_value, parameter, regnum) /* not supported */
           =3 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) /* not supported */
           =3 // Note: Hi-Tech does not support functions using different register banks. Register
           =3 //       banks can only be specified in interrupts. If a function is called from
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 30  

           =3 //       inside an interrupt, it will use the same register bank as the interrupt.
           =3 
           =3 # define SEGMENT_VARIABLE(name, vartype, locsegment) locsegment vartype name
           =3 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) targsegment vartype * name
           =3 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) targsegment vartype * lo
             -csegment name
           =3 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment vartype name @ addr
           =3 
           =3 // used with UU16
           =3 # define LSB 0
           =3 # define MSB 1
           =3 
           =3 // used with UU32 (b0 is least-significant byte)
           =3 # define b0 0
           =3 # define b1 1
           =3 # define b2 2
           =3 # define b3 3
           =3 
           =3 typedef unsigned char U8;
           =3 typedef unsigned int U16;
           =3 typedef unsigned long U32;
           =3 
           =3 typedef signed char S8;
           =3 typedef signed int S16;
           =3 typedef signed long S32;
           =3 
           =3 typedef union UU16
           =3 {
           =3    U16 U16;
           =3    S16 S16;
           =3    U8 U8[2];
           =3    S8 S8[2];
           =3 } UU16;
           =3 
           =3 typedef union UU32
           =3 {
           =3    U32 U32;
           =3    S32 S32;
           =3    UU16 UU16[2];
           =3    U16 U16[2];
           =3    S16 S16[2];
           =3    U8 U8[4];
           =3    S8 S8[4];
           =3 } UU32;
           =3 
           =3 // NOP () macro support
           =3 #define NOP() asm(" nop ")
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 // Tasking / Altium
           =3 // http://www.altium.com/tasking
           =3 
           =3 
           =3 #elif defined _CC51
           =3 
           =3 # define SEG_GENERIC
           =3 # define SEG_FAR   _xdat
           =3 # define SEG_DATA  _data
           =3 # define SEG_NEAR  _data
           =3 # define SEG_IDATA _idat
           =3 # define SEG_XDATA _xdat
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 31  

           =3 # define SEG_PDATA _pdat
           =3 # define SEG_CODE  _rom
           =3 # define SEG_BDATA _bdat
           =3 
           =3 # define SBIT(name, addr, bit)  _sfrbit  name _at(addr+bit)
           =3 # define SFR(name, addr)        _sfrbyte name _at(addr)
           =3 # define SFRX(name, addr)       _xdat volatile unsigned char name _at(addr)
           =3 #if _CC51 > 71
           =3 # define SFR16(name, addr)      _sfrword _little name _at(addr)
           =3 #else
           =3 # define SFR16(name, addr)      /* not supported */
           =3 #endif
           =3 # define SFR16E(name, fulladdr) /* not supported */
           =3 # define SFR32(name, fulladdr)  /* not supported */
           =3 # define SFR32E(name, fulladdr) /* not supported */
           =3 
           =3 # define INTERRUPT(name, vector) _interrupt (vector) void name (void)
           =3 # define INTERRUPT_USING(name, vector, regnum) _interrupt (vector) _using(regnum) void name (void)
           =3 # define INTERRUPT_PROTO(name, vector) _interrupt (vector) void name (void)
           =3 # define INTERRUPT_PROTO_USING(name, vector, regnum) _interrupt (vector) _using(regnum) void name (void)
           =3 
           =3 // When calling FUNCTION_USING in Tasking, the function must be called from an interrupt or Main which
           =3 // is also using the same register bank. If not, the compiler will generate an error.
           =3 # define FUNCTION_USING(name, return_value, parameter, regnum) _using(regnum) return_value name (parameter
             -)
           =3 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) _using(regnum) return_value name (par
             -ameter)
           =3 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =3 
           =3 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =3 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =3 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =3 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) vartype locsegment name _at( addr )
           =3 
           =3 // used with UU16
           =3 # define LSB 1
           =3 # define MSB 0
           =3 
           =3 // used with UU32 (b0 is least-significant byte)
           =3 # define b0 3
           =3 # define b1 2
           =3 # define b2 1
           =3 # define b3 0
           =3 
           =3 typedef unsigned char U8;
           =3 typedef unsigned int U16;
           =3 typedef unsigned long U32;
           =3 
           =3 typedef signed char S8;
           =3 typedef signed int S16;
           =3 typedef signed long S32;
           =3 
           =3 typedef union UU16
           =3 {
           =3    U16 U16;
           =3    S16 S16;
           =3    U8 U8[2];
           =3    S8 S8[2];
           =3 } UU16;
           =3 
           =3 typedef union UU32
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 32  

           =3 {
           =3    U32 U32;
           =3    S32 S32;
           =3    UU16 UU16[2];
           =3    U16 U16[2];
           =3    S16 S16[2];
           =3    U8 U8[4];
           =3    S8 S8[4];
           =3 } UU32;
           =3 
           =3 // NOP () macro support
           =3 extern void _nop (void);
           =3 #define NOP() _nop()
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 
           =3 // IAR 8051
           =3 // http://www.iar.com
           =3 
           =3 #elif defined __ICC8051__
           =3 
           =3 #include <stdbool.h>
           =3 #include <intrinsics.h>
           =3 
           =3 # define SBIT(name, addr, bit)  __bit __no_init volatile bool name @ (addr+bit)
           =3 # define SFR(name, addr)        __sfr __no_init volatile unsigned char name @ addr
           =3 # define SFRX(name, addr)       __xdata __no_init volatile unsigned char name @ addr
           =3 # define SFR16(name, addr)      __sfr __no_init volatile unsigned int  name @ addr
           =3 # define SFR16E(name, fulladdr) /* not supported */
           =3 # define SFR32(name, fulladdr) /* not supported */
           =3 # define SFR32E(name, fulladdr) /* not supported */
           =3 
           =3 # define SEG_GENERIC __generic
           =3 # define SEG_FAR  __xdata
           =3 # define SEG_DATA __data
           =3 # define SEG_NEAR __data
           =3 # define SEG_IDATA __idata
           =3 # define SEG_XDATA __xdata
           =3 # define SEG_PDATA __pdata
           =3 # define SEG_CODE  __code
           =3 # define SEG_BDATA __bdata
           =3 
           =3 #define bit bool
           =3 
           =3 # define _PPTOSTR_(x) #x
           =3 # define _PPARAM_(address) _PPTOSTR_(vector=address * 8 + 3)
           =3 # define _PPARAM2_(regbank) _PPTOSTR_(register_bank=regbank)
           =3 # define INTERRUPT(name, vector) _Pragma(_PPARAM_(vector)) __interrupt void name(void)
           =3 # define INTERRUPT_PROTO(name, vector)  __interrupt void name(void)
           =3 # define INTERRUPT_USING(name, vector, regnum) _Pragma(_PPARAM2_(regnum)) _Pragma(_PPARAM_(vector)) __inte
             -rrupt void name(void)
           =3 # define INTERRUPT_PROTO_USING(name, vector, regnum) __interrupt void name(void)
           =3 
           =3 # define FUNCTION_USING(name, return_value, parameter, regnum) /* not supported */
           =3 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) /* not supported */
           =3 // Note: IAR does not support functions using different register banks. Register
           =3 //       banks can only be specified in interrupts. If a function is called from
           =3 //       inside an interrupt, it will use the same register bank as the interrupt.
           =3 
           =3 # define SEGMENT_VARIABLE(name, vartype, locsegment)  locsegment vartype name
           =3 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment  * name
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 33  

           =3 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =3 
           =3 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment __no_init vartype name @ addr
           =3 
           =3 // used with UU16
           =3 # define LSB 0
           =3 # define MSB 1
           =3 
           =3 // used with UU32 (b0 is least-significant byte)
           =3 # define b0 0
           =3 # define b1 1
           =3 # define b2 2
           =3 # define b3 3
           =3 
           =3 typedef unsigned char U8;
           =3 typedef unsigned int U16;
           =3 typedef unsigned long U32;
           =3 
           =3 typedef signed char S8;
           =3 typedef signed int S16;
           =3 typedef signed long S32;
           =3 
           =3 typedef union UU16
           =3 {
           =3    U16 U16;
           =3    S16 S16;
           =3    U8 U8[2];
           =3    S8 S8[2];
           =3 } UU16;
           =3 
           =3 typedef union UU32
           =3 {
           =3    U32 U32;
           =3    S32 S32;
           =3    UU16 UU16[2];
           =3    U16 U16[2];
           =3    S16 S16[2];
           =3    U8 U8[4];
           =3    S8 S8[4];
           =3 } UU32;
           =3 
           =3 
           =3 #define NOP() __no_operation();
           =3 
           =3 // generic pointer memory type specifiers
           =3 #define SI_GPTR
           =3 #define SI_GPTR_MTYPE_DATA       0x01
           =3 #define SI_GPTR_MTYPE_IDATA      0x01
           =3 #define SI_GPTR_MTYPE_BDATA      0x01
           =3 #define SI_GPTR_MTYPE_PDATA      0x00
           =3 #define SI_GPTR_MTYPE_XDATA      0x00
           =3 #define SI_GPTR_MTYPE_CODE       0x80
           =3 
           =3 // generic pointer access struct
           =3 typedef union SI_GENERIC_PTR
           =3 {
           =3     U8 U8[3];
           =3     struct
           =3     {
           =3         UU16 ADDR;
           =3         U8 MTYPE;
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 34  

           =3     } GPTR;
           =3 } SI_GENERIC_PTR;
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 // Crossware
           =3 // http://www.crossware.com
           =3 
           =3 #elif defined _XC51_VER
           =3 # define SBIT(name, addr, bit)  _sfrbit  name = (addr+bit)
           =3 # define SFR(name, addr)        _sfr     name = addr
           =3 # define SFR16(name, addr)      _sfrword name = addr
           =3 # define SFR16E(name, fulladdr) /* not supported */
           =3 # define SFR32(name, fulladdr)  /* not supported */
           =3 # define SFR32E(name, fulladdr) /* not supported */
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 // Wickenh盲user
           =3 // http://www.wickenhaeuser.de
           =3 
           =3 #elif defined __UC__
           =3 # define SBIT(name, addr, bit)  unsigned char bit  name @ (addr+bit)
           =3 # define SFR(name, addr)        near unsigned char name @ addr
           =3 # define SFR16(name, addr)      /* not supported */
           =3 # define SFR16E(name, fulladdr) /* not supported */
           =3 # define SFR32(name, fulladdr)  /* not supported */
           =3 # define SFR32E(name, fulladdr) /* not supported */
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 // Default
           =3 // Unknown compiler
           =3 
           =3 #else
           =3 # warning unrecognized compiler
           =3 # define SBIT(name, addr, bit)  volatile bool           name
           =3 # define SFR(name, addr)        volatile unsigned char  name
           =3 # define SFRX(name, addr)       volatile unsigned char  name
           =3 # define SFR16(name, addr)      volatile unsigned short name
           =3 # define SFR16E(name, fulladdr) volatile unsigned short name
           =3 # define SFR32(name, fulladdr)  volatile unsigned long  name
           =3 # define SFR32E(name, fulladdr) volatile unsigned long  name
           =3 
           =3 #endif
 798      =3  
 799      =3  //-----------------------------------------------------------------------------
 800      =3  // Header File PreProcessor Directive
 801      =3  //-----------------------------------------------------------------------------
 802      =3  
 803      =3  #endif                                 // #define COMPILER_DEFS_H
 804      =3  
 805      =3  //-----------------------------------------------------------------------------
 806      =3  // End Of File
 807      =3  //-----------------------------------------------------------------------------
 121      =2  #ifdef C8051F020
 122      =2  #include "C8051F020_defs.h"
   1      =3  //-----------------------------------------------------------------------------
   2      =3  // C8051F020_defs.h
   3      =3  //-----------------------------------------------------------------------------
   4      =3  // Copyright 2007, Silicon Laboratories, Inc.
   5      =3  // http://www.silabs.com
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 35  

   6      =3  //
   7      =3  // Program Description:
   8      =3  //
   9      =3  // Register/bit definitions for the C8051F02x family.
  10      =3  // **Important Note**: The compiler_defs.h header file should be included
  11      =3  // before including this header file.
  12      =3  //
  13      =3  // Target:         C8051F020, 'F021, 'F022, 'F023
  14      =3  // Tool chain:     Generic
  15      =3  // Command Line:   None
  16      =3  //
  17      =3  // Release 1.4 - 20 AUG 2012 (TP)
  18      =3  //    -Added #define for _XPAGE to provide support for SDCC memory paging
  19      =3  //     (pdata)
  20      =3  // Release 1.3 - 07 AUG 2007 (PKC)
  21      =3  //    -Removed #include <compiler_defs.h>. The C source file should include it.
  22      =3  // Release 1.2 - 09 JUL 2007 (PKC)
  23      =3  //    -Reformatted header file to enable portable SFR definitions
  24      =3  
  25      =3  //-----------------------------------------------------------------------------
  26      =3  // Header File Preprocessor Directive
  27      =3  //-----------------------------------------------------------------------------
  28      =3  
  29      =3  #ifndef C8051F020_DEFS_H
  30      =3  #define C8051F020_DEFS_H
  31      =3  
  32      =3  //-----------------------------------------------------------------------------
  33      =3  // Byte Registers
  34      =3  //-----------------------------------------------------------------------------
  35      =3  
  36      =3  SFR (P0, 0x80);                        // Port 0 Latch
  37      =3  SFR (SP, 0x81);                        // Stack Pointer
  38      =3  SFR (DPL, 0x82);                       // Data Pointer Low
  39      =3  SFR (DPH, 0x83);                       // Data Pointer High
  40      =3  SFR (P4, 0x84);                        // Port 4 Latch
  41      =3  SFR (P5, 0x85);                        // Port 5 Latch
  42      =3  SFR (P6, 0x86);                        // Port 6 Latch
  43      =3  SFR (PCON, 0x87);                      // Power Control
  44      =3  SFR (TCON, 0x88);                      // Timer/Counter Control
  45      =3  SFR (TMOD, 0x89);                      // Timer/Counter Mode
  46      =3  SFR (TL0, 0x8A);                       // Timer/Counter 0 Low
  47      =3  SFR (TL1, 0x8B);                       // Timer/Counter 1 Low
  48      =3  SFR (TH0, 0x8C);                       // Timer/Counter 0 High
  49      =3  SFR (TH1, 0x8D);                       // Timer/Counter 1 High
  50      =3  SFR (CKCON, 0x8E);                     // Clock Control
  51      =3  SFR (PSCTL, 0x8F);                     // Program Store R/W Control
  52      =3  SFR (P1, 0x90);                        // Port 1 Latch
  53      =3  SFR (TMR3CN, 0x91);                    // Timer/Counter 3 Control
  54      =3  SFR (TMR3RLL, 0x92);                   // Timer/Counter 3 Reload Low
  55      =3  SFR (TMR3RLH, 0x93);                   // Timer/Counter 3 Reload High
  56      =3  SFR (TMR3L, 0x94);                     // Timer/Counter 3 Low
  57      =3  SFR (TMR3H, 0x95);                     // Timer/Counter 3 High
  58      =3  SFR (P7, 0x96);                        // Port 7 Latch
  59      =3  SFR (SCON0, 0x98);                     // Serial Port UART0 Control
  60      =3  SFR (SBUF0, 0x99);                     // Serial Port UART0 Data Buffer
  61      =3  SFR (SPI0CFG, 0x9A);                   // SPI0 Configuration
  62      =3  SFR (SPI0DAT, 0x9B);                   // SPI0 Data
  63      =3  SFR (ADC1, 0x9C);                      // ADC1 Data
  64      =3  SFR (SPI0CKR, 0x9D);                   // SPI0 Clock Rate Control
  65      =3  SFR (CPT0CN, 0x9E);                    // Comparator 0 Control
  66      =3  SFR (CPT1CN, 0x9F);                    // Comparator 1 Control
  67      =3  SFR (P2, 0xA0);                        // Port 2 Latch
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 36  

  68      =3  SFR (EMI0TC, 0xA1);                    // EMIF Timing Control
  69      =3  SFR (EMI0CF, 0xA3);                    // EMIF Configuration
  70      =3  SFR (P0MDOUT, 0xA4);                   // Port 0 Output Mode Configuration
  71      =3  SFR (P1MDOUT, 0xA5);                   // Port 1 Output Mode Configuration
  72      =3  SFR (P2MDOUT, 0xA6);                   // Port 2 Output Mode Configuration
  73      =3  SFR (P3MDOUT, 0xA7);                   // Port 3 Output Mode Configuration
  74      =3  SFR (IE, 0xA8);                        // Interrupt Enable
  75      =3  SFR (SADDR0, 0xA9);                    // Serial Port UART0 Slave Address
  76      =3  SFR (ADC1CN, 0xAA);                    // ADC1 Control
  77      =3  SFR (ADC1CF, 0xAB);                    // ADC1 Analog Mux Configuration
  78      =3  SFR (AMX1SL, 0xAC);                    // ADC1 Analog Mux Channel Select
  79      =3  SFR (P3IF, 0xAD);                      // Port 3 External Interrupt Flags
  80      =3  SFR (SADEN1, 0xAE);                    // Serial Port UART1 Slave Address Mask
  81      =3  SFR (EMI0CN, 0xAF);                    // EMIF Control
  82      =3  SFR (P3, 0xB0);                        // Port 3 Latch
  83      =3  SFR (OSCXCN, 0xB1);                    // External Oscillator Control
  84      =3  SFR (OSCICN, 0xB2);                    // Internal Oscillator Control
  85      =3  SFR (P74OUT, 0xB5);                    // Ports 4 - 7 Output Mode
  86      =3  SFR (FLSCL, 0xB6);                     // Flash Memory Timing Prescaler
  87      =3  SFR (FLACL, 0xB7);                     // Flash Acess Limit
  88      =3  SFR (IP, 0xB8);                        // Interrupt Priority
  89      =3  SFR (SADEN0, 0xB9);                    // Serial Port UART0 Slave Address Mask
  90      =3  SFR (AMX0CF, 0xBA);                    // ADC0 Mux Configuration
  91      =3  SFR (AMX0SL, 0xBB);                    // ADC0 Mux Channel Selection
  92      =3  SFR (ADC0CF, 0xBC);                    // ADC0 Configuration
  93      =3  SFR (P1MDIN, 0xBD);                    // Port 1 Input Mode
  94      =3  SFR (ADC0L, 0xBE);                     // ADC0 Data Low
  95      =3  SFR (ADC0H, 0xBF);                     // ADC0 Data High
  96      =3  SFR (SMB0CN, 0xC0);                    // SMBus0 Control
  97      =3  SFR (SMB0STA, 0xC1);                   // SMBus0 Status
  98      =3  SFR (SMB0DAT, 0xC2);                   // SMBus0 Data
  99      =3  SFR (SMB0ADR, 0xC3);                   // SMBus0 Slave Address
 100      =3  SFR (ADC0GTL, 0xC4);                   // ADC0 Greater-Than Register Low
 101      =3  SFR (ADC0GTH, 0xC5);                   // ADC0 Greater-Than Register High
 102      =3  SFR (ADC0LTL, 0xC6);                   // ADC0 Less-Than Register Low
 103      =3  SFR (ADC0LTH, 0xC7);                   // ADC0 Less-Than Register High
 104      =3  SFR (T2CON, 0xC8);                     // Timer/Counter 2 Control
 105      =3  SFR (T4CON, 0xC9);                     // Timer/Counter 4 Control
 106      =3  SFR (RCAP2L, 0xCA);                    // Timer/Counter 2 Capture Low
 107      =3  SFR (RCAP2H, 0xCB);                    // Timer/Counter 2 Capture High
 108      =3  SFR (TL2, 0xCC);                       // Timer/Counter 2 Low
 109      =3  SFR (TH2, 0xCD);                       // Timer/Counter 2 High
 110      =3  SFR (SMB0CR, 0xCF);                    // SMBus0 Clock Rate
 111      =3  SFR (PSW, 0xD0);                       // Program Status Word
 112      =3  SFR (REF0CN, 0xD1);                    // Voltage Reference 0 Control
 113      =3  SFR (DAC0L, 0xD2);                     // DAC0 Register Low
 114      =3  SFR (DAC0H, 0xD3);                     // DAC0 Register High
 115      =3  SFR (DAC0CN, 0xD4);                    // DAC0 Control
 116      =3  SFR (DAC1L, 0xD5);                     // DAC1 Register Low
 117      =3  SFR (DAC1H, 0xD6);                     // DAC1 Register High
 118      =3  SFR (DAC1CN, 0xD7);                    // DAC1 Control
 119      =3  SFR (PCA0CN, 0xD8);                    // PCA0 Control
 120      =3  SFR (PCA0MD, 0xD9);                    // PCA0 Mode
 121      =3  SFR (PCA0CPM0, 0xDA);                  // PCA0 Module 0 Mode Register
 122      =3  SFR (PCA0CPM1, 0xDB);                  // PCA0 Module 1 Mode Register
 123      =3  SFR (PCA0CPM2, 0xDC);                  // PCA0 Module 2 Mode Register
 124      =3  SFR (PCA0CPM3, 0xDD);                  // PCA0 Module 3 Mode Register
 125      =3  SFR (PCA0CPM4, 0xDE);                  // PCA0 Module 4 Mode Register
 126      =3  SFR (ACC, 0xE0);                       // Accumulator
 127      =3  SFR (XBR0, 0xE1);                      // Port I/O Crossbar Control 0
 128      =3  SFR (XBR1, 0xE2);                      // Port I/O Crossbar Control 1
 129      =3  SFR (XBR2, 0xE3);                      // Port I/O Crossbar Control 2
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 37  

 130      =3  SFR (RCAP4L, 0xE4);                    // Timer 4 Capture Register Low
 131      =3  SFR (RCAP4H, 0xE5);                    // Timer 4 Capture Register High
 132      =3  SFR (EIE1, 0xE6);                      // External Interrupt Enable 1
 133      =3  SFR (EIE2, 0xE7);                      // External Interrupt Enable 2
 134      =3  SFR (ADC0CN, 0xE8);                    // ADC0 Control
 135      =3  SFR (PCA0L, 0xE9);                     // PCA0 Counter Low
 136      =3  SFR (PCA0CPL0, 0xEA);                  // PCA0 Capture 0 Low
 137      =3  SFR (PCA0CPL1, 0xEB);                  // PCA0 Capture 1 Low
 138      =3  SFR (PCA0CPL2, 0xEC);                  // PCA0 Capture 2 Low
 139      =3  SFR (PCA0CPL3, 0xED);                  // PCA0 Capture 3 Low
 140      =3  SFR (PCA0CPL4, 0xEE);                  // PCA0 Capture 4 Low
 141      =3  SFR (RSTSRC, 0xEF);                    // Reset Source Configuration/Status
 142      =3  SFR (B, 0xF0);                         // B Register
 143      =3  SFR (SCON1, 0xF1);                     // Serial Port UART1 Control
 144      =3  SFR (SBUF1, 0xF2);                     // Serail Port UART1 Data
 145      =3  SFR (SADDR1, 0xF3);                    // Serail Port UART1 Slave Address
 146      =3  SFR (TL4, 0xF4);                       // Timer/Counter 4 Low
 147      =3  SFR (TH4, 0xF5);                       // Timer/Counter 4 High
 148      =3  SFR (EIP1, 0xF6);                      // External Interrupt Priority 1
 149      =3  SFR (EIP2, 0xF7);                      // External Interrupt Priority 2
 150      =3  SFR (SPI0CN, 0xF8);                    // SPI0 Control
 151      =3  SFR (PCA0H, 0xF9);                     // PCA0 Counter High
 152      =3  SFR (PCA0CPH0, 0xFA);                  // PCA0 Capture 0 High
 153      =3  SFR (PCA0CPH1, 0xFB);                  // PCA0 Capture 1 High
 154      =3  SFR (PCA0CPH2, 0xFC);                  // PCA0 Capture 2 High
 155      =3  SFR (PCA0CPH3, 0xFD);                  // PCA0 Capture 3 High
 156      =3  SFR (PCA0CPH4, 0xFE);                  // PCA0 Capture 4 High
 157      =3  SFR (WDTCN, 0xFF);                     // Watchdog Timer Control
 158      =3  
 159      =3  //-----------------------------------------------------------------------------
 160      =3  // 16-bit Register Definitions (might not be supported by all compilers)
 161      =3  //-----------------------------------------------------------------------------
 162      =3  
 163      =3  SFR16 (DP, 0x82);                      // Data Pointer
 164      =3  SFR16 (TMR3RL, 0x92);                  // Timer3 Reload Value
 165      =3  SFR16 (TMR3, 0x94);                    // Timer3 Counter
 166      =3  SFR16 (ADC0, 0xBE);                    // ADC0 Data
 167      =3  SFR16 (ADC0GT, 0xC4);                  // ADC0 Greater Than Window
 168      =3  SFR16 (ADC0LT, 0xC6);                  // ADC0 Less Than Window
 169      =3  SFR16 (RCAP2, 0xCA);                   // Timer2 Capture/Reload
 170      =3  SFR16 (T2, 0xCC);                      // Timer2 Counter
 171      =3  SFR16 (TMR2RL, 0xCA);                  // Timer2 Capture/Reload
 172      =3  SFR16 (TMR2, 0xCC);                    // Timer2 Counter
 173      =3  SFR16 (RCAP4, 0xE4);                   // Timer4 Capture/Reload
 174      =3  SFR16 (T4, 0xF4);                      // Timer4 Counter
 175      =3  SFR16 (TMR4RL, 0xE4);                  // Timer4 Capture/Reload
 176      =3  SFR16 (TMR4, 0xF4);                    // Timer4 Counter
 177      =3  SFR16 (DAC0, 0xD2);                    // DAC0 Data
 178      =3  SFR16 (DAC1, 0xD5);                    // DAC1 Data
 179      =3  
 180      =3  //-----------------------------------------------------------------------------
 181      =3  // Address Definitions for bit-addressable SFRs
 182      =3  //-----------------------------------------------------------------------------
 183      =3  
 184      =3  #define SFR_P0       0x80
 185      =3  #define SFR_TCON     0x88
 186      =3  #define SFR_P1       0x90
 187      =3  #define SFR_SCON0    0x98
 188      =3  #define SFR_P2       0xA0
 189      =3  #define SFR_IE       0xA8
 190      =3  #define SFR_P3       0xB0
 191      =3  #define SFR_IP       0xB8
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 38  

 192      =3  #define SFR_SMB0CN   0xC0
 193      =3  #define SFR_T2CON    0xC8
 194      =3  #define SFR_PSW      0xD0
 195      =3  #define SFR_PCA0CN   0xD8
 196      =3  #define SFR_ACC      0xE0
 197      =3  #define SFR_ADC0CN   0xE8
 198      =3  #define SFR_B        0xF0
 199      =3  #define SFR_SPI0CN   0xF8
 200      =3  
 201      =3  //-----------------------------------------------------------------------------
 202      =3  // Bit Definitions
 203      =3  //-----------------------------------------------------------------------------
 204      =3  
 205      =3  // TCON 0x88
 206      =3  SBIT (TF1, SFR_TCON, 7);               // Timer 1 Overflow Flag
 207      =3  SBIT (TR1, SFR_TCON, 6);               // Timer 1 On/Off Control
 208      =3  SBIT (TF0, SFR_TCON, 5);               // Timer 0 Overflow Flag
 209      =3  SBIT (TR0, SFR_TCON, 4);               // Timer 0 On/Off Control
 210      =3  SBIT (IE1, SFR_TCON, 3);               // Ext. Interrupt 1 Edge Flag
 211      =3  SBIT (IT1, SFR_TCON, 2);               // Ext. Interrupt 1 Type
 212      =3  SBIT (IE0, SFR_TCON, 1);               // Ext. Interrupt 0 Edge Flag
 213      =3  SBIT (IT0, SFR_TCON, 0);               // Ext. Interrupt 0 Type
 214      =3  
 215      =3  // SCON0 0x98
 216      =3  SBIT (SM00, SFR_SCON0, 7);             // Serial Mode Control Bit 0
 217      =3  SBIT (SM10, SFR_SCON0, 6);             // Serial Mode Control Bit 1
 218      =3  SBIT (SM20, SFR_SCON0, 5);             // Multiprocessor Communication Enable
 219      =3  SBIT (REN0, SFR_SCON0, 4);             // Receive Enable
 220      =3  SBIT (TB80, SFR_SCON0, 3);             // Transmit Bit 8
 221      =3  SBIT (RB80, SFR_SCON0, 2);             // Receive Bit 8
 222      =3  SBIT (TI0, SFR_SCON0, 1);              // Transmit Interrupt Flag
 223      =3  SBIT (RI0, SFR_SCON0, 0);              // Receive Interrupt Flag
 224      =3  
 225      =3  // IE 0xA8
 226      =3  SBIT (EA, SFR_IE, 7);                  // Global Interrupt Enable
 227      =3  SBIT (IEGF0, SFR_IE, 6);               // General Purpose Flag 0
 228      =3  SBIT (ET2, SFR_IE, 5);                 // Timer 2 Interrupt Enable
 229      =3  SBIT (ES0, SFR_IE, 4);                 // Uart0 Interrupt Enable
 230      =3  SBIT (ET1, SFR_IE, 3);                 // Timer 1 Interrupt Enable
 231      =3  SBIT (EX1, SFR_IE, 2);                 // External Interrupt 1 Enable
 232      =3  SBIT (ET0, SFR_IE, 1);                 // Timer 0 Interrupt Enable
 233      =3  SBIT (EX0, SFR_IE, 0);                 // External Interrupt 0 Enable
 234      =3  
 235      =3  // IP 0xB8
 236      =3                                         // Bit7 UNUSED
 237      =3                                         // Bit6 UNUSED
 238      =3  SBIT (PT2, SFR_IP, 5);                 // Timer 2 Priority
 239      =3  SBIT (PS, SFR_IP, 4);                  // Serial Port Priority
 240      =3  SBIT (PT1, SFR_IP, 3);                 // Timer 1 Priority
 241      =3  SBIT (PX1, SFR_IP, 2);                 // External Interrupt 1 Priority
 242      =3  SBIT (PT0, SFR_IP, 1);                 // Timer 0 Priority
 243      =3  SBIT (PX0, SFR_IP, 0);                 // External Interrupt 0 Priority
 244      =3  
 245      =3  // SMB0CN 0xC0
 246      =3  SBIT (BUSY, SFR_SMB0CN, 7);            // SMBus 0 Busy
 247      =3  SBIT (ENSMB, SFR_SMB0CN, 6);           // SMBus 0 Enable
 248      =3  SBIT (STA, SFR_SMB0CN, 5);             // SMBus 0 Start Flag
 249      =3  SBIT (STO, SFR_SMB0CN, 4);             // SMBus 0 Stop Flag
 250      =3  SBIT (SI, SFR_SMB0CN, 3);              // SMBus 0 Interrupt Pending Flag
 251      =3  SBIT (AA, SFR_SMB0CN, 2);              // SMBus 0 Assert/Acknowledge Flag
 252      =3  SBIT (SMBFTE, SFR_SMB0CN, 1);          // SMBus 0 Free Timer Enable
 253      =3  SBIT (SMBTOE, SFR_SMB0CN, 0);          // SMBus 0 Timeout Enable
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 39  

 254      =3  
 255      =3  // T2CON 0xC8
 256      =3  SBIT (TF2, SFR_T2CON, 7);              // Timer 2 Overflow Flag
 257      =3  SBIT (EXF2, SFR_T2CON, 6);             // External Flag
 258      =3  SBIT (RCLK0, SFR_T2CON, 5);            // Uart0 Rx Clock Source
 259      =3  SBIT (TCLK0, SFR_T2CON, 4);            // Uart0 Tx Clock Source
 260      =3  SBIT (EXEN2, SFR_T2CON, 3);            // Timer 2 External Enable Flag
 261      =3  SBIT (TR2, SFR_T2CON, 2);              // Timer 2 On/Off Control
 262      =3  SBIT (CT2, SFR_T2CON, 1);              // Timer Or Counter Select
 263      =3  SBIT (CPRL2, SFR_T2CON, 0);            // Capture Or Reload Select
 264      =3  
 265      =3  //  PSW 0xD0
 266      =3  SBIT (CY, SFR_PSW, 7);                 // Carry Flag
 267      =3  SBIT (AC, SFR_PSW, 6);                 // Auxiliary Carry Flag
 268      =3  SBIT (F0, SFR_PSW, 5);                 // User Flag 0
 269      =3  SBIT (RS1, SFR_PSW, 4);                // Register Bank Select 1
 270      =3  SBIT (RS0, SFR_PSW, 3);                // Register Bank Select 0
 271      =3  SBIT (OV, SFR_PSW, 2);                 // Overflow Flag
 272      =3  SBIT (F1, SFR_PSW, 1);                 // User Flag 1
 273      =3  SBIT (P, SFR_PSW, 0);                  // Accumulator Parity Flag
 274      =3  
 275      =3  // PCA0CN 0xD8
 276      =3  SBIT (CF, SFR_PCA0CN, 7);              // PCA 0 Counter Overflow Flag
 277      =3  SBIT (CR, SFR_PCA0CN, 6);              // PCA 0 Counter Run Control Bit
 278      =3                                         // Bit5 UNUSED
 279      =3  SBIT (CCF4, SFR_PCA0CN, 4);            // PCA 0 Module 4 Interrupt Flag
 280      =3  SBIT (CCF3, SFR_PCA0CN, 3);            // PCA 0 Module 3 Interrupt Flag
 281      =3  SBIT (CCF2, SFR_PCA0CN, 2);            // PCA 0 Module 2 Interrupt Flag
 282      =3  SBIT (CCF1, SFR_PCA0CN, 1);            // PCA 0 Module 1 Interrupt Flag
 283      =3  SBIT (CCF0, SFR_PCA0CN, 0);            // PCA 0 Module 0 Interrupt Flag
 284      =3  
 285      =3  // ADC0CN 0xE8
 286      =3  SBIT (AD0EN, SFR_ADC0CN, 7);           // ADC 0 Enable
 287      =3  SBIT (AD0TM, SFR_ADC0CN, 6);           // ADC 0 Track Mode
 288      =3  SBIT (AD0INT, SFR_ADC0CN, 5);          // ADC 0 Converision Complete Interrupt Flag
 289      =3  SBIT (AD0BUSY, SFR_ADC0CN, 4);         // ADC 0 Busy Flag
 290      =3  SBIT (AD0CM1, SFR_ADC0CN, 3);          // ADC 0 Start Of Conversion Mode Bit 1
 291      =3  SBIT (AD0CM0, SFR_ADC0CN, 2);          // ADC 0 Start Of Conversion Mode Bit 0
 292      =3  SBIT (AD0WINT, SFR_ADC0CN, 1);         // ADC 0 Window Compare Interrupt Flag
 293      =3  SBIT (AD0LJST, SFR_ADC0CN, 0);         // ADC 0 Right Justify Data Bit
 294      =3  
 295      =3  // SPI0CN 0xF8
 296      =3  SBIT (SPIF, SFR_SPI0CN, 7);            // SPI 0 Interrupt Flag
 297      =3  SBIT (WCOL, SFR_SPI0CN, 6);            // SPI 0 Write Collision Flag
 298      =3  SBIT (MODF, SFR_SPI0CN, 5);            // SPI 0 Mode Fault Flag
 299      =3  SBIT (RXOVRN, SFR_SPI0CN, 4);          // SPI 0 Rx Overrun Flag
 300      =3  SBIT (TXBSY, SFR_SPI0CN, 3);           // SPI 0 Tx Busy Flag
 301      =3  SBIT (SLVSEL, SFR_SPI0CN, 2);          // SPI 0 Slave Select
 302      =3  SBIT (MSTEN, SFR_SPI0CN, 1);           // SPI 0 Master Enable
 303      =3  SBIT (SPIEN, SFR_SPI0CN, 0);           // SPI 0 SPI Enable
 304      =3  
 305      =3  //-----------------------------------------------------------------------------
 306      =3  // Interrupt Priorities
 307      =3  //-----------------------------------------------------------------------------
 308      =3  
 309      =3  #define INTERRUPT_INT0           0     // External Interrupt 0
 310      =3  #define INTERRUPT_TIMER0         1     // Timer0 Overflow
 311      =3  #define INTERRUPT_INT1           2     // External Interrupt 1
 312      =3  #define INTERRUPT_TIMER1         3     // Timer1 Overflow
 313      =3  #define INTERRUPT_UART0          4     // Serial Port UART0
 314      =3  #define INTERRUPT_TIMER2         5     // Timer2 Overflow
 315      =3  #define INTERRUPT_SPI0           6     // SPI0 Interface
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 40  

 316      =3  #define INTERRUPT_SMBUS0         7     // SMBus0 Interface
 317      =3  #define INTERRUPT_ADC0_WINDOW    8     // ADC0 Window Comparison
 318      =3  #define INTERRUPT_PCA0           9     // PCA0 Peripheral
 319      =3  #define INTERRUPT_COMPARATOR0F   10    // Comparator0 Falling Edge
 320      =3  #define INTERRUPT_COMPARATOR0R   11    // Comparator0 Rising Edge
 321      =3  #define INTERRUPT_COMPARATOR1F   12    // Comparator1 Falling Edge
 322      =3  #define INTERRUPT_COMPARATOR1R   13    // Comparator1 Rising Edge
 323      =3  #define INTERRUPT_TIMER3         14    // Timer3 Overflow
 324      =3  #define INTERRUPT_ADC0_EOC       15    // ADC0 End Of Conversion
 325      =3  #define INTERRUPT_TIMER4         16    // Timer4 Overflow
 326      =3  #define INTERRUPT_ADC1_EOC       17    // ADC1 End Of Conversion
 327      =3  #define INTERRUPT_INT6           18    // External Interrupt 6
 328      =3  #define INTERRUPT_INT7           19    // External Interrupt 7
 329      =3  #define INTERRUPT_UART1          20    // Serial Port UART1
 330      =3  #define INTERRUPT_XTAL_READY     21    // External Crystal Oscillator Ready
 331      =3  
 332      =3  //-----------------------------------------------------------------------------
 333      =3  // SDCC PDATA External Memory Paging Support
 334      =3  //-----------------------------------------------------------------------------
 335      =3  
 336      =3  #if defined SDCC
           =3 
           =3 SFR(_XPAGE, 0xAF); // Point to the EMI0CN register
           =3 
           =3 #endif
 341      =3  
 342      =3  //-----------------------------------------------------------------------------
 343      =3  // Header File PreProcessor Directive
 344      =3  //-----------------------------------------------------------------------------
 345      =3  
 346      =3  #endif                                 // #define C8051F020_DEFS_H
 347      =3  
 348      =3  //-----------------------------------------------------------------------------
 349      =3  // End Of File
 350      =3  //-----------------------------------------------------------------------------
 123      =2  #endif
 124      =2  #ifdef C8051F340
           =2 #include "C8051F340_defs.h"
           =2 #endif
 127      =2  /*****************************************************************************/
 128      =2  #include <stdio.h>
   1      =3  /*--------------------------------------------------------------------------
   2      =3  STDIO.H
   3      =3  
   4      =3  Prototypes for standard I/O functions.
   5      =3  Copyright (c) 1988-2002 Keil Elektronik GmbH and Keil Software, Inc.
   6      =3  All rights reserved.
   7      =3  --------------------------------------------------------------------------*/
   8      =3  
   9      =3  #ifndef __STDIO_H__
  10      =3  #define __STDIO_H__
  11      =3  
  12      =3  #ifndef EOF
  13      =3   #define EOF -1
  14      =3  #endif
  15      =3  
  16      =3  #ifndef NULL
           =3  #define NULL ((void *) 0)
           =3 #endif
  19      =3  
  20      =3  #ifndef _SIZE_T
  21      =3   #define _SIZE_T
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 41  

  22      =3   typedef unsigned int size_t;
  23      =3  #endif
  24      =3  
  25      =3  #pragma SAVE
  26      =3  #pragma REGPARMS
  27      =3  extern char _getkey (void);
  28      =3  extern char getchar (void);
  29      =3  extern char ungetchar (char);
  30      =3  extern char putchar (char);
  31      =3  extern int printf   (const char *, ...);
  32      =3  extern int sprintf  (char *, const char *, ...);
  33      =3  extern int vprintf  (const char *, char *);
  34      =3  extern int vsprintf (char *, const char *, char *);
  35      =3  extern char *gets (char *, int n);
  36      =3  extern int scanf (const char *, ...);
  37      =3  extern int sscanf (char *, const char *, ...);
  38      =3  extern int puts (const char *);
  39      =3  
  40      =3  #pragma RESTORE
  41      =3  
  42      =3  #endif
  43      =3  
 129      =2  #include <stdlib.h> 
   1      =3  /*--------------------------------------------------------------------------
   2      =3  STDLIB.H
   3      =3  
   4      =3  Standard functions.
   5      =3  Copyright (c) 1988-2008 Keil Elektronik GmbH and Keil Software, Inc.
   6      =3  Copyright (c) 2008-2016 ARM Germany GmbH
   7      =3  All rights reserved.
   8      =3  --------------------------------------------------------------------------*/
   9      =3  
  10      =3  #ifndef __STDLIB_H__
  11      =3  #define __STDLIB_H__
  12      =3  
  13      =3  #ifndef _SIZE_T
           =3  #define _SIZE_T
           =3  typedef unsigned int size_t;
           =3 #endif
  17      =3  
  18      =3  #ifndef NULL
           =3  #define NULL ((void *)0)
           =3 #endif
  21      =3  
  22      =3  #ifndef _WCHAR_T_DEFINED_
  23      =3  #define _WCHAR_T_DEFINED_
  24      =3  typedef char wchar_t;
  25      =3  #endif
  26      =3  
  27      =3  #if defined (__CX2__)
           =3 #ifndef _DIV_T_DEFINED
           =3 typedef struct _div_t {
           =3         int quot;
           =3         int rem;
           =3 } div_t;
           =3 typedef struct _ldiv_t {
           =3         long quot;
           =3         long rem;
           =3 } ldiv_t;
           =3 #define _DIV_T_DEFINED
           =3 #endif // _DIV_T_DEFINED
           =3 #endif // __CX2__
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 42  

  40      =3  
  41      =3  #ifndef RAND_MAX
  42      =3   #define RAND_MAX  32767u
  43      =3  #endif
  44      =3  
  45      =3  #if defined (__CX2__)
           =3 #pragma SAVE
           =3 #pragma FUNCTIONS(STATIC)
           =3 /* intrinsic functions are reentrant, but need static attribute */
           =3 extern int    abs  (int   val);
           =3 #pragma RESTORE
           =3 #endif // __CX2__
  52      =3  
  53      =3  #pragma SAVE
  54      =3  #pragma REGPARMS
  55      =3  
  56      =3  extern char   cabs (char  val);
  57      =3  #if !defined (__CX2__)
  58      =3  extern int    abs  (int   val);
  59      =3  #endif // __CX2__
  60      =3  extern long   labs (long  val);
  61      =3  
  62      =3  extern float  atof (const char *s1);
  63      =3  extern long   atol (const char *s1);
  64      =3  extern int    atoi (const char *s1);
  65      =3  extern int    rand (void);
  66      =3  extern void   srand (unsigned int seed);
  67      =3  
  68      =3  #ifdef _DIV_T_DEFINED
           =3 extern div_t  __div (int numer, int denom);
           =3 #define div(numer,denom)  __div((numer),(denom));
           =3 extern ldiv_t ldiv (long numer, long denom);
           =3 #endif // _DIV_T_DEFINED
  73      =3  
  74      =3  extern float         strtod  (const char *nptr, char **endptr);
  75      =3  extern long          strtol  (const char *nptr, char **endptr, unsigned char base);
  76      =3  extern unsigned long strtoul (const char *nptr, char **endptr, unsigned char base);
  77      =3  
  78      =3  #define _MALLOC_MEM_    xdata
  79      =3  
  80      =3  extern void init_mempool          (void _MALLOC_MEM_ *p, size_t size);
  81      =3  extern void _MALLOC_MEM_ *malloc  (size_t size);
  82      =3  extern void free                  (void _MALLOC_MEM_ *p);
  83      =3  extern void _MALLOC_MEM_ *realloc (void _MALLOC_MEM_ *p, size_t size);
  84      =3  extern void _MALLOC_MEM_ *calloc  (size_t nmemb, size_t size);
  85      =3  
  86      =3  #if defined (__CX2__)
           =3 extern void abort(void);
           =3 #endif // __CX2__
  89      =3  
  90      =3  #pragma RESTORE
  91      =3  
  92      =3  #endif // __STDLIB_H__
 130      =2  #include <string.h>
   1      =3  /*--------------------------------------------------------------------------
   2      =3  STRING.H
   3      =3  
   4      =3  String functions.
   5      =3  Copyright (c) 1988-2008 Keil Elektronik GmbH and Keil Software, Inc.
   6      =3  Copyright (c) 2008-2016 ARM Germany GmbH
   7      =3  All rights reserved.
   8      =3  --------------------------------------------------------------------------*/
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 43  

   9      =3  
  10      =3  #ifndef __STRING_H__
  11      =3  #define __STRING_H__
  12      =3  
  13      =3  #ifndef _SIZE_T
           =3  #define _SIZE_T
           =3  typedef unsigned int size_t;
           =3 #endif
  17      =3  
  18      =3  #ifndef NULL
           =3  #define NULL ((void *)0)
           =3 #endif
  21      =3  
  22      =3  #pragma SAVE
  23      =3  #pragma REGPARMS
  24      =3  extern char  *strcat  (char *s1, const char *s2);
  25      =3  extern char  *strncat (char *s1, const char *s2, size_t n);
  26      =3  
  27      =3  extern char   strcmp  (const char *s1, const char *s2);
  28      =3  extern char   strncmp (const char *s1, const char *s2, size_t n);
  29      =3  
  30      =3  extern char  *strcpy  (char *s1, const char *s2);
  31      =3  extern char  *strncpy (char *s1, const char *s2, size_t n);
  32      =3  
  33      =3  extern size_t strlen  (const char *);
  34      =3  
  35      =3  extern char  *strchr  (const char *s, char c);
  36      =3  extern int    strpos  (const char *s, char c);
  37      =3  extern char  *strrchr (const char *s, char c);
  38      =3  extern int    strrpos (const char *s, char c);
  39      =3  
  40      =3  extern size_t strspn  (const char *s, const char *set);
  41      =3  extern size_t strcspn (const char *s, const char *set);
  42      =3  extern char  *strpbrk (const char *s, const char *set);
  43      =3  extern char  *strrpbrk(const char *s, const char *set);
  44      =3  extern char  *strstr  (const char *s, const char *sub);
  45      =3  extern char  *strtok  (char *str, const char *set);
  46      =3  
  47      =3  extern char   memcmp  (const void *s1, const void *s2, size_t n);
  48      =3  extern void  *memcpy  (void *s1, const void *s2, size_t n);
  49      =3  extern void  *memchr  (const void *s, char val, size_t n);
  50      =3  extern void  *memccpy (void *s1, const void *s2, char val, size_t n);
  51      =3  extern void  *memmove (void *s1, const void *s2, size_t n);
  52      =3  extern void  *memset  (void *s, char val, size_t n);
  53      =3  #pragma RESTORE
  54      =3  
  55      =3  #endif
 131      =2  #include <INTRINS.H>
   1      =3  /*--------------------------------------------------------------------------
   2      =3  INTRINS.H
   3      =3  
   4      =3  Intrinsic functions for C51.
   5      =3  Copyright (c) 1988-2010 Keil Elektronik GmbH and ARM Germany GmbH
   6      =3  All rights reserved.
   7      =3  --------------------------------------------------------------------------*/
   8      =3  
   9      =3  #ifndef __INTRINS_H__
  10      =3  #define __INTRINS_H__
  11      =3  
  12      =3  #pragma SAVE
  13      =3  
  14      =3  #if defined (__CX2__)
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 44  

           =3 #pragma FUNCTIONS(STATIC)
           =3 /* intrinsic functions are reentrant, but need static attribute */
           =3 #endif
  18      =3  
  19      =3  extern void          _nop_     (void);
  20      =3  extern bit           _testbit_ (bit);
  21      =3  extern unsigned char _cror_    (unsigned char, unsigned char);
  22      =3  extern unsigned int  _iror_    (unsigned int,  unsigned char);
  23      =3  extern unsigned long _lror_    (unsigned long, unsigned char);
  24      =3  extern unsigned char _crol_    (unsigned char, unsigned char);
  25      =3  extern unsigned int  _irol_    (unsigned int,  unsigned char);
  26      =3  extern unsigned long _lrol_    (unsigned long, unsigned char);
  27      =3  extern unsigned char _chkfloat_(float);
  28      =3  #if defined (__CX2__)
           =3 extern int           abs       (int);
           =3 extern void          _illop_   (void);
           =3 #endif
  32      =3  #if !defined (__CX2__)
  33      =3  extern void          _push_    (unsigned char _sfr);
  34      =3  extern void          _pop_     (unsigned char _sfr);
  35      =3  #endif
  36      =3  
  37      =3  #pragma RESTORE
  38      =3  
  39      =3  #endif
  40      =3  
 132      =2  #include <ctype.h>
   1      =3  /*--------------------------------------------------------------------------
   2      =3  CTYPE.H
   3      =3  
   4      =3  Prototypes for character functions.
   5      =3  Copyright (c) 1988-2002 Keil Elektronik GmbH and Keil Software, Inc.
   6      =3  All rights reserved.
   7      =3  --------------------------------------------------------------------------*/
   8      =3  
   9      =3  #ifndef __CTYPE_H__
  10      =3  #define __CTYPE_H__
  11      =3  
  12      =3  #pragma SAVE
  13      =3  #pragma REGPARMS
  14      =3  extern bit isalpha (unsigned char);
  15      =3  extern bit isalnum (unsigned char);
  16      =3  extern bit iscntrl (unsigned char);
  17      =3  extern bit isdigit (unsigned char);
  18      =3  extern bit isgraph (unsigned char);
  19      =3  extern bit isprint (unsigned char);
  20      =3  extern bit ispunct (unsigned char);
  21      =3  extern bit islower (unsigned char);
  22      =3  extern bit isupper (unsigned char);
  23      =3  extern bit isspace (unsigned char);
  24      =3  extern bit isxdigit (unsigned char);
  25      =3  extern unsigned char tolower (unsigned char);
  26      =3  extern unsigned char toupper (unsigned char);
  27      =3  extern unsigned char toint (unsigned char);
  28      =3  
  29      =3  #define _tolower(c) ( (c)-'A'+'a' )
  30      =3  #define _toupper(c) ( (c)-'a'+'A' )
  31      =3  #define toascii(c)  ( (c) & 0x7F )
  32      =3  #pragma RESTORE
  33      =3  
  34      =3  #endif
 133      =2  #include <LIMITS.H>
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 45  

   1      =3  /*--------------------------------------------------------------------------
   2      =3  LIMITS.H
   3      =3  
   4      =3  ANSI standard include file.
   5      =3  Copyright (c) 1988-2008 Keil Elektronik GmbH and Keil Software, Inc.
   6      =3  Copyright (c) 2009 ARM Germany GmbH
   7      =3  All rights reserved.
   8      =3  --------------------------------------------------------------------------*/
   9      =3  
  10      =3  #ifndef __LIMITS_H__
  11      =3  #define __LIMITS_H__
  12      =3  
  13      =3  #define CHAR_BIT         8              /* Number of bits in any "char" */
  14      =3  #define CHAR_MAX         127            /* Max             "char" value */
  15      =3  #define CHAR_MIN       (-128)           /* Min             "char" value */
  16      =3  #define SCHAR_MAX        127            /* Max "signed"    "char" value */
  17      =3  #define SCHAR_MIN      (-128)           /* Min "signed"    "char" value */
  18      =3  #define UCHAR_MAX        255            /* Max "unsigned"  "char" value */
  19      =3  #define SHRT_MAX         32767          /* Max ("signed") "short" value */
  20      =3  #define SHRT_MIN       (-32767-1)       /* Min ("signed") "short" value */
  21      =3  #define USHRT_MAX        0xFFFF         /* Max "unsigned" "short" value */
  22      =3  #define INT_MAX          32767          /* Max ("signed")   "int" value */
  23      =3  #define INT_MIN        (-32767-1)       /* Min ("signed")   "int" value */
  24      =3  #define UINT_MAX         0xFFFF         /* Max "unsigned"   "int" value */
  25      =3  #define LONG_MAX         2147483647     /* Max ("signed")  "long" value */
  26      =3  #define LONG_MIN   (-2147483647L-1L)    /* Min ("signed")  "long" value */
  27      =3  #define ULONG_MAX        0xFFFFFFFF     /* Max "unsigned"  "long" value */
  28      =3  
  29      =3  #endif
 134      =2  #include <math.h>
   1      =3  /*--------------------------------------------------------------------------
   2      =3  MATH.H
   3      =3  
   4      =3  Prototypes for mathematic functions.
   5      =3  Copyright (c) 1988-2008 Keil Elektronik GmbH and Keil Software, Inc.
   6      =3  Copyright (c) 2008-2016 ARM Germany GmbH
   7      =3  All rights reserved.
   8      =3  --------------------------------------------------------------------------*/
   9      =3  
  10      =3  #ifndef __MATH_H__
  11      =3  #define __MATH_H__
  12      =3  
  13      =3  #if defined __CX2__ && (__CX2__ >= 558 || __CX2__ == 556 && __CX2_MINOR__ >= 207)
           =3 #ifndef HUGE_VAL
           =3 #define HUGE_VAL __inf__
           =3 #endif // HUGE_VAL
           =3 
           =3 #ifndef NAN
           =3 #define NAN __nan__
           =3 #endif // NAN
           =3 
           =3 #pragma SAVE
           =3 #pragma FUNCTIONS(STATIC)
           =3 /* intrinsic functions are reentrant, but need static attribute */
           =3 extern int    abs  (int   val);
           =3 #pragma RESTORE
           =3 #endif
  28      =3  
  29      =3  #pragma SAVE
  30      =3  #pragma REGPARMS
  31      =3  #if !defined (__CX2__)
  32      =3  extern char  cabs  (char  val);
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 46  

  33      =3  extern int    abs  (int   val);
  34      =3  extern long  labs  (long  val);
  35      =3  #endif
  36      =3  
  37      =3  extern float fabs  (float val);
  38      =3  extern float sqrt  (float val);
  39      =3  extern float exp   (float val);
  40      =3  extern float log   (float val);
  41      =3  extern float log10 (float val);
  42      =3  extern float sin   (float val);
  43      =3  extern float cos   (float val);
  44      =3  extern float tan   (float val);
  45      =3  extern float asin  (float val);
  46      =3  extern float acos  (float val);
  47      =3  extern float atan  (float val);
  48      =3  extern float sinh  (float val);
  49      =3  extern float cosh  (float val);
  50      =3  extern float tanh  (float val);
  51      =3  extern float atan2 (float y, float x);
  52      =3  
  53      =3  extern float ceil  (float val);
  54      =3  extern float floor (float val);
  55      =3  extern float modf  (float val, float *n);
  56      =3  extern float fmod  (float x, float y);
  57      =3  extern float pow   (float x, float y);
  58      =3  
  59      =3  #if defined (__CX2__)
           =3 extern float frexp (float val, int *exp);
           =3 extern float ldexp (float val, int exp);
           =3 #endif
  63      =3  
  64      =3  #pragma RESTORE
  65      =3  
  66      =3  #endif
 135      =2  #include "crc32.h"
   1      =3  #ifndef __CRC32_H__
   2      =3  #define __CRC32_H__
   3      =3  
   4      =3  //#ifdef __cplusplus
   5      =3  //extern "C" {
   6      =3  //#endif
   7      =3  /*****************************************************************************/
   8      =3  #include "AppConfig.h"
   1      =4  #ifndef __APPCONFIG_H__
           =4 #define __APPCONFIG_H__
           =4 /*****************************************************************************/
           =4 #define CONFIG_SYSCLK                       (22118400L)
           =4 #ifdef C8051F020
           =4 #define SAR_CLK                                                 2000000L//ADC0时钟 <2.5MHz
           =4 #endif
           =4 #define CONFIG_DEBUG                        0//调试功能
           =4 #define CONFIG_USING_WDT                                        0//使能看门狗
           =4 #define CONFIG_USING_RESET                                      0//使能PLC复位MCU功能
           =4 #define CONFIG_LADDER_SECTORS_START                     64//指令起始地址
           =4 #define CONFIG_LADDER_SECTORS_END                       128//指令结束地址
           =4 #define CONFIG_LASERTIMER_OVERFLOW_US           1000L//定时器周期 1mS
           =4 #define CONFIG_VERSION                                          0x0001
           =4 #define CONFIG_CHECK_CODE                                       0x5A00
           =4 
           =4 /*****************************************************************************/
           =4 #define CONFIG_UART0_BAUDRATE                           57600//串口波特率
           =4 #define CONFIG_UART0_PARITY                                     NONE
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 47  

           =4 #define CONFIG_UART0_STOPBIT                            1
           =4 #define CONFIG_UART0_DATABIT                            8
           =4 
           =4 #define CONFIG_UART1_BAUDRATE                           115200//串口波特率
           =4 #define CONFIG_UART1_PARITY                                     NONE
           =4 #define CONFIG_UART1_STOPBIT                            1
           =4 #define CONFIG_UART1_DATABIT                            8
           =4 /*****************************************************************************/
           =4 #define CONFIG_I2C0_FREQ                                        (100000L)               
           =4 #define CONFIG_I2C1_FREQ                                        (100000L)
           =4 #define CONFIG_I2C2_FREQ                                        (100000L)
           =4 #define CONFIG_I2C3_FREQ                                        (100000L)
           =4 #define CONFIG_I2C4_FREQ                                        (100000L)
           =4 /*****************************************************************************/
           =4 #define CONFIG_EPROM_SIZE                                       CONFIG_AT24C64_SIZE
           =4 #define CONFIG_AT24C02_SIZE                             256
           =4 #define CONFIG_AT24C04_SIZE                             512
           =4 #define CONFIG_AT24C08_SIZE                             1024
           =4 #define CONFIG_AT24C16_SIZE                             2048
           =4 #define CONFIG_AT24C32_SIZE                             4096
           =4 #define CONFIG_AT24C64_SIZE                                     8192
           =4 #define CONFIG_AT24C128_SIZE                            16384
           =4 #define CONFIG_AT24C256_SIZE                            32768
           =4 #define CONFIG_EPROM_ADDRESS                            0x50
           =4 #define CONFIG_EPROM_FRAM                                       0//铁电存储体无写入等待
           =4 #define CONFIG_EPROM_FREQ                                       1//
           =4 /*****************************************************************************/
           =4 #define CONFIG_USE_IPID                                         1//使能IPID温度控制
           =4 /*****************************************************************************/
           =4 #define CONFIG_USE_HWVER_SHOW                           1//使能固件版本显示
           =4 #define CONFIG_USE_MPD1_SHOW                            1//使能MPD1测量显示
           =4 #define CONFIG_USE_MPD2_SHOW                            1//使能MPD2测量显示
           =4 #define CONFIG_USE_FBS1                                         1//使能FBS1检测
           =4 #define CONFIG_USE_FBS2                                         1//使能FBS2检测
           =4 #define CONFIG_USE_LASER_TEMP                           1//使能激光器温度显示
           =4 #define CONFIG_USE_RADIATOR_TEMP                        1//使能散热器温度显示
           =4 #define CONFIG_USE_ENVI_TEMP                            1//使能环境温度显示
           =4 #define CONFIG_USE_IPID_UPDATE                          1//使能IPID参数更新功能
           =4 #define CONFIG_USE_IPID_OUTSHOW                         1//使能IPID输出显示
           =4 /*****************************************************************************/
           =4 //SPLC设置
           =4 #define CONFIG_SPLC_IO_INPUT_NUM                        16//硬件输入点数
           =4 #define CONFIG_SPLC_IO_OUTPUT_NUM                       16//硬件输出点数
           =4 #define CONFIG_SOFTPLC_HWTIME                           1000L//1mS
           =4 #define CONFIG_INPUT_FILTER_TIME                        3//输入数字滤波扫描周期 1mS * N
           =4 #define CONFIG_IPID_RUN_CYCLE                           40//IPID运行周期 默认 40 * 100mS
           =4 #define CONFIG_IPID_PWM_CYCLE                           20//IPID输出周期 默认 20 * 100mS
           =4 /*****************************************************************************/
           =4 #define CONFIG_SPLC_USING_WDT                           0//看门狗启用
           =4 /*****************************************************************************/
           =4 #define CONFIG_SPLC_USING_IO_INPUT                      1//输入IO刷新启用
           =4 /*****************************************************************************/
           =4 #define CONFIG_SPLC_USING_IO_OUTPUT                     1//输出IO刷新启用
           =4 /*****************************************************************************/
           =4 #define CONFIG_SPLC_USING_EPROM                         1//EPROM掉电存储启用
           =4 /*****************************************************************************/
           =4 #define CONFIG_SPLC_USING_ADC                           1//使能ADC模块
           =4 #define CONFIG_SPLC_ADC_FILTER_TAP                      18//ADC位移滤波次数
           =4 #define CONFIG_SPLC_ADC_CHANNLE                         50//ADC通道数
           =4 #define CONFIG_SPLC_ADC_TEMP_SENSOR_GAIN    3330L// Temp Sensor Gain in (uV / degC)
           =4 #define CONFIG_SPLC_ADC_TEMP_SENSOR_OFFSET  856L// Temp Sensor Offset in mV
           =4 #define CONFIG_SPLC_ADC_INTERNAL_VREF           2200L// ADC Voltage Reference (mV)
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 48  

           =4 #define CONFIG_SPLC_ADC_AMBIENT             25L// Ambient temp in deg C
           =4 /*****************************************************************************/
           =4 #define CONFIG_SPLC_USING_DAC                           1//是能DAC模块
           =4 /*****************************************************************************/
           =4 #define CONFIG_SPLC_USING_MB_RTU_SLAVE          1//是能MODBUS RTU从站
           =4 #define CONFIG_MB_RTU_SLAVE_TIMER                       1000L//1000uS
           =4 #define CONFIG_MB_RTU_SLAVE_ADDRESS                     0x01//从设备地址
           =4 #define CONFIG_MB_RTU_SLAVE_BUFFER_SIZE         256//发送接收缓冲区
           =4 #define CONFIG_MB_RTU_SLAVE_TIMEOUT                     100//接收通讯超时 10mS
           =4 #define CONFIG_MB_RTU_SLAVE_IO_DELAY            1//RX TX切换延时
           =4 /*****************************************************************************/
           =4 
           =4 /*****************************************************************************/
           =4 #define ID_ONLY_1_CHANNEL                                       4321
           =4 #define ID_ONLY_2_CHANNEL                                       8765
           =4 #define ID_BOTH_CHANNEL                                         9431
           =4 #define ID_LASER_MODE_CW                                        7631
           =4 #define ID_LASER_MODE_SP                                        8934
           =4 #define ID_LASER_MODE_MP                                        2453
           =4 #define ID_LASER_MODE_GP                                        3876
           =4 /*****************************************************************************/
           =4 #define FBS1_IN_PORT                                            3
           =4 #define FBS2_IN_PORT                                            2
           =4 #define COOLON_OUT_PORT                                         (1 * 8 + 3)
           =4 /*****************************************************************************/
           =4 //PID FUZZY 模糊PID配置
           =4 #define CONFIG_TECOUT_CYCLE                                     4000//PID输出转PWM周期
           =4 /*****************************************************************************/
           =4 /*****************************************************************************/
           =4 #define DISABLE_MODBUS_SERIAL_INTERRUPT         ES0 = 0;
           =4 #define ENABLE_MODBUS_SERIAL_INTERRUPT          ES0 = 1;
           =4 #define DISABLE_INTERRUPT                                       EA = 0;
           =4 #define ENABLE_INTERRUPT                                        EA = 1;
           =4 /*****************************************************************************/
           =4 #include "stdint.h"
           =4 #include "stdbool.h"
           =4 #include "endian.h"
           =4 #include "si_toolchain.h"
           =4 #include "compiler_defs.h"
           =4 #ifdef C8051F020
           =4 #include "C8051F020_defs.h"
           =4 #endif
           =4 #ifdef C8051F340
           =4 #include "C8051F340_defs.h"
           =4 #endif
           =4 /*****************************************************************************/
           =4 #include <stdio.h>
           =4 #include <stdlib.h> 
           =4 #include <string.h>
           =4 #include <INTRINS.H>
           =4 #include <ctype.h>
           =4 #include <LIMITS.H>
           =4 #include <math.h>
           =4 #include "crc32.h"
           =4 /*****************************************************************************/
           =4 #ifdef C8051F020
           =4 #include "InitDeviceF020.h"
           =4 #endif
           =4 #ifdef C8051F580
           =4 #include "InitDeviceF580.h"
           =4 #endif
           =4 
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 49  

           =4 #include "delay.h"
           =4 #include "i2c0.h"
           =4 //#include "i2c1.h"
           =4 //#include "i2c2.h"
           =4 //#include "i2c3.h"
           =4 //#include "i2c4.h"
           =4 //#include "i2c5.h"
           =4 //#include "i2c6.h"
           =4 #include "eprom.h"
           =4 #include "dac8568_0.h"
           =4 #include "dac8568_1.h"
           =4 #include "dac8568_2.h"
           =4 #include "dac8568_3.h"
           =4 
           =4 //#include "mcp47x6.h"
           =4 //#include "inPca9554.h"
           =4 //#include "outPca9554.h"
           =4 /*****************************************************************************/
           =4 #include "Modbus.h"
           =4 #include "ModbusPort.h"
           =4 /*****************************************************************************/
           =4 //#include "filter.h"
           =4 #include "sPLC.h"
           =4 //#include "pidFuzzy.h"
           =4 /*****************************************************************************/
           =4 //#include "AppMath.h"
           =4 //#include "chipAdc.h"
           =4 //#include "ad5621.h"
           =4 //#include "chipBeem.h"
           =4 
           =4 /*****************************************************************************/
           =4 #endif
   9      =3  /*****************************************************************************/
  10      =3  uint32_t crc32Calculate(uint8_t *buf, uint32_t len);//CRC32 计算数组
  11      =3  uint32_t crc32CalculateAdd(uint8_t dat);//CRC32 计算连续字节
  12      =3  void crc32Clear(void);//清空旧CRC32结果
  13      =3  void crc32SetCrcOld(uint32_t old);
  14      =3  /*****************************************************************************/
  15      =3  //#ifdef __cplusplus
  16      =3  //}
  17      =3  //#endif
  18      =3  #endif
  19      =3  
  20      =3  
  21      =3  
 136      =2  /*****************************************************************************/
 137      =2  #ifdef C8051F020
 138      =2  #include "InitDeviceF020.h"
   1      =3  #ifndef __INITDEVICEF020_H__
   2      =3  #define __INITDEVICEF020_H__
   3      =3  /*****************************************************************************/
   4      =3  #include "compiler_defs.h"
   1      =4  //-----------------------------------------------------------------------------
   2      =4  // compiler_defs.h
   3      =4  //-----------------------------------------------------------------------------
   4      =4  // Portions of this file are copyright Maarten Brock
   5      =4  // http://sdcc.sourceforge.net
   6      =4  // Portions of this file are Copyright 2014 Silicon Laboratories, Inc.
   7      =4  // http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   8      =4  //
   9      =4  // GNU LGPL boilerplate:
  10      =4  /** This library is free software; you can redistribute it and/or
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 50  

  11      =4    * modify it under the terms of the GNU Lesser General Public
  12      =4    * License as published by the Free Software Foundation; either
  13      =4    * version 2.1 of the License, or (at your option) any later version.
  14      =4    *
  15      =4    * This library is distributed in the hope that it will be useful,
  16      =4    * but WITHOUT ANY WARRANTY; without even the implied warranty of
  17      =4    * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
  18      =4    * Lesser General Public License for more details.
  19      =4    *
  20      =4    * You should have received a copy of the GNU Lesser General Public
  21      =4    * License along with this library; if not, write to the Free Software
  22      =4    * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  23      =4    *
  24      =4    * In other words, you are welcome to use, share and improve this program.
  25      =4    * You are forbidden to forbid anyone else to use, share and improve
  26      =4    * what you give them. Help stamp out software-hoarding!
  27      =4  **/
  28      =4  // Program Description:
  29      =4  //
  30      =4  // **Important Note**: This header file should be included before including
  31      =4  // a device-specific header file such as C8051F300_defs.h.
  32      =4  //
  33      =4  // Macro definitions to accomodate 8051 compiler differences in specifying
  34      =4  // special function registers and other 8051-specific features such as NOP
  35      =4  // generation, and locating variables in memory-specific segments.  The
  36      =4  // compilers are identified by their unique predefined macros. See also:
  37      =4  // http://predef.sourceforge.net/precomp.html
  38      =4  //
  39      =4  // SBIT and SFR define special bit and special function registers at the given
  40      =4  // address. SFR16 and SFR32 define sfr combinations at adjacent addresses in
  41      =4  // little-endian format. SFR16E and SFR32E define sfr combinations without
  42      =4  // prerequisite byte order or adjacency. None of these multi-byte sfr
  43      =4  // combinations will guarantee the order in which they are accessed when read
  44      =4  // or written.
  45      =4  //
  46      =4  // SFR16X and SFR32X for 16 bit and 32 bit xdata registers are not defined
  47      =4  // to avoid portability issues because of compiler endianness.
  48      =4  //
  49      =4  // Example:
  50      =4  // // my_mcu.c: main 'c' file for my mcu
  51      =4  // #include <compiler_defs.h>  // this file
  52      =4  // #include <C8051xxxx_defs.h> // SFR definitions for specific MCU target
  53      =4  //
  54      =4  // SBIT  (P0_1, 0x80, 1);      // Port 0 pin 1
  55      =4  // SFR   (P0, 0x80);           // Port 0
  56      =4  // SFRX  (CPUCS, 0xE600);      // Cypress FX2 Control and Status register in
  57      =4  //                             // xdata memory at 0xE600
  58      =4  // SFR16 (TMR2, 0xCC);         // Timer 2, lsb at 0xCC, msb at 0xCD
  59      =4  // SFR16E(TMR0, 0x8C8A);       // Timer 0, lsb at 0x8A, msb at 0x8C
  60      =4  // SFR32 (MAC0ACC, 0x93);      // SiLabs C8051F120 32 bits MAC0 Accumulator,
  61      =4  //                             // lsb at 0x93, msb at 0x96
  62      =4  // SFR32E(SUMR, 0xE5E4E3E2);   // TI MSC1210 SUMR 32 bits Summation register,
  63      =4  //                             // lsb at 0xE2, msb at 0xE5
  64      =4  //
  65      =4  // Target:         C8051xxxx
  66      =4  // Tool chain:     Generic
  67      =4  // Command Line:   None
  68      =4  // 
  69      =4  // Release 2.7 - 25 JUN 2014 (JM)
  70      =4  //    -Added SI_GENERIC_PTR struct for accessing generic pointers
  71      =4  //    -Added SI_GPTR_MTYPE_XXXX definitions for determining the memory type
  72      =4  //     pointed at by a generic poitner
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 51  

  73      =4  // Release 2.6 - 14 DEC 2012 (GO)
  74      =4  //        -Added define for deprecated SDCC keyword 'at'
  75      =4  // Release 2.5 - 12 SEP 2012 (TP)
  76      =4  //    -Added defines for deprecated SDCC keywords bit and code
  77      =4  // Release 2.4 - 27 AUG 2012 (TP)
  78      =4  //    -Added defines for deprecated SDCC keywords interrupt, _asm, and _endasm
  79      =4  // Release 2.3 - 27 MAY 2010 (DM)
  80      =4  //    -Removed 'LOCATED_VARIABLE' pragma from Keil because it is not supported
  81      =4  // Release 2.2 - 06 APR 2010 (ES)
  82      =4  //    -Removed 'PATHINCLUDE' pragma from Raisonance section
  83      =4  // Release 2.1 - 16 JUL 2009 (ES)
  84      =4  //    -Added SEGMENT_POINTER macro definitions for SDCC, Keil, and Raisonance
  85      =4  //    -Added LOCATED_VARIABLE_NO_INIT macro definitions for Raisonance
  86      =4  // Release 2.0 - 19 MAY 2009 (ES)
  87      =4  //    -Added LOCATED_VARIABLE_NO_INIT macro definitions for SDCC and Keil
  88      =4  // Release 1.9 - 23 OCT 2008 (ES)
  89      =4  //    -Updated Hi-Tech INTERRUPT and INTERRUPT_USING macro definitions
  90      =4  //    -Added SFR16 macro defintion for Hi-Tech
  91      =4  // Release 1.8 - 31 JUL 2008 (ES)
  92      =4  //    -Added INTERRUPT_USING and FUNCTION_USING macro's
  93      =4  //    -Added macro's for IAR
  94      =4  //    -Corrected Union definitions for Hi-Tech and added SFR16 macro defintion
  95      =4  // Release 1.7 - 11 SEP 2007 (BW)
  96      =4  //    -Added support for Raisonance EVAL 03.03.42 and Tasking Eval 7.2r1
  97      =4  // Release 1.6 - 27 AUG 2007 (BW)
  98      =4  //    -Updated copyright notice per agreement with Maartin Brock
  99      =4  //    -Added SDCC 2.7.0 "compiler.h" bug fixes
 100      =4  //    -Added memory segment defines (SEG_XDATA, for example)
 101      =4  // Release 1.5 - 24 AUG 2007 (BW)
 102      =4  //    -Added support for NOP () macro
 103      =4  //    -Added support for Hi-Tech ver 9.01
 104      =4  // Release 1.4 - 07 AUG 2007 (PKC)
 105      =4  //    -Removed FID and fixed formatting.
 106      =4  // Release 1.3 - 30 SEP 2007 (TP)
 107      =4  //    -Added INTERRUPT_PROTO_USING to properly support ISR context switching
 108      =4  //     under SDCC.
 109      =4  // Release 1.2 - (BW)
 110      =4  //    -Added support for U8,U16,U32,S8,S16,S32,UU16,UU32 data types
 111      =4  // Release 1.1 - (BW)
 112      =4  //    -Added support for INTERRUPT, INTERRUPT_USING, INTERRUPT_PROTO,
 113      =4  //     SEGMENT_VARIABLE, VARIABLE_SEGMENT_POINTER,
 114      =4  //     SEGMENT_VARIABLE_SEGMENT_POINTER, and LOCATED_VARIABLE
 115      =4  // Release 1.0 - 29 SEP 2006 (PKC)
 116      =4  //    -Initial revision
 117      =4  
 118      =4  //-----------------------------------------------------------------------------
 119      =4  // Header File Preprocessor Directive
 120      =4  //-----------------------------------------------------------------------------
 121      =4  
 122      =4  #ifndef COMPILER_DEFS_H
           =4 #define COMPILER_DEFS_H
           =4 
           =4 #include "stdbool.h"
           =4 #include "stdint.h"
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 // Macro definitions
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 //SDK Version
           =4 #define SDK_VERSION   2
           =4 
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 52  

           =4 #ifndef NULL
           =4 #define NULL ((void*) 0)
           =4 #endif
           =4 
           =4 
           =4 // SDCC - Small Device C Compiler
           =4 // http://sdcc.sourceforge.net
           =4 
           =4 #if defined SDCC
           =4 
           =4 #if (SDCC >= 300)
           =4 
           =4 #define interrupt __interrupt
           =4 #define _asm __asm
           =4 #define _endasm __endasm
           =4 #define bit __bit
           =4 #define code __code
           =4 #define at __at
           =4 
           =4 #endif
           =4 
           =4 # define SEG_GENERIC
           =4 # define SEG_FAR   __xdata
           =4 # define SEG_DATA  __data
           =4 # define SEG_NEAR  __data
           =4 # define SEG_IDATA __idata
           =4 # define SEG_XDATA __xdata
           =4 # define SEG_PDATA __pdata
           =4 # define SEG_CODE  __code
           =4 # define SEG_BDATA __bdata
           =4 
           =4 # define SBIT(name, addr, bit)  __sbit  __at(addr+bit)                  name
           =4 # define SFR(name, addr)        __sfr   __at(addr)                      name
           =4 # define SFRX(name, addr)       xdata volatile unsigned char __at(addr) name
           =4 # define SFR16(name, addr)      __sfr16 __at(((addr+1U)<<8) | addr)     name
           =4 # define SFR16E(name, fulladdr) __sfr16 __at(fulladdr)                  name
           =4 # define SFR32(name, addr)      __sfr32 __at(((addr+3UL)<<24) | ((addr+2UL)<<16) | ((addr+1UL)<<8) | addr)
             - name
           =4 # define SFR32E(name, fulladdr) __sfr32 __at(fulladdr)                  name
           =4 
           =4 # define INTERRUPT(name, vector) void name (void) interrupt (vector)
           =4 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt (vector) using (regnum)
           =4 # define INTERRUPT_PROTO(name, vector) void name (void) interrupt (vector)
           =4 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void) interrupt (vector) using (regnum)
           =4 
           =4 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using (regnum
             -)
           =4 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter) using (
             -regnum)
           =4 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =4 
           =4 # define SEGMENT_VARIABLE(name, vartype, locsegment) locsegment vartype name
           =4 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) targsegment vartype * name
           =4 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) targsegment vartype * lo
             -csegment name
           =4 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
           =4 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment at (addr) vartype name = init
           =4 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) locsegment at (addr) vartype name
           =4 
           =4 // used with UU16
           =4 # define LSB 0
           =4 # define MSB 1
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 53  

           =4 
           =4 // used with UU32 (b0 is least-significant byte)
           =4 # define b0 0
           =4 # define b1 1
           =4 # define b2 2
           =4 # define b3 3
           =4 
           =4 typedef unsigned char U8;
           =4 typedef unsigned int U16;
           =4 typedef unsigned long U32;
           =4 
           =4 typedef signed char S8;
           =4 typedef signed int S16;
           =4 typedef signed long S32;
           =4 
           =4 typedef union UU16
           =4 {
           =4    U16 U16;
           =4    S16 S16;
           =4    U8 U8[2];
           =4    S8 S8[2];
           =4 } UU16;
           =4 
           =4 typedef union UU32
           =4 {
           =4    U32 U32;
           =4    S32 S32;
           =4    UU16 UU16[2];
           =4    U16 U16[2];
           =4    S16 S16[2];
           =4    U8 U8[4];
           =4    S8 S8[4];
           =4 } UU32;
           =4 
           =4 // NOP () macro support
           =4 #define NOP() _asm NOP _endasm
           =4 
           =4 // generic pointer memory type specifiers
           =4 #define SI_GPTR
           =4 #define SI_GPTR_MTYPE_DATA       0x40
           =4 #define SI_GPTR_MTYPE_IDATA      0x40
           =4 #define SI_GPTR_MTYPE_BDATA      0x40
           =4 #define SI_GPTR_MTYPE_PDATA      0x60
           =4 #define SI_GPTR_MTYPE_XDATA      0x00
           =4 #define SI_GPTR_MTYPE_CODE       0x80
           =4 
           =4 // generic pointer access struct
           =4 typedef union SI_GENERIC_PTR
           =4 {
           =4     U8 U8[3];
           =4     struct
           =4     {
           =4         UU16 ADDR;
           =4         U8 MTYPE;
           =4     } GPTR;
           =4 } SI_GENERIC_PTR;
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 // Raisonance (must be placed before Keil C51)
           =4 // http://www.raisonance.com
           =4 
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 54  

           =4 #elif defined __RC51__
           =4 
           =4 //#error Raisonance C51 detected.
           =4 
           =4 # define SEG_GENERIC generic     //SEG_GENERIC only applies to pointers in Raisonance, not variables.
           =4 # define SEG_FAR   xdata
           =4 # define SEG_DATA  data
           =4 # define SEG_NEAR  data
           =4 # define SEG_IDATA idata
           =4 # define SEG_XDATA xdata
           =4 # define SEG_PDATA pdata
           =4 # define SEG_CODE  code
           =4 # define SEG_BDATA bdata
           =4 
           =4 # define SBIT(name, addr, bit)  at (addr+bit) sbit         name
           =4 # define SFR(name, addr)        sfr at addr                name
           =4 # define SFR16(name, addr)      sfr16 at addr              name
           =4 # define SFR16E(name, fulladdr) /* not supported */
           =4 # define SFR32(name, fulladdr)  /* not supported */
           =4 # define SFR32E(name, fulladdr) /* not supported */
           =4 
           =4 # define INTERRUPT(name, vector) void name (void) interrupt vector
           =4 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
           =4 # define INTERRUPT_PROTO(name, vector) void name (void)
           =4 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
           =4 
           =4 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using regnum
           =4 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =4 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =4 
           =4 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =4 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =4 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =4 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
           =4 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) at addr locsegment vartype name
           =4 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) at addr locsegment vartype name
           =4 
           =4 
           =4 // used with UU16
           =4 # define LSB 1
           =4 # define MSB 0
           =4 
           =4 // used with UU32 (b0 is least-significant byte)
           =4 # define b0 3
           =4 # define b1 2
           =4 # define b2 1
           =4 # define b3 0
           =4 
           =4 typedef unsigned char U8;
           =4 typedef unsigned int U16;
           =4 typedef unsigned long U32;
           =4 
           =4 typedef signed char S8;
           =4 typedef signed int S16;
           =4 typedef signed long S32;
           =4 
           =4 typedef union UU16
           =4 {
           =4    U16 U16;
           =4    S16 S16;
           =4    U8 U8[2];
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 55  

           =4    S8 S8[2];
           =4 } UU16;
           =4 
           =4 typedef union UU32
           =4 {
           =4    U32 U32;
           =4    S32 S32;
           =4    UU16 UU16[2];
           =4    U16 U16[2];
           =4    S16 S16[2];
           =4    U8 U8[4];
           =4    S8 S8[4];
           =4 } UU32;
           =4 
           =4 // NOP () macro support -- NOP is opcode 0x00
           =4 #define NOP() asm { 0x00 }
           =4 
           =4 // generic pointer memory type specifiers
           =4 #define SI_GPTR
           =4 #define SI_GPTR_MTYPE_DATA       0x04
           =4 #define SI_GPTR_MTYPE_IDATA      0x01
           =4 #define SI_GPTR_MTYPE_BDATA      0x04
           =4 #define SI_GPTR_MTYPE_PDATA      0x03
           =4 #define SI_GPTR_MTYPE_XDATA      0x02
           =4 #define SI_GPTR_MTYPE_CODE       0x05
           =4 
           =4 // generic pointer access struct
           =4 typedef union SI_GENERIC_PTR
           =4 {
           =4     U8 U8[3];
           =4     struct
           =4     {
           =4         U8 MTYPE;
           =4         UU16 ADDR;
           =4     } GPTR;
           =4 } SI_GENERIC_PTR;
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 
           =4 // Keil C51
           =4 // http://www.keil.com
           =4 
           =4 #elif defined __C51__
           =4 
           =4 //#error Keil C51 detected.
           =4 
           =4 # define SEG_GENERIC
           =4 # define SEG_FAR   xdata
           =4 # define SEG_DATA  data
           =4 # define SEG_NEAR  data
           =4 # define SEG_IDATA idata
           =4 # define SEG_XDATA xdata
           =4 # define SEG_PDATA pdata
           =4 # define SEG_CODE  code
           =4 # define SEG_BDATA bdata
           =4 
           =4 # define SBIT(name, addr, bit)  sbit  name = addr^bit
           =4 # define SFR(name, addr)        sfr   name = addr
           =4 # define SFR16(name, addr)      sfr16 name = addr
           =4 # define SFR16E(name, fulladdr) /* not supported */
           =4 # define SFR32(name, fulladdr)  /* not supported */
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 56  

           =4 # define SFR32E(name, fulladdr) /* not supported */
           =4 
           =4 # ifndef __SLS_IDE__
           =4 
           =4 # define INTERRUPT(name, vector) void name (void) interrupt vector
           =4 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
           =4 # define INTERRUPT_PROTO(name, vector) void name (void)
           =4 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
           =4 
           =4 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using regnum
           =4 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =4 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =4 
           =4 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =4 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =4 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =4 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
           =4 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) vartype locsegment name _at_ addr
           =4 
           =4 # else  // __SLS_IDE__
           =4 
           =4 # define INTERRUPT(name, vector) void name (void)
           =4 # define INTERRUPT_USING(name, vector, regnum) void name (void)
           =4 # define INTERRUPT_PROTO(name, vector) void name (void)
           =4 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
           =4 
           =4 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =4 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =4 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =4 
           =4 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype name
           =4 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype * name
           =4 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype * name
           =4 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * name
           =4 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) vartype name
           =4 
           =4 # endif // __SLS_IDE__
           =4 
           =4 // used with UU16
           =4 # define LSB 1
           =4 # define MSB 0
           =4 
           =4 // used with UU32 (b0 is least-significant byte)
           =4 # define b0 3
           =4 # define b1 2
           =4 # define b2 1
           =4 # define b3 0
           =4 
           =4 typedef unsigned char U8;
           =4 typedef unsigned int U16;
           =4 typedef unsigned long U32;
           =4 
           =4 typedef signed char S8;
           =4 typedef signed int S16;
           =4 typedef signed long S32;
           =4 
           =4 typedef union UU16
           =4 {
           =4    U16 U16;
           =4    S16 S16;
           =4    U8 U8[2];
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 57  

           =4    S8 S8[2];
           =4 } UU16;
           =4 
           =4 typedef union UU32
           =4 {
           =4    U32 U32;
           =4    S32 S32;
           =4    UU16 UU16[2];
           =4    U16 U16[2];
           =4    S16 S16[2];
           =4    U8 U8[4];
           =4    S8 S8[4];
           =4 } UU32;
           =4 
           =4 // NOP () macro support
           =4 extern void _nop_ (void);
           =4 #define NOP() _nop_()
           =4 
           =4 // generic pointer memory type specifiers
           =4 #define SI_GPTR
           =4 #define SI_GPTR_MTYPE_DATA      0x00
           =4 #define SI_GPTR_MTYPE_IDATA     0x00
           =4 #define SI_GPTR_MTYPE_BDATA     0x00
           =4 #define SI_GPTR_MTYPE_PDATA     0xFE
           =4 #define SI_GPTR_MTYPE_XDATA     0x01
           =4 #define SI_GPTR_MTYPE_CODE      0xFF
           =4 
           =4 // generic pointer access struct
           =4 typedef union SI_GENERIC_PTR
           =4 {
           =4     U8 U8[3];
           =4     struct
           =4     {
           =4         U8 MTYPE;
           =4         UU16 ADDR;
           =4     } GPTR;
           =4 } SI_GENERIC_PTR;
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 // Hi-Tech 8051
           =4 // http://www.htsoft.com
           =4 
           =4 #elif defined HI_TECH_C
           =4 
           =4 # define SEG_GENERIC
           =4 # define SEG_FAR   far
           =4 # define SEG_DATA  data
           =4 # define SEG_NEAR  near
           =4 # define SEG_IDATA idata
           =4 # define SEG_XDATA xdata
           =4 # define SEG_PDATA pdata
           =4 # define SEG_CODE  code
           =4 # define SEG_BDATA bdata
           =4 
           =4 
           =4 # define SBIT(name, addr, thebit) static volatile bit name @ (addr + thebit)
           =4 # define SFR(name, addr)          static volatile unsigned char name @ addr
           =4 # define SFR16(name, addr)        static volatile unsigned int name @ addr
           =4 # define SFR16E(name, fulladdr) /* not supported */
           =4 # define SFR32(name, fulladdr)  /* not supported */
           =4 # define SFR32E(name, fulladdr) /* not supported */
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 58  

           =4 
           =4 # define INTERRUPT(name, vector)       void name (void) interrupt vector
           =4 # define INTERRUPT_PROTO(name, vector)
           =4 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
           =4 # define INTERRUPT_PROTO_USING(name, vector, regnum)
           =4 
           =4 # define FUNCTION_USING(name, return_value, parameter, regnum) /* not supported */
           =4 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) /* not supported */
           =4 // Note: Hi-Tech does not support functions using different register banks. Register
           =4 //       banks can only be specified in interrupts. If a function is called from
           =4 //       inside an interrupt, it will use the same register bank as the interrupt.
           =4 
           =4 # define SEGMENT_VARIABLE(name, vartype, locsegment) locsegment vartype name
           =4 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) targsegment vartype * name
           =4 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) targsegment vartype * lo
             -csegment name
           =4 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment vartype name @ addr
           =4 
           =4 // used with UU16
           =4 # define LSB 0
           =4 # define MSB 1
           =4 
           =4 // used with UU32 (b0 is least-significant byte)
           =4 # define b0 0
           =4 # define b1 1
           =4 # define b2 2
           =4 # define b3 3
           =4 
           =4 typedef unsigned char U8;
           =4 typedef unsigned int U16;
           =4 typedef unsigned long U32;
           =4 
           =4 typedef signed char S8;
           =4 typedef signed int S16;
           =4 typedef signed long S32;
           =4 
           =4 typedef union UU16
           =4 {
           =4    U16 U16;
           =4    S16 S16;
           =4    U8 U8[2];
           =4    S8 S8[2];
           =4 } UU16;
           =4 
           =4 typedef union UU32
           =4 {
           =4    U32 U32;
           =4    S32 S32;
           =4    UU16 UU16[2];
           =4    U16 U16[2];
           =4    S16 S16[2];
           =4    U8 U8[4];
           =4    S8 S8[4];
           =4 } UU32;
           =4 
           =4 // NOP () macro support
           =4 #define NOP() asm(" nop ")
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 // Tasking / Altium
           =4 // http://www.altium.com/tasking
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 59  

           =4 
           =4 
           =4 #elif defined _CC51
           =4 
           =4 # define SEG_GENERIC
           =4 # define SEG_FAR   _xdat
           =4 # define SEG_DATA  _data
           =4 # define SEG_NEAR  _data
           =4 # define SEG_IDATA _idat
           =4 # define SEG_XDATA _xdat
           =4 # define SEG_PDATA _pdat
           =4 # define SEG_CODE  _rom
           =4 # define SEG_BDATA _bdat
           =4 
           =4 # define SBIT(name, addr, bit)  _sfrbit  name _at(addr+bit)
           =4 # define SFR(name, addr)        _sfrbyte name _at(addr)
           =4 # define SFRX(name, addr)       _xdat volatile unsigned char name _at(addr)
           =4 #if _CC51 > 71
           =4 # define SFR16(name, addr)      _sfrword _little name _at(addr)
           =4 #else
           =4 # define SFR16(name, addr)      /* not supported */
           =4 #endif
           =4 # define SFR16E(name, fulladdr) /* not supported */
           =4 # define SFR32(name, fulladdr)  /* not supported */
           =4 # define SFR32E(name, fulladdr) /* not supported */
           =4 
           =4 # define INTERRUPT(name, vector) _interrupt (vector) void name (void)
           =4 # define INTERRUPT_USING(name, vector, regnum) _interrupt (vector) _using(regnum) void name (void)
           =4 # define INTERRUPT_PROTO(name, vector) _interrupt (vector) void name (void)
           =4 # define INTERRUPT_PROTO_USING(name, vector, regnum) _interrupt (vector) _using(regnum) void name (void)
           =4 
           =4 // When calling FUNCTION_USING in Tasking, the function must be called from an interrupt or Main which
           =4 // is also using the same register bank. If not, the compiler will generate an error.
           =4 # define FUNCTION_USING(name, return_value, parameter, regnum) _using(regnum) return_value name (parameter
             -)
           =4 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) _using(regnum) return_value name (par
             -ameter)
           =4 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =4 
           =4 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =4 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =4 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =4 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) vartype locsegment name _at( addr )
           =4 
           =4 // used with UU16
           =4 # define LSB 1
           =4 # define MSB 0
           =4 
           =4 // used with UU32 (b0 is least-significant byte)
           =4 # define b0 3
           =4 # define b1 2
           =4 # define b2 1
           =4 # define b3 0
           =4 
           =4 typedef unsigned char U8;
           =4 typedef unsigned int U16;
           =4 typedef unsigned long U32;
           =4 
           =4 typedef signed char S8;
           =4 typedef signed int S16;
           =4 typedef signed long S32;
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 60  

           =4 
           =4 typedef union UU16
           =4 {
           =4    U16 U16;
           =4    S16 S16;
           =4    U8 U8[2];
           =4    S8 S8[2];
           =4 } UU16;
           =4 
           =4 typedef union UU32
           =4 {
           =4    U32 U32;
           =4    S32 S32;
           =4    UU16 UU16[2];
           =4    U16 U16[2];
           =4    S16 S16[2];
           =4    U8 U8[4];
           =4    S8 S8[4];
           =4 } UU32;
           =4 
           =4 // NOP () macro support
           =4 extern void _nop (void);
           =4 #define NOP() _nop()
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 
           =4 // IAR 8051
           =4 // http://www.iar.com
           =4 
           =4 #elif defined __ICC8051__
           =4 
           =4 #include <stdbool.h>
           =4 #include <intrinsics.h>
           =4 
           =4 # define SBIT(name, addr, bit)  __bit __no_init volatile bool name @ (addr+bit)
           =4 # define SFR(name, addr)        __sfr __no_init volatile unsigned char name @ addr
           =4 # define SFRX(name, addr)       __xdata __no_init volatile unsigned char name @ addr
           =4 # define SFR16(name, addr)      __sfr __no_init volatile unsigned int  name @ addr
           =4 # define SFR16E(name, fulladdr) /* not supported */
           =4 # define SFR32(name, fulladdr) /* not supported */
           =4 # define SFR32E(name, fulladdr) /* not supported */
           =4 
           =4 # define SEG_GENERIC __generic
           =4 # define SEG_FAR  __xdata
           =4 # define SEG_DATA __data
           =4 # define SEG_NEAR __data
           =4 # define SEG_IDATA __idata
           =4 # define SEG_XDATA __xdata
           =4 # define SEG_PDATA __pdata
           =4 # define SEG_CODE  __code
           =4 # define SEG_BDATA __bdata
           =4 
           =4 #define bit bool
           =4 
           =4 # define _PPTOSTR_(x) #x
           =4 # define _PPARAM_(address) _PPTOSTR_(vector=address * 8 + 3)
           =4 # define _PPARAM2_(regbank) _PPTOSTR_(register_bank=regbank)
           =4 # define INTERRUPT(name, vector) _Pragma(_PPARAM_(vector)) __interrupt void name(void)
           =4 # define INTERRUPT_PROTO(name, vector)  __interrupt void name(void)
           =4 # define INTERRUPT_USING(name, vector, regnum) _Pragma(_PPARAM2_(regnum)) _Pragma(_PPARAM_(vector)) __inte
             -rrupt void name(void)
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 61  

           =4 # define INTERRUPT_PROTO_USING(name, vector, regnum) __interrupt void name(void)
           =4 
           =4 # define FUNCTION_USING(name, return_value, parameter, regnum) /* not supported */
           =4 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) /* not supported */
           =4 // Note: IAR does not support functions using different register banks. Register
           =4 //       banks can only be specified in interrupts. If a function is called from
           =4 //       inside an interrupt, it will use the same register bank as the interrupt.
           =4 
           =4 # define SEGMENT_VARIABLE(name, vartype, locsegment)  locsegment vartype name
           =4 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment  * name
           =4 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =4 
           =4 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment __no_init vartype name @ addr
           =4 
           =4 // used with UU16
           =4 # define LSB 0
           =4 # define MSB 1
           =4 
           =4 // used with UU32 (b0 is least-significant byte)
           =4 # define b0 0
           =4 # define b1 1
           =4 # define b2 2
           =4 # define b3 3
           =4 
           =4 typedef unsigned char U8;
           =4 typedef unsigned int U16;
           =4 typedef unsigned long U32;
           =4 
           =4 typedef signed char S8;
           =4 typedef signed int S16;
           =4 typedef signed long S32;
           =4 
           =4 typedef union UU16
           =4 {
           =4    U16 U16;
           =4    S16 S16;
           =4    U8 U8[2];
           =4    S8 S8[2];
           =4 } UU16;
           =4 
           =4 typedef union UU32
           =4 {
           =4    U32 U32;
           =4    S32 S32;
           =4    UU16 UU16[2];
           =4    U16 U16[2];
           =4    S16 S16[2];
           =4    U8 U8[4];
           =4    S8 S8[4];
           =4 } UU32;
           =4 
           =4 
           =4 #define NOP() __no_operation();
           =4 
           =4 // generic pointer memory type specifiers
           =4 #define SI_GPTR
           =4 #define SI_GPTR_MTYPE_DATA       0x01
           =4 #define SI_GPTR_MTYPE_IDATA      0x01
           =4 #define SI_GPTR_MTYPE_BDATA      0x01
           =4 #define SI_GPTR_MTYPE_PDATA      0x00
           =4 #define SI_GPTR_MTYPE_XDATA      0x00
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 62  

           =4 #define SI_GPTR_MTYPE_CODE       0x80
           =4 
           =4 // generic pointer access struct
           =4 typedef union SI_GENERIC_PTR
           =4 {
           =4     U8 U8[3];
           =4     struct
           =4     {
           =4         UU16 ADDR;
           =4         U8 MTYPE;
           =4     } GPTR;
           =4 } SI_GENERIC_PTR;
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 // Crossware
           =4 // http://www.crossware.com
           =4 
           =4 #elif defined _XC51_VER
           =4 # define SBIT(name, addr, bit)  _sfrbit  name = (addr+bit)
           =4 # define SFR(name, addr)        _sfr     name = addr
           =4 # define SFR16(name, addr)      _sfrword name = addr
           =4 # define SFR16E(name, fulladdr) /* not supported */
           =4 # define SFR32(name, fulladdr)  /* not supported */
           =4 # define SFR32E(name, fulladdr) /* not supported */
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 // Wickenh盲user
           =4 // http://www.wickenhaeuser.de
           =4 
           =4 #elif defined __UC__
           =4 # define SBIT(name, addr, bit)  unsigned char bit  name @ (addr+bit)
           =4 # define SFR(name, addr)        near unsigned char name @ addr
           =4 # define SFR16(name, addr)      /* not supported */
           =4 # define SFR16E(name, fulladdr) /* not supported */
           =4 # define SFR32(name, fulladdr)  /* not supported */
           =4 # define SFR32E(name, fulladdr) /* not supported */
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 // Default
           =4 // Unknown compiler
           =4 
           =4 #else
           =4 # warning unrecognized compiler
           =4 # define SBIT(name, addr, bit)  volatile bool           name
           =4 # define SFR(name, addr)        volatile unsigned char  name
           =4 # define SFRX(name, addr)       volatile unsigned char  name
           =4 # define SFR16(name, addr)      volatile unsigned short name
           =4 # define SFR16E(name, fulladdr) volatile unsigned short name
           =4 # define SFR32(name, fulladdr)  volatile unsigned long  name
           =4 # define SFR32E(name, fulladdr) volatile unsigned long  name
           =4 
           =4 #endif
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 // Header File PreProcessor Directive
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 #endif                                 // #define COMPILER_DEFS_H
 804      =4  
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 63  

 805      =4  //-----------------------------------------------------------------------------
 806      =4  // End Of File
 807      =4  //-----------------------------------------------------------------------------
   5      =3  #include "C8051F020_defs.h"
   1      =4  //-----------------------------------------------------------------------------
   2      =4  // C8051F020_defs.h
   3      =4  //-----------------------------------------------------------------------------
   4      =4  // Copyright 2007, Silicon Laboratories, Inc.
   5      =4  // http://www.silabs.com
   6      =4  //
   7      =4  // Program Description:
   8      =4  //
   9      =4  // Register/bit definitions for the C8051F02x family.
  10      =4  // **Important Note**: The compiler_defs.h header file should be included
  11      =4  // before including this header file.
  12      =4  //
  13      =4  // Target:         C8051F020, 'F021, 'F022, 'F023
  14      =4  // Tool chain:     Generic
  15      =4  // Command Line:   None
  16      =4  //
  17      =4  // Release 1.4 - 20 AUG 2012 (TP)
  18      =4  //    -Added #define for _XPAGE to provide support for SDCC memory paging
  19      =4  //     (pdata)
  20      =4  // Release 1.3 - 07 AUG 2007 (PKC)
  21      =4  //    -Removed #include <compiler_defs.h>. The C source file should include it.
  22      =4  // Release 1.2 - 09 JUL 2007 (PKC)
  23      =4  //    -Reformatted header file to enable portable SFR definitions
  24      =4  
  25      =4  //-----------------------------------------------------------------------------
  26      =4  // Header File Preprocessor Directive
  27      =4  //-----------------------------------------------------------------------------
  28      =4  
  29      =4  #ifndef C8051F020_DEFS_H
           =4 #define C8051F020_DEFS_H
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 // Byte Registers
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 SFR (P0, 0x80);                        // Port 0 Latch
           =4 SFR (SP, 0x81);                        // Stack Pointer
           =4 SFR (DPL, 0x82);                       // Data Pointer Low
           =4 SFR (DPH, 0x83);                       // Data Pointer High
           =4 SFR (P4, 0x84);                        // Port 4 Latch
           =4 SFR (P5, 0x85);                        // Port 5 Latch
           =4 SFR (P6, 0x86);                        // Port 6 Latch
           =4 SFR (PCON, 0x87);                      // Power Control
           =4 SFR (TCON, 0x88);                      // Timer/Counter Control
           =4 SFR (TMOD, 0x89);                      // Timer/Counter Mode
           =4 SFR (TL0, 0x8A);                       // Timer/Counter 0 Low
           =4 SFR (TL1, 0x8B);                       // Timer/Counter 1 Low
           =4 SFR (TH0, 0x8C);                       // Timer/Counter 0 High
           =4 SFR (TH1, 0x8D);                       // Timer/Counter 1 High
           =4 SFR (CKCON, 0x8E);                     // Clock Control
           =4 SFR (PSCTL, 0x8F);                     // Program Store R/W Control
           =4 SFR (P1, 0x90);                        // Port 1 Latch
           =4 SFR (TMR3CN, 0x91);                    // Timer/Counter 3 Control
           =4 SFR (TMR3RLL, 0x92);                   // Timer/Counter 3 Reload Low
           =4 SFR (TMR3RLH, 0x93);                   // Timer/Counter 3 Reload High
           =4 SFR (TMR3L, 0x94);                     // Timer/Counter 3 Low
           =4 SFR (TMR3H, 0x95);                     // Timer/Counter 3 High
           =4 SFR (P7, 0x96);                        // Port 7 Latch
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 64  

           =4 SFR (SCON0, 0x98);                     // Serial Port UART0 Control
           =4 SFR (SBUF0, 0x99);                     // Serial Port UART0 Data Buffer
           =4 SFR (SPI0CFG, 0x9A);                   // SPI0 Configuration
           =4 SFR (SPI0DAT, 0x9B);                   // SPI0 Data
           =4 SFR (ADC1, 0x9C);                      // ADC1 Data
           =4 SFR (SPI0CKR, 0x9D);                   // SPI0 Clock Rate Control
           =4 SFR (CPT0CN, 0x9E);                    // Comparator 0 Control
           =4 SFR (CPT1CN, 0x9F);                    // Comparator 1 Control
           =4 SFR (P2, 0xA0);                        // Port 2 Latch
           =4 SFR (EMI0TC, 0xA1);                    // EMIF Timing Control
           =4 SFR (EMI0CF, 0xA3);                    // EMIF Configuration
           =4 SFR (P0MDOUT, 0xA4);                   // Port 0 Output Mode Configuration
           =4 SFR (P1MDOUT, 0xA5);                   // Port 1 Output Mode Configuration
           =4 SFR (P2MDOUT, 0xA6);                   // Port 2 Output Mode Configuration
           =4 SFR (P3MDOUT, 0xA7);                   // Port 3 Output Mode Configuration
           =4 SFR (IE, 0xA8);                        // Interrupt Enable
           =4 SFR (SADDR0, 0xA9);                    // Serial Port UART0 Slave Address
           =4 SFR (ADC1CN, 0xAA);                    // ADC1 Control
           =4 SFR (ADC1CF, 0xAB);                    // ADC1 Analog Mux Configuration
           =4 SFR (AMX1SL, 0xAC);                    // ADC1 Analog Mux Channel Select
           =4 SFR (P3IF, 0xAD);                      // Port 3 External Interrupt Flags
           =4 SFR (SADEN1, 0xAE);                    // Serial Port UART1 Slave Address Mask
           =4 SFR (EMI0CN, 0xAF);                    // EMIF Control
           =4 SFR (P3, 0xB0);                        // Port 3 Latch
           =4 SFR (OSCXCN, 0xB1);                    // External Oscillator Control
           =4 SFR (OSCICN, 0xB2);                    // Internal Oscillator Control
           =4 SFR (P74OUT, 0xB5);                    // Ports 4 - 7 Output Mode
           =4 SFR (FLSCL, 0xB6);                     // Flash Memory Timing Prescaler
           =4 SFR (FLACL, 0xB7);                     // Flash Acess Limit
           =4 SFR (IP, 0xB8);                        // Interrupt Priority
           =4 SFR (SADEN0, 0xB9);                    // Serial Port UART0 Slave Address Mask
           =4 SFR (AMX0CF, 0xBA);                    // ADC0 Mux Configuration
           =4 SFR (AMX0SL, 0xBB);                    // ADC0 Mux Channel Selection
           =4 SFR (ADC0CF, 0xBC);                    // ADC0 Configuration
           =4 SFR (P1MDIN, 0xBD);                    // Port 1 Input Mode
           =4 SFR (ADC0L, 0xBE);                     // ADC0 Data Low
           =4 SFR (ADC0H, 0xBF);                     // ADC0 Data High
           =4 SFR (SMB0CN, 0xC0);                    // SMBus0 Control
           =4 SFR (SMB0STA, 0xC1);                   // SMBus0 Status
           =4 SFR (SMB0DAT, 0xC2);                   // SMBus0 Data
           =4 SFR (SMB0ADR, 0xC3);                   // SMBus0 Slave Address
           =4 SFR (ADC0GTL, 0xC4);                   // ADC0 Greater-Than Register Low
           =4 SFR (ADC0GTH, 0xC5);                   // ADC0 Greater-Than Register High
           =4 SFR (ADC0LTL, 0xC6);                   // ADC0 Less-Than Register Low
           =4 SFR (ADC0LTH, 0xC7);                   // ADC0 Less-Than Register High
           =4 SFR (T2CON, 0xC8);                     // Timer/Counter 2 Control
           =4 SFR (T4CON, 0xC9);                     // Timer/Counter 4 Control
           =4 SFR (RCAP2L, 0xCA);                    // Timer/Counter 2 Capture Low
           =4 SFR (RCAP2H, 0xCB);                    // Timer/Counter 2 Capture High
           =4 SFR (TL2, 0xCC);                       // Timer/Counter 2 Low
           =4 SFR (TH2, 0xCD);                       // Timer/Counter 2 High
           =4 SFR (SMB0CR, 0xCF);                    // SMBus0 Clock Rate
           =4 SFR (PSW, 0xD0);                       // Program Status Word
           =4 SFR (REF0CN, 0xD1);                    // Voltage Reference 0 Control
           =4 SFR (DAC0L, 0xD2);                     // DAC0 Register Low
           =4 SFR (DAC0H, 0xD3);                     // DAC0 Register High
           =4 SFR (DAC0CN, 0xD4);                    // DAC0 Control
           =4 SFR (DAC1L, 0xD5);                     // DAC1 Register Low
           =4 SFR (DAC1H, 0xD6);                     // DAC1 Register High
           =4 SFR (DAC1CN, 0xD7);                    // DAC1 Control
           =4 SFR (PCA0CN, 0xD8);                    // PCA0 Control
           =4 SFR (PCA0MD, 0xD9);                    // PCA0 Mode
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 65  

           =4 SFR (PCA0CPM0, 0xDA);                  // PCA0 Module 0 Mode Register
           =4 SFR (PCA0CPM1, 0xDB);                  // PCA0 Module 1 Mode Register
           =4 SFR (PCA0CPM2, 0xDC);                  // PCA0 Module 2 Mode Register
           =4 SFR (PCA0CPM3, 0xDD);                  // PCA0 Module 3 Mode Register
           =4 SFR (PCA0CPM4, 0xDE);                  // PCA0 Module 4 Mode Register
           =4 SFR (ACC, 0xE0);                       // Accumulator
           =4 SFR (XBR0, 0xE1);                      // Port I/O Crossbar Control 0
           =4 SFR (XBR1, 0xE2);                      // Port I/O Crossbar Control 1
           =4 SFR (XBR2, 0xE3);                      // Port I/O Crossbar Control 2
           =4 SFR (RCAP4L, 0xE4);                    // Timer 4 Capture Register Low
           =4 SFR (RCAP4H, 0xE5);                    // Timer 4 Capture Register High
           =4 SFR (EIE1, 0xE6);                      // External Interrupt Enable 1
           =4 SFR (EIE2, 0xE7);                      // External Interrupt Enable 2
           =4 SFR (ADC0CN, 0xE8);                    // ADC0 Control
           =4 SFR (PCA0L, 0xE9);                     // PCA0 Counter Low
           =4 SFR (PCA0CPL0, 0xEA);                  // PCA0 Capture 0 Low
           =4 SFR (PCA0CPL1, 0xEB);                  // PCA0 Capture 1 Low
           =4 SFR (PCA0CPL2, 0xEC);                  // PCA0 Capture 2 Low
           =4 SFR (PCA0CPL3, 0xED);                  // PCA0 Capture 3 Low
           =4 SFR (PCA0CPL4, 0xEE);                  // PCA0 Capture 4 Low
           =4 SFR (RSTSRC, 0xEF);                    // Reset Source Configuration/Status
           =4 SFR (B, 0xF0);                         // B Register
           =4 SFR (SCON1, 0xF1);                     // Serial Port UART1 Control
           =4 SFR (SBUF1, 0xF2);                     // Serail Port UART1 Data
           =4 SFR (SADDR1, 0xF3);                    // Serail Port UART1 Slave Address
           =4 SFR (TL4, 0xF4);                       // Timer/Counter 4 Low
           =4 SFR (TH4, 0xF5);                       // Timer/Counter 4 High
           =4 SFR (EIP1, 0xF6);                      // External Interrupt Priority 1
           =4 SFR (EIP2, 0xF7);                      // External Interrupt Priority 2
           =4 SFR (SPI0CN, 0xF8);                    // SPI0 Control
           =4 SFR (PCA0H, 0xF9);                     // PCA0 Counter High
           =4 SFR (PCA0CPH0, 0xFA);                  // PCA0 Capture 0 High
           =4 SFR (PCA0CPH1, 0xFB);                  // PCA0 Capture 1 High
           =4 SFR (PCA0CPH2, 0xFC);                  // PCA0 Capture 2 High
           =4 SFR (PCA0CPH3, 0xFD);                  // PCA0 Capture 3 High
           =4 SFR (PCA0CPH4, 0xFE);                  // PCA0 Capture 4 High
           =4 SFR (WDTCN, 0xFF);                     // Watchdog Timer Control
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 // 16-bit Register Definitions (might not be supported by all compilers)
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 SFR16 (DP, 0x82);                      // Data Pointer
           =4 SFR16 (TMR3RL, 0x92);                  // Timer3 Reload Value
           =4 SFR16 (TMR3, 0x94);                    // Timer3 Counter
           =4 SFR16 (ADC0, 0xBE);                    // ADC0 Data
           =4 SFR16 (ADC0GT, 0xC4);                  // ADC0 Greater Than Window
           =4 SFR16 (ADC0LT, 0xC6);                  // ADC0 Less Than Window
           =4 SFR16 (RCAP2, 0xCA);                   // Timer2 Capture/Reload
           =4 SFR16 (T2, 0xCC);                      // Timer2 Counter
           =4 SFR16 (TMR2RL, 0xCA);                  // Timer2 Capture/Reload
           =4 SFR16 (TMR2, 0xCC);                    // Timer2 Counter
           =4 SFR16 (RCAP4, 0xE4);                   // Timer4 Capture/Reload
           =4 SFR16 (T4, 0xF4);                      // Timer4 Counter
           =4 SFR16 (TMR4RL, 0xE4);                  // Timer4 Capture/Reload
           =4 SFR16 (TMR4, 0xF4);                    // Timer4 Counter
           =4 SFR16 (DAC0, 0xD2);                    // DAC0 Data
           =4 SFR16 (DAC1, 0xD5);                    // DAC1 Data
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 // Address Definitions for bit-addressable SFRs
           =4 //-----------------------------------------------------------------------------
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 66  

           =4 
           =4 #define SFR_P0       0x80
           =4 #define SFR_TCON     0x88
           =4 #define SFR_P1       0x90
           =4 #define SFR_SCON0    0x98
           =4 #define SFR_P2       0xA0
           =4 #define SFR_IE       0xA8
           =4 #define SFR_P3       0xB0
           =4 #define SFR_IP       0xB8
           =4 #define SFR_SMB0CN   0xC0
           =4 #define SFR_T2CON    0xC8
           =4 #define SFR_PSW      0xD0
           =4 #define SFR_PCA0CN   0xD8
           =4 #define SFR_ACC      0xE0
           =4 #define SFR_ADC0CN   0xE8
           =4 #define SFR_B        0xF0
           =4 #define SFR_SPI0CN   0xF8
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 // Bit Definitions
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 // TCON 0x88
           =4 SBIT (TF1, SFR_TCON, 7);               // Timer 1 Overflow Flag
           =4 SBIT (TR1, SFR_TCON, 6);               // Timer 1 On/Off Control
           =4 SBIT (TF0, SFR_TCON, 5);               // Timer 0 Overflow Flag
           =4 SBIT (TR0, SFR_TCON, 4);               // Timer 0 On/Off Control
           =4 SBIT (IE1, SFR_TCON, 3);               // Ext. Interrupt 1 Edge Flag
           =4 SBIT (IT1, SFR_TCON, 2);               // Ext. Interrupt 1 Type
           =4 SBIT (IE0, SFR_TCON, 1);               // Ext. Interrupt 0 Edge Flag
           =4 SBIT (IT0, SFR_TCON, 0);               // Ext. Interrupt 0 Type
           =4 
           =4 // SCON0 0x98
           =4 SBIT (SM00, SFR_SCON0, 7);             // Serial Mode Control Bit 0
           =4 SBIT (SM10, SFR_SCON0, 6);             // Serial Mode Control Bit 1
           =4 SBIT (SM20, SFR_SCON0, 5);             // Multiprocessor Communication Enable
           =4 SBIT (REN0, SFR_SCON0, 4);             // Receive Enable
           =4 SBIT (TB80, SFR_SCON0, 3);             // Transmit Bit 8
           =4 SBIT (RB80, SFR_SCON0, 2);             // Receive Bit 8
           =4 SBIT (TI0, SFR_SCON0, 1);              // Transmit Interrupt Flag
           =4 SBIT (RI0, SFR_SCON0, 0);              // Receive Interrupt Flag
           =4 
           =4 // IE 0xA8
           =4 SBIT (EA, SFR_IE, 7);                  // Global Interrupt Enable
           =4 SBIT (IEGF0, SFR_IE, 6);               // General Purpose Flag 0
           =4 SBIT (ET2, SFR_IE, 5);                 // Timer 2 Interrupt Enable
           =4 SBIT (ES0, SFR_IE, 4);                 // Uart0 Interrupt Enable
           =4 SBIT (ET1, SFR_IE, 3);                 // Timer 1 Interrupt Enable
           =4 SBIT (EX1, SFR_IE, 2);                 // External Interrupt 1 Enable
           =4 SBIT (ET0, SFR_IE, 1);                 // Timer 0 Interrupt Enable
           =4 SBIT (EX0, SFR_IE, 0);                 // External Interrupt 0 Enable
           =4 
           =4 // IP 0xB8
           =4                                        // Bit7 UNUSED
           =4                                        // Bit6 UNUSED
           =4 SBIT (PT2, SFR_IP, 5);                 // Timer 2 Priority
           =4 SBIT (PS, SFR_IP, 4);                  // Serial Port Priority
           =4 SBIT (PT1, SFR_IP, 3);                 // Timer 1 Priority
           =4 SBIT (PX1, SFR_IP, 2);                 // External Interrupt 1 Priority
           =4 SBIT (PT0, SFR_IP, 1);                 // Timer 0 Priority
           =4 SBIT (PX0, SFR_IP, 0);                 // External Interrupt 0 Priority
           =4 
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 67  

           =4 // SMB0CN 0xC0
           =4 SBIT (BUSY, SFR_SMB0CN, 7);            // SMBus 0 Busy
           =4 SBIT (ENSMB, SFR_SMB0CN, 6);           // SMBus 0 Enable
           =4 SBIT (STA, SFR_SMB0CN, 5);             // SMBus 0 Start Flag
           =4 SBIT (STO, SFR_SMB0CN, 4);             // SMBus 0 Stop Flag
           =4 SBIT (SI, SFR_SMB0CN, 3);              // SMBus 0 Interrupt Pending Flag
           =4 SBIT (AA, SFR_SMB0CN, 2);              // SMBus 0 Assert/Acknowledge Flag
           =4 SBIT (SMBFTE, SFR_SMB0CN, 1);          // SMBus 0 Free Timer Enable
           =4 SBIT (SMBTOE, SFR_SMB0CN, 0);          // SMBus 0 Timeout Enable
           =4 
           =4 // T2CON 0xC8
           =4 SBIT (TF2, SFR_T2CON, 7);              // Timer 2 Overflow Flag
           =4 SBIT (EXF2, SFR_T2CON, 6);             // External Flag
           =4 SBIT (RCLK0, SFR_T2CON, 5);            // Uart0 Rx Clock Source
           =4 SBIT (TCLK0, SFR_T2CON, 4);            // Uart0 Tx Clock Source
           =4 SBIT (EXEN2, SFR_T2CON, 3);            // Timer 2 External Enable Flag
           =4 SBIT (TR2, SFR_T2CON, 2);              // Timer 2 On/Off Control
           =4 SBIT (CT2, SFR_T2CON, 1);              // Timer Or Counter Select
           =4 SBIT (CPRL2, SFR_T2CON, 0);            // Capture Or Reload Select
           =4 
           =4 //  PSW 0xD0
           =4 SBIT (CY, SFR_PSW, 7);                 // Carry Flag
           =4 SBIT (AC, SFR_PSW, 6);                 // Auxiliary Carry Flag
           =4 SBIT (F0, SFR_PSW, 5);                 // User Flag 0
           =4 SBIT (RS1, SFR_PSW, 4);                // Register Bank Select 1
           =4 SBIT (RS0, SFR_PSW, 3);                // Register Bank Select 0
           =4 SBIT (OV, SFR_PSW, 2);                 // Overflow Flag
           =4 SBIT (F1, SFR_PSW, 1);                 // User Flag 1
           =4 SBIT (P, SFR_PSW, 0);                  // Accumulator Parity Flag
           =4 
           =4 // PCA0CN 0xD8
           =4 SBIT (CF, SFR_PCA0CN, 7);              // PCA 0 Counter Overflow Flag
           =4 SBIT (CR, SFR_PCA0CN, 6);              // PCA 0 Counter Run Control Bit
           =4                                        // Bit5 UNUSED
           =4 SBIT (CCF4, SFR_PCA0CN, 4);            // PCA 0 Module 4 Interrupt Flag
           =4 SBIT (CCF3, SFR_PCA0CN, 3);            // PCA 0 Module 3 Interrupt Flag
           =4 SBIT (CCF2, SFR_PCA0CN, 2);            // PCA 0 Module 2 Interrupt Flag
           =4 SBIT (CCF1, SFR_PCA0CN, 1);            // PCA 0 Module 1 Interrupt Flag
           =4 SBIT (CCF0, SFR_PCA0CN, 0);            // PCA 0 Module 0 Interrupt Flag
           =4 
           =4 // ADC0CN 0xE8
           =4 SBIT (AD0EN, SFR_ADC0CN, 7);           // ADC 0 Enable
           =4 SBIT (AD0TM, SFR_ADC0CN, 6);           // ADC 0 Track Mode
           =4 SBIT (AD0INT, SFR_ADC0CN, 5);          // ADC 0 Converision Complete Interrupt Flag
           =4 SBIT (AD0BUSY, SFR_ADC0CN, 4);         // ADC 0 Busy Flag
           =4 SBIT (AD0CM1, SFR_ADC0CN, 3);          // ADC 0 Start Of Conversion Mode Bit 1
           =4 SBIT (AD0CM0, SFR_ADC0CN, 2);          // ADC 0 Start Of Conversion Mode Bit 0
           =4 SBIT (AD0WINT, SFR_ADC0CN, 1);         // ADC 0 Window Compare Interrupt Flag
           =4 SBIT (AD0LJST, SFR_ADC0CN, 0);         // ADC 0 Right Justify Data Bit
           =4 
           =4 // SPI0CN 0xF8
           =4 SBIT (SPIF, SFR_SPI0CN, 7);            // SPI 0 Interrupt Flag
           =4 SBIT (WCOL, SFR_SPI0CN, 6);            // SPI 0 Write Collision Flag
           =4 SBIT (MODF, SFR_SPI0CN, 5);            // SPI 0 Mode Fault Flag
           =4 SBIT (RXOVRN, SFR_SPI0CN, 4);          // SPI 0 Rx Overrun Flag
           =4 SBIT (TXBSY, SFR_SPI0CN, 3);           // SPI 0 Tx Busy Flag
           =4 SBIT (SLVSEL, SFR_SPI0CN, 2);          // SPI 0 Slave Select
           =4 SBIT (MSTEN, SFR_SPI0CN, 1);           // SPI 0 Master Enable
           =4 SBIT (SPIEN, SFR_SPI0CN, 0);           // SPI 0 SPI Enable
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 // Interrupt Priorities
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 68  

           =4 //-----------------------------------------------------------------------------
           =4 
           =4 #define INTERRUPT_INT0           0     // External Interrupt 0
           =4 #define INTERRUPT_TIMER0         1     // Timer0 Overflow
           =4 #define INTERRUPT_INT1           2     // External Interrupt 1
           =4 #define INTERRUPT_TIMER1         3     // Timer1 Overflow
           =4 #define INTERRUPT_UART0          4     // Serial Port UART0
           =4 #define INTERRUPT_TIMER2         5     // Timer2 Overflow
           =4 #define INTERRUPT_SPI0           6     // SPI0 Interface
           =4 #define INTERRUPT_SMBUS0         7     // SMBus0 Interface
           =4 #define INTERRUPT_ADC0_WINDOW    8     // ADC0 Window Comparison
           =4 #define INTERRUPT_PCA0           9     // PCA0 Peripheral
           =4 #define INTERRUPT_COMPARATOR0F   10    // Comparator0 Falling Edge
           =4 #define INTERRUPT_COMPARATOR0R   11    // Comparator0 Rising Edge
           =4 #define INTERRUPT_COMPARATOR1F   12    // Comparator1 Falling Edge
           =4 #define INTERRUPT_COMPARATOR1R   13    // Comparator1 Rising Edge
           =4 #define INTERRUPT_TIMER3         14    // Timer3 Overflow
           =4 #define INTERRUPT_ADC0_EOC       15    // ADC0 End Of Conversion
           =4 #define INTERRUPT_TIMER4         16    // Timer4 Overflow
           =4 #define INTERRUPT_ADC1_EOC       17    // ADC1 End Of Conversion
           =4 #define INTERRUPT_INT6           18    // External Interrupt 6
           =4 #define INTERRUPT_INT7           19    // External Interrupt 7
           =4 #define INTERRUPT_UART1          20    // Serial Port UART1
           =4 #define INTERRUPT_XTAL_READY     21    // External Crystal Oscillator Ready
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 // SDCC PDATA External Memory Paging Support
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 #if defined SDCC
           =4 
           =4 SFR(_XPAGE, 0xAF); // Point to the EMI0CN register
           =4 
           =4 #endif
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 // Header File PreProcessor Directive
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 #endif                                 // #define C8051F020_DEFS_H
 347      =4  
 348      =4  //-----------------------------------------------------------------------------
 349      =4  // End Of File
 350      =4  //-----------------------------------------------------------------------------
   6      =3  /*****************************************************************************/
   7      =3  void initDeviceF020(void);
   8      =3  #endif
 139      =2  #endif
 140      =2  #ifdef C8051F580
           =2 #include "InitDeviceF580.h"
           =2 #endif
 143      =2  
 144      =2  #include "delay.h"
   1      =3  #ifndef __DELAY_H__
   2      =3  #define __DELAY_H__
   3      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
           =2 #include "i2c0.h"
           =2 //#include "i2c1.h"
           =2 //#include "i2c2.h"
           =2 //#include "i2c3.h"
           =2 //#include "i2c4.h"
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 69  

           =2 //#include "i2c5.h"
           =2 //#include "i2c6.h"
           =2 #include "eprom.h"
           =2 #include "dac8568_0.h"
           =2 #include "dac8568_1.h"
           =2 #include "dac8568_2.h"
           =2 #include "dac8568_3.h"
           =2 
           =2 //#include "mcp47x6.h"
           =2 //#include "inPca9554.h"
           =2 //#include "outPca9554.h"
           =2 /*****************************************************************************/
           =2 #include "Modbus.h"
           =2 #include "ModbusPort.h"
           =2 /*****************************************************************************/
           =2 //#include "filter.h"
           =2 #include "sPLC.h"
           =2 //#include "pidFuzzy.h"
           =2 /*****************************************************************************/
           =2 //#include "AppMath.h"
           =2 //#include "chipAdc.h"
           =2 //#include "ad5621.h"
           =2 //#include "chipBeem.h"
           =2 
           =2 /*****************************************************************************/
           =2 #endif
   4      =3  #ifndef __DELAY_H__
   4      =3  #define __DELAY_H__
   4      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   5      =3  /*****************************************************************************/
   6      =3  void delayMs(uint8_t ms) reentrant;
   7      =3  void delayUs(uint8_t us) reentrant;
   8      =3  void hwDelayInit(uint8_t reload_h, uint8_t reload_l);
   9      =3  void hwDelay(uint8_t control, uint8_t reload_h, uint8_t reload_l);
  10      =3  /*****************************************************************************/
  11      =3  #endif
  12      =3  
   1      =3  #ifndef __I2C0_H__
   2      =3  #define __I2C0_H__
   3      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   4      =3  #ifndef __I2C0_H__
   4      =3  #define __I2C0_H__
   4      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   5      =3  /*****************************************************************************/
   6      =3  
   7      =3  /*****************************************************************************/
   8      =3  void iic0Init(void);
   9      =3  void iic0Start(void);
  10      =3  void iic0Stop(void);
  11      =3  uint8_t iic0WaitAck(void);
  12      =3  void iic0Ack(void);
  13      =3  void iic0NAck(void);
  14      =3  void iic0SendByte(uint8_t txd);
  15      =3  uint8_t iic0ReadByte(uint8_t ack);
  16      =3  
  17      =3  #endif
  18      =3  
  19      =3  
   1      =3  #ifndef __EPROM_H__
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 70  

   2      =3  #define __EPROM_H__
   3      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   4      =3  #ifndef __EPROM_H__
   4      =3  #define __EPROM_H__
   4      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   5      =3  /*****************************************************************************/
   6      =3  /*****************************************************************************/
   7      =3  void epromInit(void);
   8      =3  uint8_t epromReadOneByte(uint16_t ReadAddr);
   9      =3  void epromWriteOneByte(uint16_t WriteAddr, uint8_t DataToWrite);
  10      =3  void epromWriteLenByte(uint16_t WriteAddr, uint32_t DataToWrite, uint8_t Len);
  11      =3  uint32_t epromReadLenByte(uint16_t ReadAddr, uint8_t Len);
  12      =3  void epromRead(uint16_t ReadAddr,uint8_t *pBuffer,uint16_t NumToRead);
  13      =3  void epromWrite(uint16_t WriteAddr, uint8_t *pBuffer, uint16_t NumToWrite);
  14      =3  void epromTest(void);
  15      =3  #endif
   1      =3  #include "appConfig.h"
   1      =3  #include "appConfig.h"
   2      =3  /*****************************************************************************/
   3      =3  void dac8568_0_Init(void);
   4      =3  void dac8568_0_Update(uint8_t ch);
   5      =3  void dac8568_0_WriteInputRegister(uint8_t ch, uint16_t dat);
   6      =3  void dac8568_0_WriteDacRegister(uint8_t ch, uint16_t dat);
   7      =3  void dac8568_0_Clear(void);
   8      =3  void dac8568_0_Reset(void);
   1      =3  #include "appConfig.h"
   1      =3  #include "appConfig.h"
   2      =3  /*****************************************************************************/
   3      =3  void dac8568_1_Init(void);
   4      =3  void dac8568_1_Update(uint8_t ch);
   5      =3  void dac8568_1_WriteInputRegister(uint8_t ch, uint16_t dat);
   6      =3  void dac8568_1_WriteDacRegister(uint8_t ch, uint16_t dat);
   7      =3  void dac8568_1_Clear(void);
   8      =3  void dac8568_1_Reset(void);
   1      =3  #include "appConfig.h"
   1      =3  #include "appConfig.h"
   2      =3  /*****************************************************************************/
   3      =3  void dac8568_2_Init(void);
   4      =3  void dac8568_2_Update(uint8_t ch);
   5      =3  void dac8568_2_WriteInputRegister(uint8_t ch, uint16_t dat);
   6      =3  void dac8568_2_WriteDacRegister(uint8_t ch, uint16_t dat);
   7      =3  void dac8568_2_Clear(void);
   8      =3  void dac8568_2_Reset(void);
   1      =3  #include "appConfig.h"
   1      =3  #include "appConfig.h"
   2      =3  /*****************************************************************************/
   3      =3  void dac8568_3_Init(void);
   4      =3  void dac8568_3_Update(uint8_t ch);
   5      =3  void dac8568_3_WriteInputRegister(uint8_t ch, uint16_t dat);
   6      =3  void dac8568_3_WriteDacRegister(uint8_t ch, uint16_t dat);
   7      =3  void dac8568_3_Clear(void);
   8      =3  void dac8568_3_Reset(void);
   1      =3  #ifndef __MODBUS__H__
           =3 #define __MODBUS__H__
           =3 /*****************************************************************************/
           =3 #include "appConfig.h"
           =3 /*****************************************************************************/
           =3 extern volatile uint16_t modbusTimerValue;
           =3 extern volatile uint8_t modbusReceiveCounter;// Collected data number
           =3 extern xdata volatile uint8_t modbusReceiveBuffer[CONFIG_MB_RTU_SLAVE_BUFFER_SIZE];
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 71  

           =3 /*****************************************************************************/
           =3 extern void initModbus(uint8_t modbusSlaveAddress, uint32_t bd);
           =3 extern void modbusPorcess(void);
           =3 #endif
   1      =3  #ifndef __MODBUSPORT__H__
   2      =3  #define __MODBUSPORT__H__
   3      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   4      =3  #ifndef __MODBUSPORT__H__
   4      =3  #define __MODBUSPORT__H__
   4      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   5      =3  /*****************************************************************************/
   6      =3  extern void modBusUartInitialise(uint32_t baudrate);
   7      =3  extern void modBusTimerInitialise(void);
   8      =3  extern void modBusUartPutch(uint8_t c);
   9      =3  extern uint8_t modBusUartString(uint8_t *s, uint16_t Length);
  10      =3  extern void receiveInterrupt(uint8_t Data);
  11      =3  /*****************************************************************************/
  12      =3  #endif
   1      =3  #ifndef __SPLC_H__
   2      =3  #define __SPLC_H__
   3      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   1      =4  #ifndef __APPCONFIG_H__
           =4 #define __APPCONFIG_H__
           =4 /*****************************************************************************/
           =4 #define CONFIG_SYSCLK                       (22118400L)
           =4 #ifdef C8051F020
           =4 #define SAR_CLK                                                 2000000L//ADC0时钟 <2.5MHz
           =4 #endif
           =4 #define CONFIG_DEBUG                        0//调试功能
           =4 #define CONFIG_USING_WDT                                        0//使能看门狗
           =4 #define CONFIG_USING_RESET                                      0//使能PLC复位MCU功能
           =4 #define CONFIG_LADDER_SECTORS_START                     64//指令起始地址
           =4 #define CONFIG_LADDER_SECTORS_END                       128//指令结束地址
           =4 #define CONFIG_LASERTIMER_OVERFLOW_US           1000L//定时器周期 1mS
           =4 #define CONFIG_VERSION                                          0x0001
           =4 #define CONFIG_CHECK_CODE                                       0x5A00
           =4 
           =4 /*****************************************************************************/
           =4 #define CONFIG_UART0_BAUDRATE                           57600//串口波特率
           =4 #define CONFIG_UART0_PARITY                                     NONE
           =4 #define CONFIG_UART0_STOPBIT                            1
           =4 #define CONFIG_UART0_DATABIT                            8
           =4 
           =4 #define CONFIG_UART1_BAUDRATE                           115200//串口波特率
           =4 #define CONFIG_UART1_PARITY                                     NONE
           =4 #define CONFIG_UART1_STOPBIT                            1
           =4 #define CONFIG_UART1_DATABIT                            8
           =4 /*****************************************************************************/
           =4 #define CONFIG_I2C0_FREQ                                        (100000L)               
           =4 #define CONFIG_I2C1_FREQ                                        (100000L)
           =4 #define CONFIG_I2C2_FREQ                                        (100000L)
           =4 #define CONFIG_I2C3_FREQ                                        (100000L)
           =4 #define CONFIG_I2C4_FREQ                                        (100000L)
           =4 /*****************************************************************************/
           =4 #define CONFIG_EPROM_SIZE                                       CONFIG_AT24C64_SIZE
           =4 #define CONFIG_AT24C02_SIZE                             256
           =4 #define CONFIG_AT24C04_SIZE                             512
           =4 #define CONFIG_AT24C08_SIZE                             1024
           =4 #define CONFIG_AT24C16_SIZE                             2048
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 72  

           =4 #define CONFIG_AT24C32_SIZE                             4096
           =4 #define CONFIG_AT24C64_SIZE                                     8192
           =4 #define CONFIG_AT24C128_SIZE                            16384
           =4 #define CONFIG_AT24C256_SIZE                            32768
           =4 #define CONFIG_EPROM_ADDRESS                            0x50
           =4 #define CONFIG_EPROM_FRAM                                       0//铁电存储体无写入等待
           =4 #define CONFIG_EPROM_FREQ                                       1//
           =4 /*****************************************************************************/
           =4 #define CONFIG_USE_IPID                                         1//使能IPID温度控制
           =4 /*****************************************************************************/
           =4 #define CONFIG_USE_HWVER_SHOW                           1//使能固件版本显示
           =4 #define CONFIG_USE_MPD1_SHOW                            1//使能MPD1测量显示
           =4 #define CONFIG_USE_MPD2_SHOW                            1//使能MPD2测量显示
           =4 #define CONFIG_USE_FBS1                                         1//使能FBS1检测
           =4 #define CONFIG_USE_FBS2                                         1//使能FBS2检测
           =4 #define CONFIG_USE_LASER_TEMP                           1//使能激光器温度显示
           =4 #define CONFIG_USE_RADIATOR_TEMP                        1//使能散热器温度显示
           =4 #define CONFIG_USE_ENVI_TEMP                            1//使能环境温度显示
           =4 #define CONFIG_USE_IPID_UPDATE                          1//使能IPID参数更新功能
           =4 #define CONFIG_USE_IPID_OUTSHOW                         1//使能IPID输出显示
           =4 /*****************************************************************************/
           =4 //SPLC设置
           =4 #define CONFIG_SPLC_IO_INPUT_NUM                        16//硬件输入点数
           =4 #define CONFIG_SPLC_IO_OUTPUT_NUM                       16//硬件输出点数
           =4 #define CONFIG_SOFTPLC_HWTIME                           1000L//1mS
           =4 #define CONFIG_INPUT_FILTER_TIME                        3//输入数字滤波扫描周期 1mS * N
           =4 #define CONFIG_IPID_RUN_CYCLE                           40//IPID运行周期 默认 40 * 100mS
           =4 #define CONFIG_IPID_PWM_CYCLE                           20//IPID输出周期 默认 20 * 100mS
           =4 /*****************************************************************************/
           =4 #define CONFIG_SPLC_USING_WDT                           0//看门狗启用
           =4 /*****************************************************************************/
           =4 #define CONFIG_SPLC_USING_IO_INPUT                      1//输入IO刷新启用
           =4 /*****************************************************************************/
           =4 #define CONFIG_SPLC_USING_IO_OUTPUT                     1//输出IO刷新启用
           =4 /*****************************************************************************/
           =4 #define CONFIG_SPLC_USING_EPROM                         1//EPROM掉电存储启用
           =4 /*****************************************************************************/
           =4 #define CONFIG_SPLC_USING_ADC                           1//使能ADC模块
           =4 #define CONFIG_SPLC_ADC_FILTER_TAP                      18//ADC位移滤波次数
           =4 #define CONFIG_SPLC_ADC_CHANNLE                         50//ADC通道数
           =4 #define CONFIG_SPLC_ADC_TEMP_SENSOR_GAIN    3330L// Temp Sensor Gain in (uV / degC)
           =4 #define CONFIG_SPLC_ADC_TEMP_SENSOR_OFFSET  856L// Temp Sensor Offset in mV
           =4 #define CONFIG_SPLC_ADC_INTERNAL_VREF           2200L// ADC Voltage Reference (mV)
           =4 #define CONFIG_SPLC_ADC_AMBIENT             25L// Ambient temp in deg C
           =4 /*****************************************************************************/
           =4 #define CONFIG_SPLC_USING_DAC                           1//是能DAC模块
           =4 /*****************************************************************************/
           =4 #define CONFIG_SPLC_USING_MB_RTU_SLAVE          1//是能MODBUS RTU从站
           =4 #define CONFIG_MB_RTU_SLAVE_TIMER                       1000L//1000uS
           =4 #define CONFIG_MB_RTU_SLAVE_ADDRESS                     0x01//从设备地址
           =4 #define CONFIG_MB_RTU_SLAVE_BUFFER_SIZE         256//发送接收缓冲区
           =4 #define CONFIG_MB_RTU_SLAVE_TIMEOUT                     100//接收通讯超时 10mS
           =4 #define CONFIG_MB_RTU_SLAVE_IO_DELAY            1//RX TX切换延时
           =4 /*****************************************************************************/
           =4 
           =4 /*****************************************************************************/
           =4 #define ID_ONLY_1_CHANNEL                                       4321
           =4 #define ID_ONLY_2_CHANNEL                                       8765
           =4 #define ID_BOTH_CHANNEL                                         9431
           =4 #define ID_LASER_MODE_CW                                        7631
           =4 #define ID_LASER_MODE_SP                                        8934
           =4 #define ID_LASER_MODE_MP                                        2453
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 73  

           =4 #define ID_LASER_MODE_GP                                        3876
           =4 /*****************************************************************************/
           =4 #define FBS1_IN_PORT                                            3
           =4 #define FBS2_IN_PORT                                            2
           =4 #define COOLON_OUT_PORT                                         (1 * 8 + 3)
           =4 /*****************************************************************************/
           =4 //PID FUZZY 模糊PID配置
           =4 #define CONFIG_TECOUT_CYCLE                                     4000//PID输出转PWM周期
           =4 /*****************************************************************************/
           =4 /*****************************************************************************/
           =4 #define DISABLE_MODBUS_SERIAL_INTERRUPT         ES0 = 0;
           =4 #define ENABLE_MODBUS_SERIAL_INTERRUPT          ES0 = 1;
           =4 #define DISABLE_INTERRUPT                                       EA = 0;
           =4 #define ENABLE_INTERRUPT                                        EA = 1;
           =4 /*****************************************************************************/
           =4 #include "stdint.h"
           =4 #include "stdbool.h"
           =4 #include "endian.h"
           =4 #include "si_toolchain.h"
           =4 #include "compiler_defs.h"
           =4 #ifdef C8051F020
           =4 #include "C8051F020_defs.h"
           =4 #endif
           =4 #ifdef C8051F340
           =4 #include "C8051F340_defs.h"
           =4 #endif
           =4 /*****************************************************************************/
           =4 #include <stdio.h>
           =4 #include <stdlib.h> 
           =4 #include <string.h>
           =4 #include <INTRINS.H>
           =4 #include <ctype.h>
           =4 #include <LIMITS.H>
           =4 #include <math.h>
           =4 #include "crc32.h"
           =4 /*****************************************************************************/
           =4 #ifdef C8051F020
           =4 #include "InitDeviceF020.h"
           =4 #endif
           =4 #ifdef C8051F580
           =4 #include "InitDeviceF580.h"
           =4 #endif
           =4 
           =4 #include "delay.h"
           =4 #include "i2c0.h"
           =4 //#include "i2c1.h"
           =4 //#include "i2c2.h"
           =4 //#include "i2c3.h"
           =4 //#include "i2c4.h"
           =4 //#include "i2c5.h"
           =4 //#include "i2c6.h"
           =4 #include "eprom.h"
           =4 #include "dac8568_0.h"
           =4 #include "dac8568_1.h"
           =4 #include "dac8568_2.h"
           =4 #include "dac8568_3.h"
           =4 
           =4 //#include "mcp47x6.h"
           =4 //#include "inPca9554.h"
           =4 //#include "outPca9554.h"
           =4 /*****************************************************************************/
           =4 #include "Modbus.h"
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 74  

           =4 #include "ModbusPort.h"
           =4 /*****************************************************************************/
           =4 //#include "filter.h"
           =4 #include "sPLC.h"
           =4 //#include "pidFuzzy.h"
           =4 /*****************************************************************************/
           =4 //#include "AppMath.h"
           =4 //#include "chipAdc.h"
           =4 //#include "ad5621.h"
           =4 //#include "chipBeem.h"
           =4 
           =4 /*****************************************************************************/
           =4 #endif
   5      =3  /*****************************************************************************/
   6      =3  //线圈 保持 4 * 16 = 64BIT
   7      =3  #define MR_START                                                0
   8      =3  #define MR_END                                                  3
   9      =3  //线圈寄存器 非保持 4 * 16 = 64BIT
  10      =3  #define R_START                                                 4
  11      =3  #define R_END                                                   7
  12      =3  //数据寄存器 保持 8
  13      =3  #define DM_START                                                8
  14      =3  #define DM_END                                                  15
  15      =3  //数据寄存器 非保持 128个字
  16      =3  #define EM_START                                                16
  17      =3  #define EM_END                                                  143
  18      =3  //延时线圈
  19      =3  //1MS 1 * 16 = 32BIT
  20      =3  #define T_1MS_START                                             144
  21      =3  #define T_1MS_END                                               144
  22      =3  //10MS 2 * 16 = 32BIT
  23      =3  #define T_10MS_START                                    145
  24      =3  #define T_10MS_END                                              145
  25      =3  //100MS 1 * 16 = 32BIT
  26      =3  #define T_100MS_START                                   146
  27      =3  #define T_100MS_END                                             146
  28      =3  //延时计时器 
  29      =3  //1MS 32
  30      =3  #define TD_1MS_START                                    147
  31      =3  #define TD_1MS_END                                              162
  32      =3  //10MS 32
  33      =3  #define TD_10MS_START                                   163
  34      =3  #define TD_10MS_END                                             178
  35      =3  //100MS 32
  36      =3  #define TD_100MS_START                                  179
  37      =3  #define TD_100MS_END                                    194
  38      =3  //计数器 1
  39      =3  #define C_START                                                 195
  40      =3  #define C_END                                                   195
  41      =3  //输入位寄存器 8 * 16 = 128个
  42      =3  #define X_START                                                 196
  43      =3  #define X_END                                                   203                     
  44      =3  //输出位寄存器 8 * 16 = 128个
  45      =3  #define Y_START                                                 204
  46      =3  #define Y_END                                                   211
  47      =3  //特殊寄存器 4个字
  48      =3  #define SPREG_START                                             212
  49      =3  #define SPREG_END                                               215
  50      =3  //特殊线圈      4 * 16 = 64个
  51      =3  #define SPCOIL_START                                    216
  52      =3  #define SPCOIL_END                                              219
  53      =3  /*****************************************************************************/
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 75  

  54      =3  #define EM_ADC_0                                                (EM_START + 0)//ADC0->MLD0
  55      =3  #define EM_ADC_1                                                (EM_START + 1)//ADC1->MLD1
  56      =3  #define EM_ADC_2                                                (EM_START + 2)//ADC2->MLD2
  57      =3  #define EM_ADC_3                                                (EM_START + 3)//ADC3->MLD3
  58      =3  #define EM_ADC_4                                                (EM_START + 4)//ADC4->MLD4
  59      =3  #define EM_ADC_5                                                (EM_START + 5)//ADC5->MLD5
  60      =3  #define EM_ADC_6                                                (EM_START + 6)//ADC6->MLD6
  61      =3  #define EM_ADC_7                                                (EM_START + 7)//ADC7->MLD7
  62      =3  #define EM_ADC_8                                                (EM_START + 8)//ADC8->MLD8
  63      =3  #define EM_ADC_9                                                (EM_START + 9)//ADC9->MLD9
  64      =3  #define EM_ADC_10                                               (EM_START + 10)//ADC10->MLD10
  65      =3  #define EM_ADC_11                                               (EM_START + 11)//ADC11->MLD11
  66      =3  #define EM_ADC_12                                               (EM_START + 12)//ADC12->MLD12
  67      =3  #define EM_ADC_13                                               (EM_START + 13)//ADC13->MLD13
  68      =3  #define EM_ADC_14                                               (EM_START + 14)//ADC14->MLD14
  69      =3  #define EM_ADC_15                                               (EM_START + 15)//ADC15->MLD15
  70      =3  #define EM_ADC_16                                               (EM_START + 16)//ADC16->MLD16
  71      =3  #define EM_ADC_17                                               (EM_START + 17)//ADC17->MLD17
  72      =3  #define EM_ADC_18                                               (EM_START + 18)//ADC18->MLD18
  73      =3  #define EM_ADC_19                                               (EM_START + 19)//ADC19->MLD19
  74      =3  #define EM_ADC_20                                               (EM_START + 20)//ADC20->MLD20
  75      =3  #define EM_ADC_21                                               (EM_START + 21)//ADC21->MLD21
  76      =3  #define EM_ADC_22                                               (EM_START + 22)//ADC22->MLD22
  77      =3  #define EM_ADC_23                                               (EM_START + 23)//ADC23->MLD23
  78      =3  #define EM_ADC_24                                               (EM_START + 24)//ADC24->MLD24
  79      =3  #define EM_ADC_25                                               (EM_START + 25)//ADC25->MLD25
  80      =3  #define EM_ADC_26                                               (EM_START + 26)//ADC26->MLD26
  81      =3  #define EM_ADC_27                                               (EM_START + 27)//ADC27->MLD27
  82      =3  #define EM_ADC_28                                               (EM_START + 28)//ADC28->MLD28
  83      =3  #define EM_ADC_29                                               (EM_START + 29)//ADC29->MLD29
  84      =3  #define EM_ADC_30                                               (EM_START + 30)//ADC30->MLD30
  85      =3  #define EM_ADC_31                                               (EM_START + 31)//ADC31->MLD31
  86      =3  #define EM_ADC_32                                               (EM_START + 32)//ADC32->MPD0
  87      =3  #define EM_ADC_33                                               (EM_START + 33)//ADC33->MPD1
  88      =3  #define EM_ADC_34                                               (EM_START + 34)//ADC34->MPD2
  89      =3  #define EM_ADC_35                                               (EM_START + 35)//ADC35->MPD3
  90      =3  #define EM_ADC_36                                               (EM_START + 36)//ADC36->MPD4
  91      =3  #define EM_ADC_37                                               (EM_START + 37)//ADC37->MPD5
  92      =3  #define EM_ADC_38                                               (EM_START + 38)//ADC38->MPD6
  93      =3  #define EM_ADC_39                                               (EM_START + 39)//ADC39->MPD7
  94      =3  #define EM_ADC_40                                               (EM_START + 40)//ADC40->MPD8
  95      =3  #define EM_ADC_41                                               (EM_START + 41)//ADC41->MPD9
  96      =3  #define EM_ADC_42                                               (EM_START + 42)//ADC42->MPD10
  97      =3  #define EM_ADC_43                                               (EM_START + 43)//ADC42->MPD11
  98      =3  #define EM_ADC_44                                               (EM_START + 44)//ADC42->MPD12
  99      =3  #define EM_ADC_45                                               (EM_START + 45)//ADC42->MPD13
 100      =3  #define EM_ADC_46                                               (EM_START + 46)//ADC42->MPD14
 101      =3  #define EM_ADC_47                                               (EM_START + 47)//ADC42->MPD15
 102      =3  #define EM_ADC_48                                               (EM_START + 48)//ADC42->MPD16
 103      =3  #define EM_ADC_49                                               (EM_START + 49)//ADC42->MPD17
 104      =3  #define EM_ADC_50                                               (EM_START + 50)//ADC42->MPD18
 105      =3  #define EM_ADC_51                                               (EM_START + 51)//ADC42->MPD19
 106      =3  #define EM_ADC_52                                               (EM_START + 52)//ADC42->MPD20
 107      =3  #define EM_ADC_53                                               (EM_START + 53)//ADC43->MPD21
 108      =3  #define EM_ADC_54                                               (EM_START + 54)//ADC44->MPD22
 109      =3  #define EM_ADC_55                                               (EM_START + 55)//ADC45->MPD23
 110      =3  #define EM_ADC_56                                               (EM_START + 56)//ADC46->MPD24
 111      =3  #define EM_ADC_57                                               (EM_START + 57)//ADC47->MPD25
 112      =3  #define EM_ADC_58                                               (EM_START + 58)//ADC48->MPD26
 113      =3  #define EM_ADC_59                                               (EM_START + 59)//ADC49->MPD27
 114      =3  #define EM_ADC_60                                               (EM_START + 60)//ADC50->MPD28
 115      =3  #define EM_ADC_61                                               (EM_START + 61)//ADC50->MPD29
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 76  

 116      =3  #define EM_ADC_62                                               (EM_START + 62)//ADC50->MPD30
 117      =3  #define EM_ADC_63                                               (EM_START + 63)//ADC50->MPD31
 118      =3  #define EM_DAC_0                                                (EM_START + 64)//DAC0
 119      =3  #define EM_DAC_1                                                (EM_START + 65)//DAC1
 120      =3  #define EM_DAC_2                                                (EM_START + 66)//DAC2
 121      =3  #define EM_DAC_3                                                (EM_START + 67)//DAC3
 122      =3  #define EM_DAC_4                                                (EM_START + 68)//DAC4
 123      =3  #define EM_DAC_5                                                (EM_START + 69)//DAC5
 124      =3  #define EM_DAC_6                                                (EM_START + 70)//DAC6
 125      =3  #define EM_DAC_7                                                (EM_START + 71)//DAC7
 126      =3  #define EM_DAC_8                                                (EM_START + 72)//DAC8
 127      =3  #define EM_DAC_9                                                (EM_START + 73)//DAC9
 128      =3  #define EM_DAC_10                                               (EM_START + 74)//DAC10
 129      =3  #define EM_DAC_11                                               (EM_START + 75)//DAC11
 130      =3  #define EM_DAC_12                                               (EM_START + 76)//DAC12
 131      =3  #define EM_DAC_13                                               (EM_START + 77)//DAC13
 132      =3  #define EM_DAC_14                                               (EM_START + 78)//DAC14
 133      =3  #define EM_DAC_15                                               (EM_START + 79)//DAC15
 134      =3  #define EM_DAC_16                                               (EM_START + 80)//DAC16
 135      =3  #define EM_DAC_17                                               (EM_START + 81)//DAC17
 136      =3  #define EM_DAC_18                                               (EM_START + 82)//DAC18
 137      =3  #define EM_DAC_19                                               (EM_START + 83)//DAC19
 138      =3  #define EM_DAC_20                                               (EM_START + 84)//DAC20
 139      =3  #define EM_DAC_21                                               (EM_START + 85)//DAC21
 140      =3  #define EM_DAC_22                                               (EM_START + 86)//DAC22
 141      =3  #define EM_DAC_23                                               (EM_START + 87)//DAC23
 142      =3  #define EM_DAC_24                                               (EM_START + 88)//DAC24
 143      =3  #define EM_DAC_25                                               (EM_START + 89)//DAC25
 144      =3  #define EM_DAC_26                                               (EM_START + 90)//DAC26
 145      =3  #define EM_DAC_27                                               (EM_START + 91)//DAC27
 146      =3  #define EM_DAC_28                                               (EM_START + 92)//DAC28
 147      =3  #define EM_DAC_29                                               (EM_START + 93)//DAC29
 148      =3  #define EM_DAC_30                                               (EM_START + 94)//DAC30
 149      =3  #define EM_DAC_31                                               (EM_START + 95)//DAC31
 150      =3  /*****************************************************************************/
 151      =3  #define CONFIG_NVRAM_SIZE                               (SPCOIL_END + 1)
 152      =3  /*****************************************************************************/
 153      =3  #define SPCOIL_ON                                               0//长通线圈
 154      =3  #define SPCOIL_PS1MS                                    1//1mS间隔 50%占空比脉冲
 155      =3  #define SPCOIL_PS10MS                                   2//10mS
 156      =3  #define SPCOIL_PS100MS                                  3//100mS
 157      =3  /*****************************************************************************/
 158      =3  #define SP_EM_MODBUS_SLAVE_ERR                  300
 159      =3  #define SP_R_ON                                                 800//上电ON
 160      =3  #define SP_R_TICK_1MS                                   801//
 161      =3  #define SP_R_TICK_10MS                                  802//
 162      =3  #define SP_R_TICK_100MS                                 803//
 163      =3  #define SP_R_TICK_1S                                    804//
 164      =3  /*****************************************************************************/
 165      =3  typedef struct{//ADC滤波器
 166      =3          uint16_t dat[CONFIG_SPLC_ADC_FILTER_TAP];
 167      =3          uint16_t out;
 168      =3          uint8_t wIndex;//写入指针
 169      =3  }adcTempDat_t;
 170      =3  /*****************************************************************************/
 171      =3  extern uint16_t ModbusSlaveAsciiOverTimeCounter;//Modbus Slave通信超时计时器
 172      =3  extern xdata int16_t NVRAM0[CONFIG_NVRAM_SIZE];//掉电保持寄存器 当前
 173      =3  extern xdata int16_t NVRAM1[CONFIG_NVRAM_SIZE];//掉电保持寄存器 上一次
 174      =3  /*****************************************************************************/
 175      =3  void wdtDisable(void);//看门狗屏蔽
 176      =3  void sPlcInit(void);//软逻辑初始化
 177      =3  void sPlcProcessStart(void);//sPLC轮询起始
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 77  

 178      =3  void sPlcProcessEnd(void);//sPLC轮询结束
 179      =3  /*****************************************************************************/
 180      =3  void assertCoilAddress(uint16_t adr);
 181      =3  void assertRegisterAddress(uint16_t adr);
 182      =3  /*****************************************************************************/
 183      =3  void nvramUpdata(void);
 184      =3  void clearDM(void);
 185      =3  void clearEM(void);
 186      =3  void clearR(void);
 187      =3  void clearT(void);
 188      =3  void clearTD(void);
 189      =3  void clearC(void);
 190      =3  void nvramLoad(void);
 191      =3  void nvramSave(void);
 192      =3  void nvramUpdata(void);
 193      =3  /*****************************************************************************/
 194      =3  void SET(uint16_t A);//置位
 195      =3  void RESET(uint16_t A);//复位
 196      =3  void FLIP(uint16_t A);//翻转
 197      =3  uint8_t LD(uint16_t A);//载入
 198      =3  uint8_t LDP(uint16_t A);//脉冲上升沿
 199      =3  uint8_t LDN(uint16_t A);//脉冲下降沿
 200      =3  void T100US(uint8_t A, uint8_t start, uint16_t value);
 201      =3  void T1MS(uint8_t A, uint8_t start, uint16_t value);
 202      =3  void T10MS(uint8_t A, uint8_t start, uint16_t value);
 203      =3  void T100MS(uint8_t A, uint8_t start, uint16_t value);
 204      =3  /*****************************************************************************/
 205      =3  void chipDacInit(void);
 206      =3  void chipAdcInit(void);
 207      =3  void sPlcInit(void);
 208      =3  void refreshInput(void);
 209      =3  void refreshOutput(void);
 210      =3  void refreshDac(void);
 211      =3  /*****************************************************************************/
 212      =3  #endif
   5      =1  /*****************************************************************************/
   6      =1  extern volatile uint16_t modbusTimerValue;
   7      =1  extern volatile uint8_t modbusReceiveCounter;// Collected data number
   8      =1  extern xdata volatile uint8_t modbusReceiveBuffer[CONFIG_MB_RTU_SLAVE_BUFFER_SIZE];
   9      =1  /*****************************************************************************/
  10      =1  extern void initModbus(uint8_t modbusSlaveAddress, uint32_t bd);
  11      =1  extern void modbusPorcess(void);
  12      =1  #endif
   2          /*******************************ModBus Functions*******************************/
   3          #define MODBUS_READ_COILS                                               1
   4          #define MODBUS_READ_DISCRETE_INPUTS                                     2
   5          #define MODBUS_READ_HOLDING_REGISTERS                                   3
   6          #define MODBUS_READ_INPUT_REGISTERS                                     4
   7          #define MODBUS_WRITE_SINGLE_COIL                                        5
   8          #define MODBUS_WRITE_SINGLE_REGISTER                                    6
   9          #define MODBUS_WRITE_MULTIPLE_COILS                                     15
  10          #define MODBUS_WRITE_MULTIPLE_REGISTERS                                 16
  11          /****************************End of ModBus Functions***************************/
  12          #define FALSE_FUNCTION                                                  0
  13          #define FALSE_SLAVE_ADDRESS                                             1
  14          #define DATA_NOT_READY                                                  2
  15          #define DATA_READY                                                      3
  16          #define ERROR_CODE_01                                                   0x01// function code is not supported
  17          #define ERROR_CODE_02                                                   0x02// Register address is not allowed or write-protected
  18          #define ERROR_CODE_03                                                   0x03//Some data values are out of range, invalid number of r
             -egister
  19          /*****************************************************************************/
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 78  

  20          typedef enum{
  21              RXTX_IDLE,
  22              RXTX_START,
  23              RXTX_DATABUF,
  24              RXTX_WAIT_ANSWER,
  25              RXTX_TIMEOUT
  26          }MODBUS_RXTX_STATE;
  27          typedef struct{
  28                  uint8_t address;
  29                  uint8_t function;
  30                  uint8_t dataBuf[CONFIG_MB_RTU_SLAVE_BUFFER_SIZE];
  31                  uint16_t dataLen;
  32          }modbusRxTxData_t;
  33          /**********************Slave Transmit and Receive Variables********************/
  34          pdata uint8_t ModbusSlaveAddress = 1;
  35          xdata modbusRxTxData_t Tx_Data;
  36          pdata uint32_t Tx_Current = 0;
  37          pdata uint32_t Tx_CRC16 = 0xFFFF;
  38          pdata MODBUS_RXTX_STATE Tx_State = RXTX_IDLE;
  39          xdata uint8_t Tx_Buf[CONFIG_MB_RTU_SLAVE_BUFFER_SIZE];
  40          pdata uint32_t Tx_Buf_Size = 0;
  41          /*****************************************************************************/
  42          xdata modbusRxTxData_t Rx_Data;
  43          pdata uint32_t Rx_CRC16 = 0xFFFF;
  44          pdata MODBUS_RXTX_STATE Rx_State = RXTX_IDLE;
  45          pdata uint8_t Rx_Data_Available = false;
  46          /*****************************************************************************/
  47          volatile uint16_t modbusTimerValue = 0;
  48          volatile uint8_t modbusReceiveCounter = 0;// Collected data number
  49          xdata volatile uint8_t modbusReceiveBuffer[CONFIG_MB_RTU_SLAVE_BUFFER_SIZE];// Buffer to collect data from
             - hardware
  50          /*****************************************************************************/
  51          void modbusCrc16(const uint8_t Data, uint32_t* CRC){
  52   1          data uint32_t i;
  53   1          *CRC = *CRC ^(uint32_t) Data;
  54   1          for (i = 8; i > 0; i--){
  55   2              if (*CRC & 0x0001)
  56   2                  *CRC = (*CRC >> 1) ^ 0xA001;
  57   2              else
  58   2                  *CRC >>= 1;
  59   2          }
  60   1      }
  61          
  62          
  63          uint8_t DoSlaveTX(void){//It is used for send data package over physical layer
  64   1          modBusUartString(Tx_Buf, Tx_Buf_Size);
  65   1          Tx_Buf_Size = 0;
  66   1          return true;
  67   1      }
  68          uint8_t SendMessage(void){//This function start to sending messages
  69   1          if (Tx_State != RXTX_IDLE){
  70   2              return false;
  71   2              }
  72   1          Tx_Current  =0;
  73   1          Tx_State    =RXTX_START;
  74   1          return true;
  75   1      }
  76          void HandleModbusError(char ErrorCode){// Initialise the output buffer. The first byte in the buffer says 
             -how many registers we have read
  77   1          Tx_Data.function = ErrorCode | 0x80;
  78   1          Tx_Data.address = ModbusSlaveAddress;
  79   1          Tx_Data.dataLen = 0;
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 79  

  80   1          SendMessage();
  81   1      }
  82          
  83          void HandleModbusReadCoils(void){//Modbus function 01 - 读取线圈状态
  84   1              uint16_t startAddress, numberOfCoil, byteCount, tempAddr, i, j;
  85   1              uint8_t tempData = 0;
  86   1              // The message contains the requested start address and number of registers
  87   1          startAddress = ((uint16_t) (Rx_Data.dataBuf[0]) << 8) + (uint16_t) (Rx_Data.dataBuf[1]);
  88   1          numberOfCoil = ((uint16_t) (Rx_Data.dataBuf[2]) << 8) + (uint16_t) (Rx_Data.dataBuf[3]);
  89   1              if((startAddress + numberOfCoil) > (CONFIG_NVRAM_SIZE * 16)){//If it is bigger than RegisterNumber return
             - error to Modbus Master
  90   2              HandleModbusError(ERROR_CODE_02);
  91   2              }
  92   1              else{
  93   2                      byteCount = numberOfCoil / 8;
  94   2                      if((numberOfCoil % 8) != 0){
  95   3                              byteCount += 1;
  96   3                      }
  97   2                      Tx_Data.function = MODBUS_READ_COILS;
  98   2                      Tx_Data.address = ModbusSlaveAddress;
  99   2                      Tx_Data.dataLen = 1;
 100   2                      tempAddr = startAddress;
 101   2                      for(i = 0; i < byteCount; i ++){
 102   3                              Tx_Data.dataBuf[Tx_Data.dataLen] = 0;
 103   3                              for(j = 0; j < 8; j ++){
 104   4                                      tempData = (NVRAM0[(tempAddr / 16)] >> (tempAddr % 16)) & 0x01;
 105   4                                      Tx_Data.dataBuf[Tx_Data.dataLen] |= (uint8_t)(tempData << j);
 106   4                                      tempAddr++;     
 107   4                                      //if(tempAddr >= startAddress + numberOfCoil){//读完
 108   4                                      //      exit = 1;
 109   4                                      //      break;
 110   4                                      //} 
 111   4                              }
 112   3                              Tx_Data.dataLen ++;     
 113   3                      }
 114   2                      Tx_Data.dataBuf[0] = Tx_Data.dataLen - 1;
 115   2                      SendMessage();
 116   2              }
 117   1      }
 118          void HandleModbusReadInputCoil(void){//Modbus function 02 - 读取输入线圈状态
 119   1      }
 120          void HandleModbusReadHoldingRegisters(void){//Modbus function 03 - Read holding registers
 121   1          uint16_t startAddress, numberOfRegisters, i, currentData;
 122   1              // The message contains the requested start address and number of registers
 123   1          startAddress = ((uint16_t) (Rx_Data.dataBuf[0]) << 8) + (uint16_t) (Rx_Data.dataBuf[1]);
 124   1          numberOfRegisters = ((uint16_t) (Rx_Data.dataBuf[2]) << 8) + (uint16_t) (Rx_Data.dataBuf[3]);
 125   1              if((startAddress + numberOfRegisters) > CONFIG_NVRAM_SIZE){//If it is bigger than RegisterNumber return e
             -rror to Modbus Master
 126   2              HandleModbusError(ERROR_CODE_02);
 127   2              }
 128   1          else{//Initialise the output buffer. The first byte in the buffer says how many registers we have read
 129   2              Tx_Data.function = MODBUS_READ_HOLDING_REGISTERS;
 130   2              Tx_Data.address = ModbusSlaveAddress;
 131   2              Tx_Data.dataLen = 1;
 132   2              Tx_Data.dataBuf[0] = 0;
 133   2              for (i = 0;i < numberOfRegisters;i ++){
 134   3                  currentData = (uint16_t)NVRAM0[startAddress + i];
 135   3                  Tx_Data.dataBuf[Tx_Data.dataLen] = (uint8_t)((currentData & 0xFF00) >> 8);
 136   3                  Tx_Data.dataBuf[Tx_Data.dataLen + 1] = (uint8_t)(currentData & 0x00FF);
 137   3                  Tx_Data.dataLen += 2;
 138   3                  Tx_Data.dataBuf[0] = Tx_Data.dataLen - 1;
 139   3              }
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 80  

 140   2              SendMessage();
 141   2          }
 142   1      }
 143          void HandleModbusWriteSingleCoil(void){//Modbus function 05 -强置单线圈
 144   1              uint16_t startAddress, value;
 145   1              // The message contains the requested start address and number of registers
 146   1          startAddress = ((uint16_t) (Rx_Data.dataBuf[0]) << 8) + (uint16_t) (Rx_Data.dataBuf[1]);
 147   1              value = ((uint16_t) (Rx_Data.dataBuf[2]) << 8) + (uint16_t)(Rx_Data.dataBuf[3]);
 148   1              if((startAddress) > (CONFIG_NVRAM_SIZE * 16)){//If it is bigger than RegisterNumber return error to Modbu
             -s Master
 149   2              HandleModbusError(ERROR_CODE_02);
 150   2              }
 151   1              else{
 152   2                      Tx_Data.function = MODBUS_WRITE_SINGLE_COIL;
 153   2                      Tx_Data.address = ModbusSlaveAddress;
 154   2                      Tx_Data.dataLen = 4;
 155   2                      Tx_Data.dataBuf[0] = Rx_Data.dataBuf[0];
 156   2                      Tx_Data.dataBuf[1] = Rx_Data.dataBuf[1];
 157   2                      if(value == 0x0000){//0
 158   3                              NVRAM0[(startAddress / 16)] &= ~((uint16_t)(1 << (startAddress % 16)));
 159   3                              Tx_Data.dataBuf[2] = 0x00;
 160   3                              Tx_Data.dataBuf[3] = 0x00;
 161   3                      }
 162   2                      else if(value == 0xFF00){//1
 163   3                              NVRAM0[(startAddress / 16)] |= (uint16_t)(1 << (startAddress % 16));
 164   3                              Tx_Data.dataBuf[2] = 0xFF;
 165   3                              Tx_Data.dataBuf[3] = 0x00;
 166   3                      }
 167   2                      else{           
 168   3                      }
 169   2                      SendMessage();
 170   2              }
 171   1      }
 172          void HandleModbusWriteSingleRegister(void){//Modbus function 06 - Write single register
 173   1          uint16_t address, value,i;
 174   1          // The message contains the requested start address and number of registers
 175   1          address = ((uint16_t) (Rx_Data.dataBuf[0]) << 8) + (uint16_t)(Rx_Data.dataBuf[1]);
 176   1          value = ((uint16_t) (Rx_Data.dataBuf[2]) << 8) + (uint16_t)(Rx_Data.dataBuf[3]);
 177   1          // Initialise the output buffer. The first byte in the buffer says how many registers we have read
 178   1          Tx_Data.function = MODBUS_WRITE_SINGLE_REGISTER;
 179   1          Tx_Data.address = ModbusSlaveAddress;
 180   1          Tx_Data.dataLen = 4;
 181   1          if(address >= CONFIG_NVRAM_SIZE){
 182   2              HandleModbusError(ERROR_CODE_03);
 183   2              }
 184   1          else{
 185   2                      NVRAM0[address] = (int16_t)value;
 186   2              for (i = 0; i < 4; ++i){
 187   3                  Tx_Data.dataBuf[i] = Rx_Data.dataBuf[i];
 188   3                      }
 189   2          }
 190   1          SendMessage();
 191   1      }
 192          void HandleModbusWriteMultipleCoils(void){//Modbus function 15 - Write multiple coils
 193   1              uint16_t startAddress, numberOfCoil, byteCount, tempAddr, i, j;
 194   1              uint8_t tempData = 0;
 195   1              // The message contains the requested start address and number of registers
 196   1          startAddress = ((uint16_t) (Rx_Data.dataBuf[0]) << 8) + (uint16_t) (Rx_Data.dataBuf[1]);
 197   1          numberOfCoil = ((uint16_t) (Rx_Data.dataBuf[2]) << 8) + (uint16_t) (Rx_Data.dataBuf[3]);
 198   1              if((startAddress + numberOfCoil) > (CONFIG_NVRAM_SIZE * 16)){//If it is bigger than RegisterNumber return
             - error to Modbus Master
 199   2              HandleModbusError(ERROR_CODE_02);
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 81  

 200   2              }
 201   1              else{
 202   2                      byteCount = numberOfCoil / 8;
 203   2                      if((numberOfCoil % 8) != 0){
 204   3                              byteCount += 1;
 205   3                      }
 206   2                      Tx_Data.function = MODBUS_WRITE_MULTIPLE_COILS;
 207   2                      Tx_Data.address = ModbusSlaveAddress;
 208   2                      Tx_Data.dataLen = 4;
 209   2                      Tx_Data.dataBuf[0] = Rx_Data.dataBuf[0];
 210   2                      Tx_Data.dataBuf[1] = Rx_Data.dataBuf[1];
 211   2                      Tx_Data.dataBuf[2] = Rx_Data.dataBuf[2];
 212   2                      Tx_Data.dataBuf[3] = Rx_Data.dataBuf[3];
 213   2                      tempAddr = startAddress;
 214   2                      for(i = 0;i < byteCount;i ++){
 215   3                              for(j = 0;j < 8;j ++){
 216   4                                      tempData = (uint8_t)((Rx_Data.dataBuf[(5 + i)] >> j) & 0x01);
 217   4                                      if(tempData){//ON
 218   5                                              NVRAM0[(tempAddr / 16)] |= (uint16_t)(1 << (tempAddr % 16));
 219   5                                      }
 220   4                                      else{//OFF
 221   5                                              NVRAM0[(tempAddr / 16)] &= ~((uint16_t)(1 << (tempAddr % 16)));
 222   5                                      }
 223   4                                      tempAddr ++;
 224   4                                      numberOfCoil --;
 225   4                                      if(numberOfCoil == 0){
 226   5                                              break;
 227   5                                      }
 228   4                              }
 229   3                              
 230   3                      }
 231   2                      SendMessage();
 232   2              }
 233   1      }
 234          void HandleModbusWriteMultipleRegisters(void){//Modbus function 16 - Write multiple registers
 235   1          // Write single numerical output
 236   1          data uint16_t startAddress, numberOfRegisters, value;
 237   1          data uint8_t byteCount , i;
 238   1          // The message contains the requested start address and number of registers
 239   1          startAddress = ((uint16_t)(Rx_Data.dataBuf[0]) << 8) + (uint16_t)(Rx_Data.dataBuf[1]);
 240   1          numberOfRegisters = ((uint16_t)(Rx_Data.dataBuf[2]) << 8) + (uint16_t)(Rx_Data.dataBuf[3]);
 241   1          byteCount = Rx_Data.dataBuf[4];
 242   1          // If it is bigger than RegisterNumber return error to Modbus Master
 243   1          if((startAddress+numberOfRegisters) > CONFIG_NVRAM_SIZE){
 244   2              HandleModbusError(ERROR_CODE_03);
 245   2              }
 246   1          else{
 247   2              // Initialise the output buffer. The first byte in the buffer says how many outputs we have set
 248   2              Tx_Data.function = MODBUS_WRITE_MULTIPLE_REGISTERS;
 249   2              Tx_Data.address = ModbusSlaveAddress;
 250   2              Tx_Data.dataLen = 4;
 251   2              Tx_Data.dataBuf[0] = Rx_Data.dataBuf[0];
 252   2              Tx_Data.dataBuf[1] = Rx_Data.dataBuf[1];
 253   2              Tx_Data.dataBuf[2] = Rx_Data.dataBuf[2];
 254   2              Tx_Data.dataBuf[3] = Rx_Data.dataBuf[3];
 255   2              // Output data buffer is exact copy of input buffer
 256   2              for (i = 0;i < numberOfRegisters;i ++){
 257   3                  value = (uint16_t)((Rx_Data.dataBuf[5 + 2 * i] << 8) & 0xFF00) + (uint16_t)((Rx_Data.dataBuf[6
             - + 2 * i]) & 0x00FF);
 258   3                  NVRAM0[startAddress + i] = (int16_t)value;
 259   3              }
 260   2              SendMessage();
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 82  

 261   2          }
 262   1      }
 263          uint8_t RxDataAvailable(void){//RxDataAvailable
 264   1          uint8_t Result = Rx_Data_Available;   
 265   1          Rx_Data_Available = false;
 266   1          return Result;
 267   1      }
 268          uint8_t CheckRxTimeout(void){//CheckRxTimeout
 269   1          // A return value of true indicates there is a timeout    
 270   1          if (modbusTimerValue >= CONFIG_MB_RTU_SLAVE_BUFFER_SIZE){
 271   2              modbusTimerValue = 0;
 272   2              modbusReceiveCounter = 0;
 273   2              return true;
 274   2          }
 275   1          return false;
 276   1      }
 277          uint8_t checkModbusBufferComplete(void){//CheckBufferComplete
 278   1          data int32_t expectedReceiveCount=0;
 279   1          if(modbusReceiveCounter > 4)
 280   1          {
 281   2              if(modbusReceiveBuffer[0] == ModbusSlaveAddress)
 282   2              {
 283   3                  if(modbusReceiveBuffer[1]==0x01 || modbusReceiveBuffer[1]==0x02 || modbusReceiveBuffer[1]==0x0
             -3 || modbusReceiveBuffer[1]==0x04 || modbusReceiveBuffer[1]==0x05 || modbusReceiveBuffer[1]==0x06)  // RHR
 284   3                  {
 285   4                      expectedReceiveCount = 8;
 286   4                  }
 287   3                  else if(modbusReceiveBuffer[1] == 0x0F || modbusReceiveBuffer[1] == 0x10)
 288   3                  {
 289   4                      expectedReceiveCount=modbusReceiveBuffer[6] + 9;
 290   4                  }
 291   3                  else{
 292   4                      modbusReceiveCounter = 0;
 293   4                      return FALSE_FUNCTION;
 294   4                  }
 295   3              }
 296   2              else
 297   2              {
 298   3                  modbusReceiveCounter=0;
 299   3                  return FALSE_SLAVE_ADDRESS;
 300   3              }
 301   2          }
 302   1          else
 303   1              return DATA_NOT_READY;
 304   1      
 305   1          if(modbusReceiveCounter==expectedReceiveCount)
 306   1          {
 307   2              return DATA_READY;
 308   2          }
 309   1      
 310   1          return DATA_NOT_READY;
 311   1      }
 312          void RxRTU(void){//Check for data ready, if it is good return answer
 313   1          uint8_t i;
 314   1          uint8_t receiveBufferControl=0;
 315   1          receiveBufferControl = checkModbusBufferComplete();
 316   1          if(receiveBufferControl == DATA_READY){
 317   2              Rx_Data.address               =modbusReceiveBuffer[0];
 318   2              Rx_CRC16                      = 0xffff;
 319   2              modbusCrc16(Rx_Data.address, &Rx_CRC16);
 320   2              Rx_Data.function              =modbusReceiveBuffer[1];
 321   2              modbusCrc16(Rx_Data.function, &Rx_CRC16);
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 83  

 322   2      
 323   2              Rx_Data.dataLen=0;
 324   2      
 325   2              for(i=2;i<modbusReceiveCounter;i++)
 326   2                  Rx_Data.dataBuf[Rx_Data.dataLen++]=modbusReceiveBuffer[i];
 327   2      
 328   2              Rx_State =RXTX_DATABUF;
 329   2      
 330   2              modbusReceiveCounter=0;
 331   2          }
 332   1      
 333   1          CheckRxTimeout();
 334   1      
 335   1          if ((Rx_State == RXTX_DATABUF) && (Rx_Data.dataLen >= 2))
 336   1          {
 337   2              // Finish off our CRC check
 338   2              Rx_Data.dataLen -= 2;
 339   2              for (i = 0; i < Rx_Data.dataLen; ++i)
 340   2              {
 341   3                  modbusCrc16(Rx_Data.dataBuf[i], &Rx_CRC16);
 342   3              }
 343   2              
 344   2              if (((uint32_t) Rx_Data.dataBuf[Rx_Data.dataLen] + ((uint32_t) Rx_Data.dataBuf[Rx_Data.dataLen + 1
             -] << 8)) == Rx_CRC16)
 345   2              {
 346   3                  // Valid message!
 347   3                  Rx_Data_Available = true;
 348   3              }
 349   2      
 350   2              Rx_State = RXTX_IDLE;
 351   2          }
 352   1      }
 353          void TxRTU(void){//If it is ready send answers!
 354   1          Tx_CRC16 = 0xFFFF;
 355   1          Tx_Buf_Size = 0;
 356   1          Tx_Buf[Tx_Buf_Size++] = Tx_Data.address;
 357   1          modbusCrc16(Tx_Data.address, &Tx_CRC16);
 358   1          Tx_Buf[Tx_Buf_Size++] = Tx_Data.function;
 359   1          modbusCrc16(Tx_Data.function, &Tx_CRC16);
 360   1          for(Tx_Current=0; Tx_Current < Tx_Data.dataLen; Tx_Current++){
 361   2              Tx_Buf[Tx_Buf_Size++] = Tx_Data.dataBuf[Tx_Current];
 362   2              modbusCrc16(Tx_Data.dataBuf[Tx_Current], &Tx_CRC16);
 363   2          }
 364   1          Tx_Buf[Tx_Buf_Size++] = Tx_CRC16 & 0x00FF;
 365   1          Tx_Buf[Tx_Buf_Size++] = (Tx_CRC16 & 0xFF00) >> 8;
 366   1          DoSlaveTX();
 367   1          Tx_State = RXTX_IDLE;
 368   1      }
 369          void modbusPorcess(void){//ModBus main core! Call this function into main!
 370   1          if (Tx_State != RXTX_IDLE){                                      // If answer is ready, send it!
 371   2              TxRTU();
 372   2              }
 373   1          RxRTU();                                                              // Call this function every cycl
             -e
 374   1          if (RxDataAvailable()){
 375   2              if (Rx_Data.address == ModbusSlaveAddress){
 376   3                  switch (Rx_Data.function)                                     // Data is for us but which func
             -tion?
 377   3                  {
 378   4                                      case MODBUS_READ_COILS:{//FUN 01
 379   5                                              HandleModbusReadCoils();
 380   5                                              break;
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 84  

 381   5                                      }
 382   4                      case MODBUS_READ_HOLDING_REGISTERS:{//FUN 03
 383   5                                              HandleModbusReadHoldingRegisters();
 384   5                                              break;  
 385   5                                      }
 386   4                                      case MODBUS_WRITE_SINGLE_COIL:{//FUN 05
 387   5                                              HandleModbusWriteSingleCoil();
 388   5                                              break;
 389   5                                      }
 390   4                      case MODBUS_WRITE_SINGLE_REGISTER:{//FUN 06
 391   5                                              HandleModbusWriteSingleRegister();
 392   5                                              break;
 393   5                                      }
 394   4                                      case MODBUS_WRITE_MULTIPLE_COILS:{//FUN 15
 395   5                                              HandleModbusWriteMultipleCoils();
 396   5                                              break;
 397   5                                      }
 398   4                      case MODBUS_WRITE_MULTIPLE_REGISTERS:{//FUN 16
 399   5                                              HandleModbusWriteMultipleRegisters();
 400   5                                              break;
 401   5                                      }
 402   4                      default:{
 403   5                                              HandleModbusError(ERROR_CODE_01);
 404   5                                              break;
 405   5                                      }
 406   4                  }
 407   3              }
 408   2          }
 409   1      }
 410          void InitModbus(uint8_t modbusSlaveAddress, uint32_t baudrate){//ModBus slave initialize
 411   1          ModbusSlaveAddress = modbusSlaveAddress;
 412   1          modBusUartInitialise(baudrate);
 413   1          modBusTimerInitialise();
 414   1      }
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 85  

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION Com0086 (BEGIN)
0000         L?0135:
0000 E500        R     MOV     A,startAddress
0002 C4                SWAP    A
0003 F8                MOV     R0,A
0004 54F0              ANL     A,#0F0H
0006 C8                XCH     A,R0
0007 68                XRL     A,R0
0008 FE                MOV     R6,A
0009 E500        R     MOV     A,startAddress+01H
000B         L?0136:
000B C4                SWAP    A
000C 540F              ANL     A,#0FH
000E 48                ORL     A,R0
000F         L?0137:
000F 25E0              ADD     A,ACC
0011 FF                MOV     R7,A
0012 EE                MOV     A,R6
0013         L?0138:
0013 33                RLC     A
0014 FE                MOV     R6,A
0015 7400        E     MOV     A,#LOW NVRAM0
0017 2F                ADD     A,R7
0018 F582              MOV     DPL,A
001A 7400        E     MOV     A,#HIGH NVRAM0
001C 3E                ADDC    A,R6
001D F583              MOV     DPH,A
001F 22                RET     
0020         L?0139:
0020 900000      R     MOV     DPTR,#Tx_Data+01H
0023         L?0140:
0023 F0                MOVX    @DPTR,A
0024 7800        R     MOV     R0,#LOW ModbusSlaveAddress
0026 E2                MOVX    A,@R0
0027 900000      R     MOV     DPTR,#Tx_Data
002A F0                MOVX    @DPTR,A
002B 900000      R     MOV     DPTR,#Tx_Data+0102H
002E E4                CLR     A
002F F0                MOVX    @DPTR,A
0030 A3                INC     DPTR
0031 22                RET     
0032         L?0141:
0032 E0                MOVX    A,@DPTR
0033 FB                MOV     R3,A
0034         L?0142:
0034 7800        R     MOV     R0,#LOW Tx_Buf_Size
0036 120000      E     LCALL   ?C?LLDIPDATA1
0039 7400        R     MOV     A,#LOW Tx_Buf
003B 2F                ADD     A,R7
003C F582              MOV     DPL,A
003E 7400        R     MOV     A,#HIGH Tx_Buf
0040 3E                ADDC    A,R6
0041 F583              MOV     DPH,A
0043 22                RET     
0044         L?0143:
0044         L?0144:
0044 900000      R     MOV     DPTR,#Rx_Data+02H
0047 7C00              MOV     R4,#00H
0049         L?0145:
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 86  

0049 E0                MOVX    A,@DPTR
004A FE                MOV     R6,A
004B A3                INC     DPTR
004C E0                MOVX    A,@DPTR
004D 2400              ADD     A,#00H
004F 22                RET     
0050         L?0146:
0050         L?0147:
0050 7404              MOV     A,#04H
0052 F0                MOVX    @DPTR,A
0053 900000      R     MOV     DPTR,#Rx_Data+02H
0056 E0                MOVX    A,@DPTR
0057 900000      R     MOV     DPTR,#Tx_Data+02H
005A F0                MOVX    @DPTR,A
005B 900000      R     MOV     DPTR,#Rx_Data+03H
005E E0                MOVX    A,@DPTR
005F 900000      R     MOV     DPTR,#Tx_Data+03H
0062 F0                MOVX    @DPTR,A
0063 22                RET     
0064         L?0148:
0064 E0                MOVX    A,@DPTR
0065 FC                MOV     R4,A
0066 A3                INC     DPTR
0067 E0                MOVX    A,@DPTR
0068 FD                MOV     R5,A
0069 E500        R     MOV     A,startAddress+01H
006B         L?0149:
006B 540F              ANL     A,#0FH
006D FF                MOV     R7,A
006E 7E00              MOV     R6,#00H
0070 7401              MOV     A,#01H
0072 A807              MOV     R0,AR7
0074 08                INC     R0
0075 22                RET     
0076         L?0150:
0076 900000      R     MOV     DPTR,#Tx_Data+0102H
0079 E0                MOVX    A,@DPTR
007A FE                MOV     R6,A
007B A3                INC     DPTR
007C E0                MOVX    A,@DPTR
007D 2400        R     ADD     A,#LOW Tx_Data+02H
007F         L?0151:
007F F582              MOV     DPL,A
0081 7400        R     MOV     A,#HIGH Tx_Data+02H
0083 3E                ADDC    A,R6
0084 F583              MOV     DPH,A
0086 22                RET     
0087         L?0154:
0087 E2                MOVX    A,@R0
0088 FB                MOV     R3,A
0089 08                INC     R0
008A E2                MOVX    A,@R0
008B F9                MOV     R1,A
008C 08                INC     R0
008D E2                MOVX    A,@R0
008E FA                MOV     R2,A
008F 08                INC     R0
0090 E2                MOVX    A,@R0
0091 CB                XCH     A,R3
0092 F8                MOV     R0,A
0093 C3                CLR     C
0094 020000      E     LJMP    ?C?ULCMP
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 87  

0097         L?0155:
0097 E500        R     MOV     A,tempAddr
0099         L?0156:
0099 C4                SWAP    A
009A F8                MOV     R0,A
009B 54F0              ANL     A,#0F0H
009D C8                XCH     A,R0
009E 68                XRL     A,R0
009F FE                MOV     R6,A
00A0 22                RET     
00A1         L?0157:
00A1 E2                MOVX    A,@R0
00A2 FC                MOV     R4,A
00A3 08                INC     R0
00A4 E2                MOVX    A,@R0
00A5 FD                MOV     R5,A
00A6 08                INC     R0
00A7 E2                MOVX    A,@R0
00A8 FE                MOV     R6,A
00A9 08                INC     R0
00AA E2                MOVX    A,@R0
00AB 22                RET     
00AC         L?0158:
00AC         L?0159:
00AC FF                MOV     R7,A
00AD EC                MOV     A,R4
00AE 3E                ADDC    A,R6
00AF AD07              MOV     R5,AR7
00B1 FC                MOV     R4,A
00B2 22                RET     
00B3         L?0160:
00B3 3C                ADDC    A,R4
00B4 FE                MOV     R6,A
00B5 D3                SETB    C
00B6 EF                MOV     A,R7
00B7 94C0              SUBB    A,#0C0H
00B9 EE                MOV     A,R6
00BA 940D              SUBB    A,#0DH
00BC 22                RET     
00BD         L?0161:
00BD 3E                ADDC    A,R6
00BE F583              MOV     DPH,A
00C0 E0                MOVX    A,@DPTR
00C1 FF                MOV     R7,A
00C2 E4                CLR     A
00C3 FC                MOV     R4,A
00C4 FD                MOV     R5,A
00C5 FE                MOV     R6,A
00C6 22                RET     
             ; FUNCTION Com0086 (END)

             ; FUNCTION _modbusCrc16 (BEGIN)
                                           ; SOURCE LINE # 51
;---- Variable 'Data' assigned to Register 'R7' ----
0000 8B00        R     MOV     CRC,R3
0002 8A00        R     MOV     CRC+01H,R2
0004 8900        R     MOV     CRC+02H,R1
                                           ; SOURCE LINE # 53
0006 E4                CLR     A
0007 FC                MOV     R4,A
0008 FD                MOV     R5,A
0009 FE                MOV     R6,A
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 88  

000A 120000      E     LCALL   ?C?LLDPTR0
000D EF                MOV     A,R7
000E 6B                XRL     A,R3
000F FF                MOV     R7,A
0010 EA                MOV     A,R2
0011 FE                MOV     R6,A
0012 E9                MOV     A,R1
0013 FD                MOV     R5,A
0014 E8                MOV     A,R0
0015 FC                MOV     R4,A
0016 AB00        R     MOV     R3,CRC
0018 AA00        R     MOV     R2,CRC+01H
001A A900        R     MOV     R1,CRC+02H
001C 120000      E     LCALL   ?C?LSTPTR
                                           ; SOURCE LINE # 54
001F E4                CLR     A
0020 750008      R     MOV     i+03H,#08H
0023 F500        R     MOV     i+02H,A
0025 F500        R     MOV     i+01H,A
0027 F500        R     MOV     i,A
0029         ?C0001:
0029 E4                CLR     A
002A FF                MOV     R7,A
002B FE                MOV     R6,A
002C FD                MOV     R5,A
002D FC                MOV     R4,A
002E AB00        R     MOV     R3,i+03H
0030 AA00        R     MOV     R2,i+02H
0032 A900        R     MOV     R1,i+01H
0034 A800        R     MOV     R0,i
0036 D3                SETB    C
0037 120000      E     LCALL   ?C?ULCMP
003A 404C              JC      ?C0006
                                           ; SOURCE LINE # 55
003C AB00        R     MOV     R3,CRC
003E AA00        R     MOV     R2,CRC+01H
0040 A900        R     MOV     R1,CRC+02H
0042 120000      E     LCALL   ?C?LLDPTR
0045 EF                MOV     A,R7
0046 5401              ANL     A,#01H
0048 FF                MOV     R7,A
0049 E4                CLR     A
004A FE                MOV     R6,A
004B FD                MOV     R5,A
004C FC                MOV     R4,A
004D EF                MOV     A,R7
004E 6013              JZ      ?C0004
                                           ; SOURCE LINE # 56
0050 120000      E     LCALL   ?C?LLDPTR
0053 7801              MOV     R0,#01H
0055 120000      E     LCALL   ?C?ULSHR
0058 EF                MOV     A,R7
0059 6401              XRL     A,#01H
005B FF                MOV     R7,A
005C EE                MOV     A,R6
005D 64A0              XRL     A,#0A0H
005F FE                MOV     R6,A
0060 EC                MOV     A,R4
0061 8008              SJMP    ?C0131
0063         ?C0004:
                                           ; SOURCE LINE # 58
0063 120000      E     LCALL   ?C?LLDPTR
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 89  

0066 7801              MOV     R0,#01H
0068 120000      E     LCALL   ?C?ULSHR
006B         ?C0131:
006B 120000      E     LCALL   ?C?LSTPTR
                                           ; SOURCE LINE # 59
006E         ?C0003:
006E E500        R     MOV     A,i+03H
0070 24FF              ADD     A,#0FFH
0072 F500        R     MOV     i+03H,A
0074 E500        R     MOV     A,i+02H
0076 34FF              ADDC    A,#0FFH
0078 F500        R     MOV     i+02H,A
007A E500        R     MOV     A,i+01H
007C 34FF              ADDC    A,#0FFH
007E F500        R     MOV     i+01H,A
0080 E500        R     MOV     A,i
0082 34FF              ADDC    A,#0FFH
0084 F500        R     MOV     i,A
0086 80A1              SJMP    ?C0001
                                           ; SOURCE LINE # 60
0088         ?C0006:
0088 22                RET     
             ; FUNCTION _modbusCrc16 (END)

             ; FUNCTION DoSlaveTX (BEGIN)
                                           ; SOURCE LINE # 63
                                           ; SOURCE LINE # 64
0000 7B01              MOV     R3,#01H
0002 7A00        R     MOV     R2,#HIGH Tx_Buf
0004 7900        R     MOV     R1,#LOW Tx_Buf
0006 7800        R     MOV     R0,#LOW Tx_Buf_Size
0008 08                INC     R0
0009 08                INC     R0
000A E2                MOVX    A,@R0
000B FE                MOV     R6,A
000C 08                INC     R0
000D E2                MOVX    A,@R0
000E FD                MOV     R5,A
000F AC06              MOV     R4,AR6
0011 120000      E     LCALL   _modBusUartString
                                           ; SOURCE LINE # 65
0014 7800        R     MOV     R0,#LOW Tx_Buf_Size
0016 120000      E     LCALL   ?C?LSTKPDATA
0019 00                DB      00H
001A 00                DB      00H
001B 00                DB      00H
001C 00                DB      00H
                                           ; SOURCE LINE # 66
001D 7F01              MOV     R7,#01H
                                           ; SOURCE LINE # 67
001F 22                RET     
             ; FUNCTION DoSlaveTX (END)

             ; FUNCTION SendMessage (BEGIN)
                                           ; SOURCE LINE # 68
                                           ; SOURCE LINE # 69
0000 7800        R     MOV     R0,#LOW Tx_State
0002 E2                MOVX    A,@R0
0003 6003              JZ      ?C0008
                                           ; SOURCE LINE # 70
0005 7F00              MOV     R7,#00H
0007 22                RET     
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 90  

                                           ; SOURCE LINE # 71
0008         ?C0008:
                                           ; SOURCE LINE # 72
0008 7800        R     MOV     R0,#LOW Tx_Current
000A 120000      E     LCALL   ?C?LSTKPDATA
000D 00                DB      00H
000E 00                DB      00H
000F 00                DB      00H
0010 00                DB      00H
                                           ; SOURCE LINE # 73
0011 7800        R     MOV     R0,#LOW Tx_State
0013 7401              MOV     A,#01H
0015 F2                MOVX    @R0,A
                                           ; SOURCE LINE # 74
0016 FF                MOV     R7,A
                                           ; SOURCE LINE # 75
0017         ?C0009:
0017 22                RET     
             ; FUNCTION SendMessage (END)

             ; FUNCTION _HandleModbusError (BEGIN)
                                           ; SOURCE LINE # 76
;---- Variable 'ErrorCode' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 77
0000 EF                MOV     A,R7
0001 4480              ORL     A,#080H
0003 900000      R     MOV     DPTR,#Tx_Data+01H
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 78
0007 7800        R     MOV     R0,#LOW ModbusSlaveAddress
0009 E2                MOVX    A,@R0
000A 900000      R     MOV     DPTR,#Tx_Data
000D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 79
000E E4                CLR     A
000F 900000      R     MOV     DPTR,#Tx_Data+0102H
0012 F0                MOVX    @DPTR,A
0013 A3                INC     DPTR
0014 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 80
0015 020000      R     LJMP    SendMessage
             ; FUNCTION _HandleModbusError (END)

             ; FUNCTION HandleModbusReadCoils (BEGIN)
                                           ; SOURCE LINE # 83
                                           ; SOURCE LINE # 85
;---- Variable 'tempData' assigned to Register 'R1' ----
0000 E4                CLR     A
0001 F9                MOV     R1,A
                                           ; SOURCE LINE # 87
0002 120000      R     LCALL   L?0143
0005 F500        R     MOV     startAddress+01H,A
0007 EC                MOV     A,R4
0008 3E                ADDC    A,R6
0009 F500        R     MOV     startAddress,A
                                           ; SOURCE LINE # 88
000B A3                INC     DPTR
000C 120000      R     LCALL   L?0145
;---- Variable 'numberOfCoil' assigned to Register 'R4/R5' ----
000F 120000      R     LCALL   L?0158
                                           ; SOURCE LINE # 89
0012 E500        R     MOV     A,startAddress+01H
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 91  

0014 2D                ADD     A,R5
0015 FF                MOV     R7,A
0016 E500        R     MOV     A,startAddress
0018 120000      R     LCALL   L?0160
001B 4005              JC      ?C0011
                                           ; SOURCE LINE # 90
001D 7F02              MOV     R7,#02H
001F 020000      R     LJMP    _HandleModbusError
                                           ; SOURCE LINE # 91
0022         ?C0011:
                                           ; SOURCE LINE # 92
                                           ; SOURCE LINE # 93
0022 AE04              MOV     R6,AR4
0024 ED                MOV     A,R5
0025 7803              MOV     R0,#03H
0027         ?C0102:
0027 CE                XCH     A,R6
0028 C3                CLR     C
0029 13                RRC     A
002A CE                XCH     A,R6
002B 13                RRC     A
002C D8F9              DJNZ    R0,?C0102
002E F500        R     MOV     byteCount+01H,A
0030 8E00        R     MOV     byteCount,R6
                                           ; SOURCE LINE # 94
0032 ED                MOV     A,R5
0033 5407              ANL     A,#07H
0035 6008              JZ      ?C0013
                                           ; SOURCE LINE # 95
0037 0500        R     INC     byteCount+01H
0039 E500        R     MOV     A,byteCount+01H
003B 7002              JNZ     ?C0103
003D 0500        R     INC     byteCount
003F         ?C0103:
                                           ; SOURCE LINE # 96
003F         ?C0013:
                                           ; SOURCE LINE # 97
003F 7401              MOV     A,#01H
                                           ; SOURCE LINE # 98
                                           ; SOURCE LINE # 99
0041 120000      R     LCALL   L?0139
0044 04                INC     A
0045 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 100
0046 850000      R     MOV     tempAddr,startAddress
0049 850000      R     MOV     tempAddr+01H,startAddress+01H
                                           ; SOURCE LINE # 101
004C E4                CLR     A
004D F500        R     MOV     i,A
004F F500        R     MOV     i+01H,A
0051         ?C0014:
0051 C3                CLR     C
0052 E500        R     MOV     A,i+01H
0054 9500        R     SUBB    A,byteCount+01H
0056 E500        R     MOV     A,i
0058 9500        R     SUBB    A,byteCount
005A 506B              JNC     ?C0015
                                           ; SOURCE LINE # 102
005C 120000      R     LCALL   L?0150
005F E4                CLR     A
0060 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 103
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 92  

;---- Variable 'j' assigned to Register 'R4/R5' ----
0061 FD                MOV     R5,A
0062 FC                MOV     R4,A
0063         ?C0017:
                                           ; SOURCE LINE # 104
0063 E500        R     MOV     A,tempAddr
0065 120000      R     LCALL   L?0156
0068 E500        R     MOV     A,tempAddr+01H
006A 120000      R     LCALL   L?0136
006D E0                MOVX    A,@DPTR
006E FE                MOV     R6,A
006F A3                INC     DPTR
0070 E0                MOVX    A,@DPTR
0071 FF                MOV     R7,A
0072 E500        R     MOV     A,tempAddr+01H
0074 540F              ANL     A,#0FH
0076 FB                MOV     R3,A
0077 EF                MOV     A,R7
0078 A803              MOV     R0,AR3
007A 08                INC     R0
007B 8006              SJMP    ?C0105
007D         ?C0104:
007D CE                XCH     A,R6
007E A2E7              MOV     C,ACC.7
0080 13                RRC     A
0081 CE                XCH     A,R6
0082 13                RRC     A
0083         ?C0105:
0083 D8F8              DJNZ    R0,?C0104
0085 5401              ANL     A,#01H
0087 F9                MOV     R1,A
                                           ; SOURCE LINE # 105
0088 120000      R     LCALL   L?0150
008B E0                MOVX    A,@DPTR
008C FF                MOV     R7,A
008D AE05              MOV     R6,AR5
008F A806              MOV     R0,AR6
0091 E9                MOV     A,R1
0092 08                INC     R0
0093 8002              SJMP    ?C0107
0095         ?C0106:
0095 C3                CLR     C
0096 33                RLC     A
0097         ?C0107:
0097 D8FC              DJNZ    R0,?C0106
0099 4F                ORL     A,R7
009A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 106
009B 0500        R     INC     tempAddr+01H
009D E500        R     MOV     A,tempAddr+01H
009F 7002              JNZ     ?C0108
00A1 0500        R     INC     tempAddr
00A3         ?C0108:
                                           ; SOURCE LINE # 111
00A3 0D                INC     R5
00A4 BD0001            CJNE    R5,#00H,?C0109
00A7 0C                INC     R4
00A8         ?C0109:
00A8 ED                MOV     A,R5
00A9 6408              XRL     A,#08H
00AB 4C                ORL     A,R4
00AC 70B5              JNZ     ?C0017
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 93  

00AE         ?C0018:
                                           ; SOURCE LINE # 112
00AE 900000      R     MOV     DPTR,#Tx_Data+0103H
00B1 E0                MOVX    A,@DPTR
00B2 04                INC     A
00B3 F0                MOVX    @DPTR,A
00B4 7006              JNZ     ?C0110
00B6 900000      R     MOV     DPTR,#Tx_Data+0102H
00B9 E0                MOVX    A,@DPTR
00BA 04                INC     A
00BB F0                MOVX    @DPTR,A
00BC         ?C0110:
                                           ; SOURCE LINE # 113
00BC 0500        R     INC     i+01H
00BE E500        R     MOV     A,i+01H
00C0 708F              JNZ     ?C0014
00C2 0500        R     INC     i
00C4         ?C0111:
00C4 020000      R     LJMP    ?C0014
00C7         ?C0015:
                                           ; SOURCE LINE # 114
00C7 900000      R     MOV     DPTR,#Tx_Data+0102H
00CA A3                INC     DPTR
00CB E0                MOVX    A,@DPTR
00CC 14                DEC     A
00CD 900000      R     MOV     DPTR,#Tx_Data+02H
00D0 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 115
00D1 120000      R     LCALL   SendMessage
                                           ; SOURCE LINE # 116
                                           ; SOURCE LINE # 117
00D4         ?C0020:
00D4 22                RET     
             ; FUNCTION HandleModbusReadCoils (END)

             ; FUNCTION HandleModbusReadInputCoil (BEGIN)
                                           ; SOURCE LINE # 118
                                           ; SOURCE LINE # 119
0000 22                RET     
             ; FUNCTION HandleModbusReadInputCoil (END)

             ; FUNCTION HandleModbusReadHoldingRegisters (BEGIN)
                                           ; SOURCE LINE # 120
                                           ; SOURCE LINE # 123
0000 120000      R     LCALL   L?0143
0003 F500        R     MOV     startAddress+01H,A
0005 EC                MOV     A,R4
0006 3E                ADDC    A,R6
0007 F500        R     MOV     startAddress,A
                                           ; SOURCE LINE # 124
0009 A3                INC     DPTR
000A 120000      R     LCALL   L?0145
000D F500        R     MOV     numberOfRegisters+01H,A
000F EC                MOV     A,R4
0010 3E                ADDC    A,R6
0011 F500        R     MOV     numberOfRegisters,A
                                           ; SOURCE LINE # 125
0013 E500        R     MOV     A,startAddress+01H
0015 2500        R     ADD     A,numberOfRegisters+01H
0017 FF                MOV     R7,A
0018 E500        R     MOV     A,startAddress
001A 3500        R     ADDC    A,numberOfRegisters
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 94  

001C FE                MOV     R6,A
001D D3                SETB    C
001E EF                MOV     A,R7
001F 94DC              SUBB    A,#0DCH
0021 EE                MOV     A,R6
0022 9400              SUBB    A,#00H
0024 4005              JC      ?C0022
                                           ; SOURCE LINE # 126
0026 7F02              MOV     R7,#02H
0028 020000      R     LJMP    _HandleModbusError
                                           ; SOURCE LINE # 127
002B         ?C0022:
                                           ; SOURCE LINE # 128
                                           ; SOURCE LINE # 129
002B 7403              MOV     A,#03H
                                           ; SOURCE LINE # 130
                                           ; SOURCE LINE # 131
002D 120000      R     LCALL   L?0139
0030 04                INC     A
0031 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 132
0032 E4                CLR     A
0033 900000      R     MOV     DPTR,#Tx_Data+02H
0036 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 133
;---- Variable 'i' assigned to Register 'R4/R5' ----
0037 FD                MOV     R5,A
0038 FC                MOV     R4,A
0039         ?C0024:
0039 C3                CLR     C
003A ED                MOV     A,R5
003B 9500        R     SUBB    A,numberOfRegisters+01H
003D EC                MOV     A,R4
003E 9500        R     SUBB    A,numberOfRegisters
0040 5052              JNC     ?C0025
                                           ; SOURCE LINE # 134
0042 E500        R     MOV     A,startAddress+01H
0044 2D                ADD     A,R5
0045 FF                MOV     R7,A
0046 E500        R     MOV     A,startAddress
0048 3C                ADDC    A,R4
0049 FE                MOV     R6,A
004A EF                MOV     A,R7
004B 120000      R     LCALL   L?0137
004E E0                MOVX    A,@DPTR
004F FE                MOV     R6,A
0050 A3                INC     DPTR
0051 E0                MOVX    A,@DPTR
0052 8E00        R     MOV     currentData,R6
0054 F500        R     MOV     currentData+01H,A
                                           ; SOURCE LINE # 135
0056 EE                MOV     A,R6
0057 FF                MOV     R7,A
0058 900000      R     MOV     DPTR,#Tx_Data+0102H
005B E0                MOVX    A,@DPTR
005C FA                MOV     R2,A
005D A3                INC     DPTR
005E E0                MOVX    A,@DPTR
005F FB                MOV     R3,A
0060 2400        R     ADD     A,#LOW Tx_Data+02H
0062 F582              MOV     DPL,A
0064 7400        R     MOV     A,#HIGH Tx_Data+02H
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 95  

0066 3A                ADDC    A,R2
0067 F583              MOV     DPH,A
0069 EF                MOV     A,R7
006A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 136
006B 7400        R     MOV     A,#LOW Tx_Data+03H
006D 2B                ADD     A,R3
006E F582              MOV     DPL,A
0070 7400        R     MOV     A,#HIGH Tx_Data+03H
0072 3A                ADDC    A,R2
0073 F583              MOV     DPH,A
0075 E500        R     MOV     A,currentData+01H
0077 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 137
0078 900000      R     MOV     DPTR,#Tx_Data+0103H
007B E0                MOVX    A,@DPTR
007C 2402              ADD     A,#02H
007E F0                MOVX    @DPTR,A
007F 900000      R     MOV     DPTR,#Tx_Data+0102H
0082 E0                MOVX    A,@DPTR
0083 3400              ADDC    A,#00H
0085 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 138
0086 A3                INC     DPTR
0087 E0                MOVX    A,@DPTR
0088 14                DEC     A
0089 900000      R     MOV     DPTR,#Tx_Data+02H
008C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 139
008D 0D                INC     R5
008E BD0001            CJNE    R5,#00H,?C0112
0091 0C                INC     R4
0092         ?C0112:
0092 80A5              SJMP    ?C0024
0094         ?C0025:
                                           ; SOURCE LINE # 140
0094 120000      R     LCALL   SendMessage
                                           ; SOURCE LINE # 141
                                           ; SOURCE LINE # 142
0097         ?C0027:
0097 22                RET     
             ; FUNCTION HandleModbusReadHoldingRegisters (END)

             ; FUNCTION HandleModbusWriteSingleCoil (BEGIN)
                                           ; SOURCE LINE # 143
                                           ; SOURCE LINE # 146
0000 120000      R     LCALL   L?0144
0003 F500        R     MOV     startAddress+01H,A
0005 EC                MOV     A,R4
0006 3E                ADDC    A,R6
0007 F500        R     MOV     startAddress,A
                                           ; SOURCE LINE # 147
0009 A3                INC     DPTR
000A 120000      R     LCALL   L?0145
000D F500        R     MOV     value+01H,A
000F EC                MOV     A,R4
0010 3E                ADDC    A,R6
0011 F500        R     MOV     value,A
                                           ; SOURCE LINE # 148
0013 D3                SETB    C
0014 E500        R     MOV     A,startAddress+01H
0016 94C0              SUBB    A,#0C0H
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 96  

0018 E500        R     MOV     A,startAddress
001A 940D              SUBB    A,#0DH
001C 4005              JC      ?C0028
                                           ; SOURCE LINE # 149
001E 7F02              MOV     R7,#02H
0020 020000      R     LJMP    _HandleModbusError
                                           ; SOURCE LINE # 150
0023         ?C0028:
                                           ; SOURCE LINE # 151
                                           ; SOURCE LINE # 152
0023 900000      R     MOV     DPTR,#Tx_Data+01H
0026 7405              MOV     A,#05H
                                           ; SOURCE LINE # 153
                                           ; SOURCE LINE # 154
0028 120000      R     LCALL   L?0140
                                           ; SOURCE LINE # 155
                                           ; SOURCE LINE # 156
002B 120000      R     LCALL   L?0146
                                           ; SOURCE LINE # 157
002E E500        R     MOV     A,value+01H
0030 4500        R     ORL     A,value
0032 702E              JNZ     ?C0030
                                           ; SOURCE LINE # 158
0034 120000      R     LCALL   L?0135
0037 C083              PUSH    DPH
0039 C082              PUSH    DPL
003B 120000      R     LCALL   L?0148
003E 8005              SJMP    ?C0114
0040         ?C0113:
0040 C3                CLR     C
0041 33                RLC     A
0042 CE                XCH     A,R6
0043 33                RLC     A
0044 CE                XCH     A,R6
0045         ?C0114:
0045 D8F9              DJNZ    R0,?C0113
0047 F4                CPL     A
0048 FF                MOV     R7,A
0049 EE                MOV     A,R6
004A F4                CPL     A
004B 5C                ANL     A,R4
004C FE                MOV     R6,A
004D ED                MOV     A,R5
004E 5F                ANL     A,R7
004F FF                MOV     R7,A
0050 D082              POP     DPL
0052 D083              POP     DPH
0054 EE                MOV     A,R6
0055 F0                MOVX    @DPTR,A
0056 A3                INC     DPTR
0057 EF                MOV     A,R7
0058 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 159
0059 E4                CLR     A
005A 900000      R     MOV     DPTR,#Tx_Data+04H
005D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 160
005E A3                INC     DPTR
005F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 161
0060 8035              SJMP    ?C0031
0062         ?C0030:
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 97  

                                           ; SOURCE LINE # 162
0062 E4                CLR     A
0063 B50031      R     CJNE    A,value+01H,?C0031
0066 E500        R     MOV     A,value
0068 B4FF2C            CJNE    A,#0FFH,?C0031
                                           ; SOURCE LINE # 163
006B 120000      R     LCALL   L?0135
006E C083              PUSH    DPH
0070 C082              PUSH    DPL
0072 120000      R     LCALL   L?0148
0075 8005              SJMP    ?C0117
0077         ?C0116:
0077 C3                CLR     C
0078 33                RLC     A
0079 CE                XCH     A,R6
007A 33                RLC     A
007B CE                XCH     A,R6
007C         ?C0117:
007C D8F9              DJNZ    R0,?C0116
007E FF                MOV     R7,A
007F EC                MOV     A,R4
0080 4E                ORL     A,R6
0081 FE                MOV     R6,A
0082 ED                MOV     A,R5
0083 4F                ORL     A,R7
0084 FF                MOV     R7,A
0085 D082              POP     DPL
0087 D083              POP     DPH
0089 EE                MOV     A,R6
008A F0                MOVX    @DPTR,A
008B A3                INC     DPTR
008C EF                MOV     A,R7
008D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 164
008E 900000      R     MOV     DPTR,#Tx_Data+04H
0091 74FF              MOV     A,#0FFH
0093 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 165
0094 E4                CLR     A
0095 A3                INC     DPTR
0096 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 166
                                           ; SOURCE LINE # 167
                                           ; SOURCE LINE # 168
0097         ?C0031:
                                           ; SOURCE LINE # 169
0097 120000      R     LCALL   SendMessage
                                           ; SOURCE LINE # 170
                                           ; SOURCE LINE # 171
009A         ?C0034:
009A 22                RET     
             ; FUNCTION HandleModbusWriteSingleCoil (END)

             ; FUNCTION HandleModbusWriteSingleRegister (BEGIN)
                                           ; SOURCE LINE # 172
                                           ; SOURCE LINE # 175
0000 120000      R     LCALL   L?0144
;---- Variable 'address' assigned to Register 'R4/R5' ----
0003 120000      R     LCALL   L?0158
                                           ; SOURCE LINE # 176
0006 A3                INC     DPTR
0007 7A00              MOV     R2,#00H
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 98  

0009 120000      R     LCALL   L?0145
000C F500        R     MOV     value+01H,A
000E EA                MOV     A,R2
000F 3E                ADDC    A,R6
0010 F500        R     MOV     value,A
                                           ; SOURCE LINE # 178
0012 900000      R     MOV     DPTR,#Tx_Data+01H
0015 7406              MOV     A,#06H
                                           ; SOURCE LINE # 179
                                           ; SOURCE LINE # 180
0017 120000      R     LCALL   L?0140
001A 7404              MOV     A,#04H
001C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 181
001D C3                CLR     C
001E ED                MOV     A,R5
001F 94DC              SUBB    A,#0DCH
0021 EC                MOV     A,R4
0022 9400              SUBB    A,#00H
0024 4007              JC      ?C0035
                                           ; SOURCE LINE # 182
0026 7F03              MOV     R7,#03H
0028 120000      R     LCALL   _HandleModbusError
                                           ; SOURCE LINE # 183
002B 8031              SJMP    ?C0036
002D         ?C0035:
                                           ; SOURCE LINE # 184
                                           ; SOURCE LINE # 185
002D ED                MOV     A,R5
002E 25E0              ADD     A,ACC
0030 FF                MOV     R7,A
0031 EC                MOV     A,R4
0032 120000      R     LCALL   L?0138
0035 E500        R     MOV     A,value
0037 F0                MOVX    @DPTR,A
0038 A3                INC     DPTR
0039 E500        R     MOV     A,value+01H
003B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 186
;---- Variable 'i' assigned to Register 'R6/R7' ----
003C E4                CLR     A
003D FF                MOV     R7,A
003E FE                MOV     R6,A
003F         ?C0037:
                                           ; SOURCE LINE # 187
003F 7400        R     MOV     A,#LOW Rx_Data+02H
0041 2F                ADD     A,R7
0042 F582              MOV     DPL,A
0044 7400        R     MOV     A,#HIGH Rx_Data+02H
0046 3E                ADDC    A,R6
0047 F583              MOV     DPH,A
0049 E0                MOVX    A,@DPTR
004A FD                MOV     R5,A
004B 7400        R     MOV     A,#LOW Tx_Data+02H
004D 2F                ADD     A,R7
004E 120000      R     LCALL   L?0151
0051 ED                MOV     A,R5
0052 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 188
0053 0F                INC     R7
0054 BF0001            CJNE    R7,#00H,?C0118
0057 0E                INC     R6
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 99  

0058         ?C0118:
0058 EF                MOV     A,R7
0059 6404              XRL     A,#04H
005B 4E                ORL     A,R6
005C 70E1              JNZ     ?C0037
                                           ; SOURCE LINE # 189
005E         ?C0036:
                                           ; SOURCE LINE # 190
005E 020000      R     LJMP    SendMessage
             ; FUNCTION HandleModbusWriteSingleRegister (END)

             ; FUNCTION HandleModbusWriteMultipleCoils (BEGIN)
                                           ; SOURCE LINE # 192
                                           ; SOURCE LINE # 194
0000 E4                CLR     A
0001 F500        R     MOV     tempData,A
                                           ; SOURCE LINE # 196
0003 120000      R     LCALL   L?0144
;---- Variable 'startAddress' assigned to Register 'R4/R5' ----
0006 120000      R     LCALL   L?0159
                                           ; SOURCE LINE # 197
0009 A3                INC     DPTR
000A E0                MOVX    A,@DPTR
000B FE                MOV     R6,A
000C A3                INC     DPTR
000D E0                MOVX    A,@DPTR
000E F9                MOV     R1,A
000F 7A00              MOV     R2,#00H
0011 2400              ADD     A,#00H
0013 F500        R     MOV     numberOfCoil+01H,A
0015 EA                MOV     A,R2
0016 3E                ADDC    A,R6
0017 F500        R     MOV     numberOfCoil,A
                                           ; SOURCE LINE # 198
0019 E500        R     MOV     A,numberOfCoil+01H
001B 2D                ADD     A,R5
001C FF                MOV     R7,A
001D E500        R     MOV     A,numberOfCoil
001F 120000      R     LCALL   L?0160
0022 4005              JC      ?C0041
                                           ; SOURCE LINE # 199
0024 7F02              MOV     R7,#02H
0026 020000      R     LJMP    _HandleModbusError
                                           ; SOURCE LINE # 200
0029         ?C0041:
                                           ; SOURCE LINE # 201
                                           ; SOURCE LINE # 202
0029 AE00        R     MOV     R6,numberOfCoil
002B E500        R     MOV     A,numberOfCoil+01H
002D 7803              MOV     R0,#03H
002F         ?C0119:
002F CE                XCH     A,R6
0030 C3                CLR     C
0031 13                RRC     A
0032 CE                XCH     A,R6
0033 13                RRC     A
0034 D8F9              DJNZ    R0,?C0119
0036 F500        R     MOV     byteCount+01H,A
0038 8E00        R     MOV     byteCount,R6
                                           ; SOURCE LINE # 203
003A E500        R     MOV     A,numberOfCoil+01H
003C 5407              ANL     A,#07H
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 100 

003E 6008              JZ      ?C0043
                                           ; SOURCE LINE # 204
0040 0500        R     INC     byteCount+01H
0042 E500        R     MOV     A,byteCount+01H
0044 7002              JNZ     ?C0120
0046 0500        R     INC     byteCount
0048         ?C0120:
                                           ; SOURCE LINE # 205
0048         ?C0043:
                                           ; SOURCE LINE # 206
0048 900000      R     MOV     DPTR,#Tx_Data+01H
004B 740F              MOV     A,#0FH
                                           ; SOURCE LINE # 207
                                           ; SOURCE LINE # 208
004D 120000      R     LCALL   L?0140
                                           ; SOURCE LINE # 209
                                           ; SOURCE LINE # 210
0050 120000      R     LCALL   L?0146
                                           ; SOURCE LINE # 211
0053 900000      R     MOV     DPTR,#Rx_Data+04H
0056 E0                MOVX    A,@DPTR
0057 900000      R     MOV     DPTR,#Tx_Data+04H
005A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 212
005B A3                INC     DPTR
005C E9                MOV     A,R1
005D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 213
005E 8C00        R     MOV     tempAddr,R4
0060 8D00        R     MOV     tempAddr+01H,R5
                                           ; SOURCE LINE # 214
0062 E4                CLR     A
0063 F500        R     MOV     i,A
0065 F500        R     MOV     i+01H,A
0067         ?C0044:
0067 C3                CLR     C
0068 E500        R     MOV     A,i+01H
006A 9500        R     SUBB    A,byteCount+01H
006C E500        R     MOV     A,i
006E 9500        R     SUBB    A,byteCount
0070 4003              JC      $ + 5H
0072 020000      R     LJMP    ?C0045
                                           ; SOURCE LINE # 215
0075 E4                CLR     A
0076 F500        R     MOV     j,A
0078 F500        R     MOV     j+01H,A
007A         ?C0047:
                                           ; SOURCE LINE # 216
007A AF00        R     MOV     R7,j+01H
007C 7400        R     MOV     A,#LOW Rx_Data+07H
007E 2500        R     ADD     A,i+01H
0080 F582              MOV     DPL,A
0082 7400        R     MOV     A,#HIGH Rx_Data+07H
0084 3500        R     ADDC    A,i
0086 F583              MOV     DPH,A
0088 E0                MOVX    A,@DPTR
0089 FE                MOV     R6,A
008A A807              MOV     R0,AR7
008C 08                INC     R0
008D 8002              SJMP    ?C0122
008F         ?C0121:
008F C3                CLR     C
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 101 

0090 13                RRC     A
0091         ?C0122:
0091 D8FC              DJNZ    R0,?C0121
0093 5401              ANL     A,#01H
0095 F500        R     MOV     tempData,A
                                           ; SOURCE LINE # 217
0097 6027              JZ      ?C0050
                                           ; SOURCE LINE # 218
0099 120000      R     LCALL   L?0155
009C E500        R     MOV     A,tempAddr+01H
009E 120000      R     LCALL   L?0136
00A1 C083              PUSH    DPH
00A3 C082              PUSH    DPL
00A5 E0                MOVX    A,@DPTR
00A6 FC                MOV     R4,A
00A7 A3                INC     DPTR
00A8 E0                MOVX    A,@DPTR
00A9 FD                MOV     R5,A
00AA E500        R     MOV     A,tempAddr+01H
00AC 120000      R     LCALL   L?0149
00AF 8005              SJMP    ?C0124
00B1         ?C0123:
00B1 C3                CLR     C
00B2 33                RLC     A
00B3 CE                XCH     A,R6
00B4 33                RLC     A
00B5 CE                XCH     A,R6
00B6         ?C0124:
00B6 D8F9              DJNZ    R0,?C0123
00B8 FF                MOV     R7,A
00B9 EC                MOV     A,R4
00BA 4E                ORL     A,R6
00BB FE                MOV     R6,A
00BC ED                MOV     A,R5
00BD 4F                ORL     A,R7
                                           ; SOURCE LINE # 219
00BE 8027              SJMP    ?C0132
00C0         ?C0050:
                                           ; SOURCE LINE # 220
                                           ; SOURCE LINE # 221
00C0 120000      R     LCALL   L?0155
00C3 E500        R     MOV     A,tempAddr+01H
00C5 120000      R     LCALL   L?0136
00C8 C083              PUSH    DPH
00CA C082              PUSH    DPL
00CC E0                MOVX    A,@DPTR
00CD FC                MOV     R4,A
00CE A3                INC     DPTR
00CF E0                MOVX    A,@DPTR
00D0 FD                MOV     R5,A
00D1 E500        R     MOV     A,tempAddr+01H
00D3 120000      R     LCALL   L?0149
00D6 8005              SJMP    ?C0126
00D8         ?C0125:
00D8 C3                CLR     C
00D9 33                RLC     A
00DA CE                XCH     A,R6
00DB 33                RLC     A
00DC CE                XCH     A,R6
00DD         ?C0126:
00DD D8F9              DJNZ    R0,?C0125
00DF F4                CPL     A
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 102 

00E0 FF                MOV     R7,A
00E1 EE                MOV     A,R6
00E2 F4                CPL     A
00E3 5C                ANL     A,R4
00E4 FE                MOV     R6,A
00E5 ED                MOV     A,R5
00E6 5F                ANL     A,R7
00E7         ?C0132:
00E7 FF                MOV     R7,A
00E8 D082              POP     DPL
00EA D083              POP     DPH
00EC EE                MOV     A,R6
00ED F0                MOVX    @DPTR,A
00EE A3                INC     DPTR
00EF EF                MOV     A,R7
00F0 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 222
00F1         ?C0051:
                                           ; SOURCE LINE # 223
00F1 0500        R     INC     tempAddr+01H
00F3 E500        R     MOV     A,tempAddr+01H
00F5 7002              JNZ     ?C0127
00F7 0500        R     INC     tempAddr
00F9         ?C0127:
                                           ; SOURCE LINE # 224
00F9 E500        R     MOV     A,numberOfCoil+01H
00FB 1500        R     DEC     numberOfCoil+01H
00FD 7002              JNZ     ?C0128
00FF 1500        R     DEC     numberOfCoil
0101         ?C0128:
                                           ; SOURCE LINE # 225
0101 E500        R     MOV     A,numberOfCoil+01H
0103 4500        R     ORL     A,numberOfCoil
0105 6011              JZ      ?C0046
                                           ; SOURCE LINE # 226
                                           ; SOURCE LINE # 227
                                           ; SOURCE LINE # 228
0107 0500        R     INC     j+01H
0109 E500        R     MOV     A,j+01H
010B 7002              JNZ     ?C0129
010D 0500        R     INC     j
010F         ?C0129:
010F 6408              XRL     A,#08H
0111 4500        R     ORL     A,j
0113 6003              JZ      $ + 5H
0115 020000      R     LJMP    ?C0047
                                           ; SOURCE LINE # 230
0118         ?C0046:
0118 0500        R     INC     i+01H
011A E500        R     MOV     A,i+01H
011C 7002              JNZ     ?C0130
011E 0500        R     INC     i
0120         ?C0130:
0120 020000      R     LJMP    ?C0044
0123         ?C0045:
                                           ; SOURCE LINE # 231
0123 120000      R     LCALL   SendMessage
                                           ; SOURCE LINE # 232
                                           ; SOURCE LINE # 233
0126         ?C0053:
0126 22                RET     
             ; FUNCTION HandleModbusWriteMultipleCoils (END)
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 103 


             ; FUNCTION HandleModbusWriteMultipleRegisters (BEGIN)
                                           ; SOURCE LINE # 234
                                           ; SOURCE LINE # 239
0000 120000      R     LCALL   L?0144
0003 F500        R     MOV     startAddress+01H,A
0005 EC                MOV     A,R4
0006 3E                ADDC    A,R6
0007 F500        R     MOV     startAddress,A
                                           ; SOURCE LINE # 240
0009 A3                INC     DPTR
000A E0                MOVX    A,@DPTR
000B F9                MOV     R1,A
000C FE                MOV     R6,A
000D A3                INC     DPTR
000E E0                MOVX    A,@DPTR
000F FB                MOV     R3,A
0010 2400              ADD     A,#00H
0012 F500        R     MOV     numberOfRegisters+01H,A
0014 EC                MOV     A,R4
0015 3E                ADDC    A,R6
0016 F500        R     MOV     numberOfRegisters,A
                                           ; SOURCE LINE # 241
0018 A3                INC     DPTR
0019 E0                MOVX    A,@DPTR
001A F500        R     MOV     byteCount,A
                                           ; SOURCE LINE # 243
001C E500        R     MOV     A,startAddress+01H
001E 2500        R     ADD     A,numberOfRegisters+01H
0020 FF                MOV     R7,A
0021 E500        R     MOV     A,startAddress
0023 3500        R     ADDC    A,numberOfRegisters
0025 FE                MOV     R6,A
0026 D3                SETB    C
0027 EF                MOV     A,R7
0028 94DC              SUBB    A,#0DCH
002A EE                MOV     A,R6
002B 9400              SUBB    A,#00H
002D 4005              JC      ?C0054
                                           ; SOURCE LINE # 244
002F 7F03              MOV     R7,#03H
0031 020000      R     LJMP    _HandleModbusError
                                           ; SOURCE LINE # 245
0034         ?C0054:
                                           ; SOURCE LINE # 246
                                           ; SOURCE LINE # 248
0034 900000      R     MOV     DPTR,#Tx_Data+01H
0037 7410              MOV     A,#010H
                                           ; SOURCE LINE # 249
                                           ; SOURCE LINE # 250
0039 120000      R     LCALL   L?0140
                                           ; SOURCE LINE # 251
                                           ; SOURCE LINE # 252
003C 120000      R     LCALL   L?0147
                                           ; SOURCE LINE # 253
003F A3                INC     DPTR
0040 E9                MOV     A,R1
0041 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 254
0042 A3                INC     DPTR
0043 EB                MOV     A,R3
0044 F0                MOVX    @DPTR,A
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 104 

                                           ; SOURCE LINE # 256
;---- Variable 'i' assigned to Register 'R5' ----
0045 E4                CLR     A
0046 FD                MOV     R5,A
0047         ?C0056:
0047 ED                MOV     A,R5
0048 C3                CLR     C
0049 9500        R     SUBB    A,numberOfRegisters+01H
004B E4                CLR     A
004C 9500        R     SUBB    A,numberOfRegisters
004E 5043              JNC     ?C0057
                                           ; SOURCE LINE # 257
0050 75F002            MOV     B,#02H
0053 ED                MOV     A,R5
0054 A4                MUL     AB
0055 2400        R     ADD     A,#LOW Rx_Data+07H
0057 F582              MOV     DPL,A
0059 E5F0              MOV     A,B
005B 3400        R     ADDC    A,#HIGH Rx_Data+07H
005D F583              MOV     DPH,A
005F E0                MOVX    A,@DPTR
0060 FE                MOV     R6,A
0061 75F002            MOV     B,#02H
0064 ED                MOV     A,R5
0065 A4                MUL     AB
0066 2400        R     ADD     A,#LOW Rx_Data+08H
0068 F582              MOV     DPL,A
006A E5F0              MOV     A,B
006C 3400        R     ADDC    A,#HIGH Rx_Data+08H
006E F583              MOV     DPH,A
0070 E0                MOVX    A,@DPTR
0071 7A00              MOV     R2,#00H
0073 2400              ADD     A,#00H
0075 F500        R     MOV     value+01H,A
0077 EA                MOV     A,R2
0078 3E                ADDC    A,R6
0079 F500        R     MOV     value,A
                                           ; SOURCE LINE # 258
007B FA                MOV     R2,A
007C ED                MOV     A,R5
007D 7E00              MOV     R6,#00H
007F 2500        R     ADD     A,startAddress+01H
0081 FF                MOV     R7,A
0082 EE                MOV     A,R6
0083 3500        R     ADDC    A,startAddress
0085 FE                MOV     R6,A
0086 EF                MOV     A,R7
0087 120000      R     LCALL   L?0137
008A EA                MOV     A,R2
008B F0                MOVX    @DPTR,A
008C A3                INC     DPTR
008D E500        R     MOV     A,value+01H
008F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 259
0090 0D                INC     R5
0091 80B4              SJMP    ?C0056
0093         ?C0057:
                                           ; SOURCE LINE # 260
0093 120000      R     LCALL   SendMessage
                                           ; SOURCE LINE # 261
                                           ; SOURCE LINE # 262
0096         ?C0059:
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 105 

0096 22                RET     
             ; FUNCTION HandleModbusWriteMultipleRegisters (END)

             ; FUNCTION RxDataAvailable (BEGIN)
                                           ; SOURCE LINE # 263
                                           ; SOURCE LINE # 264
0000 7800        R     MOV     R0,#LOW Rx_Data_Available
0002 E2                MOVX    A,@R0
0003 FF                MOV     R7,A
;---- Variable 'Result' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 265
0004 E4                CLR     A
0005 F2                MOVX    @R0,A
                                           ; SOURCE LINE # 266
                                           ; SOURCE LINE # 267
0006 22                RET     
             ; FUNCTION RxDataAvailable (END)

             ; FUNCTION CheckRxTimeout (BEGIN)
                                           ; SOURCE LINE # 268
                                           ; SOURCE LINE # 270
0000 C3                CLR     C
0001 E500        R     MOV     A,modbusTimerValue
0003 9401              SUBB    A,#01H
0005 400A              JC      ?C0061
                                           ; SOURCE LINE # 271
0007 E4                CLR     A
0008 F500        R     MOV     modbusTimerValue,A
000A F500        R     MOV     modbusTimerValue+01H,A
                                           ; SOURCE LINE # 272
000C F500        R     MOV     modbusReceiveCounter,A
                                           ; SOURCE LINE # 273
000E 7F01              MOV     R7,#01H
0010 22                RET     
                                           ; SOURCE LINE # 274
0011         ?C0061:
                                           ; SOURCE LINE # 275
0011 7F00              MOV     R7,#00H
                                           ; SOURCE LINE # 276
0013         ?C0062:
0013 22                RET     
             ; FUNCTION CheckRxTimeout (END)

             ; FUNCTION checkModbusBufferComplete (BEGIN)
                                           ; SOURCE LINE # 277
                                           ; SOURCE LINE # 278
0000 E4                CLR     A
0001 F500        R     MOV     expectedReceiveCount+03H,A
0003 F500        R     MOV     expectedReceiveCount+02H,A
0005 F500        R     MOV     expectedReceiveCount+01H,A
0007 F500        R     MOV     expectedReceiveCount,A
                                           ; SOURCE LINE # 279
0009 AF00        R     MOV     R7,modbusReceiveCounter
000B D3                SETB    C
000C EF                MOV     A,R7
000D 9404              SUBB    A,#04H
000F 7480              MOV     A,#080H
0011 9480              SUBB    A,#080H
0013 4061              JC      ?C0063
                                           ; SOURCE LINE # 280
                                           ; SOURCE LINE # 281
0015 7800        R     MOV     R0,#LOW ModbusSlaveAddress
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 106 

0017 E2                MOVX    A,@R0
0018 FF                MOV     R7,A
0019 900000      R     MOV     DPTR,#modbusReceiveBuffer
001C E0                MOVX    A,@DPTR
001D 6F                XRL     A,R7
001E 7050              JNZ     ?C0064
                                           ; SOURCE LINE # 282
                                           ; SOURCE LINE # 283
0020 A3                INC     DPTR
0021 E0                MOVX    A,@DPTR
0022 6401              XRL     A,#01H
0024 6019              JZ      ?C0066
0026 E0                MOVX    A,@DPTR
0027 6402              XRL     A,#02H
0029 6014              JZ      ?C0066
002B E0                MOVX    A,@DPTR
002C 6403              XRL     A,#03H
002E 600F              JZ      ?C0066
0030 E0                MOVX    A,@DPTR
0031 6404              XRL     A,#04H
0033 600A              JZ      ?C0066
0035 E0                MOVX    A,@DPTR
0036 6405              XRL     A,#05H
0038 6005              JZ      ?C0066
003A E0                MOVX    A,@DPTR
003B 6406              XRL     A,#06H
003D 7008              JNZ     ?C0065
003F         ?C0066:
                                           ; SOURCE LINE # 284
                                           ; SOURCE LINE # 285
003F E4                CLR     A
0040 750008      R     MOV     expectedReceiveCount+03H,#08H
0043 F500        R     MOV     expectedReceiveCount+02H,A
                                           ; SOURCE LINE # 286
0045 801E              SJMP    ?C0133
0047         ?C0065:
                                           ; SOURCE LINE # 287
0047 900000      R     MOV     DPTR,#modbusReceiveBuffer+01H
004A E0                MOVX    A,@DPTR
004B 640F              XRL     A,#0FH
004D 6005              JZ      ?C0069
004F E0                MOVX    A,@DPTR
0050 6410              XRL     A,#010H
0052 7017              JNZ     ?C0068
0054         ?C0069:
                                           ; SOURCE LINE # 288
                                           ; SOURCE LINE # 289
0054 900000      R     MOV     DPTR,#modbusReceiveBuffer+06H
0057 E0                MOVX    A,@DPTR
0058 2409              ADD     A,#09H
005A FF                MOV     R7,A
005B E4                CLR     A
005C 33                RLC     A
005D FE                MOV     R6,A
005E 33                RLC     A
005F 95E0              SUBB    A,ACC
0061 8F00        R     MOV     expectedReceiveCount+03H,R7
0063 8E00        R     MOV     expectedReceiveCount+02H,R6
0065         ?C0133:
0065 F500        R     MOV     expectedReceiveCount+01H,A
0067 F500        R     MOV     expectedReceiveCount,A
                                           ; SOURCE LINE # 290
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 107 

0069 800E              SJMP    ?C0073
006B         ?C0068:
                                           ; SOURCE LINE # 291
                                           ; SOURCE LINE # 292
006B E4                CLR     A
006C F500        R     MOV     modbusReceiveCounter,A
                                           ; SOURCE LINE # 293
006E FF                MOV     R7,A
006F 22                RET     
                                           ; SOURCE LINE # 294
                                           ; SOURCE LINE # 295
0070         ?C0064:
                                           ; SOURCE LINE # 297
                                           ; SOURCE LINE # 298
0070 E4                CLR     A
0071 F500        R     MOV     modbusReceiveCounter,A
                                           ; SOURCE LINE # 299
0073 7F01              MOV     R7,#01H
0075 22                RET     
                                           ; SOURCE LINE # 300
                                           ; SOURCE LINE # 301
0076         ?C0063:
                                           ; SOURCE LINE # 303
0076 7F02              MOV     R7,#02H
0078 22                RET     
0079         ?C0073:
                                           ; SOURCE LINE # 305
0079 AF00        R     MOV     R7,modbusReceiveCounter
007B E4                CLR     A
007C FC                MOV     R4,A
007D FD                MOV     R5,A
007E FE                MOV     R6,A
007F AB00        R     MOV     R3,expectedReceiveCount+03H
0081 AA00        R     MOV     R2,expectedReceiveCount+02H
0083 A900        R     MOV     R1,expectedReceiveCount+01H
0085 A800        R     MOV     R0,expectedReceiveCount
0087 C3                CLR     C
0088 120000      E     LCALL   ?C?SLCMP
008B 7003              JNZ     ?C0074
                                           ; SOURCE LINE # 306
                                           ; SOURCE LINE # 307
008D 7F03              MOV     R7,#03H
008F 22                RET     
                                           ; SOURCE LINE # 308
0090         ?C0074:
                                           ; SOURCE LINE # 310
0090 7F02              MOV     R7,#02H
                                           ; SOURCE LINE # 311
0092         ?C0071:
0092 22                RET     
             ; FUNCTION checkModbusBufferComplete (END)

             ; FUNCTION RxRTU (BEGIN)
                                           ; SOURCE LINE # 312
                                           ; SOURCE LINE # 314
;---- Variable 'receiveBufferControl' assigned to Register 'R7' ----
0000 E4                CLR     A
0001 FF                MOV     R7,A
                                           ; SOURCE LINE # 315
0002 120000      R     LCALL   checkModbusBufferComplete
                                           ; SOURCE LINE # 316
0005 EF                MOV     A,R7
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 108 

0006 6403              XRL     A,#03H
0008 7064              JNZ     ?C0075
                                           ; SOURCE LINE # 317
000A 900000      R     MOV     DPTR,#modbusReceiveBuffer
000D E0                MOVX    A,@DPTR
000E 900000      R     MOV     DPTR,#Rx_Data
0011 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 318
0012 7800        R     MOV     R0,#LOW Rx_CRC16
0014 120000      E     LCALL   ?C?LSTKPDATA
0017 00                DB      00H
0018 00                DB      00H
0019 FF                DB      0FFH
001A FF                DB      0FFH
                                           ; SOURCE LINE # 319
001B 900000      R     MOV     DPTR,#Rx_Data
001E 120000      R     LCALL   L?0152
                                           ; SOURCE LINE # 320
0021 900000      R     MOV     DPTR,#modbusReceiveBuffer+01H
0024 E0                MOVX    A,@DPTR
0025 900000      R     MOV     DPTR,#Rx_Data+01H
0028 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 321
0029 120000      R     LCALL   L?0152
                                           ; SOURCE LINE # 323
002C E4                CLR     A
002D 900000      R     MOV     DPTR,#Rx_Data+0102H
0030 F0                MOVX    @DPTR,A
0031 A3                INC     DPTR
0032 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 325
0033 750002      R     MOV     i,#02H
0036         ?C0076:
0036 E500        R     MOV     A,i
0038 C3                CLR     C
0039 9500        R     SUBB    A,modbusReceiveCounter
003B 5029              JNC     ?C0077
                                           ; SOURCE LINE # 326
003D 7400        R     MOV     A,#LOW modbusReceiveBuffer
003F 2500        R     ADD     A,i
0041 F582              MOV     DPL,A
0043 E4                CLR     A
0044 3400        R     ADDC    A,#HIGH modbusReceiveBuffer
0046 F583              MOV     DPH,A
0048 E0                MOVX    A,@DPTR
0049 FF                MOV     R7,A
004A 900000      R     MOV     DPTR,#Rx_Data+0102H
004D E4                CLR     A
004E 75F001            MOV     B,#01H
0051 120000      E     LCALL   ?C?ILDIX
0054 FC                MOV     R4,A
0055 7400        R     MOV     A,#LOW Rx_Data+02H
0057 25F0              ADD     A,B
0059 F582              MOV     DPL,A
005B 7400        R     MOV     A,#HIGH Rx_Data+02H
005D 3C                ADDC    A,R4
005E F583              MOV     DPH,A
0060 EF                MOV     A,R7
0061 F0                MOVX    @DPTR,A
0062 0500        R     INC     i
0064 80D0              SJMP    ?C0076
0066         ?C0077:
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 109 

                                           ; SOURCE LINE # 328
0066 7800        R     MOV     R0,#LOW Rx_State
0068 7402              MOV     A,#02H
006A F2                MOVX    @R0,A
                                           ; SOURCE LINE # 330
006B E4                CLR     A
006C F500        R     MOV     modbusReceiveCounter,A
                                           ; SOURCE LINE # 331
006E         ?C0075:
                                           ; SOURCE LINE # 333
006E 120000      R     LCALL   CheckRxTimeout
                                           ; SOURCE LINE # 335
0071 7800        R     MOV     R0,#LOW Rx_State
0073 E2                MOVX    A,@R0
0074 6402              XRL     A,#02H
0076 6003              JZ      $ + 5H
0078 020000      R     LJMP    ?C0084
007B C3                CLR     C
007C 900000      R     MOV     DPTR,#Rx_Data+0103H
007F E0                MOVX    A,@DPTR
0080 9402              SUBB    A,#02H
0082 900000      R     MOV     DPTR,#Rx_Data+0102H
0085 E0                MOVX    A,@DPTR
0086 9400              SUBB    A,#00H
0088 5003              JNC     $ + 5H
008A 020000      R     LJMP    ?C0084
                                           ; SOURCE LINE # 336
                                           ; SOURCE LINE # 338
008D A3                INC     DPTR
008E E0                MOVX    A,@DPTR
008F 24FE              ADD     A,#0FEH
0091 F0                MOVX    @DPTR,A
0092 900000      R     MOV     DPTR,#Rx_Data+0102H
0095 E0                MOVX    A,@DPTR
0096 34FF              ADDC    A,#0FFH
0098 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 339
0099 E4                CLR     A
009A F500        R     MOV     i,A
009C         ?C0080:
009C D3                SETB    C
009D 900000      R     MOV     DPTR,#Rx_Data+0103H
00A0 E0                MOVX    A,@DPTR
00A1 9500        R     SUBB    A,i
00A3 900000      R     MOV     DPTR,#Rx_Data+0102H
00A6 E0                MOVX    A,@DPTR
00A7 9400              SUBB    A,#00H
00A9 401A              JC      ?C0081
                                           ; SOURCE LINE # 340
                                           ; SOURCE LINE # 341
00AB 7400        R     MOV     A,#LOW Rx_Data+02H
00AD 2500        R     ADD     A,i
00AF F582              MOV     DPL,A
00B1 E4                CLR     A
00B2 3400        R     ADDC    A,#HIGH Rx_Data+02H
00B4 F583              MOV     DPH,A
00B6 E0                MOVX    A,@DPTR
00B7 FF                MOV     R7,A
00B8 7BFE              MOV     R3,#0FEH
00BA 7A00        R     MOV     R2,#HIGH Rx_CRC16
00BC 7900        R     MOV     R1,#LOW Rx_CRC16
00BE 120000      R     LCALL   _modbusCrc16
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 110 

                                           ; SOURCE LINE # 342
00C1 0500        R     INC     i
00C3 80D7              SJMP    ?C0080
00C5         ?C0081:
                                           ; SOURCE LINE # 344
00C5 900000      R     MOV     DPTR,#Rx_Data+0102H
00C8 E0                MOVX    A,@DPTR
00C9 FE                MOV     R6,A
00CA A3                INC     DPTR
00CB E0                MOVX    A,@DPTR
00CC 2400        R     ADD     A,#LOW Rx_Data+03H
00CE F582              MOV     DPL,A
00D0 7400        R     MOV     A,#HIGH Rx_Data+03H
00D2 120000      R     LCALL   L?0161
00D5 7808              MOV     R0,#08H
00D7 120000      E     LCALL   ?C?LSHL
00DA A804              MOV     R0,AR4
00DC A905              MOV     R1,AR5
00DE AA06              MOV     R2,AR6
00E0 AB07              MOV     R3,AR7
00E2 900000      R     MOV     DPTR,#Rx_Data+0102H
00E5 E0                MOVX    A,@DPTR
00E6 FE                MOV     R6,A
00E7 A3                INC     DPTR
00E8 E0                MOVX    A,@DPTR
00E9 2400        R     ADD     A,#LOW Rx_Data+02H
00EB F582              MOV     DPL,A
00ED 7400        R     MOV     A,#HIGH Rx_Data+02H
00EF 120000      R     LCALL   L?0161
00F2 EB                MOV     A,R3
00F3 2F                ADD     A,R7
00F4 FF                MOV     R7,A
00F5 EE                MOV     A,R6
00F6 3A                ADDC    A,R2
00F7 FE                MOV     R6,A
00F8 ED                MOV     A,R5
00F9 39                ADDC    A,R1
00FA FD                MOV     R5,A
00FB EC                MOV     A,R4
00FC 38                ADDC    A,R0
00FD FC                MOV     R4,A
00FE 7800        R     MOV     R0,#LOW Rx_CRC16
0100 120000      R     LCALL   L?0154
0103 7004              JNZ     ?C0083
                                           ; SOURCE LINE # 345
                                           ; SOURCE LINE # 347
0105 7800        R     MOV     R0,#LOW Rx_Data_Available
0107 04                INC     A
0108 F2                MOVX    @R0,A
                                           ; SOURCE LINE # 348
0109         ?C0083:
                                           ; SOURCE LINE # 350
0109 E4                CLR     A
010A 7800        R     MOV     R0,#LOW Rx_State
010C F2                MOVX    @R0,A
                                           ; SOURCE LINE # 351
                                           ; SOURCE LINE # 352
010D         ?C0084:
010D 22                RET     
010E         L?0152:
010E E0                MOVX    A,@DPTR
010F FF                MOV     R7,A
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 111 

0110 7BFE              MOV     R3,#0FEH
0112 7A00        R     MOV     R2,#HIGH Rx_CRC16
0114 7900        R     MOV     R1,#LOW Rx_CRC16
0116 120000      R     LCALL   _modbusCrc16
0119 22                RET     
             ; FUNCTION RxRTU (END)

             ; FUNCTION TxRTU (BEGIN)
                                           ; SOURCE LINE # 353
                                           ; SOURCE LINE # 354
0000 7800        R     MOV     R0,#LOW Tx_CRC16
0002 120000      E     LCALL   ?C?LSTKPDATA
0005 00                DB      00H
0006 00                DB      00H
0007 FF                DB      0FFH
0008 FF                DB      0FFH
                                           ; SOURCE LINE # 355
0009 7800        R     MOV     R0,#LOW Tx_Buf_Size
000B 120000      E     LCALL   ?C?LSTKPDATA
000E 00                DB      00H
000F 00                DB      00H
0010 00                DB      00H
0011 00                DB      00H
                                           ; SOURCE LINE # 356
0012 900000      R     MOV     DPTR,#Tx_Data
0015 120000      R     LCALL   L?0141
                                           ; SOURCE LINE # 357
0018 120000      R     LCALL   L?0153
                                           ; SOURCE LINE # 358
001B 900000      R     MOV     DPTR,#Tx_Data+01H
001E 120000      R     LCALL   L?0141
                                           ; SOURCE LINE # 359
0021 120000      R     LCALL   L?0153
                                           ; SOURCE LINE # 360
0024 7800        R     MOV     R0,#LOW Tx_Current
0026 120000      E     LCALL   ?C?LSTKPDATA
0029 00                DB      00H
002A 00                DB      00H
002B 00                DB      00H
002C 00                DB      00H
002D         ?C0085:
002D 900000      R     MOV     DPTR,#Tx_Data+0102H
0030 E0                MOVX    A,@DPTR
0031 FE                MOV     R6,A
0032 A3                INC     DPTR
0033 E0                MOVX    A,@DPTR
0034 FF                MOV     R7,A
0035 E4                CLR     A
0036 FC                MOV     R4,A
0037 FD                MOV     R5,A
0038 7800        R     MOV     R0,#LOW Tx_Current
003A 120000      R     LCALL   L?0154
003D 5044              JNC     ?C0086
                                           ; SOURCE LINE # 361
003F 7800        R     MOV     R0,#LOW Tx_Current
0041 08                INC     R0
0042 08                INC     R0
0043 08                INC     R0
0044 E2                MOVX    A,@R0
0045 FB                MOV     R3,A
0046 2400        R     ADD     A,#LOW Tx_Data+02H
0048 F582              MOV     DPL,A
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 112 

004A E4                CLR     A
004B 3400        R     ADDC    A,#HIGH Tx_Data+02H
004D F583              MOV     DPH,A
004F E0                MOVX    A,@DPTR
0050 FA                MOV     R2,A
0051 120000      R     LCALL   L?0142
0054 EA                MOV     A,R2
0055 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 362
0056 7400        R     MOV     A,#LOW Tx_Data+02H
0058 2B                ADD     A,R3
0059 F582              MOV     DPL,A
005B E4                CLR     A
005C 3400        R     ADDC    A,#HIGH Tx_Data+02H
005E F583              MOV     DPH,A
0060 E0                MOVX    A,@DPTR
0061 FF                MOV     R7,A
0062 7BFE              MOV     R3,#0FEH
0064 7A00        R     MOV     R2,#HIGH Tx_CRC16
0066 7900        R     MOV     R1,#LOW Tx_CRC16
0068 120000      R     LCALL   _modbusCrc16
                                           ; SOURCE LINE # 363
006B 7800        R     MOV     R0,#LOW Tx_Current
006D 120000      R     LCALL   L?0157
0070 2401              ADD     A,#01H
0072 FF                MOV     R7,A
0073 E4                CLR     A
0074 3E                ADDC    A,R6
0075 FE                MOV     R6,A
0076 E4                CLR     A
0077 3D                ADDC    A,R5
0078 FD                MOV     R5,A
0079 E4                CLR     A
007A 3C                ADDC    A,R4
007B FC                MOV     R4,A
007C 7800        R     MOV     R0,#LOW Tx_Current
007E 120000      E     LCALL   ?C?LSTPDATA
0081 80AA              SJMP    ?C0085
0083         ?C0086:
                                           ; SOURCE LINE # 364
0083 7800        R     MOV     R0,#LOW Tx_CRC16
0085 120000      R     LCALL   L?0157
0088 FF                MOV     R7,A
0089 E4                CLR     A
008A AB07              MOV     R3,AR7
008C 120000      R     LCALL   L?0142
008F EB                MOV     A,R3
0090 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 365
0091 7800        R     MOV     R0,#LOW Tx_CRC16
0093 08                INC     R0
0094 08                INC     R0
0095 E2                MOVX    A,@R0
0096 FE                MOV     R6,A
0097 E4                CLR     A
0098 FF                MOV     R7,A
0099 E4                CLR     A
009A FD                MOV     R5,A
009B FC                MOV     R4,A
009C 7808              MOV     R0,#08H
009E 120000      E     LCALL   ?C?ULSHR
00A1 AB07              MOV     R3,AR7
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 113 

00A3 120000      R     LCALL   L?0142
00A6 EB                MOV     A,R3
00A7 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 366
00A8 120000      R     LCALL   DoSlaveTX
                                           ; SOURCE LINE # 367
00AB E4                CLR     A
00AC 7800        R     MOV     R0,#LOW Tx_State
00AE F2                MOVX    @R0,A
                                           ; SOURCE LINE # 368
00AF 22                RET     
00B0         L?0153:
00B0 EB                MOV     A,R3
00B1 F0                MOVX    @DPTR,A
00B2 FF                MOV     R7,A
00B3 7BFE              MOV     R3,#0FEH
00B5 7A00        R     MOV     R2,#HIGH Tx_CRC16
00B7 7900        R     MOV     R1,#LOW Tx_CRC16
00B9 120000      R     LCALL   _modbusCrc16
00BC 22                RET     
             ; FUNCTION TxRTU (END)

             ; FUNCTION modbusPorcess (BEGIN)
                                           ; SOURCE LINE # 369
                                           ; SOURCE LINE # 370
0000 7800        R     MOV     R0,#LOW Tx_State
0002 E2                MOVX    A,@R0
0003 6003              JZ      ?C0089
                                           ; SOURCE LINE # 371
0005 120000      R     LCALL   TxRTU
                                           ; SOURCE LINE # 372
0008         ?C0089:
                                           ; SOURCE LINE # 373
0008 120000      R     LCALL   RxRTU
                                           ; SOURCE LINE # 374
000B 120000      R     LCALL   RxDataAvailable
000E EF                MOV     A,R7
000F 603A              JZ      ?C0100
                                           ; SOURCE LINE # 375
0011 7800        R     MOV     R0,#LOW ModbusSlaveAddress
0013 E2                MOVX    A,@R0
0014 FF                MOV     R7,A
0015 900000      R     MOV     DPTR,#Rx_Data
0018 E0                MOVX    A,@DPTR
0019 6F                XRL     A,R7
001A 702F              JNZ     ?C0100
                                           ; SOURCE LINE # 376
001C A3                INC     DPTR
001D E0                MOVX    A,@DPTR
001E 24FD              ADD     A,#0FDH
0020 6015              JZ      ?C0094
0022 24FE              ADD     A,#0FEH
0024 6014              JZ      ?C0095
0026 14                DEC     A
0027 6014              JZ      ?C0096
0029 24F7              ADD     A,#0F7H
002B 6013              JZ      ?C0097
002D 14                DEC     A
002E 6013              JZ      ?C0098
0030 240F              ADD     A,#0FH
0032 7012              JNZ     ?C0099
                                           ; SOURCE LINE # 377
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 114 

                                           ; SOURCE LINE # 378
0034         ?C0093:
                                           ; SOURCE LINE # 379
0034 020000      R     LJMP    HandleModbusReadCoils
                                           ; SOURCE LINE # 380
                                           ; SOURCE LINE # 381
                                           ; SOURCE LINE # 382
0037         ?C0094:
                                           ; SOURCE LINE # 383
0037 020000      R     LJMP    HandleModbusReadHoldingRegisters
                                           ; SOURCE LINE # 384
                                           ; SOURCE LINE # 385
                                           ; SOURCE LINE # 386
003A         ?C0095:
                                           ; SOURCE LINE # 387
003A 020000      R     LJMP    HandleModbusWriteSingleCoil
                                           ; SOURCE LINE # 388
                                           ; SOURCE LINE # 389
                                           ; SOURCE LINE # 390
003D         ?C0096:
                                           ; SOURCE LINE # 391
003D 020000      R     LJMP    HandleModbusWriteSingleRegister
                                           ; SOURCE LINE # 392
                                           ; SOURCE LINE # 393
                                           ; SOURCE LINE # 394
0040         ?C0097:
                                           ; SOURCE LINE # 395
0040 020000      R     LJMP    HandleModbusWriteMultipleCoils
                                           ; SOURCE LINE # 396
                                           ; SOURCE LINE # 397
                                           ; SOURCE LINE # 398
0043         ?C0098:
                                           ; SOURCE LINE # 399
0043 020000      R     LJMP    HandleModbusWriteMultipleRegisters
                                           ; SOURCE LINE # 400
                                           ; SOURCE LINE # 401
                                           ; SOURCE LINE # 402
0046         ?C0099:
                                           ; SOURCE LINE # 403
0046 7F01              MOV     R7,#01H
0048 120000      R     LCALL   _HandleModbusError
                                           ; SOURCE LINE # 404
                                           ; SOURCE LINE # 405
                                           ; SOURCE LINE # 406
                                           ; SOURCE LINE # 407
                                           ; SOURCE LINE # 408
                                           ; SOURCE LINE # 409
004B         ?C0100:
004B 22                RET     
             ; FUNCTION modbusPorcess (END)

             ; FUNCTION _InitModbus (BEGIN)
                                           ; SOURCE LINE # 410
;---- Variable 'modbusSlaveAddress' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 411
0000 7800        R     MOV     R0,#LOW ModbusSlaveAddress
0002 EF                MOV     A,R7
0003 F2                MOVX    @R0,A
                                           ; SOURCE LINE # 412
0004 AF00        R     MOV     R7,baudrate+03H
0006 AE00        R     MOV     R6,baudrate+02H
0008 AD00        R     MOV     R5,baudrate+01H
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 115 

000A AC00        R     MOV     R4,baudrate
000C 120000      E     LCALL   _modBusUartInitialise
                                           ; SOURCE LINE # 413
000F 020000      E     LJMP    modBusTimerInitialise
             ; FUNCTION _InitModbus (END)

C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 116 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


uint8_t. . . . . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
uint16_t . . . . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
uint32_t . . . . . . . . . . . . . . .  TYPEDEF  -----  U_LONG   -----  4
uint64_t . . . . . . . . . . . . . . .  TYPEDEF  -----  ARRAY    -----  8
int8_t . . . . . . . . . . . . . . . .  TYPEDEF  -----  CHAR     -----  1
int16_t. . . . . . . . . . . . . . . .  TYPEDEF  -----  INT      -----  2
int32_t. . . . . . . . . . . . . . . .  TYPEDEF  -----  LONG     -----  4
int64_t. . . . . . . . . . . . . . . .  TYPEDEF  -----  ARRAY    -----  8
fp32_t . . . . . . . . . . . . . . . .  TYPEDEF  -----  FLOAT    -----  4
fp64_t . . . . . . . . . . . . . . . .  TYPEDEF  -----  FLOAT    -----  4
bool . . . . . . . . . . . . . . . . .  TYPEDEF  -----  BIT      -----  1
false. . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
true . . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
SI_UU16. . . . . . . . . . . . . . . .  * TAG *  -----  UNION    -----  2
  u16. . . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0000H  2
  s16. . . . . . . . . . . . . . . . .  MEMBER   -----  INT      0000H  2
  u8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
  s8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
SI_UU16_t. . . . . . . . . . . . . . .  TYPEDEF  -----  UNION    -----  2
  u16. . . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0000H  2
  s16. . . . . . . . . . . . . . . . .  MEMBER   -----  INT      0000H  2
  u8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
  s8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
SI_UU32. . . . . . . . . . . . . . . .  * TAG *  -----  UNION    -----  4
  u32. . . . . . . . . . . . . . . . .  MEMBER   -----  U_LONG   0000H  4
  s32. . . . . . . . . . . . . . . . .  MEMBER   -----  LONG     0000H  4
  uu16 . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  u16. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  s16. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  u8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  s8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
SI_UU32_t. . . . . . . . . . . . . . .  TYPEDEF  -----  UNION    -----  4
  u32. . . . . . . . . . . . . . . . .  MEMBER   -----  U_LONG   0000H  4
  s32. . . . . . . . . . . . . . . . .  MEMBER   -----  LONG     0000H  4
  uu16 . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  u16. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  s16. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  u8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  s8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
GPTR_t . . . . . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  3
  memtype. . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  address. . . . . . . . . . . . . . .  MEMBER   -----  UNION    0001H  2
SI_GEN_PTR . . . . . . . . . . . . . .  * TAG *  -----  UNION    -----  3
  u8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  3
  gptr . . . . . . . . . . . . . . . .  MEMBER   -----  STRUCT   0000H  3
SI_GEN_PTR_t . . . . . . . . . . . . .  TYPEDEF  -----  UNION    -----  3
  u8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  3
  gptr . . . . . . . . . . . . . . . .  MEMBER   -----  STRUCT   0000H  3
U8 . . . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
U16. . . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
U32. . . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_LONG   -----  4
S8 . . . . . . . . . . . . . . . . . .  TYPEDEF  -----  CHAR     -----  1
S16. . . . . . . . . . . . . . . . . .  TYPEDEF  -----  INT      -----  2
S32. . . . . . . . . . . . . . . . . .  TYPEDEF  -----  LONG     -----  4
UU16 . . . . . . . . . . . . . . . . .  * TAG *  -----  UNION    -----  2
  U16. . . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0000H  2
  S16. . . . . . . . . . . . . . . . .  MEMBER   -----  INT      0000H  2
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 117 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


  U8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
  S8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
UU16 . . . . . . . . . . . . . . . . .  TYPEDEF  -----  UNION    -----  2
  U16. . . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0000H  2
  S16. . . . . . . . . . . . . . . . .  MEMBER   -----  INT      0000H  2
  U8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
  S8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
UU32 . . . . . . . . . . . . . . . . .  * TAG *  -----  UNION    -----  4
  U32. . . . . . . . . . . . . . . . .  MEMBER   -----  U_LONG   0000H  4
  S32. . . . . . . . . . . . . . . . .  MEMBER   -----  LONG     0000H  4
  UU16 . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  U16. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  S16. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  U8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  S8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
UU32 . . . . . . . . . . . . . . . . .  TYPEDEF  -----  UNION    -----  4
  U32. . . . . . . . . . . . . . . . .  MEMBER   -----  U_LONG   0000H  4
  S32. . . . . . . . . . . . . . . . .  MEMBER   -----  LONG     0000H  4
  UU16 . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  U16. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  S16. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  U8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  S8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
SI_GENERIC_PTR . . . . . . . . . . . .  * TAG *  -----  UNION    -----  3
  U8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  3
  GPTR . . . . . . . . . . . . . . . .  MEMBER   -----  STRUCT   0000H  3
SI_GENERIC_PTR . . . . . . . . . . . .  TYPEDEF  -----  UNION    -----  3
  U8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  3
  GPTR . . . . . . . . . . . . . . . .  MEMBER   -----  STRUCT   0000H  3
size_t . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
wchar_t. . . . . . . . . . . . . . . .  TYPEDEF  -----  CHAR     -----  1
_modBusUartInitialise. . . . . . . . .  EXTERN   CODE   PROC     -----  -----
modBusTimerInitialise. . . . . . . . .  EXTERN   CODE   PROC     -----  -----
_modBusUartString. . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
adcTempDat_t . . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  39
  dat. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  36
  out. . . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0024H  2
  wIndex . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0026H  1
NVRAM0 . . . . . . . . . . . . . . . .  EXTERN   XDATA  ARRAY    -----  440
modbusTimerValue . . . . . . . . . . .  PUBLIC   DATA   U_INT    0000H  2
modbusReceiveCounter . . . . . . . . .  PUBLIC   DATA   U_CHAR   0002H  1
modbusReceiveBuffer. . . . . . . . . .  PUBLIC   XDATA  ARRAY    0000H  256
modbusPorcess. . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
RXTX_IDLE. . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
RXTX_START . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
RXTX_DATABUF . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
RXTX_WAIT_ANSWER . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
RXTX_TIMEOUT . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
MODBUS_RXTX_STATE. . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
modbusRxTxData_t . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  260
  address. . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  function . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  dataBuf. . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0002H  256
  dataLen. . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0102H  2
ModbusSlaveAddress . . . . . . . . . .  PUBLIC   PDATA  U_CHAR   0000H  1
Tx_Data. . . . . . . . . . . . . . . .  PUBLIC   XDATA  STRUCT   0100H  260
Tx_Current . . . . . . . . . . . . . .  PUBLIC   PDATA  U_LONG   0001H  4
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 118 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


Tx_CRC16 . . . . . . . . . . . . . . .  PUBLIC   PDATA  U_LONG   0005H  4
Tx_State . . . . . . . . . . . . . . .  PUBLIC   PDATA  U_CHAR   0009H  1
Tx_Buf . . . . . . . . . . . . . . . .  PUBLIC   XDATA  ARRAY    0204H  256
Tx_Buf_Size. . . . . . . . . . . . . .  PUBLIC   PDATA  U_LONG   000AH  4
Rx_Data. . . . . . . . . . . . . . . .  PUBLIC   XDATA  STRUCT   0304H  260
Rx_CRC16 . . . . . . . . . . . . . . .  PUBLIC   PDATA  U_LONG   000EH  4
Rx_State . . . . . . . . . . . . . . .  PUBLIC   PDATA  U_CHAR   0012H  1
Rx_Data_Available. . . . . . . . . . .  PUBLIC   PDATA  U_CHAR   0013H  1
_modbusCrc16 . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  Data . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
  CRC. . . . . . . . . . . . . . . . .  AUTO     DATA   PTR      0000H  3
  i. . . . . . . . . . . . . . . . . .  AUTO     DATA   U_LONG   0003H  4
DoSlaveTX. . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
SendMessage. . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
_HandleModbusError . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  ErrorCode. . . . . . . . . . . . . .  * REG *  DATA   CHAR     0007H  1
HandleModbusReadCoils. . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  startAddress . . . . . . . . . . . .  AUTO     DATA   U_INT    0000H  2
  numberOfCoil . . . . . . . . . . . .  * REG *  DATA   U_INT    0004H  2
  byteCount. . . . . . . . . . . . . .  AUTO     DATA   U_INT    0002H  2
  tempAddr . . . . . . . . . . . . . .  AUTO     DATA   U_INT    0004H  2
  i. . . . . . . . . . . . . . . . . .  AUTO     DATA   U_INT    0006H  2
  j. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0004H  2
  tempData . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0001H  1
HandleModbusReadInputCoil. . . . . . .  PUBLIC   CODE   PROC     0000H  -----
HandleModbusReadHoldingRegisters . . .  PUBLIC   CODE   PROC     0000H  -----
  startAddress . . . . . . . . . . . .  AUTO     DATA   U_INT    0000H  2
  numberOfRegisters. . . . . . . . . .  AUTO     DATA   U_INT    0002H  2
  i. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0004H  2
  currentData. . . . . . . . . . . . .  AUTO     DATA   U_INT    0004H  2
HandleModbusWriteSingleCoil. . . . . .  PUBLIC   CODE   PROC     0000H  -----
  startAddress . . . . . . . . . . . .  AUTO     DATA   U_INT    0000H  2
  value. . . . . . . . . . . . . . . .  AUTO     DATA   U_INT    0002H  2
HandleModbusWriteSingleRegister. . . .  PUBLIC   CODE   PROC     0000H  -----
  address. . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0004H  2
  value. . . . . . . . . . . . . . . .  AUTO     DATA   U_INT    0000H  2
  i. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0006H  2
HandleModbusWriteMultipleCoils . . . .  PUBLIC   CODE   PROC     0000H  -----
  startAddress . . . . . . . . . . . .  * REG *  DATA   U_INT    0004H  2
  numberOfCoil . . . . . . . . . . . .  AUTO     DATA   U_INT    0000H  2
  byteCount. . . . . . . . . . . . . .  AUTO     DATA   U_INT    0002H  2
  tempAddr . . . . . . . . . . . . . .  AUTO     DATA   U_INT    0004H  2
  i. . . . . . . . . . . . . . . . . .  AUTO     DATA   U_INT    0006H  2
  j. . . . . . . . . . . . . . . . . .  AUTO     DATA   U_INT    0008H  2
  tempData . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   000AH  1
HandleModbusWriteMultipleRegisters . .  PUBLIC   CODE   PROC     0000H  -----
  startAddress . . . . . . . . . . . .  AUTO     DATA   U_INT    0000H  2
  numberOfRegisters. . . . . . . . . .  AUTO     DATA   U_INT    0002H  2
  value. . . . . . . . . . . . . . . .  AUTO     DATA   U_INT    0004H  2
  byteCount. . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0006H  1
  i. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0005H  1
RxDataAvailable. . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  Result . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
CheckRxTimeout . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
checkModbusBufferComplete. . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  expectedReceiveCount . . . . . . . .  AUTO     DATA   LONG     0000H  4
RxRTU. . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
C51 COMPILER V9.59.0.0   MODBUS                                                            01/01/2019 23:40:45 PAGE 119 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


  i. . . . . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0000H  1
  receiveBufferControl . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
TxRTU. . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
_InitModbus. . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  modbusSlaveAddress . . . . . . . . .  AUTO     DATA   U_CHAR   0007H  1
  baudrate . . . . . . . . . . . . . .  AUTO     DATA   U_LONG   0001H  4


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2219    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   1032    ----
   PDATA SIZE       =     20    ----
   DATA SIZE        =      3      55
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
