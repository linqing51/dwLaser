C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MODBUS
OBJECT MODULE PLACED IN .\Objects\Modbus.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Modbus\Modbus.c OBJECTADVANCED OPTIMIZE(8,SPEED) REGFILE(.\Objects\dwLas
                    -er_F020.ORC) BROWSE ORDER INCDIR(.\Lib;.\Driver;.\MainApp;.\Modbus) DEFINE(C8051F580) DEBUG CODE LISTINCLUDE SYMBOLS PRI
                    -NT(.\Listings\Modbus.lst) PREPRINT(.\Listings\Modbus.i) OBJECT(.\Objects\Modbus.obj)

line level    source

   1          #include "modbus.h"
   1      =1  #ifndef __MODBUS__H__
   2      =1  #define __MODBUS__H__
   3      =1  /*****************************************************************************/
   4      =1  #include "appConfig.h"
   1      =2  #ifndef __APPCONFIG_H__
   2      =2  #define __APPCONFIG_H__
   3      =2  /*****************************************************************************/
   4      =2  #define CONFIG_SYSCLK                       (22118400L)
   5      =2  #ifdef C8051F020
           =2 #define SAR_CLK                                                 2000000L//ADC0时钟 <2.5MHz
           =2 #endif
   8      =2  #define CONFIG_DEBUG                        0//调试功能
   9      =2  #define CONFIG_USING_WDT                                        0//使能看门狗
  10      =2  #define CONFIG_USING_RESET                                      0//使能PLC复位MCU功能
  11      =2  #define CONFIG_LADDER_SECTORS_START                     64//指令起始地址
  12      =2  #define CONFIG_LADDER_SECTORS_END                       128//指令结束地址
  13      =2  #define CONFIG_LASERTIMER_OVERFLOW_US           1000L//定时器周期 1mS
  14      =2  #define CONFIG_VERSION                                          0x0001
  15      =2  #define CONFIG_CHECK_CODE                                       0x5A7E
  16      =2  
  17      =2  /*****************************************************************************/
  18      =2  #define CONFIG_UART0_BAUDRATE                           57600//串口波特率
  19      =2  #define CONFIG_UART0_PARITY                                     NONE
  20      =2  #define CONFIG_UART0_STOPBIT                            1
  21      =2  #define CONFIG_UART0_DATABIT                            8
  22      =2  
  23      =2  #define CONFIG_UART1_BAUDRATE                           115200//串口波特率
  24      =2  #define CONFIG_UART1_PARITY                                     NONE
  25      =2  #define CONFIG_UART1_STOPBIT                            1
  26      =2  #define CONFIG_UART1_DATABIT                            8
  27      =2  /*****************************************************************************/
  28      =2  #define CONFIG_I2C0_FREQ                                        (100000L)               
  29      =2  #define CONFIG_I2C1_FREQ                                        (100000L)
  30      =2  #define CONFIG_I2C2_FREQ                                        (100000L)
  31      =2  #define CONFIG_I2C3_FREQ                                        (100000L)
  32      =2  #define CONFIG_I2C4_FREQ                                        (100000L)
  33      =2  /*****************************************************************************/
  34      =2  #define CONFIG_EPROM_SIZE                                       CONFIG_AT24C64_SIZE
  35      =2  #define CONFIG_AT24C02_SIZE                             256
  36      =2  #define CONFIG_AT24C04_SIZE                             512
  37      =2  #define CONFIG_AT24C08_SIZE                             1024
  38      =2  #define CONFIG_AT24C16_SIZE                             2048
  39      =2  #define CONFIG_AT24C32_SIZE                             4096
  40      =2  #define CONFIG_AT24C64_SIZE                                     8192
  41      =2  #define CONFIG_AT24C128_SIZE                            16384
  42      =2  #define CONFIG_AT24C256_SIZE                            32768
  43      =2  #define CONFIG_EPROM_ADDRESS                            0x50
  44      =2  #define CONFIG_EPROM_FRAM                                       0//铁电存储体无写入等待
  45      =2  #define CONFIG_EPROM_FREQ                                       1//
  46      =2  /*****************************************************************************/
  47      =2  #define CONFIG_USE_IPID                                         1//使能IPID温度控制
  48      =2  /*****************************************************************************/
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 2   

  49      =2  #define CONFIG_USE_HWVER_SHOW                           1//使能固件版本显示
  50      =2  #define CONFIG_USE_MPD1_SHOW                            1//使能MPD1测量显示
  51      =2  #define CONFIG_USE_MPD2_SHOW                            1//使能MPD2测量显示
  52      =2  #define CONFIG_USE_FBS1                                         1//使能FBS1检测
  53      =2  #define CONFIG_USE_FBS2                                         1//使能FBS2检测
  54      =2  #define CONFIG_USE_LASER_TEMP                           1//使能激光器温度显示
  55      =2  #define CONFIG_USE_RADIATOR_TEMP                        1//使能散热器温度显示
  56      =2  #define CONFIG_USE_ENVI_TEMP                            1//使能环境温度显示
  57      =2  #define CONFIG_USE_IPID_UPDATE                          1//使能IPID参数更新功能
  58      =2  #define CONFIG_USE_IPID_OUTSHOW                         1//使能IPID输出显示
  59      =2  /*****************************************************************************/
  60      =2  //SPLC设置
  61      =2  #define CONFIG_SPLC_IO_INPUT_NUM                        16//硬件输入点数
  62      =2  #define CONFIG_SPLC_IO_OUTPUT_NUM                       16//硬件输出点数
  63      =2  #define CONFIG_SOFTPLC_HWTIME                           1000L//1mS
  64      =2  #define CONFIG_INPUT_FILTER_TIME                        3//输入数字滤波扫描周期 1mS * N
  65      =2  #define CONFIG_IPID_RUN_CYCLE                           40//IPID运行周期 默认 40 * 100mS
  66      =2  #define CONFIG_IPID_PWM_CYCLE                           20//IPID输出周期 默认 20 * 100mS
  67      =2  /*****************************************************************************/
  68      =2  #define CONFIG_SPLC_USING_WDT                           0//看门狗启用
  69      =2  /*****************************************************************************/
  70      =2  #define CONFIG_SPLC_USING_IO_INPUT                      1//输入IO刷新启用
  71      =2  /*****************************************************************************/
  72      =2  #define CONFIG_SPLC_USING_IO_OUTPUT                     1//输出IO刷新启用
  73      =2  /*****************************************************************************/
  74      =2  #define CONFIG_SPLC_USING_EPROM                         0//EPROM掉电存储启用
  75      =2  /*****************************************************************************/
  76      =2  #define CONFIG_SPLC_USING_ADC                           0//使能ADC模块
  77      =2  #define CONFIG_SPLC_ADC_FILTER_TAP                      48//ADC位移滤波次数
  78      =2  #define CONFIG_SPLC_ADC_CHANNLE                         9//ADC通道数
  79      =2  #define CONFIG_SPLC_ADC_TEMP_SENSOR_GAIN    3330L// Temp Sensor Gain in (uV / degC)
  80      =2  #define CONFIG_SPLC_ADC_TEMP_SENSOR_OFFSET  856L// Temp Sensor Offset in mV
  81      =2  #define CONFIG_SPLC_ADC_INTERNAL_VREF           2200L// ADC Voltage Reference (mV)
  82      =2  #define CONFIG_SPLC_ADC_AMBIENT             25L// Ambient temp in deg C
  83      =2  /*****************************************************************************/
  84      =2  #define CONFIG_SPLC_USING_DAC                           1//是能DAC模块
  85      =2  /*****************************************************************************/
  86      =2  #define CONFIG_SPLC_USING_MB_RTU_SLAVE          1//是能MODBUS RTU从站
  87      =2  #define CONFIG_MB_RTU_SLAVE_TIMER                       1000L//1000uS
  88      =2  #define CONFIG_MB_RTU_SLAVE_ADDRESS                     0x01//从设备地址
  89      =2  #define CONFIG_MB_RTU_SLAVE_BUFFER_SIZE         256//发送接收缓冲区
  90      =2  #define CONFIG_MB_RTU_SLAVE_TIMEOUT                     100//接收通讯超时 10mS
  91      =2  #define CONFIG_MB_RTU_SLAVE_IO_DELAY            1//RX TX切换延时
  92      =2  /*****************************************************************************/
  93      =2  
  94      =2  /*****************************************************************************/
  95      =2  #define ID_ONLY_1_CHANNEL                                       4321
  96      =2  #define ID_ONLY_2_CHANNEL                                       8765
  97      =2  #define ID_BOTH_CHANNEL                                         9431
  98      =2  #define ID_LASER_MODE_CW                                        7631
  99      =2  #define ID_LASER_MODE_SP                                        8934
 100      =2  #define ID_LASER_MODE_MP                                        2453
 101      =2  #define ID_LASER_MODE_GP                                        3876
 102      =2  /*****************************************************************************/
 103      =2  #define FBS1_IN_PORT                                            3
 104      =2  #define FBS2_IN_PORT                                            2
 105      =2  #define COOLON_OUT_PORT                                         (1 * 8 + 3)
 106      =2  /*****************************************************************************/
 107      =2  //PID FUZZY 模糊PID配置
 108      =2  #define CONFIG_TECOUT_CYCLE                                     4000//PID输出转PWM周期
 109      =2  /*****************************************************************************/
 110      =2  /*****************************************************************************/
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 3   

 111      =2  #define DISABLE_MODBUS_SERIAL_INTERRUPT         ES0 = 0;
 112      =2  #define ENABLE_MODBUS_SERIAL_INTERRUPT          ES0 = 1;
 113      =2  #define DISABLE_INTERRUPT                                       EA = 0;
 114      =2  #define ENABLE_INTERRUPT                                        EA = 1;
 115      =2  /*****************************************************************************/
 116      =2  #include "stdint.h"
   1      =3  /**************************************************************************//**
   2      =3   * Copyright (c) 2015 by Silicon Laboratories Inc. All rights reserved.
   3      =3   *
   4      =3   * http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   5      =3   *****************************************************************************/
   6      =3  
   7      =3  #ifndef STDINT_H
   8      =3  #define STDINT_H
   9      =3  
  10      =3  #if defined __C51__
  11      =3  
  12      =3  typedef unsigned char uint8_t;
  13      =3  typedef unsigned short uint16_t;
  14      =3  typedef unsigned long uint32_t;
  15      =3  typedef uint32_t uint64_t[2];
  16      =3  
  17      =3  typedef signed char int8_t;
  18      =3  typedef short int16_t;
  19      =3  typedef long int32_t;
  20      =3  typedef int32_t int64_t[2];
  21      =3  typedef float fp32_t;
  22      =3  typedef double fp64_t;
  23      =3  
  24      =3  #elif defined __ICC8051__
           =3 
           =3 /* Fixed size types. These are all optional. */
           =3 #ifdef __INT8_T_TYPE__
           =3   typedef __INT8_T_TYPE__   int8_t;
           =3   typedef __UINT8_T_TYPE__ uint8_t;
           =3 #endif /* __INT8_T_TYPE__ */
           =3 
           =3 #ifdef __INT16_T_TYPE__
           =3   typedef __INT16_T_TYPE__   int16_t;
           =3   typedef __UINT16_T_TYPE__ uint16_t;
           =3 #endif /* __INT16_T_TYPE__ */
           =3 
           =3 #ifdef __INT32_T_TYPE__
           =3   typedef __INT32_T_TYPE__   int32_t;
           =3   typedef __UINT32_T_TYPE__ uint32_t;
           =3 #endif /* __INT32_T_TYPE__ */
           =3 
           =3 #ifdef __INT64_T_TYPE__
           =3   #pragma language=save
           =3   #pragma language=extended
           =3   typedef __INT64_T_TYPE__   int64_t;
           =3   typedef __UINT64_T_TYPE__ uint64_t;
           =3   #pragma language=restore
           =3 #endif /* __INT64_T_TYPE__ */
           =3 
           =3 #endif
  51      =3  
  52      =3  #endif
 117      =2  #include "stdbool.h"
   1      =3  /**************************************************************************//**
   2      =3   * Copyright (c) 2015 by Silicon Laboratories Inc. All rights reserved.
   3      =3   *
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 4   

   4      =3   * http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   5      =3   *****************************************************************************/
   6      =3  
   7      =3  #ifndef STDBOOL_H
   8      =3  #define STDBOOL_H
   9      =3  
  10      =3  #if defined __C51__
  11      =3  
  12      =3  typedef bit bool;
  13      =3  enum{
  14      =3    false = 0,
  15      =3    true = 1,
  16      =3  };
  17      =3  
  18      =3  #elif defined __ICC8051__
           =3 
           =3 #ifndef _SYSTEM_BUILD
           =3   #pragma system_include
           =3 #endif
           =3 
           =3 #ifndef __cplusplus
           =3 
           =3 #define bool _Bool
           =3 #define true 1
           =3 #define false 0
           =3 
           =3 #define __bool_true_false_are_defined 1
           =3 
           =3 #endif /* !__cplusplus */
           =3 
           =3 #else  // __SLS_IDE__ : Macros defined to remove syntax errors within Simplicity Studio
           =3 
           =3 typedef bit bool;
           =3 enum{
           =3   false = 0,
           =3   true = 1,
           =3 };
           =3 
           =3 #endif
  43      =3  
  44      =3  #endif //STDBOOL_H
  45      =3  
 118      =2  #include "endian.h"
   1      =3  /**************************************************************************//**
   2      =3   * Copyright (c) 2015 by Silicon Laboratories Inc. All rights reserved.
   3      =3   *
   4      =3   * http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   5      =3   *****************************************************************************/
   6      =3  
   7      =3  #ifndef __ENDIAN_H__
   8      =3  #define __ENDIAN_H__
   9      =3  
  10      =3  #define bswapu16(x) (((x) >> 8) | ((x) << 8))
  11      =3  #define bswapu32(x) (((x) >> 24) | (((x) & 0x00FF0000) >> 8) \
  12      =3                    | (((x) & 0x0000FF00) << 8) | ((x) << 24))
  13      =3  
  14      =3  #define bswap16(x) bswapu16((uint16_t)(x))
  15      =3  #define bswap32(x) bswapu32((uint32_t)(x))
  16      =3  
  17      =3  // Big Endian Compilers
  18      =3  #if ((defined __C51__) || (defined __RC51__) || (defined _CC51))
  19      =3  
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 5   

  20      =3  #define htobe16(x) (x)
  21      =3  #define htobe32(x) (x)
  22      =3  #define be16toh(x) (x)
  23      =3  #define be32toh(x) (x)
  24      =3  
  25      =3  #define htole16(x) bswap16(x)
  26      =3  #define htole32(x) bswap32(x)
  27      =3  #define le16toh(x) bswap16(x)
  28      =3  #define le32toh(x) bswap32(x)
  29      =3  
  30      =3  #elif ((defined SDCC) || (defined HI_TECH_C) || (defined __ICC8051__))
           =3 
           =3 #define htobe16(x) bswap16(x)
           =3 #define htobe32(x) bswap32(x)
           =3 #define be16toh(x) bswap16(x)
           =3 #define be32toh(x) bswap32(x)
           =3 
           =3 #define htole16(x) (x)
           =3 #define htole32(x) (x)
           =3 #define le16toh(x) (x)
           =3 #define le32toh(x) (x)
           =3 
           =3 #else
           =3 
           =3 #define htobe16(x) (x)
           =3 #define htobe32(x) (x)
           =3 #define be16toh(x) (x)
           =3 #define be32toh(x) (x)
           =3 
           =3 #define htole16(x) (x)
           =3 #define htole32(x) (x)
           =3 #define le16toh(x) (x)
           =3 #define le32toh(x) (x)
           =3 
           =3 #endif  // Compiler Definitions
  55      =3  
  56      =3  #endif  // __ENDIAN_H__
 119      =2  #include "si_toolchain.h"
   1      =3  /******************************************************************************
   2      =3   * Copyright (c) 2015 by Silicon Laboratories Inc. All rights reserved.
   3      =3   *
   4      =3   * http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   5      =3   *****************************************************************************/
   6      =3  
   7      =3  #ifndef __SI_TOOLCHAIN_H__
   8      =3  #define __SI_TOOLCHAIN_H__
   9      =3  
  10      =3  #include <stdint.h>
   1      =4  /**************************************************************************//**
   2      =4   * Copyright (c) 2015 by Silicon Laboratories Inc. All rights reserved.
   3      =4   *
   4      =4   * http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   5      =4   *****************************************************************************/
   6      =4  
   7      =4  #ifndef STDINT_H
           =4 #define STDINT_H
           =4 
           =4 #if defined __C51__
           =4 
           =4 typedef unsigned char uint8_t;
           =4 typedef unsigned short uint16_t;
           =4 typedef unsigned long uint32_t;
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 6   

           =4 typedef uint32_t uint64_t[2];
           =4 
           =4 typedef signed char int8_t;
           =4 typedef short int16_t;
           =4 typedef long int32_t;
           =4 typedef int32_t int64_t[2];
           =4 typedef float fp32_t;
           =4 typedef double fp64_t;
           =4 
           =4 #elif defined __ICC8051__
           =4 
           =4 /* Fixed size types. These are all optional. */
           =4 #ifdef __INT8_T_TYPE__
           =4   typedef __INT8_T_TYPE__   int8_t;
           =4   typedef __UINT8_T_TYPE__ uint8_t;
           =4 #endif /* __INT8_T_TYPE__ */
           =4 
           =4 #ifdef __INT16_T_TYPE__
           =4   typedef __INT16_T_TYPE__   int16_t;
           =4   typedef __UINT16_T_TYPE__ uint16_t;
           =4 #endif /* __INT16_T_TYPE__ */
           =4 
           =4 #ifdef __INT32_T_TYPE__
           =4   typedef __INT32_T_TYPE__   int32_t;
           =4   typedef __UINT32_T_TYPE__ uint32_t;
           =4 #endif /* __INT32_T_TYPE__ */
           =4 
           =4 #ifdef __INT64_T_TYPE__
           =4   #pragma language=save
           =4   #pragma language=extended
           =4   typedef __INT64_T_TYPE__   int64_t;
           =4   typedef __UINT64_T_TYPE__ uint64_t;
           =4   #pragma language=restore
           =4 #endif /* __INT64_T_TYPE__ */
           =4 
           =4 #endif
           =4 
           =4 #endif
  11      =3  #include <stdbool.h>
   1      =4  /**************************************************************************//**
   2      =4   * Copyright (c) 2015 by Silicon Laboratories Inc. All rights reserved.
   3      =4   *
   4      =4   * http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   5      =4   *****************************************************************************/
   6      =4  
   7      =4  #ifndef STDBOOL_H
           =4 #define STDBOOL_H
           =4 
           =4 #if defined __C51__
           =4 
           =4 typedef bit bool;
           =4 enum{
           =4   false = 0,
           =4   true = 1,
           =4 };
           =4 
           =4 #elif defined __ICC8051__
           =4 
           =4 #ifndef _SYSTEM_BUILD
           =4   #pragma system_include
           =4 #endif
           =4 
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 7   

           =4 #ifndef __cplusplus
           =4 
           =4 #define bool _Bool
           =4 #define true 1
           =4 #define false 0
           =4 
           =4 #define __bool_true_false_are_defined 1
           =4 
           =4 #endif /* !__cplusplus */
           =4 
           =4 #else  // __SLS_IDE__ : Macros defined to remove syntax errors within Simplicity Studio
           =4 
           =4 typedef bit bool;
           =4 enum{
           =4   false = 0,
           =4   true = 1,
           =4 };
           =4 
           =4 #endif
           =4 
           =4 #endif //STDBOOL_H
  45      =4  
  12      =3  
  13      =3  /**************************************************************************//**
  14      =3   *
  15      =3   * @addtogroup toolchain_group Toolchain Abstraction
  16      =3   *
  17      =3   * @brief Macros for toolchain abstraction.
  18      =3   *
  19      =3   * # Introduction #
  20      =3   *
  21      =3   * This header file contains macros that are used to provide an abstraction
  22      =3   * for toolchain use in source code.  The 8051 compiler requires C-language
  23      =3   * extensions in order to fully use features of the 8051 architecture.  All
  24      =3   * compilers for 8051 implement a set of extensions but use different names
  25      =3   * and ways of implementing those extensions.  This header file provides
  26      =3   * macros that are defined for each supported toolchain and can be used in
  27      =3   * the source code.  This allows the source code to use 8051 extensions and
  28      =3   * remain independent of which toolchain is used for compilation.
  29      =3   *
  30      =3   * ## Variable and Pointer Declarations ##
  31      =3   *
  32      =3   * It is often useful to specify the memory area (or segment) of a variable,
  33      =3   * pointer, or pointer target.  For example, you may wish to place all
  34      =3   * variables in XDATA by default, but for variables used in time-sensitive
  35      =3   * code you use DATA for efficient access.  In this case you declare the
  36      =3   * XDATA variable in the normal C way, but declare the variables to be located
  37      =3   * in the DATA segment using @ref SI_SEGMENT_VARIABLE.
  38      =3   *
  39      =3   * Pointers are more complicated because there are two memory spaces
  40      =3   * associated with a pointer, the pointer target, and the pointer variable
  41      =3   * itself.  When using default memory segment for the pointer location and
  42      =3   * target, then no special macro is needed.  But if you wish to specify the
  43      =3   * pointer variable location, or target memory segment, then you can use one
  44      =3   * of the following macros to do this in a toolchain-independent way.
  45      =3   *
  46      =3   * |Pointer segment|Target segment|Macro                                   |
  47      =3   * |---------------|--------------|----------------------------------------|
  48      =3   * |default        |generic       |None                                    |
  49      =3   * |default        |specific      |@ref SI_VARIABLE_SEGMENT_POINTER        |
  50      =3   * |specific       |generic       |@ref SI_SEGMENT_POINTER                 |
  51      =3   * |specific       |specific      |@ref SI_SEGMENT_VARIABLE_SEGMENT_POINTER|
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 8   

  52      =3   *
  53      =3   * ## Prior Toolchain Abstraction Header File ##
  54      =3   *
  55      =3   * This file supercedes an earlier header file named `compiler_defs.h`.  We
  56      =3   * are deprecating the use of compiler_defs.h, however it will remain for
  57      =3   * backwards compatibility.  This file was created to normalize macro names,
  58      =3   * remove unused macros, and to provide documentation.
  59      =3   *
  60      =3   * ## Supported Toolchains ##
  61      =3   *
  62      =3   * - Keil/ARM C51
  63      =3   *
  64      =3   * @{
  65      =3   *
  66      =3   *****************************************************************************/
  67      =3  
  68      =3  // Make sure there is a NULL defined if the toolchain does not provide it.
  69      =3  #ifndef NULL
  70      =3  #define NULL ((void *)0)
  71      =3  #endif
  72      =3  
  73      =3  // -------------------------------
  74      =3  // Keil/ARM C51
  75      =3  //
  76      =3  #if defined(__C51__)
  77      =3  
  78      =3  /// Used with pointers, declares a generic pointer.  Generic pointers
  79      =3  /// work with any memory space but are inefficient.
  80      =3  #define SI_SEG_GENERIC
  81      =3  
  82      =3  /// Declares a variable to be located in 8051 DATA space.
  83      =3  #define SI_SEG_DATA data
  84      =3  
  85      =3  /// Declares a variable to be located in 8051 IDATA space.
  86      =3  #define SI_SEG_IDATA idata
  87      =3  
  88      =3  /// Declares a variable to be located in 8051 XDATA space.
  89      =3  #define SI_SEG_XDATA xdata
  90      =3  
  91      =3  /// Declares a variable to be located in 8051 PDATA space.
  92      =3  #define SI_SEG_PDATA pdata
  93      =3  
  94      =3  /// Declares a variable to be located in 8051 BDATA (bit-addressable) space.
  95      =3  #define SI_SEG_BDATA bdata
  96      =3  
  97      =3  /// Declares a variable to be located in 8051 CODE space.
  98      =3  #define SI_SEG_CODE code
  99      =3  
 100      =3  /**************************************************************************//**
 101      =3   * Declares a bit variable in a bit-addressable memory space.
 102      =3   *
 103      =3   * @param name The name of the bit variable.
 104      =3   *****************************************************************************/
 105      =3  #define SI_BIT(name) bit name
 106      =3  
 107      =3  /**************************************************************************//**
 108      =3   * Declares a bit variable in a bit-addressable SFR or memory space.
 109      =3   *
 110      =3   * @param name The name of the bit variable.
 111      =3   * @param address The address of the byte containing the bit.
 112      =3   * @param bitnum The bit number (0-7) within the byte.
 113      =3   *
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 9   

 114      =3   * This cannot be used to make any arbitrary SFR or variable into
 115      =3   * a bit variable.  The underlying memory must support bit-addressability.
 116      =3   *****************************************************************************/
 117      =3  #define SI_SBIT(name, address, bitnum) sbit name = address^bitnum
 118      =3  
 119      =3  /**************************************************************************//**
 120      =3   * Declares an 8-bit special function register (SFR) variable.
 121      =3   *
 122      =3   * @param name The name of the SFR variable.
 123      =3   * @param address The address of the SFR.
 124      =3   *
 125      =3   * This creates a C variable (8-bit) that maps to a physical special function
 126      =3   * register of the 8051.  This cannot be used to make any arbitrary memory
 127      =3   * location into an SFR.  The _address_ must map to a real SFR in the memory
 128      =3   * map.
 129      =3   *****************************************************************************/
 130      =3  #define SI_SFR(name, address) sfr name = address
 131      =3  
 132      =3  /**************************************************************************//**
 133      =3   * Declares a 16-bit special function register (SFR) variable.
 134      =3   *
 135      =3   * @param name The name of the SFR variable.
 136      =3   * @param address The address of the 16-bit SFR.
 137      =3   *
 138      =3   * This creates a C variable (16-bit) that maps to a physical special function
 139      =3   * register of the 8051.  This cannot be used to make any arbitrary memory
 140      =3   * location into an SFR.  The _address_ must map to a real 16-bit SFR in the
 141      =3   * memory map.
 142      =3   *****************************************************************************/
 143      =3  #define SI_SFR16(name, address) sfr16 name = address
 144      =3  
 145      =3  #ifndef __SLS_IDE__
 146      =3  /**************************************************************************//**
 147      =3   * Define an interrupt handler function for an interrupt vector.
 148      =3   *
 149      =3   * @param name The name of the interrupt handler function.
 150      =3   * @param vector The interrupt vector number.
 151      =3   *
 152      =3   * This macro defines a function to be an interrupt handler.  The _vector_
 153      =3   * parameter is the 8051 interrupt vector number, not the address.  This
 154      =3   * will cause the compiler to treat the function as the interrupt handler
 155      =3   * and generate the appropriate prolog/epilog code.
 156      =3   *
 157      =3   * @note This macro is used to define the function implementation.  To declare
 158      =3   * the interrupt function prototype, use @ref SI_INTERRUPT_PROTO.
 159      =3   *****************************************************************************/
 160      =3  #define SI_INTERRUPT(name, vector) void name (void) interrupt vector
 161      =3  
 162      =3  /**************************************************************************//**
 163      =3   * Define an interrupt handler function using a specific register bank.
 164      =3   *
 165      =3   * @param name The name of the interrupt handler function.
 166      =3   * @param vector The interrupt vector number.
 167      =3   * @param regnum The register bank number (0-3).
 168      =3   *
 169      =3   * This macro defines a function to be an interrupt handler, using a specific
 170      =3   * register bank for the interrupt code.  The _vector_ parameter is the 8051
 171      =3   * interrupt vector number, not the address.  The _regnum_ parameter is the
 172      =3   * register bank number (0-3) that will be used as general purpose registers
 173      =3   * for the instructions in the compiled code.  Using dedicated register banks
 174      =3   * for interrupt handlers allows the prolog code to just switch banks instead
 175      =3   * of saving and restoring all the general purpose registers.  This can make
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 10  

 176      =3   * interrupt entry/exit faster but requires dedicating a register bank for
 177      =3   * the interrupt handler.
 178      =3   *
 179      =3   * @note This macro is used to define the function implementation.  To declare
 180      =3   * the interrupt function prototype, use @ref SI_INTERRUPT_PROTO_USING.
 181      =3   *****************************************************************************/
 182      =3  #define SI_INTERRUPT_USING(name, vector, regnum)                             \
 183      =3               void name (void) interrupt vector using regnum
 184      =3  
 185      =3  /**************************************************************************//**
 186      =3   * Declare an interrupt handler prototype for an interrupt vector.
 187      =3   *
 188      =3   * @param name The name of the interrupt handler function.
 189      =3   * @param vector The interrupt vector number.
 190      =3   *
 191      =3   * This macro declares a function prototype for an interrupt handler.  The
 192      =3   * _vector_ parameter is the 8051 interrupt vector number, not the address.
 193      =3   * Declaring the function prototype this way will cause the compiler to
 194      =3   * recognize that the function is an interrupt handler and not a normal C
 195      =3   * function.
 196      =3   *
 197      =3   * @note This macro is used to declare a prototype for the interrupt function.
 198      =3   * To define the interrupt function implementation, use @ref SI_INTERRUPT.
 199      =3   *****************************************************************************/
 200      =3  #define SI_INTERRUPT_PROTO(name, vector) void name (void)
 201      =3  
 202      =3  /**************************************************************************//**
 203      =3   * Declare an interrupt handler prototype using a specific register bank.
 204      =3   *
 205      =3   * @param name The name of the interrupt handler function.
 206      =3   * @param vector The interrupt vector number.
 207      =3   * @param regnum The register bank number (0-3).
 208      =3   *
 209      =3   * This macro declares a function prototype for an interrupt handler, for a
 210      =3   * function that uses a specific register bank for the interrupt code.  The
 211      =3   * _vector_ parameter is the 8051 interrupt vector number, not the address.
 212      =3   * The _regnum_ parameter is the register bank number (0-3) that will be used
 213      =3   * as general purpose registers in the function.  Declaring the function
 214      =3   * prototype this way will cause the compiler to recognize that the function
 215      =3   * is an interrupt handler and is not a normal C function.
 216      =3   *
 217      =3   * @note This macro is used to declare a prototype for the interrupt function.
 218      =3   * To define the interrupt function implementation,
 219      =3   * use @ref SI_INTERRUPT_USING.
 220      =3   *****************************************************************************/
 221      =3  #define SI_INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
 222      =3  
 223      =3  /**************************************************************************//**
 224      =3   * Define a function to be reentrant (store local variables on the stack).
 225      =3   *
 226      =3   * @param name The name of the function.
 227      =3   * @param return_type The data type of the function return value
 228      =3   * (void, int, etc).
 229      =3   * @param parameter One C function parameter (or "void") (type and name).
 230      =3   *
 231      =3   * This macro defines a function to be reentrant.
 232      =3   *
 233      =3   * You must specify the _return_type_ which is the type of the function.  It
 234      =3   * can be `void` or any other C type or typedef.  The _parameters_ argument
 235      =3   * is the list of function parameters.  It can be `void` or else it must be
 236      =3   * a parameter data type and name.  It can also be multiple parameters but
 237      =3   * they must be enclosed in parentheses and separated by commas.
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 11  

 238      =3   *
 239      =3   * __Example__
 240      =3   *
 241      =3   * ~~~~~~~~.c
 242      =3   * // The following is used to implement a function with the following
 243      =3   * // signature...
 244      =3   * uint16_t myFunction(uint8_t parm1, uint8_t parm2);
 245      =3   *
 246      =3   * SI_REENTRANT_FUNCTION(myFunction, uint16_t, (uint8_t parm1, uint8_t parm2))
 247      =3   * {
 248      =3   *   // Function implementation body
 249      =3   * }
 250      =3   * ~~~~~~~~
 251      =3   *
 252      =3   * @note This macro is used to define the function implementation.  To declare
 253      =3   * the function prototype, use @ref SI_REENTRANT_FUNCTION_PROTO.
 254      =3   *****************************************************************************/
 255      =3  #define SI_REENTRANT_FUNCTION(name, return_type, parameter) \
 256      =3    return_type name parameter reentrant
 257      =3  
 258      =3  /**************************************************************************//**
 259      =3   * Declare a function to be reentrant (store local variables on the stack).
 260      =3   *
 261      =3   * @param name The name of the function.
 262      =3   * @param return_type The data type of the function return value
 263      =3   * (void, int, etc).
 264      =3   * @param parameter One C function parameter (or "void") (type and name).
 265      =3   *
 266      =3   * This macro declares a function prototype for a C function that is reentrant.
 267      =3   * See the documentation for @ref SI_REENTRANT_FUNCTION for an explanation of
 268      =3   * the macro arguments.  This is an advanced feature.
 269      =3   *
 270      =3   * @note This macro is used to declare a prototype for the function.  To
 271      =3   * define the function implementation, use @ref SI_REENTRANT_FUNCTION.
 272      =3   *****************************************************************************/
 273      =3  #define SI_REENTRANT_FUNCTION_PROTO(name, return_type, parameter) \
 274      =3    return_type name parameter reentrant
 275      =3                 
 276      =3  /**************************************************************************//**
 277      =3   * Define a function to use a specific register bank.
 278      =3   *
 279      =3   * @param name The name of the function.
 280      =3   * @param return_value The data type of the function return value
 281      =3   * (void, int, etc).
 282      =3   * @param parameter One C function parameter (or "void") (type and name).
 283      =3   * @param regnum The register bank number (0-3).
 284      =3   *
 285      =3   * This macro defines a function that uses a specific register bank.  The
 286      =3   * _regnum_ parameter is the register bank number (0-3) that will be used as
 287      =3   * general purpose registers for the instructions in the compiled function
 288      =3   * code.  Using dedicated register banks for a function can reduce the amount
 289      =3   * of registers saving and restoring needed on entry and exit to the
 290      =3   * function.  However, this is an advanced feature and you should not use it
 291      =3   * unless you fully understand how and when to use register banking.
 292      =3   *
 293      =3   * You must specify the _return_value_ which is the type of the function.  It
 294      =3   * can be `void` or any other C type or typedef.  The _parameters_ argument
 295      =3   * is the list of function parameters.  It can be `void` or else it must be
 296      =3   * a parameter data type and name.  It can also be multiple parameters but
 297      =3   * they must be enclosed in parentheses and separated by commas.
 298      =3   *
 299      =3   * __Example__
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 12  

 300      =3   *
 301      =3   * ~~~~~~~~.c
 302      =3   * // The following is used to implement a function with the following
 303      =3   * // signature, and that uses register bank 3 ...
 304      =3   * uint16_t myFunction(uint8_t parm1, uint8_t parm2);
 305      =3   *
 306      =3   * SI_FUNCTION_USING(myFunction, uint16_t, (uint8_t parm1, uint8_t parm2), 3)
 307      =3   * {
 308      =3   *   // Function implementation body
 309      =3   * }
 310      =3   * ~~~~~~~~
 311      =3   *
 312      =3   * @note This macro is used to define the function implementation.  To declare
 313      =3   * the function prototype, use @ref SI_FUNCTION_PROTO_USING.
 314      =3   *****************************************************************************/
 315      =3  #define SI_FUNCTION_USING(name, return_value, parameter, regnum)              \
 316      =3               return_value name parameter using regnum
 317      =3  
 318      =3  /**************************************************************************//**
 319      =3   * Declare a function that uses a specific register bank.
 320      =3   *
 321      =3   * @param name The name of the function.
 322      =3   * @param return_value The data type of the function return value
 323      =3   * (void, int, etc).
 324      =3   * @param parameter One C function parameter (or "void") (type and name).
 325      =3   * @param regnum The register bank number (0-3).
 326      =3   *
 327      =3   * This macro declares a function prototype for a C function that uses a
 328      =3   * specific register its working registers.  See the documentation for
 329      =3   * @ref SI_FUNCTION_USING for an explanation of the macro arguments.  This is
 330      =3   * an advanced feature.
 331      =3   *
 332      =3   * @note This macro is used to declare a prototype for the function.  To
 333      =3   * define the function implementation, use @ref SI_FUNCTION_USING.
 334      =3   *****************************************************************************/
 335      =3  #define SI_FUNCTION_PROTO_USING(name, return_value, parameter, regnum)        \
 336      =3               return_value name parameter
 337      =3  
 338      =3  /**************************************************************************//**
 339      =3   * Declare a variable to be located in a specific memory segment.
 340      =3   *
 341      =3   * @param name The variable name.
 342      =3   * @param vartype The variable data type.* @param memseg The memory segment to use for the variable.
 343      =3   *
 344      =3   * This macro declares a variable to be located in a specific memory area
 345      =3   * (or segment) of the 8051 memory space.  It is only necessary to use this
 346      =3   * macro if you want to force the variable into a specific memory space instead
 347      =3   * of the default memory space used by the compiler.  The segment can be
 348      =3   * one of the following:
 349      =3   *
 350      =3   * - @ref SI_SEG_DATA
 351      =3   * - @ref SI_SEG_IDATA
 352      =3   * - @ref SI_SEG_BDATA
 353      =3   * - @ref SI_SEG_PDATA
 354      =3   * - @ref SI_SEG_XDATA
 355      =3   * - @ref SI_SEG_CODE
 356      =3   *
 357      =3   * __Example__
 358      =3   *
 359      =3   * ~~~~~~~~.c
 360      =3   * // The following macro can be used to create a variable located in
 361      =3   * // XDATA with the following signature:
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 13  

 362      =3   * uint8_t myVar;
 363      =3   *
 364      =3   * SI_SEGMENT_VARIABLE(myVar, uint8_t, SEG_XDATA);
 365      =3   * ~~~~~~~~
 366      =3   *****************************************************************************/
 367      =3  #define SI_SEGMENT_VARIABLE(name, vartype, memseg) vartype memseg name
 368      =3  
 369      =3  /**************************************************************************//**
 370      =3   * Declare a memory segment specific pointer variable.
 371      =3   *
 372      =3   * @param name The pointer variable name.
 373      =3   * @param vartype The pointer data type.
 374      =3   * @param targseg The target memory segment for the pointer.
 375      =3   *
 376      =3   * This macro declares a pointer that points at a specific memory area
 377      =3   * (or segment).  The memory segment of the pointer variable itself is not
 378      =3   * specified and the default is used.  The segment can be one of the following:
 379      =3   *
 380      =3   * - @ref SI_SEG_DATA
 381      =3   * - @ref SI_SEG_IDATA
 382      =3   * - @ref SI_SEG_BDATA
 383      =3   * - @ref SI_SEG_PDATA
 384      =3   * - @ref SI_SEG_XDATA
 385      =3   * - @ref SI_SEG_CODE
 386      =3   *
 387      =3   * __Example__
 388      =3   *
 389      =3   * ~~~~~~~~.c
 390      =3   * // The following macro can be used to create a pointer that points to
 391      =3   * // a location in XDATA with the following signature:
 392      =3   * uint8_t *pVar; // where pVar is pointing at XDATA
 393      =3   *
 394      =3   * SI_VARIABLE_SEGMENT_POINTER(pVar, uint8_t, SEG_XDATA);
 395      =3   * ~~~~~~~~
 396      =3   *****************************************************************************/
 397      =3  #define SI_VARIABLE_SEGMENT_POINTER(name, vartype, targseg)                  \
 398      =3               vartype targseg * name
 399      =3  
 400      =3  /**************************************************************************//**
 401      =3   * Declare a memory segment specific pointer variable, in a specific segment.
 402      =3   *
 403      =3   * @param name The pointer variable name.
 404      =3   * @param vartype The pointer data type.
 405      =3   * @param targseg The target memory segment for the pointer.
 406      =3   * @param memseg The memory segment to use for the pointer variable.
 407      =3   *
 408      =3   * This macro declares a pointer that points at a specific memory area
 409      =3   * (or segment).  The pointer variable itself is also located in a specified
 410      =3   * memory segment by _memseg_.  The arguments _targseg_ and _memseg_ can be
 411      =3   * one of the following:
 412      =3   *
 413      =3   * - @ref SI_SEG_DATA
 414      =3   * - @ref SI_SEG_IDATA
 415      =3   * - @ref SI_SEG_BDATA
 416      =3   * - @ref SI_SEG_PDATA
 417      =3   * - @ref SI_SEG_XDATA
 418      =3   * - @ref SI_SEG_CODE
 419      =3   *
 420      =3   * __Example__
 421      =3   *
 422      =3   * ~~~~~~~~.c
 423      =3   * // The following macro can be used to create a pointer that points to
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 14  

 424      =3   * // a location in XDATA while the pointer itself is located in DATA, with
 425      =3   * // the following signature:
 426      =3   * uint8_t *pVar; // where pVar is located in DATA and is pointing at XDATA
 427      =3   *
 428      =3   * SI_SEGMENT_VARIABLE_SEGMENT_POINTER(pVar, uint8_t, SEG_XDATA, SEG_DATA);
 429      =3   * ~~~~~~~~
 430      =3   *****************************************************************************/
 431      =3  #define SI_SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targseg, memseg)  \
 432      =3               vartype targseg * memseg name
 433      =3  
 434      =3  /**************************************************************************//**
 435      =3   * Declare a generic pointer variable that is located in a specific segment.
 436      =3   *
 437      =3   * @param name The pointer variable name.
 438      =3   * @param vartype The pointer data type.
 439      =3   * @param memseg The memory segment to use for the pointer variable.
 440      =3   *
 441      =3   * This macro declares a pointer that is a generic pointer.  This means it can
 442      =3   * point at any kind of memory location.  However the pointer variable itself
 443      =3   * is located in a specific memory segment by _memseg_, which can be one of
 444      =3   * the following:
 445      =3   *
 446      =3   * - @ref SI_SEG_DATA
 447      =3   * - @ref SI_SEG_IDATA
 448      =3   * - @ref SI_SEG_BDATA
 449      =3   * - @ref SI_SEG_PDATA
 450      =3   * - @ref SI_SEG_XDATA
 451      =3   * - @ref SI_SEG_CODE
 452      =3   *
 453      =3   * __Example__
 454      =3   *
 455      =3   * ~~~~~~~~.c
 456      =3   * // The following macro can be used to create a generic pointer that
 457      =3   * // is located in DATA and points at any memory type, with the
 458      =3   * // following signature:
 459      =3   * uint8_t *pVar; // where pVar is located in DATA and is a generic pointer
 460      =3   *
 461      =3   * SI_SEGMENT_POINTER(pVar, uint8_t, SEG_DATA);
 462      =3   * ~~~~~~~~
 463      =3   *****************************************************************************/
 464      =3  #define SI_SEGMENT_POINTER(name, vartype, memseg) vartype * memseg name
 465      =3  
 466      =3  /**************************************************************************//**
 467      =3   * Declare an uninitialized variable that is located at a specific address.
 468      =3   *
 469      =3   * @param name The variable name.
 470      =3   * @param vartype The variable data type.
 471      =3   * @param memseg The memory segment to use for the variable.
 472      =3   * @param address The memory address of the variable.
 473      =3   *
 474      =3   * This macro allows declaring a variable that can be placed at a specific
 475      =3   * location in memory.  This can only be used for variables that do not need
 476      =3   * initializers.  The _address_ is the memory address within the specified
 477      =3   * segment.  The memory segment, _memseg_, can be one of the following:
 478      =3   *
 479      =3   * - @ref SI_SEG_DATA
 480      =3   * - @ref SI_SEG_IDATA
 481      =3   * - @ref SI_SEG_BDATA
 482      =3   * - @ref SI_SEG_PDATA
 483      =3   * - @ref SI_SEG_XDATA
 484      =3   * - @ref SI_SEG_CODE
 485      =3   *
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 15  

 486      =3   * __Example__
 487      =3   *
 488      =3   * ~~~~~~~~.c
 489      =3   * // The following declares a variable located at 0x4000 in XDATA with
 490      =3   * // the following signature:
 491      =3   * uint8_t myMemVar;
 492      =3   *
 493      =3   * SI_LOCATED_VARIABLE_NO_INIT(myMemVar, uint8_t, SEG_DATA, 0x4000);
 494      =3   * ~~~~~~~~
 495      =3   *****************************************************************************/
 496      =3  #define SI_LOCATED_VARIABLE_NO_INIT(name, vartype, memseg, address)          \
 497      =3               vartype memseg name _at_ address
 498      =3  
 499      =3  
 500      =3  #else  // __SLS_IDE__ : Macros defined to remove syntax errors within Simplicity Studio
           =3 #define SI_INTERRUPT(name, vector) void name (void)
           =3 #define SI_INTERRUPT_USING(name, vector, regnum) void name (void)
           =3 #define SI_INTERRUPT_PROTO(name, vector) void name (void)
           =3 #define SI_INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
           =3 
           =3 #define SI_REENTRANT_FUNCTION(name, return_value, parameter, regnum) return_value name (parameter)
           =3 #define SI_REENTRANT_FUNCTION_PROTO(name, return_value, parameter, regnum) return_value name (parameter)
           =3 
           =3 #define SI_FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =3 #define SI_FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =3 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =3 
           =3 #define SI_SEGMENT_VARIABLE(name, vartype, locsegment) vartype name
           =3 #define SI_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype * name
           =3 #define SI_SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype * name
           =3 #define SI_SEGMENT_POINTER(name, vartype, locsegment) vartype * name
           =3 #define SI_LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) vartype name
           =3 #endif // __SLS_IDE__
 519      =3  
 520      =3  // The following are used for byte ordering when referring to individual
 521      =3  // bytes within a SI_UU32_t.  B0 is the least significant byte.
 522      =3  #define B0 3 ///< Least significant byte of a 4 byte word
 523      =3  #define B1 2 ///< Byte 1 of a 4-byte word, where byte 0 is LSB
 524      =3  #define B2 1 ///< Byte 2 of a 4-byte word, where byte 0 is LSB
 525      =3  #define B3 0 ///< Most significant byte of a 4-byte word
 526      =3  
 527      =3  #define LSB 1 ///< Index to least significant bit of a 2 byte word
 528      =3  #define MSB 0 ///< Index to most significant bit of a 2 byte word
 529      =3  
 530      =3  /// A union type to make it easier to access individual bytes of a 16-bit
 531      =3  /// word, and to use as signed or unsigned type.
 532      =3  typedef union SI_UU16
 533      =3  {
 534      =3    uint16_t u16;   ///< The two byte value as a 16-bit unsigned integer.
 535      =3    int16_t s16;    ///< The two byte value as a 16-bit signed integer.
 536      =3    uint8_t u8[2];  ///< The two byte value as two unsigned 8-bit integers.
 537      =3    int8_t s8[2];   ///< The two byte value as two signed 8-bit integers.
 538      =3  } SI_UU16_t;
 539      =3  
 540      =3  /// A union type to make it easier to access individual bytes within a
 541      =3  /// 32-bit word, or to access it as variations of 16-bit words, or to
 542      =3  /// use as signed or unsigned type.
 543      =3  typedef union SI_UU32
 544      =3  {
 545      =3    uint32_t u32;       ///< The 4-byte value as a 32-bit unsigned integer.
 546      =3    int32_t s32;        ///< The 4-byte value as a 32-bit signed integer.
 547      =3    SI_UU16_t uu16[2];  ///< The 4-byte value as a SI_UU16_t.
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 16  

 548      =3    uint16_t u16[2];    ///< The 4-byte value as two unsigned 16-bit integers.
 549      =3    int16_t s16[2];     ///< The 4-byte value as two signed 16-bit integers.
 550      =3    uint8_t u8[4];      ///< The 4-byte value as 4 unsigned 8-bit integers.
 551      =3    int8_t s8[4];       ///< The 4-byte value as 4 signed 8-bit integers.
 552      =3  } SI_UU32_t;
 553      =3  
 554      =3  // Generic pointer memory segment constants.
 555      =3  #define SI_GPTR                   ///< Generic pointer indeterminate type.
 556      =3  #define SI_GPTR_MTYPE_DATA  0x00  ///< Generic pointer for DATA segment.
 557      =3  #define SI_GPTR_MTYPE_IDATA 0x00  ///< Generic pointer for IDATA segment.
 558      =3  #define SI_GPTR_MTYPE_BDATA 0x00  ///< Generic pointer for BDATA segment.
 559      =3  #define SI_GPTR_MTYPE_PDATA 0xFE  ///< Generic pointer for PDATA segment.
 560      =3  #define SI_GPTR_MTYPE_XDATA 0x01  ///< Generic pointer for XDATA segment.
 561      =3  #define SI_GPTR_MTYPE_CODE  0xFF  ///< Generic pointer for CODE segment.
 562      =3  
 563      =3  /// Generic pointer structure containing the type and address.
 564      =3  typedef struct
 565      =3  {
 566      =3    uint8_t memtype;    ///< The type of memory of the generic pointer.
 567      =3    SI_UU16_t address;  ///< The address of the generic pointer.
 568      =3  } GPTR_t;
 569      =3  
 570      =3  /// A union type to allow access to the fields of a generic pointer.
 571      =3  /// A generic pointer has a field indicating the type of memory and an
 572      =3  /// address within the memory.
 573      =3  typedef union SI_GEN_PTR
 574      =3  {
 575      =3    uint8_t u8[3];    ///< 3-byte generic pointer as 3 unsigned 8-bit integers.
 576      =3    GPTR_t gptr;      ///< 3-byte generic pointer as pointer structure
 577      =3  } SI_GEN_PTR_t;
 578      =3  
 579      =3  // Declaration of Keil intrinisc
 580      =3  extern void _nop_(void);
 581      =3  /// Macro to insert a no-operation (NOP) instruction.
 582      =3  #define NOP() _nop_()
 583      =3  
 584      =3  // -------------------------------
 585      =3  // GCC for ARM Cortex-M
 586      =3  // Provides support for code that can be compiled for 8 or 32-bit
 587      =3  //
 588      =3  #elif defined (__GNUC__)
           =3 #if defined(__ARMEL__) && ((__ARMEL__ == 1) && ((__ARM_ARCH == 6) || (__ARM_ARCH == 7)))
           =3 
           =3 // these ignore any memory segment directives
           =3 #define SI_SEG_GENERIC
           =3 #define SI_SEG_DATA
           =3 #define SI_SEG_IDATA
           =3 #define SI_SEG_XDATA
           =3 #define SI_SEG_PDATA
           =3 #define SI_SEG_BDATA
           =3 #define SI_SEG_CODE
           =3 
           =3 // the following create a variable of the specified name but ignore the
           =3 // address and bit number.  If the using-code cares about the actual
           =3 // address or bit number, this probably will break it
           =3 #define SI_SBIT(name, address, bitnum) uint8_t name
           =3 #define SI_SFR(name, address) uint8_t name
           =3 #define SI_SFR16(name, address) uint16_t name
           =3 
           =3 // the following create function and variable names of the specified types
           =3 // but the 8051-specific aspects (like memory segment) are ignored
           =3 #define SI_INTERRUPT(name, vector) void name (void)
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 17  

           =3 #define SI_INTERRUPT_USING(name, vector, regnum) void name (void)
           =3 #define SI_INTERRUPT_PROTO(name, vector) void name (void)
           =3 #define SI_INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
           =3 #define SI_FUNCTION_USING(name, return_value, parameter, regnum)              \
           =3              return_value name (parameter)
           =3 #define SI_FUNCTION_PROTO_USING(name, return_value, parameter, regnum)        \
           =3              return_value name (parameter)
           =3 #define SI_SEGMENT_VARIABLE(name, vartype, memseg) vartype name
           =3 #define SI_VARIABLE_SEGMENT_POINTER(name, vartype, targseg)                  \
           =3              vartype * name
           =3 #define SI_SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targseg, memseg)  \
           =3              vartype * name
           =3 #define SI_SEGMENT_POINTER(name, vartype, memseg) vartype * name
           =3 #define SI_LOCATED_VARIABLE_NO_INIT(name, vartype, memseg, address)          \
           =3              vartype name
           =3 
           =3 #define B0 0
           =3 #define B1 1
           =3 #define B2 2
           =3 #define B3 3
           =3 #define LSB 0
           =3 #define MSB 1
           =3 typedef union SI_UU16
           =3 {
           =3   uint16_t u16;
           =3   int16_t s16;
           =3   uint8_t u8[2];
           =3   int8_t s8[2];
           =3 } SI_UU16_t;
           =3 
           =3 typedef union SI_UU32
           =3 {
           =3   uint32_t u32;
           =3   int32_t s32;
           =3   SI_UU16_t uu16[2];
           =3   uint16_t u16[2];
           =3   int16_t s16[2];
           =3   uint8_t u8[4];
           =3   int8_t s8[4];
           =3 } SI_UU32_t;
           =3 
           =3 // Generic pointer stuff is left out because if you are accessing
           =3 // generic pointer fields then it will need to be rewritten for 32-bit
           =3 
           =3 // __NOP should be declared in cmsis header core_cmInstr.h
           =3 extern void __NOP(void);
           =3 /// Macro to insert a no-operation (NOP) instruction.
           =3 #define NOP() __NOP()
           =3 
           =3 #else // ARM_ARCH 6 | 7
           =3 #error unsupported ARM arch
           =3 #endif
           =3 
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 // IAR 8051
           =3 // http://www.iar.com
           =3 #elif defined __ICC8051__
           =3 
           =3 #include <intrinsics.h>
           =3 
           =3 #define SI_BIT(name)              __no_init bool __bit name
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 18  

           =3 #define SI_SBIT(name, addr, bit)  __bit __no_init volatile bool name @ (addr+bit)
           =3 #define SI_SFR(name, addr)        __sfr __no_init volatile unsigned char name @ addr
           =3 #define SI_SFR16(name, addr)      __sfr __no_init volatile unsigned int  name @ addr
           =3 
           =3 #define SI_SEG_GENERIC __generic
           =3 #define SI_SEG_FAR  __xdata
           =3 #define SI_SEG_DATA __data
           =3 #define SI_SEG_NEAR __data
           =3 #define SI_SEG_IDATA __idata
           =3 #define SI_SEG_XDATA __xdata
           =3 #define SI_SEG_PDATA __pdata
           =3 #define SI_SEG_CODE  __code
           =3 #define SI_SEG_BDATA __bdata
           =3 
           =3 #define _PPTOSTR_(x) #x
           =3 #define _PPARAM_(address) _PPTOSTR_(vector=address * 8 + 3)
           =3 #define _PPARAM2_(regbank) _PPTOSTR_(register_bank=regbank)
           =3 #define SI_INTERRUPT(name, vector) _Pragma(_PPARAM_(vector)) __interrupt void name(void)
           =3 #define SI_INTERRUPT_PROTO(name, vector)  __interrupt void name(void)
           =3 #define SI_INTERRUPT_USING(name, vector, regnum) _Pragma(_PPARAM2_(regnum)) _Pragma(_PPARAM_(vector)) __in
             -terrupt void name(void)
           =3 #define SI_INTERRUPT_PROTO_USING(name, vector, regnum) __interrupt void name(void)
           =3 
           =3 #if (__DATA_MODEL__ == 0) /* TINY */ || \
           =3     (__DATA_MODEL__ == 1) /* SMALL */
           =3 #define SI_REENTRANT_FUNCTION(name, return_type, parameter) \
           =3   __idata_reentrant return_type name parameter
           =3 #define SI_REENTRANT_FUNCTION_PROTO(name, return_type, parameter) \
           =3   __idata_reentrant return_type name parameter
           =3 #elif (__DATA_MODEL__ == 2) /* LARGE */ || \
           =3       (__DATA_MODEL__ == 3) /* GENERIC */ || \
           =3       (__DATA_MODEL__ == 4) /* FAR */
           =3 #define SI_REENTRANT_FUNCTION(name, return_type, parameter) \
           =3   __xdata_reentrant return_type name parameter
           =3 #define SI_REENTRANT_FUNCTION_PROTO(name, return_type, parameter) \
           =3   __xdata_reentrant return_type name (parameter)
           =3 #else
           =3 #error "Illegal memory model setting."
           =3 #endif
           =3 
           =3 // Note: IAR does not support functions using different register banks. Register
           =3 //       banks can only be specified in interrupts. If a function is called from
           =3 //       inside an interrupt, it will use the same register bank as the interrupt.
           =3 #define SI_FUNCTION_USING(name, return_value, parameter, regnum)              \
           =3              return_value name parameter
           =3 #define SI_FUNCTION_PROTO_USING(name, return_value, parameter, regnum)        \
           =3              return_value name parameter
           =3 
           =3 #define SI_SEGMENT_VARIABLE(name, vartype, locsegment)  vartype locsegment name
           =3 #define SI_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment  * name
           =3 #define SI_SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * 
             -locsegment name
           =3                
           =3 #define SI_SEGMENT_POINTER(name, vartype, ptrseg) vartype __generic * ptrseg name
           =3 
           =3 #define SI_LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment __no_init vartype name @ add
             -r
           =3 
           =3 #define SI_LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) locsegment __no_init vartype name @ a
             -ddr
           =3 
           =3 // The following are used for byte ordering when referring to individual
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 19  

           =3 // bytes within a SI_UU32_t.  B0 is the least significant byte.
           =3 #define B0 0 ///< Least significant byte of a 4 byte word
           =3 #define B1 1 ///< Byte 1 of a 4-byte word, where byte 0 is LSB
           =3 #define B2 2 ///< Byte 2 of a 4-byte word, where byte 0 is LSB
           =3 #define B3 3 ///< Most significant byte of a 4-byte word
           =3 
           =3 #define LSB 0 ///< Index to least significant bit of a 2 byte word
           =3 #define MSB 1 ///< Index to most significant bit of a 2 byte word
           =3 
           =3 /// A union type to make it easier to access individual bytes of a 16-bit
           =3 /// word, and to use as signed or unsigned type.
           =3 typedef union SI_UU16
           =3 {
           =3   uint16_t u16;   ///< The two byte value as a 16-bit unsigned integer.
           =3   int16_t s16;    ///< The two byte value as a 16-bit signed integer.
           =3   uint8_t u8[2];  ///< The two byte value as two unsigned 8-bit integers.
           =3   int8_t s8[2];   ///< The two byte value as two signed 8-bit integers.
           =3 } SI_UU16_t;
           =3 
           =3 /// A union type to make it easier to access individual bytes within a
           =3 /// 32-bit word, or to access it as variations of 16-bit words, or to
           =3 /// use as signed or unsigned type.
           =3 typedef union SI_UU32
           =3 {
           =3   uint32_t u32;       ///< The 4-byte value as a 32-bit unsigned integer.
           =3   int32_t s32;        ///< The 4-byte value as a 32-bit signed integer.
           =3   SI_UU16_t uu16[2];  ///< The 4-byte value as a SI_UU16_t.
           =3   uint16_t u16[2];    ///< The 4-byte value as two unsigned 16-bit integers.
           =3   int16_t s16[2];     ///< The 4-byte value as two signed 16-bit integers.
           =3   uint8_t u8[4];      ///< The 4-byte value as 4 unsigned 8-bit integers.
           =3   int8_t s8[4];       ///< The 4-byte value as 4 signed 8-bit integers.
           =3 } SI_UU32_t;
           =3 
           =3 // Generic pointer memory segment constants.
           =3 #define SI_GPTR                   ///< Generic pointer indeterminate type.
           =3 #define SI_GPTR_MTYPE_DATA  0x01  ///< Generic pointer for DATA segment.
           =3 #define SI_GPTR_MTYPE_IDATA 0x01  ///< Generic pointer for IDATA segment.
           =3 #define SI_GPTR_MTYPE_BDATA 0x01  ///< Generic pointer for BDATA segment.
           =3 #define SI_GPTR_MTYPE_PDATA 0x00  ///< Generic pointer for PDATA segment.
           =3 #define SI_GPTR_MTYPE_XDATA 0x00  ///< Generic pointer for XDATA segment.
           =3 #define SI_GPTR_MTYPE_CODE  0x80  ///< Generic pointer for CODE segment.
           =3 
           =3 /// Generic pointer structure containing the type and address.
           =3 typedef struct
           =3 {
           =3   SI_UU16_t address;  ///< The address of the generic pointer.
           =3   uint8_t memtype;    ///< The type of memory of the generic pointer.  
           =3 } GPTR_t;
           =3 
           =3 /// A union type to allow access to the fields of a generic pointer.
           =3 /// A generic pointer has a field indicating the type of memory and an
           =3 /// address within the memory.
           =3 typedef union SI_GEN_PTR
           =3 {
           =3   uint8_t u8[3];    ///< 3-byte generic pointer as 3 unsigned 8-bit integers.
           =3   GPTR_t gptr;      ///< 3-byte generic pointer as pointer structure
           =3 } SI_GEN_PTR_t;
           =3 
           =3 /// Macro to insert a no-operation (NOP) instruction.
           =3 #define NOP() __no_operation()
           =3 
           =3 #else // unknown toolchain
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 20  

           =3 #error Unrecognized toolchain in si_toolchain.h
           =3 #endif
 794      =3  
 795      =3  /** @} */
 796      =3  
 797      =3  #endif
 120      =2  #include "compiler_defs.h"
   1      =3  //-----------------------------------------------------------------------------
   2      =3  // compiler_defs.h
   3      =3  //-----------------------------------------------------------------------------
   4      =3  // Portions of this file are copyright Maarten Brock
   5      =3  // http://sdcc.sourceforge.net
   6      =3  // Portions of this file are Copyright 2014 Silicon Laboratories, Inc.
   7      =3  // http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   8      =3  //
   9      =3  // GNU LGPL boilerplate:
  10      =3  /** This library is free software; you can redistribute it and/or
  11      =3    * modify it under the terms of the GNU Lesser General Public
  12      =3    * License as published by the Free Software Foundation; either
  13      =3    * version 2.1 of the License, or (at your option) any later version.
  14      =3    *
  15      =3    * This library is distributed in the hope that it will be useful,
  16      =3    * but WITHOUT ANY WARRANTY; without even the implied warranty of
  17      =3    * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
  18      =3    * Lesser General Public License for more details.
  19      =3    *
  20      =3    * You should have received a copy of the GNU Lesser General Public
  21      =3    * License along with this library; if not, write to the Free Software
  22      =3    * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  23      =3    *
  24      =3    * In other words, you are welcome to use, share and improve this program.
  25      =3    * You are forbidden to forbid anyone else to use, share and improve
  26      =3    * what you give them. Help stamp out software-hoarding!
  27      =3  **/
  28      =3  // Program Description:
  29      =3  //
  30      =3  // **Important Note**: This header file should be included before including
  31      =3  // a device-specific header file such as C8051F300_defs.h.
  32      =3  //
  33      =3  // Macro definitions to accomodate 8051 compiler differences in specifying
  34      =3  // special function registers and other 8051-specific features such as NOP
  35      =3  // generation, and locating variables in memory-specific segments.  The
  36      =3  // compilers are identified by their unique predefined macros. See also:
  37      =3  // http://predef.sourceforge.net/precomp.html
  38      =3  //
  39      =3  // SBIT and SFR define special bit and special function registers at the given
  40      =3  // address. SFR16 and SFR32 define sfr combinations at adjacent addresses in
  41      =3  // little-endian format. SFR16E and SFR32E define sfr combinations without
  42      =3  // prerequisite byte order or adjacency. None of these multi-byte sfr
  43      =3  // combinations will guarantee the order in which they are accessed when read
  44      =3  // or written.
  45      =3  //
  46      =3  // SFR16X and SFR32X for 16 bit and 32 bit xdata registers are not defined
  47      =3  // to avoid portability issues because of compiler endianness.
  48      =3  //
  49      =3  // Example:
  50      =3  // // my_mcu.c: main 'c' file for my mcu
  51      =3  // #include <compiler_defs.h>  // this file
  52      =3  // #include <C8051xxxx_defs.h> // SFR definitions for specific MCU target
  53      =3  //
  54      =3  // SBIT  (P0_1, 0x80, 1);      // Port 0 pin 1
  55      =3  // SFR   (P0, 0x80);           // Port 0
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 21  

  56      =3  // SFRX  (CPUCS, 0xE600);      // Cypress FX2 Control and Status register in
  57      =3  //                             // xdata memory at 0xE600
  58      =3  // SFR16 (TMR2, 0xCC);         // Timer 2, lsb at 0xCC, msb at 0xCD
  59      =3  // SFR16E(TMR0, 0x8C8A);       // Timer 0, lsb at 0x8A, msb at 0x8C
  60      =3  // SFR32 (MAC0ACC, 0x93);      // SiLabs C8051F120 32 bits MAC0 Accumulator,
  61      =3  //                             // lsb at 0x93, msb at 0x96
  62      =3  // SFR32E(SUMR, 0xE5E4E3E2);   // TI MSC1210 SUMR 32 bits Summation register,
  63      =3  //                             // lsb at 0xE2, msb at 0xE5
  64      =3  //
  65      =3  // Target:         C8051xxxx
  66      =3  // Tool chain:     Generic
  67      =3  // Command Line:   None
  68      =3  // 
  69      =3  // Release 2.7 - 25 JUN 2014 (JM)
  70      =3  //    -Added SI_GENERIC_PTR struct for accessing generic pointers
  71      =3  //    -Added SI_GPTR_MTYPE_XXXX definitions for determining the memory type
  72      =3  //     pointed at by a generic poitner
  73      =3  // Release 2.6 - 14 DEC 2012 (GO)
  74      =3  //        -Added define for deprecated SDCC keyword 'at'
  75      =3  // Release 2.5 - 12 SEP 2012 (TP)
  76      =3  //    -Added defines for deprecated SDCC keywords bit and code
  77      =3  // Release 2.4 - 27 AUG 2012 (TP)
  78      =3  //    -Added defines for deprecated SDCC keywords interrupt, _asm, and _endasm
  79      =3  // Release 2.3 - 27 MAY 2010 (DM)
  80      =3  //    -Removed 'LOCATED_VARIABLE' pragma from Keil because it is not supported
  81      =3  // Release 2.2 - 06 APR 2010 (ES)
  82      =3  //    -Removed 'PATHINCLUDE' pragma from Raisonance section
  83      =3  // Release 2.1 - 16 JUL 2009 (ES)
  84      =3  //    -Added SEGMENT_POINTER macro definitions for SDCC, Keil, and Raisonance
  85      =3  //    -Added LOCATED_VARIABLE_NO_INIT macro definitions for Raisonance
  86      =3  // Release 2.0 - 19 MAY 2009 (ES)
  87      =3  //    -Added LOCATED_VARIABLE_NO_INIT macro definitions for SDCC and Keil
  88      =3  // Release 1.9 - 23 OCT 2008 (ES)
  89      =3  //    -Updated Hi-Tech INTERRUPT and INTERRUPT_USING macro definitions
  90      =3  //    -Added SFR16 macro defintion for Hi-Tech
  91      =3  // Release 1.8 - 31 JUL 2008 (ES)
  92      =3  //    -Added INTERRUPT_USING and FUNCTION_USING macro's
  93      =3  //    -Added macro's for IAR
  94      =3  //    -Corrected Union definitions for Hi-Tech and added SFR16 macro defintion
  95      =3  // Release 1.7 - 11 SEP 2007 (BW)
  96      =3  //    -Added support for Raisonance EVAL 03.03.42 and Tasking Eval 7.2r1
  97      =3  // Release 1.6 - 27 AUG 2007 (BW)
  98      =3  //    -Updated copyright notice per agreement with Maartin Brock
  99      =3  //    -Added SDCC 2.7.0 "compiler.h" bug fixes
 100      =3  //    -Added memory segment defines (SEG_XDATA, for example)
 101      =3  // Release 1.5 - 24 AUG 2007 (BW)
 102      =3  //    -Added support for NOP () macro
 103      =3  //    -Added support for Hi-Tech ver 9.01
 104      =3  // Release 1.4 - 07 AUG 2007 (PKC)
 105      =3  //    -Removed FID and fixed formatting.
 106      =3  // Release 1.3 - 30 SEP 2007 (TP)
 107      =3  //    -Added INTERRUPT_PROTO_USING to properly support ISR context switching
 108      =3  //     under SDCC.
 109      =3  // Release 1.2 - (BW)
 110      =3  //    -Added support for U8,U16,U32,S8,S16,S32,UU16,UU32 data types
 111      =3  // Release 1.1 - (BW)
 112      =3  //    -Added support for INTERRUPT, INTERRUPT_USING, INTERRUPT_PROTO,
 113      =3  //     SEGMENT_VARIABLE, VARIABLE_SEGMENT_POINTER,
 114      =3  //     SEGMENT_VARIABLE_SEGMENT_POINTER, and LOCATED_VARIABLE
 115      =3  // Release 1.0 - 29 SEP 2006 (PKC)
 116      =3  //    -Initial revision
 117      =3  
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 22  

 118      =3  //-----------------------------------------------------------------------------
 119      =3  // Header File Preprocessor Directive
 120      =3  //-----------------------------------------------------------------------------
 121      =3  
 122      =3  #ifndef COMPILER_DEFS_H
 123      =3  #define COMPILER_DEFS_H
 124      =3  
 125      =3  #include "stdbool.h"
   1      =4  /**************************************************************************//**
   2      =4   * Copyright (c) 2015 by Silicon Laboratories Inc. All rights reserved.
   3      =4   *
   4      =4   * http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   5      =4   *****************************************************************************/
   6      =4  
   7      =4  #ifndef STDBOOL_H
           =4 #define STDBOOL_H
           =4 
           =4 #if defined __C51__
           =4 
           =4 typedef bit bool;
           =4 enum{
           =4   false = 0,
           =4   true = 1,
           =4 };
           =4 
           =4 #elif defined __ICC8051__
           =4 
           =4 #ifndef _SYSTEM_BUILD
           =4   #pragma system_include
           =4 #endif
           =4 
           =4 #ifndef __cplusplus
           =4 
           =4 #define bool _Bool
           =4 #define true 1
           =4 #define false 0
           =4 
           =4 #define __bool_true_false_are_defined 1
           =4 
           =4 #endif /* !__cplusplus */
           =4 
           =4 #else  // __SLS_IDE__ : Macros defined to remove syntax errors within Simplicity Studio
           =4 
           =4 typedef bit bool;
           =4 enum{
           =4   false = 0,
           =4   true = 1,
           =4 };
           =4 
           =4 #endif
           =4 
           =4 #endif //STDBOOL_H
  45      =4  
 126      =3  #include "stdint.h"
   1      =4  /**************************************************************************//**
   2      =4   * Copyright (c) 2015 by Silicon Laboratories Inc. All rights reserved.
   3      =4   *
   4      =4   * http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   5      =4   *****************************************************************************/
   6      =4  
   7      =4  #ifndef STDINT_H
           =4 #define STDINT_H
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 23  

           =4 
           =4 #if defined __C51__
           =4 
           =4 typedef unsigned char uint8_t;
           =4 typedef unsigned short uint16_t;
           =4 typedef unsigned long uint32_t;
           =4 typedef uint32_t uint64_t[2];
           =4 
           =4 typedef signed char int8_t;
           =4 typedef short int16_t;
           =4 typedef long int32_t;
           =4 typedef int32_t int64_t[2];
           =4 typedef float fp32_t;
           =4 typedef double fp64_t;
           =4 
           =4 #elif defined __ICC8051__
           =4 
           =4 /* Fixed size types. These are all optional. */
           =4 #ifdef __INT8_T_TYPE__
           =4   typedef __INT8_T_TYPE__   int8_t;
           =4   typedef __UINT8_T_TYPE__ uint8_t;
           =4 #endif /* __INT8_T_TYPE__ */
           =4 
           =4 #ifdef __INT16_T_TYPE__
           =4   typedef __INT16_T_TYPE__   int16_t;
           =4   typedef __UINT16_T_TYPE__ uint16_t;
           =4 #endif /* __INT16_T_TYPE__ */
           =4 
           =4 #ifdef __INT32_T_TYPE__
           =4   typedef __INT32_T_TYPE__   int32_t;
           =4   typedef __UINT32_T_TYPE__ uint32_t;
           =4 #endif /* __INT32_T_TYPE__ */
           =4 
           =4 #ifdef __INT64_T_TYPE__
           =4   #pragma language=save
           =4   #pragma language=extended
           =4   typedef __INT64_T_TYPE__   int64_t;
           =4   typedef __UINT64_T_TYPE__ uint64_t;
           =4   #pragma language=restore
           =4 #endif /* __INT64_T_TYPE__ */
           =4 
           =4 #endif
           =4 
           =4 #endif
 127      =3  
 128      =3  //-----------------------------------------------------------------------------
 129      =3  // Macro definitions
 130      =3  //-----------------------------------------------------------------------------
 131      =3  
 132      =3  //SDK Version
 133      =3  #define SDK_VERSION   2
 134      =3  
 135      =3  #ifndef NULL
           =3 #define NULL ((void*) 0)
           =3 #endif
 138      =3  
 139      =3  
 140      =3  // SDCC - Small Device C Compiler
 141      =3  // http://sdcc.sourceforge.net
 142      =3  
 143      =3  #if defined SDCC
           =3 
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 24  

           =3 #if (SDCC >= 300)
           =3 
           =3 #define interrupt __interrupt
           =3 #define _asm __asm
           =3 #define _endasm __endasm
           =3 #define bit __bit
           =3 #define code __code
           =3 #define at __at
           =3 
           =3 #endif
           =3 
           =3 # define SEG_GENERIC
           =3 # define SEG_FAR   __xdata
           =3 # define SEG_DATA  __data
           =3 # define SEG_NEAR  __data
           =3 # define SEG_IDATA __idata
           =3 # define SEG_XDATA __xdata
           =3 # define SEG_PDATA __pdata
           =3 # define SEG_CODE  __code
           =3 # define SEG_BDATA __bdata
           =3 
           =3 # define SBIT(name, addr, bit)  __sbit  __at(addr+bit)                  name
           =3 # define SFR(name, addr)        __sfr   __at(addr)                      name
           =3 # define SFRX(name, addr)       xdata volatile unsigned char __at(addr) name
           =3 # define SFR16(name, addr)      __sfr16 __at(((addr+1U)<<8) | addr)     name
           =3 # define SFR16E(name, fulladdr) __sfr16 __at(fulladdr)                  name
           =3 # define SFR32(name, addr)      __sfr32 __at(((addr+3UL)<<24) | ((addr+2UL)<<16) | ((addr+1UL)<<8) | addr)
             - name
           =3 # define SFR32E(name, fulladdr) __sfr32 __at(fulladdr)                  name
           =3 
           =3 # define INTERRUPT(name, vector) void name (void) interrupt (vector)
           =3 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt (vector) using (regnum)
           =3 # define INTERRUPT_PROTO(name, vector) void name (void) interrupt (vector)
           =3 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void) interrupt (vector) using (regnum)
           =3 
           =3 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using (regnum
             -)
           =3 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter) using (
             -regnum)
           =3 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =3 
           =3 # define SEGMENT_VARIABLE(name, vartype, locsegment) locsegment vartype name
           =3 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) targsegment vartype * name
           =3 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) targsegment vartype * lo
             -csegment name
           =3 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
           =3 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment at (addr) vartype name = init
           =3 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) locsegment at (addr) vartype name
           =3 
           =3 // used with UU16
           =3 # define LSB 0
           =3 # define MSB 1
           =3 
           =3 // used with UU32 (b0 is least-significant byte)
           =3 # define b0 0
           =3 # define b1 1
           =3 # define b2 2
           =3 # define b3 3
           =3 
           =3 typedef unsigned char U8;
           =3 typedef unsigned int U16;
           =3 typedef unsigned long U32;
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 25  

           =3 
           =3 typedef signed char S8;
           =3 typedef signed int S16;
           =3 typedef signed long S32;
           =3 
           =3 typedef union UU16
           =3 {
           =3    U16 U16;
           =3    S16 S16;
           =3    U8 U8[2];
           =3    S8 S8[2];
           =3 } UU16;
           =3 
           =3 typedef union UU32
           =3 {
           =3    U32 U32;
           =3    S32 S32;
           =3    UU16 UU16[2];
           =3    U16 U16[2];
           =3    S16 S16[2];
           =3    U8 U8[4];
           =3    S8 S8[4];
           =3 } UU32;
           =3 
           =3 // NOP () macro support
           =3 #define NOP() _asm NOP _endasm
           =3 
           =3 // generic pointer memory type specifiers
           =3 #define SI_GPTR
           =3 #define SI_GPTR_MTYPE_DATA       0x40
           =3 #define SI_GPTR_MTYPE_IDATA      0x40
           =3 #define SI_GPTR_MTYPE_BDATA      0x40
           =3 #define SI_GPTR_MTYPE_PDATA      0x60
           =3 #define SI_GPTR_MTYPE_XDATA      0x00
           =3 #define SI_GPTR_MTYPE_CODE       0x80
           =3 
           =3 // generic pointer access struct
           =3 typedef union SI_GENERIC_PTR
           =3 {
           =3     U8 U8[3];
           =3     struct
           =3     {
           =3         UU16 ADDR;
           =3         U8 MTYPE;
           =3     } GPTR;
           =3 } SI_GENERIC_PTR;
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 // Raisonance (must be placed before Keil C51)
           =3 // http://www.raisonance.com
           =3 
           =3 #elif defined __RC51__
           =3 
           =3 //#error Raisonance C51 detected.
           =3 
           =3 # define SEG_GENERIC generic     //SEG_GENERIC only applies to pointers in Raisonance, not variables.
           =3 # define SEG_FAR   xdata
           =3 # define SEG_DATA  data
           =3 # define SEG_NEAR  data
           =3 # define SEG_IDATA idata
           =3 # define SEG_XDATA xdata
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 26  

           =3 # define SEG_PDATA pdata
           =3 # define SEG_CODE  code
           =3 # define SEG_BDATA bdata
           =3 
           =3 # define SBIT(name, addr, bit)  at (addr+bit) sbit         name
           =3 # define SFR(name, addr)        sfr at addr                name
           =3 # define SFR16(name, addr)      sfr16 at addr              name
           =3 # define SFR16E(name, fulladdr) /* not supported */
           =3 # define SFR32(name, fulladdr)  /* not supported */
           =3 # define SFR32E(name, fulladdr) /* not supported */
           =3 
           =3 # define INTERRUPT(name, vector) void name (void) interrupt vector
           =3 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
           =3 # define INTERRUPT_PROTO(name, vector) void name (void)
           =3 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
           =3 
           =3 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using regnum
           =3 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =3 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =3 
           =3 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =3 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =3 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =3 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
           =3 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) at addr locsegment vartype name
           =3 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) at addr locsegment vartype name
           =3 
           =3 
           =3 // used with UU16
           =3 # define LSB 1
           =3 # define MSB 0
           =3 
           =3 // used with UU32 (b0 is least-significant byte)
           =3 # define b0 3
           =3 # define b1 2
           =3 # define b2 1
           =3 # define b3 0
           =3 
           =3 typedef unsigned char U8;
           =3 typedef unsigned int U16;
           =3 typedef unsigned long U32;
           =3 
           =3 typedef signed char S8;
           =3 typedef signed int S16;
           =3 typedef signed long S32;
           =3 
           =3 typedef union UU16
           =3 {
           =3    U16 U16;
           =3    S16 S16;
           =3    U8 U8[2];
           =3    S8 S8[2];
           =3 } UU16;
           =3 
           =3 typedef union UU32
           =3 {
           =3    U32 U32;
           =3    S32 S32;
           =3    UU16 UU16[2];
           =3    U16 U16[2];
           =3    S16 S16[2];
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 27  

           =3    U8 U8[4];
           =3    S8 S8[4];
           =3 } UU32;
           =3 
           =3 // NOP () macro support -- NOP is opcode 0x00
           =3 #define NOP() asm { 0x00 }
           =3 
           =3 // generic pointer memory type specifiers
           =3 #define SI_GPTR
           =3 #define SI_GPTR_MTYPE_DATA       0x04
           =3 #define SI_GPTR_MTYPE_IDATA      0x01
           =3 #define SI_GPTR_MTYPE_BDATA      0x04
           =3 #define SI_GPTR_MTYPE_PDATA      0x03
           =3 #define SI_GPTR_MTYPE_XDATA      0x02
           =3 #define SI_GPTR_MTYPE_CODE       0x05
           =3 
           =3 // generic pointer access struct
           =3 typedef union SI_GENERIC_PTR
           =3 {
           =3     U8 U8[3];
           =3     struct
           =3     {
           =3         U8 MTYPE;
           =3         UU16 ADDR;
           =3     } GPTR;
           =3 } SI_GENERIC_PTR;
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 
           =3 // Keil C51
           =3 // http://www.keil.com
           =3 
           =3 #elif defined __C51__
 360      =3  
 361      =3  //#error Keil C51 detected.
 362      =3  
 363      =3  # define SEG_GENERIC
 364      =3  # define SEG_FAR   xdata
 365      =3  # define SEG_DATA  data
 366      =3  # define SEG_NEAR  data
 367      =3  # define SEG_IDATA idata
 368      =3  # define SEG_XDATA xdata
 369      =3  # define SEG_PDATA pdata
 370      =3  # define SEG_CODE  code
 371      =3  # define SEG_BDATA bdata
 372      =3  
 373      =3  # define SBIT(name, addr, bit)  sbit  name = addr^bit
 374      =3  # define SFR(name, addr)        sfr   name = addr
 375      =3  # define SFR16(name, addr)      sfr16 name = addr
 376      =3  # define SFR16E(name, fulladdr) /* not supported */
 377      =3  # define SFR32(name, fulladdr)  /* not supported */
 378      =3  # define SFR32E(name, fulladdr) /* not supported */
 379      =3  
 380      =3  # ifndef __SLS_IDE__
 381      =3  
 382      =3  # define INTERRUPT(name, vector) void name (void) interrupt vector
 383      =3  # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
 384      =3  # define INTERRUPT_PROTO(name, vector) void name (void)
 385      =3  # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
 386      =3  
 387      =3  # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using regnum
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 28  

 388      =3  # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter)
 389      =3  // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
 390      =3  
 391      =3  # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
 392      =3  # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
 393      =3  # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
 394      =3  # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
 395      =3  # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) vartype locsegment name _at_ addr
 396      =3  
 397      =3  # else  // __SLS_IDE__
           =3 
           =3 # define INTERRUPT(name, vector) void name (void)
           =3 # define INTERRUPT_USING(name, vector, regnum) void name (void)
           =3 # define INTERRUPT_PROTO(name, vector) void name (void)
           =3 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
           =3 
           =3 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =3 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =3 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =3 
           =3 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype name
           =3 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype * name
           =3 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype * name
           =3 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * name
           =3 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) vartype name
           =3 
           =3 # endif // __SLS_IDE__
 415      =3  
 416      =3  // used with UU16
 417      =3  # define LSB 1
 418      =3  # define MSB 0
 419      =3  
 420      =3  // used with UU32 (b0 is least-significant byte)
 421      =3  # define b0 3
 422      =3  # define b1 2
 423      =3  # define b2 1
 424      =3  # define b3 0
 425      =3  
 426      =3  typedef unsigned char U8;
 427      =3  typedef unsigned int U16;
 428      =3  typedef unsigned long U32;
 429      =3  
 430      =3  typedef signed char S8;
 431      =3  typedef signed int S16;
 432      =3  typedef signed long S32;
 433      =3  
 434      =3  typedef union UU16
 435      =3  {
 436      =3     U16 U16;
 437      =3     S16 S16;
 438      =3     U8 U8[2];
 439      =3     S8 S8[2];
 440      =3  } UU16;
 441      =3  
 442      =3  typedef union UU32
 443      =3  {
 444      =3     U32 U32;
 445      =3     S32 S32;
 446      =3     UU16 UU16[2];
 447      =3     U16 U16[2];
 448      =3     S16 S16[2];
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 29  

 449      =3     U8 U8[4];
 450      =3     S8 S8[4];
 451      =3  } UU32;
 452      =3  
 453      =3  // NOP () macro support
 454      =3  extern void _nop_ (void);
 455      =3  #define NOP() _nop_()
 456      =3  
 457      =3  // generic pointer memory type specifiers
 458      =3  #define SI_GPTR
 459      =3  #define SI_GPTR_MTYPE_DATA      0x00
 460      =3  #define SI_GPTR_MTYPE_IDATA     0x00
 461      =3  #define SI_GPTR_MTYPE_BDATA     0x00
 462      =3  #define SI_GPTR_MTYPE_PDATA     0xFE
 463      =3  #define SI_GPTR_MTYPE_XDATA     0x01
 464      =3  #define SI_GPTR_MTYPE_CODE      0xFF
 465      =3  
 466      =3  // generic pointer access struct
 467      =3  typedef union SI_GENERIC_PTR
 468      =3  {
 469      =3      U8 U8[3];
 470      =3      struct
 471      =3      {
 472      =3          U8 MTYPE;
 473      =3          UU16 ADDR;
 474      =3      } GPTR;
 475      =3  } SI_GENERIC_PTR;
 476      =3  
 477      =3  //-----------------------------------------------------------------------------
 478      =3  
 479      =3  // Hi-Tech 8051
 480      =3  // http://www.htsoft.com
 481      =3  
 482      =3  #elif defined HI_TECH_C
           =3 
           =3 # define SEG_GENERIC
           =3 # define SEG_FAR   far
           =3 # define SEG_DATA  data
           =3 # define SEG_NEAR  near
           =3 # define SEG_IDATA idata
           =3 # define SEG_XDATA xdata
           =3 # define SEG_PDATA pdata
           =3 # define SEG_CODE  code
           =3 # define SEG_BDATA bdata
           =3 
           =3 
           =3 # define SBIT(name, addr, thebit) static volatile bit name @ (addr + thebit)
           =3 # define SFR(name, addr)          static volatile unsigned char name @ addr
           =3 # define SFR16(name, addr)        static volatile unsigned int name @ addr
           =3 # define SFR16E(name, fulladdr) /* not supported */
           =3 # define SFR32(name, fulladdr)  /* not supported */
           =3 # define SFR32E(name, fulladdr) /* not supported */
           =3 
           =3 # define INTERRUPT(name, vector)       void name (void) interrupt vector
           =3 # define INTERRUPT_PROTO(name, vector)
           =3 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
           =3 # define INTERRUPT_PROTO_USING(name, vector, regnum)
           =3 
           =3 # define FUNCTION_USING(name, return_value, parameter, regnum) /* not supported */
           =3 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) /* not supported */
           =3 // Note: Hi-Tech does not support functions using different register banks. Register
           =3 //       banks can only be specified in interrupts. If a function is called from
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 30  

           =3 //       inside an interrupt, it will use the same register bank as the interrupt.
           =3 
           =3 # define SEGMENT_VARIABLE(name, vartype, locsegment) locsegment vartype name
           =3 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) targsegment vartype * name
           =3 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) targsegment vartype * lo
             -csegment name
           =3 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment vartype name @ addr
           =3 
           =3 // used with UU16
           =3 # define LSB 0
           =3 # define MSB 1
           =3 
           =3 // used with UU32 (b0 is least-significant byte)
           =3 # define b0 0
           =3 # define b1 1
           =3 # define b2 2
           =3 # define b3 3
           =3 
           =3 typedef unsigned char U8;
           =3 typedef unsigned int U16;
           =3 typedef unsigned long U32;
           =3 
           =3 typedef signed char S8;
           =3 typedef signed int S16;
           =3 typedef signed long S32;
           =3 
           =3 typedef union UU16
           =3 {
           =3    U16 U16;
           =3    S16 S16;
           =3    U8 U8[2];
           =3    S8 S8[2];
           =3 } UU16;
           =3 
           =3 typedef union UU32
           =3 {
           =3    U32 U32;
           =3    S32 S32;
           =3    UU16 UU16[2];
           =3    U16 U16[2];
           =3    S16 S16[2];
           =3    U8 U8[4];
           =3    S8 S8[4];
           =3 } UU32;
           =3 
           =3 // NOP () macro support
           =3 #define NOP() asm(" nop ")
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 // Tasking / Altium
           =3 // http://www.altium.com/tasking
           =3 
           =3 
           =3 #elif defined _CC51
           =3 
           =3 # define SEG_GENERIC
           =3 # define SEG_FAR   _xdat
           =3 # define SEG_DATA  _data
           =3 # define SEG_NEAR  _data
           =3 # define SEG_IDATA _idat
           =3 # define SEG_XDATA _xdat
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 31  

           =3 # define SEG_PDATA _pdat
           =3 # define SEG_CODE  _rom
           =3 # define SEG_BDATA _bdat
           =3 
           =3 # define SBIT(name, addr, bit)  _sfrbit  name _at(addr+bit)
           =3 # define SFR(name, addr)        _sfrbyte name _at(addr)
           =3 # define SFRX(name, addr)       _xdat volatile unsigned char name _at(addr)
           =3 #if _CC51 > 71
           =3 # define SFR16(name, addr)      _sfrword _little name _at(addr)
           =3 #else
           =3 # define SFR16(name, addr)      /* not supported */
           =3 #endif
           =3 # define SFR16E(name, fulladdr) /* not supported */
           =3 # define SFR32(name, fulladdr)  /* not supported */
           =3 # define SFR32E(name, fulladdr) /* not supported */
           =3 
           =3 # define INTERRUPT(name, vector) _interrupt (vector) void name (void)
           =3 # define INTERRUPT_USING(name, vector, regnum) _interrupt (vector) _using(regnum) void name (void)
           =3 # define INTERRUPT_PROTO(name, vector) _interrupt (vector) void name (void)
           =3 # define INTERRUPT_PROTO_USING(name, vector, regnum) _interrupt (vector) _using(regnum) void name (void)
           =3 
           =3 // When calling FUNCTION_USING in Tasking, the function must be called from an interrupt or Main which
           =3 // is also using the same register bank. If not, the compiler will generate an error.
           =3 # define FUNCTION_USING(name, return_value, parameter, regnum) _using(regnum) return_value name (parameter
             -)
           =3 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) _using(regnum) return_value name (par
             -ameter)
           =3 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =3 
           =3 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =3 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =3 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =3 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) vartype locsegment name _at( addr )
           =3 
           =3 // used with UU16
           =3 # define LSB 1
           =3 # define MSB 0
           =3 
           =3 // used with UU32 (b0 is least-significant byte)
           =3 # define b0 3
           =3 # define b1 2
           =3 # define b2 1
           =3 # define b3 0
           =3 
           =3 typedef unsigned char U8;
           =3 typedef unsigned int U16;
           =3 typedef unsigned long U32;
           =3 
           =3 typedef signed char S8;
           =3 typedef signed int S16;
           =3 typedef signed long S32;
           =3 
           =3 typedef union UU16
           =3 {
           =3    U16 U16;
           =3    S16 S16;
           =3    U8 U8[2];
           =3    S8 S8[2];
           =3 } UU16;
           =3 
           =3 typedef union UU32
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 32  

           =3 {
           =3    U32 U32;
           =3    S32 S32;
           =3    UU16 UU16[2];
           =3    U16 U16[2];
           =3    S16 S16[2];
           =3    U8 U8[4];
           =3    S8 S8[4];
           =3 } UU32;
           =3 
           =3 // NOP () macro support
           =3 extern void _nop (void);
           =3 #define NOP() _nop()
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 
           =3 // IAR 8051
           =3 // http://www.iar.com
           =3 
           =3 #elif defined __ICC8051__
           =3 
           =3 #include <stdbool.h>
           =3 #include <intrinsics.h>
           =3 
           =3 # define SBIT(name, addr, bit)  __bit __no_init volatile bool name @ (addr+bit)
           =3 # define SFR(name, addr)        __sfr __no_init volatile unsigned char name @ addr
           =3 # define SFRX(name, addr)       __xdata __no_init volatile unsigned char name @ addr
           =3 # define SFR16(name, addr)      __sfr __no_init volatile unsigned int  name @ addr
           =3 # define SFR16E(name, fulladdr) /* not supported */
           =3 # define SFR32(name, fulladdr) /* not supported */
           =3 # define SFR32E(name, fulladdr) /* not supported */
           =3 
           =3 # define SEG_GENERIC __generic
           =3 # define SEG_FAR  __xdata
           =3 # define SEG_DATA __data
           =3 # define SEG_NEAR __data
           =3 # define SEG_IDATA __idata
           =3 # define SEG_XDATA __xdata
           =3 # define SEG_PDATA __pdata
           =3 # define SEG_CODE  __code
           =3 # define SEG_BDATA __bdata
           =3 
           =3 #define bit bool
           =3 
           =3 # define _PPTOSTR_(x) #x
           =3 # define _PPARAM_(address) _PPTOSTR_(vector=address * 8 + 3)
           =3 # define _PPARAM2_(regbank) _PPTOSTR_(register_bank=regbank)
           =3 # define INTERRUPT(name, vector) _Pragma(_PPARAM_(vector)) __interrupt void name(void)
           =3 # define INTERRUPT_PROTO(name, vector)  __interrupt void name(void)
           =3 # define INTERRUPT_USING(name, vector, regnum) _Pragma(_PPARAM2_(regnum)) _Pragma(_PPARAM_(vector)) __inte
             -rrupt void name(void)
           =3 # define INTERRUPT_PROTO_USING(name, vector, regnum) __interrupt void name(void)
           =3 
           =3 # define FUNCTION_USING(name, return_value, parameter, regnum) /* not supported */
           =3 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) /* not supported */
           =3 // Note: IAR does not support functions using different register banks. Register
           =3 //       banks can only be specified in interrupts. If a function is called from
           =3 //       inside an interrupt, it will use the same register bank as the interrupt.
           =3 
           =3 # define SEGMENT_VARIABLE(name, vartype, locsegment)  locsegment vartype name
           =3 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment  * name
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 33  

           =3 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =3 
           =3 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment __no_init vartype name @ addr
           =3 
           =3 // used with UU16
           =3 # define LSB 0
           =3 # define MSB 1
           =3 
           =3 // used with UU32 (b0 is least-significant byte)
           =3 # define b0 0
           =3 # define b1 1
           =3 # define b2 2
           =3 # define b3 3
           =3 
           =3 typedef unsigned char U8;
           =3 typedef unsigned int U16;
           =3 typedef unsigned long U32;
           =3 
           =3 typedef signed char S8;
           =3 typedef signed int S16;
           =3 typedef signed long S32;
           =3 
           =3 typedef union UU16
           =3 {
           =3    U16 U16;
           =3    S16 S16;
           =3    U8 U8[2];
           =3    S8 S8[2];
           =3 } UU16;
           =3 
           =3 typedef union UU32
           =3 {
           =3    U32 U32;
           =3    S32 S32;
           =3    UU16 UU16[2];
           =3    U16 U16[2];
           =3    S16 S16[2];
           =3    U8 U8[4];
           =3    S8 S8[4];
           =3 } UU32;
           =3 
           =3 
           =3 #define NOP() __no_operation();
           =3 
           =3 // generic pointer memory type specifiers
           =3 #define SI_GPTR
           =3 #define SI_GPTR_MTYPE_DATA       0x01
           =3 #define SI_GPTR_MTYPE_IDATA      0x01
           =3 #define SI_GPTR_MTYPE_BDATA      0x01
           =3 #define SI_GPTR_MTYPE_PDATA      0x00
           =3 #define SI_GPTR_MTYPE_XDATA      0x00
           =3 #define SI_GPTR_MTYPE_CODE       0x80
           =3 
           =3 // generic pointer access struct
           =3 typedef union SI_GENERIC_PTR
           =3 {
           =3     U8 U8[3];
           =3     struct
           =3     {
           =3         UU16 ADDR;
           =3         U8 MTYPE;
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 34  

           =3     } GPTR;
           =3 } SI_GENERIC_PTR;
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 // Crossware
           =3 // http://www.crossware.com
           =3 
           =3 #elif defined _XC51_VER
           =3 # define SBIT(name, addr, bit)  _sfrbit  name = (addr+bit)
           =3 # define SFR(name, addr)        _sfr     name = addr
           =3 # define SFR16(name, addr)      _sfrword name = addr
           =3 # define SFR16E(name, fulladdr) /* not supported */
           =3 # define SFR32(name, fulladdr)  /* not supported */
           =3 # define SFR32E(name, fulladdr) /* not supported */
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 // Wickenh盲user
           =3 // http://www.wickenhaeuser.de
           =3 
           =3 #elif defined __UC__
           =3 # define SBIT(name, addr, bit)  unsigned char bit  name @ (addr+bit)
           =3 # define SFR(name, addr)        near unsigned char name @ addr
           =3 # define SFR16(name, addr)      /* not supported */
           =3 # define SFR16E(name, fulladdr) /* not supported */
           =3 # define SFR32(name, fulladdr)  /* not supported */
           =3 # define SFR32E(name, fulladdr) /* not supported */
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 // Default
           =3 // Unknown compiler
           =3 
           =3 #else
           =3 # warning unrecognized compiler
           =3 # define SBIT(name, addr, bit)  volatile bool           name
           =3 # define SFR(name, addr)        volatile unsigned char  name
           =3 # define SFRX(name, addr)       volatile unsigned char  name
           =3 # define SFR16(name, addr)      volatile unsigned short name
           =3 # define SFR16E(name, fulladdr) volatile unsigned short name
           =3 # define SFR32(name, fulladdr)  volatile unsigned long  name
           =3 # define SFR32E(name, fulladdr) volatile unsigned long  name
           =3 
           =3 #endif
 798      =3  
 799      =3  //-----------------------------------------------------------------------------
 800      =3  // Header File PreProcessor Directive
 801      =3  //-----------------------------------------------------------------------------
 802      =3  
 803      =3  #endif                                 // #define COMPILER_DEFS_H
 804      =3  
 805      =3  //-----------------------------------------------------------------------------
 806      =3  // End Of File
 807      =3  //-----------------------------------------------------------------------------
 121      =2  #ifdef C8051F020
           =2 #include "C8051F020_defs.h"
           =2 #endif
 124      =2  #ifdef C8051F340
           =2 #include "C8051F340_defs.h"
           =2 #endif
 127      =2  #ifdef C8051F580
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 35  

 128      =2  #include "C8051F580_defs.h"
   1      =3  //-----------------------------------------------------------------------------
   2      =3  // C8051F580_defs.h
   3      =3  //-----------------------------------------------------------------------------
   4      =3  // Copyright 2008, Silicon Laboratories, Inc.
   5      =3  // http://www.silabs.com
   6      =3  //
   7      =3  // Program Description:
   8      =3  //
   9      =3  // Register/bit definitions for the C8051F58x family.
  10      =3  // **Important Note**: The compiler_defs.h header file should be included
  11      =3  // before including this header file.
  12      =3  //
  13      =3  // Target:         C8051F580/1/2/3/4/5/6/7,8/9-F590/1
  14      =3  // Tool chain:     Generic
  15      =3  // Command Line:   None
  16      =3  //
  17      =3  // Release 0.6 - 20 AUG 2012 (TP)
  18      =3  //    -Added #define for _XPAGE to provide support for SDCC memory paging
  19      =3  //     (pdata)
  20      =3  //
  21      =3  // Release 0.5 - 10 SEP 2011 (GP)
  22      =3  //    - Fixed SFR16 definition for CAN0IF2MC
  23      =3  //
  24      =3  // Release 0.4 - 08 OCT 2010 (TP)
  25      =3  //    - Fixed bit definitions for SCON0
  26      =3  //
  27      =3  // Release 0.3 - 01 APR 2009 (GP)
  28      =3  //    - Added SN0-SN3
  29      =3  //
  30      =3  // Release 0.2 - 29 JUL 2008 (ADT)
  31      =3  //    - Added Timer 4 bit definitions
  32      =3  //
  33      =3  // Release 0.1 - 09 JUL 2008 (GP)
  34      =3  //    - Initial Revision
  35      =3  //
  36      =3  //-----------------------------------------------------------------------------
  37      =3  // Header File Preprocessor Directive
  38      =3  //-----------------------------------------------------------------------------
  39      =3  
  40      =3  #ifndef C8051F580_DEFS_H
  41      =3  #define C8051F580_DEFS_H
  42      =3  
  43      =3  //-----------------------------------------------------------------------------
  44      =3  // Page 0, Page 1 and Page F Registers
  45      =3  //-----------------------------------------------------------------------------
  46      =3  
  47      =3  SFR (P0, 0x80);                        // Port 0 Latch
  48      =3  SFR (SP, 0x81);                        // Stack Pointer
  49      =3  SFR (DPL, 0x82);                       // Data Pointer Low
  50      =3  SFR (DPH, 0x83);                       // Data Pointer High
  51      =3  SFR (SFR0CN, 0x84);                    // SFR Page Control
  52      =3  SFR (SFRNEXT, 0x85);                   // SFR stack next page
  53      =3  SFR (SFRLAST, 0x86);                   // SFR stack last page
  54      =3  SFR (PCON, 0x87);                      // Power Control
  55      =3  SFR (TCON, 0x88);                      // Timer/Counter Control
  56      =3  SFR (TMOD, 0x89);                      // Timer/Counter Mode
  57      =3  SFR (TL0, 0x8A);                       // Timer/Counter 0 Low
  58      =3  SFR (TL1, 0x8B);                       // Timer/Counter 1 Low
  59      =3  SFR (TH0, 0x8C);                       // Timer/Counter 0 High
  60      =3  SFR (TH1, 0x8D);                       // Timer/Counter 1 High
  61      =3  SFR (CKCON, 0x8E);                     // Clock Control
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 36  

  62      =3  SFR (PSCTL, 0x8F);                     // Program Store R/W Control
  63      =3  SFR (CLKSEL, 0x8F);                    // System clock select
  64      =3  SFR (P1, 0x90);                        // Port 1 Latch
  65      =3  SFR (TMR3CN, 0x91);                    // Timer/Counter 3 Control
  66      =3  SFR (TMR5CN, 0x91);                    // Timer/Counter 5 Control
  67      =3  SFR (TMR3RLL, 0x92);                   // Timer/Counter 3 Reload Low
  68      =3  SFR (TMR5CAPL, 0x92);                  // Timer/Counter 5 Capture Low
  69      =3  SFR (TMR3RLH, 0x93);                   // Timer/Counter 3 Reload High
  70      =3  SFR (TMR5CAPH, 0x93);                  // Timer/Counter 5 Capture High
  71      =3  SFR (TMR3L, 0x94);                     // Timer/Counter 3 Low
  72      =3  SFR (TMR5L, 0x94);                     // Timer/Counter 5 Low
  73      =3  SFR (TMR3H, 0x95);                     // Timer/Counter 3 High
  74      =3  SFR (TMR5H, 0x95);                     // Timer/Counter 5 High
  75      =3  SFR (TMR5CF, 0x96);                    // Timer/Counter 5 Configuration
  76      =3  SFR (CLKMUL, 0x97);                    // Clock Multiplier
  77      =3  SFR (SCON0, 0x98);                     // UART0 Control
  78      =3  SFR (SCON1, 0x98);                     // UART1 Control
  79      =3  SFR (SBUF0, 0x99);                     // UART0 Data Buffer
  80      =3  SFR (SBUF1, 0x99);                     // UART1 Data Buffer
  81      =3  SFR (CPT0CN, 0x9A);                    // Comparator 0 Control
  82      =3  SFR (CPT2CN, 0x9A);                    // Comparator 2 Control
  83      =3  SFR (CPT0MD, 0x9B);                    // Comparator 0 Mode
  84      =3  SFR (CPT2MD, 0x9B);                    // Comparator 2 Mode
  85      =3  SFR (CPT0MX, 0x9C);                    // Comparator 0 Mux
  86      =3  SFR (CPT2MX, 0x9C);                    // Comparator 2 Mux
  87      =3  SFR (CPT1CN, 0x9D);                    // Comparator 1 Control
  88      =3  SFR (CPT1MD, 0x9E);                    // Comparator 0 Mode
  89      =3  SFR (OSCIFIN, 0x9E);                   // Internal Oscillator Fine Control
  90      =3  SFR (CPT1MX, 0x9F);                    // Comparator 1 Mux
  91      =3  SFR (OSCXCN, 0x9F);                    // External Oscillator Control
  92      =3  SFR (P2, 0xA0);                        // Port 2 Latch
  93      =3  SFR (SPI0CFG, 0xA1);                   // SPI0 Configuration
  94      =3  SFR (OSCICN, 0xA1);                    // Internal Oscillator Control
  95      =3  SFR (SPI0CKR, 0xA2);                   // SPI0 Clock rate control
  96      =3  SFR (OSCICRS, 0xA2);                   // Internal Oscillator Coarse Control
  97      =3  SFR (SPI0DAT, 0xA3);                   // SPI0 Data Buffer
  98      =3  SFR (P0MDOUT, 0xA4);                   // Port 0 Output Mode
  99      =3  SFR (P1MDOUT, 0xA5);                   // Port 1 Output Mode
 100      =3  SFR (P2MDOUT, 0xA6);                   // Port 2 Output Mode
 101      =3  SFR (SFRPAGE, 0xA7);                   // SFR Page Select
 102      =3  SFR (IE, 0xA8);                        // Interrupt Enable
 103      =3  SFR (SMOD0, 0xA9);                     // Serial Port 0 Control
 104      =3  SFR (EMI0CN, 0xAA);                    // EMIF Control
 105      =3  SFR (EMI0TC, 0xAA);                    // EMIF Timing control
 106      =3  SFR (SBCON0, 0xAB);                    // UART0 Baud Rate Generator Control
 107      =3  SFR (SBRLL0, 0xAC);                    // UART0 Baud Rate Generator Low
 108      =3  SFR (SBRLH0, 0xAD);                    // UART0 Baud Rate Generator High
 109      =3  SFR (P3MAT, 0xAE);                     // Port 3 Match
 110      =3  SFR (P3MDOUT, 0xAE);                   // Port 3 Mode
 111      =3  SFR (P3MASK, 0xAF);                    // Port 3 Mask
 112      =3  SFR (P4MDOUT, 0xAF);                   // Port 4 Mode
 113      =3  SFR (P3, 0xB0);                        // Port 3 Latch
 114      =3  SFR (P2MAT, 0xB1);                     // Port 2 Match
 115      =3  SFR (P2MASK, 0xB2);                    // Port 2 Mask
 116      =3  SFR (EMI0CF, 0xB2);                    // EMIF Configuration
 117      =3  SFR (P4, 0xB5);                        // Port 4 Latch
 118      =3  SFR (FLSCL, 0xB6);                     // Flash Scale
 119      =3  SFR (FLKEY, 0xB7);                     // Flash access limit
 120      =3  SFR (IP, 0xB8);                        // Interrupt Priority
 121      =3  SFR (SMB0ADR, 0xB9);                   // SMBus0 Slave address
 122      =3  SFR (ADC0TK, 0xBA);                    // ADC0 Tracking Mode Select
 123      =3  SFR (SMB0ADM, 0xBA);                   // SMBus0 Address Mask
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 37  

 124      =3  SFR (ADC0MX, 0xBB);                    // AMUX0 Channel select
 125      =3  SFR (ADC0CF, 0xBC);                    // AMUX0 Channel configuration
 126      =3  SFR (ADC0L, 0xBD);                     // ADC0 Data Low
 127      =3  SFR (ADC0H, 0xBE);                     // ADC0 Data High
 128      =3  SFR (SMB0CN, 0xC0);                    // SMBus0 Control
 129      =3  SFR (SMB0CF, 0xC1);                    // SMBus0 Configuration
 130      =3  SFR (SMB0DAT, 0xC2);                   // SMBus0 Data
 131      =3  SFR (ADC0GTL, 0xC3);                   // ADC0 Greater-Than Compare Low
 132      =3  SFR (ADC0GTH, 0xC4);                   // ADC0 Greater-Than Compare High
 133      =3  SFR (ADC0LTL, 0xC5);                   // ADC0 Less-Than Compare Word Low
 134      =3  SFR (ADC0LTH, 0xC6);                   // ADC0 Less-Than Compare Word High
 135      =3  SFR (XBR3, 0xC6);                      // Port I/O Crossbar Control 3
 136      =3  SFR (XBR2, 0xC7);                      // Port I/O Crossbar Control 2
 137      =3  SFR (TMR2CN, 0xC8);                    // Timer/Counter 2 Control
 138      =3  SFR (TMR4CN, 0xC8);                    // Timer/Counter 4 Control
 139      =3  SFR (REG0CN, 0xC9);                    // Regulator Control
 140      =3  SFR (LIN0CF, 0xC9);                    // LIN 0 Configuration
 141      =3  SFR (TMR4CF, 0xC9);                    // Timer/Counter 4 Configuration
 142      =3  SFR (TMR2RLL, 0xCA);                   // Timer/Counter 2 Reload Low
 143      =3  SFR (TMR4CAPL, 0xCA);                  // Timer/Counter 4 Capture Low
 144      =3  SFR (TMR2RLH, 0xCB);                   // Timer/Counter 2 Reload High
 145      =3  SFR (TMR4CAPH, 0xCB);                  // Timer/Counter 4 Capture High
 146      =3  SFR (TMR2L, 0xCC);                     // Timer/Counter 2 Low
 147      =3  SFR (TMR4L, 0xCC);                     // Timer/Counter 4 Low
 148      =3  SFR (TMR2H, 0xCD);                     // Timer/Counter 2 High
 149      =3  SFR (TMR4H, 0xCD);                     // Timer/Counter 4 High
 150      =3  SFR (PCA0CPL5, 0xCE);                  // PCA0 Capture 5 Low
 151      =3  SFR (PCA1CPL11, 0xCE);                 // PCA1 Capture 11 Low
 152      =3  SFR (PCA0CPH5, 0xCF);                  // PCA0 Capture 5 High
 153      =3  SFR (PCA1CPH11, 0xCF);                 // PCA1 Capture 11 High
 154      =3  SFR (PSW, 0xD0);                       // Program Status Word
 155      =3  SFR (REF0CN, 0xD1);                    // Voltage Reference Control
 156      =3  SFR (LIN0DAT, 0xD2);                   // LIN0 Data
 157      =3  SFR (LIN0ADR, 0xD3);                   // LIN0 Address
 158      =3  SFR (P0SKIP, 0xD4);                    // Port 0 Skip
 159      =3  SFR (P1SKIP, 0xD5);                    // Port 1 Skip
 160      =3  SFR (P2SKIP, 0xD6);                    // Port 2 Skip
 161      =3  SFR (P3SKIP, 0xD7);                    // Port 3 Skip
 162      =3  SFR (PCA0CN, 0xD8);                    // PCA0 Control
 163      =3  SFR (PCA1CN, 0xD8);                    // PCA1 Control
 164      =3  SFR (PCA0MD, 0xD9);                    // PCA0 Mode
 165      =3  SFR (PCA1MD, 0xD9);                    // PCA1 Mode
 166      =3  SFR (PCA0PWM, 0xD9);                   // PCA0 PWM Control
 167      =3  SFR (PCA0CPM0, 0xDA);                  // PCA0 Module 0 Mode
 168      =3  SFR (PCA1CPM6, 0xDA);                  // PCA1 Module 6 Mode
 169      =3  SFR (PCA1PWM, 0xDA);                   // PCA1 PWM Control
 170      =3  SFR (PCA0CPM1, 0xDB);                  // PCA0 Module 1  Mode
 171      =3  SFR (PCA1CPM7, 0xDB);                  // PCA1 Module 7  Mode
 172      =3  SFR (PCA0CPM2, 0xDC);                  // PCA0 Module 2  Mode
 173      =3  SFR (PCA1CPM8, 0xDC);                  // PCA1 Module 8  Mode
 174      =3  SFR (PCA0CPM3, 0xDD);                  // PCA0 Module 3  Mode
 175      =3  SFR (PCA1CPM9, 0xDD);                  // PCA1 Module 9  Mode
 176      =3  SFR (PCA0CPM4, 0xDE);                  // PCA0 Module 4  Mode
 177      =3  SFR (PCA1CPM10, 0xDE);                  // PCA1 Module 10 Mode
 178      =3  SFR (PCA0CPM5, 0xDF);                  // PCA0 Module 5  Mode
 179      =3  SFR (PCA1CPM11, 0xDF);                  // PCA1 Module 11 Mode
 180      =3  SFR (ACC, 0xE0);                       // Accumulator
 181      =3  SFR (XBR0, 0xE1);                      // Port I/O Crossbar Control 0
 182      =3  SFR (XBR1, 0xE2);                      // Port I/O Crossbar Control 1
 183      =3  SFR (CCH0CN, 0xE3);                    // Cache control
 184      =3  SFR (IT01CF, 0xE4);                    // INT0/INT1 Configuration
 185      =3  SFR (EIE1, 0xE6);                      // Extended Interrupt Enable 2
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 38  

 186      =3  SFR (EIE2, 0xE7);                      // Extended Interrupt Enable 2
 187      =3  SFR (ADC0CN, 0xE8);                    // ADC0 Control
 188      =3  SFR (PCA0CPL1, 0xE9);                  // PCA0 Capture 1 Low
 189      =3  SFR (PCA1CPL1, 0xE9);                  // PCA1 Capture 7 Low
 190      =3  SFR (PCA0CPH1, 0xEA);                  // PCA0 Capture 1 High
 191      =3  SFR (PCA1CPH1, 0xEA);                  // PCA1 Capture 7 High
 192      =3  SFR (PCA0CPL2, 0xEB);                  // PCA0 Capture 2 Low
 193      =3  SFR (PCA1CPL2, 0xEB);                  // PCA1 Capture 8 Low
 194      =3  SFR (PCA0CPH2, 0xEC);                  // PCA0 Capture 2 High
 195      =3  SFR (PCA1CPH2, 0xEC);                  // PCA1 Capture 8 High
 196      =3  SFR (PCA0CPL3, 0xED);                  // PCA0 Capture 3 Low
 197      =3  SFR (PCA1CPL3, 0xED);                  // PCA1 Capture 9 Low
 198      =3  SFR (PCA0CPH3, 0xEE);                  // PCA0 Capture 3 High
 199      =3  SFR (PCA1CPH3, 0xEE);                  // PCA1 Capture 9 High
 200      =3  SFR (RSTSRC, 0xEF);                    // Reset Source Configuration/Status
 201      =3  SFR (B, 0xF0);                         // B Register
 202      =3  SFR (P0MAT, 0xF1);                     // Port 0 Match
 203      =3  SFR (P0MDIN, 0xF1);                    // Port 0 Input Mode
 204      =3  SFR (P0MASK, 0xF2);                    // Port 0 Mask
 205      =3  SFR (P1MDIN, 0xF2);                    // Port 1 Input Mode
 206      =3  SFR (P1MAT, 0xF3);                     // Port 1 Match
 207      =3  SFR (P2MDIN, 0xF3);                    // Port 2 Input Mode
 208      =3  SFR (P1MASK, 0xF4);                    // Port 1 Mask
 209      =3  SFR (P3MDIN, 0xF4);                    // Port 3 Input Mode
 210      =3  SFR (PSBANK, 0xF5);                    // Program Space Bank Select
 211      =3  SFR (EIP1, 0xF6);                      // External Interrupt Priority 1
 212      =3  SFR (EIP2, 0xF7);                      // External Interrupt Priority 2
 213      =3  SFR (SPI0CN, 0xF8);                    // SPI0 Control
 214      =3  SFR (PCA0L, 0xF9);                     // PCA0 Counter Low
 215      =3  SFR (PCA1L, 0xF9);                     // PCA1 Counter Low
 216      =3  SFR (SN0, 0xF9);                       // Serial Number 0
 217      =3  SFR (PCA0H, 0xFA);                     // PCA0 Counter High
 218      =3  SFR (PCA1H, 0xFA);                     // PCA1 Counter High
 219      =3  SFR (SN1, 0xFA);                       // Serial Number 1
 220      =3  SFR (PCA0CPL0, 0xFB);                  // PCA0 Capture 0 Low
 221      =3  SFR (PCA1CPL6, 0xFB);                  // PCA1 Capture 6 Low
 222      =3  SFR (SN2, 0xFB);                       // Serial Number 2
 223      =3  SFR (PCA0CPH0, 0xFC);                  // PCA0 Capture 0 High
 224      =3  SFR (PCA1CPH6, 0xFC);                  // PCA1 Capture 6 High
 225      =3  SFR (SN3, 0xFC);                       // Serial Number 3
 226      =3  SFR (PCA0CPL4, 0xFD);                  // PCA0 Capture 4 Low
 227      =3  SFR (PCA1CPL10, 0xFD);                 // PCA1 Capture 10 Low
 228      =3  SFR (PCA0CPH4, 0xFE);                  // PCA0 Capture 4 High
 229      =3  SFR (PCA1CPH10, 0xFE);                 // PCA1 Capture 10 High
 230      =3  SFR (VDM0CN, 0xFF);                    // VDD Monitor Control
 231      =3  
 232      =3  //-----------------------------------------------------------------------------
 233      =3  // Page C (CAN0) Registers
 234      =3  //-----------------------------------------------------------------------------
 235      =3  
 236      =3  SFR (CAN0CFG, 0x92);                   // CAN0 Clock Configuration
 237      =3  SFR (CAN0STAT, 0x94);                  // Status Register Low Byte
 238      =3  SFR (CAN0ERRL, 0x96);                  // Error Counter Low Byte
 239      =3  SFR (CAN0ERRH, 0x97);                  // Error Counter High Byte
 240      =3  SFR (CAN0BTL, 0x9A);                   // Bit Timing Register Low Byte
 241      =3  SFR (CAN0BTH, 0x9B);                   // Bit Timing Register High Byte
 242      =3  SFR (CAN0IIDL, 0x9C);                  // Interrupt Register Low Byte
 243      =3  SFR (CAN0IIDH, 0x9D);                  // Interrupt Register High Byte
 244      =3  SFR (CAN0TST, 0x9E);                   // Test Register Low Byte
 245      =3  SFR (CAN0BRPE, 0xA1);                  // BRP Extension Register Low Byte
 246      =3  SFR (CAN0TR1L, 0xA2);                  // Transmission Request 1 Low Byte
 247      =3  SFR (CAN0TR1H, 0xA3);                  // Transmission Request 1 High Byte
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 39  

 248      =3  SFR (CAN0TR2L, 0xA4);                  // Transmission Request 2 Low Byte
 249      =3  SFR (CAN0TR2H, 0xA5);                  // Transmission Request 2 High Byte
 250      =3  SFR (CAN0ND1L, 0xAA);                  // New Data 1 Low Byte
 251      =3  SFR (CAN0ND1H, 0xAB);                  // New Data 1 High Byte
 252      =3  SFR (CAN0ND2L, 0xAC);                  // New Data 2 Low Byte
 253      =3  SFR (CAN0ND2H, 0xAD);                  // New Data 2 High Byte
 254      =3  SFR (CAN0IP1L, 0xAE);                  // Interrupt Pending 1 Low Byte
 255      =3  SFR (CAN0IP1H, 0xAF);                  // Interrupt Pending 1 High Byte
 256      =3  SFR (CAN0IP2L, 0xB2);                  // Interrupt Pending 2 Low Byte
 257      =3  SFR (CAN0IP2H, 0xB3);                  // Interrupt Pending 2 High Byte
 258      =3  SFR (CAN0MV1L, 0xBA);                  // Message Valid 1 Low Byte
 259      =3  SFR (CAN0MV1H, 0xBB);                  // Message Valid 1 High Byte
 260      =3  SFR (CAN0MV2L, 0xBC);                  // Message Valid 2 Low Byte
 261      =3  SFR (CAN0MV2H, 0xBD);                  // Message Valid 2 High Byte
 262      =3  SFR (CAN0IF1CRL, 0xBE);                // IF1 Command Request Low Byte
 263      =3  SFR (CAN0IF1CRH, 0xBF);                // IF1 Command Request High Byte
 264      =3  SFR (CAN0CN, 0xC0);                    // CAN Control Register Low Byte
 265      =3  SFR (CAN0IF1CML, 0xC2);                // IF1 Command Mask Low Byte
 266      =3  SFR (CAN0IF1CMH, 0xC3);                // IF1 Command Mask High Byte
 267      =3  SFR (CAN0IF1M1L, 0xC4);                // IF1 Mask 1 Low Byte
 268      =3  SFR (CAN0IF1M1H, 0xC5);                // IF1 Mask 1 High Byte
 269      =3  SFR (CAN0IF1M2L, 0xC6);                // IF1 Mask 2 Low Byte
 270      =3  SFR (CAN0IF1M2H, 0xC7);                // IF1 Mask 2 High Byte
 271      =3  SFR (CAN0IF1A1L, 0xCA);                // IF1 Arbitration 1 Low Byte
 272      =3  SFR (CAN0IF1A1H, 0xCB);                // IF1 Arbitration 1 High Byte
 273      =3  SFR (CAN0IF1A2L, 0xCC);                // IF1 Arbitration 2 Low Byte
 274      =3  SFR (CAN0IF1A2H, 0xCD);                // IF1 Arbitration 2 High Byte
 275      =3  SFR (CAN0IF2MCL, 0xCE);                // IF2 Message Control Low Byte
 276      =3  SFR (CAN0IF2MCH, 0xCF);                // IF2 Message Control High Byte
 277      =3  SFR (CAN0IF1MCL, 0xD2);                // IF1 Message Control Low Byte
 278      =3  SFR (CAN0IF1MCH, 0xD3);                // IF1 Message Control High Byte
 279      =3  SFR (CAN0IF1DA1L, 0xD4);               // IF1 Data A 1 Low Byte
 280      =3  SFR (CAN0IF1DA1H, 0xD5);               // IF1 Data A 1 High Byte
 281      =3  SFR (CAN0IF1DA2L, 0xD6);               // IF1 Data A 2 Low Byte
 282      =3  SFR (CAN0IF1DA2H, 0xD7);               // IF1 Data A 2 High Byte
 283      =3  SFR (CAN0IF1DB1L, 0xDA);               // IF1 Data B 1 Low Byte
 284      =3  SFR (CAN0IF1DB1H, 0xDB);               // IF1 Data B 1 High Byte
 285      =3  SFR (CAN0IF1DB2L, 0xDC);               // IF1 Data B 2 Low Byte
 286      =3  SFR (CAN0IF1DB2H, 0xDD);               // IF1 Data B 2 High Byte
 287      =3  SFR (CAN0IF2CRL, 0xDE);                // IF2 Command Request Low Byte
 288      =3  SFR (CAN0IF2CRH, 0xDF);                // IF2 Command Request High Byte
 289      =3  SFR (CAN0IF2CML, 0xE2);                // IF2 Command Mask Low Byte
 290      =3  SFR (CAN0IF2CMH, 0xE3);                // IF2 Command Mask High Byte
 291      =3  SFR (CAN0IF2M1L, 0xEA);                // IF2 Mask 1 Low Byte
 292      =3  SFR (CAN0IF2M1H, 0xEB);                // IF2 Mask 1 High Byte
 293      =3  SFR (CAN0IF2M2L, 0xEC);                // IF2 Mask 2 Low Byte
 294      =3  SFR (CAN0IF2M2H, 0xED);                // IF2 Mask 2 High Byte
 295      =3  SFR (CAN0IF2A1L, 0xEE);                // IF2 Arbitration 1 Low Byte
 296      =3  SFR (CAN0IF2A1H, 0xEF);                // IF2 Arbitration 1 High Byte
 297      =3  SFR (CAN0IF2A2L, 0xF2);                // IF2 Arbitration 2 Low Byte
 298      =3  SFR (CAN0IF2A2H, 0xF3);                // IF2 Arbitration 2 High Byte
 299      =3  SFR (CAN0IF2DA1L, 0xF6);               // IF2 Data A 1 Low Byte
 300      =3  SFR (CAN0IF2DA1H, 0xF7);               // IF2 Data A 1 High Byte
 301      =3  SFR (CAN0IF2DA2L, 0xFA);               // IF2 Data A 2 Low Byte
 302      =3  SFR (CAN0IF2DA2H, 0xFB);               // IF2 Data A 2 High Byte
 303      =3  SFR (CAN0IF2DB1L, 0xFC);               // IF2 Data B 1 Low Byte
 304      =3  SFR (CAN0IF2DB1H, 0xFD);               // IF2 Data B 1 High Byte
 305      =3  SFR (CAN0IF2DB2L, 0xFE);               // IF2 Data B 2 Low Byte
 306      =3  SFR (CAN0IF2DB2H, 0xFF);               // IF2 Data B 2 High Byte
 307      =3  
 308      =3  
 309      =3  //-----------------------------------------------------------------------------
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 40  

 310      =3  // 16-bit Register Definitions (might not be supported by all compilers)
 311      =3  //-----------------------------------------------------------------------------
 312      =3  
 313      =3  SFR16 (DP, 0x82);                      // Data Pointer
 314      =3  SFR16 (TMR3RL, 0x92);                  // Timer 3 Reload
 315      =3  SFR16 (TMR5CAP, 0x92);                 // Timer 5 Capture
 316      =3  SFR16 (TMR3, 0x94);                    // Timer 3 Capture / Reload
 317      =3  SFR16 (TMR5, 0x94);                    // Timer 5
 318      =3  SFR16 (SBRL0, 0xAC);                   // UART0 Reload
 319      =3  SFR16 (ADC0, 0xBD);                    // ADC0 data
 320      =3  SFR16 (ADC0GT, 0xC3);                  // ADC0 Greater Than Window
 321      =3  SFR16 (ADC0LT, 0xC5);                  // ADC0 Less Than Window
 322      =3  SFR16 (TMR2RL, 0xCA);                  // Timer 2 Reload
 323      =3  SFR16 (TMR4CAP, 0xCA);                 // Timer 4 Capture
 324      =3  SFR16 (TMR2, 0xCC);                    // Timer 2 Capture / Reload
 325      =3  SFR16 (TMR4, 0xCC);                    // Timer 4
 326      =3  SFR16 (PCA0CP5, 0xCE);                 // PCA0 Module 5 Capture
 327      =3  SFR16 (PCA1CP11, 0xCE);                // PCA1 Module 11 Capture
 328      =3  SFR16 (PCA0CP1, 0xE9);                 // PCA0 Module 1 Capture
 329      =3  SFR16 (PCA1CP7, 0xE9);                 // PCA1 Module 7 Capture
 330      =3  SFR16 (PCA0CP2, 0xEB);                 // PCA0 Module 2 Capture
 331      =3  SFR16 (PCA1CP8, 0xEB);                 // PCA1 Module 8 Capture
 332      =3  SFR16 (PCA0CP3, 0xED);                 // PCA0 Module 3 Capture
 333      =3  SFR16 (PCA1CP9, 0xED);                 // PCA1 Module 9 Capture
 334      =3  SFR16 (PCA0, 0xF9);                    // PCA0 Counter
 335      =3  SFR16 (PCA1, 0xF9);                    // PCA1 Counter
 336      =3  SFR16 (PCA0CP0, 0xFB);                 // PCA0 Module 0 Capture
 337      =3  SFR16 (PCA1CP6, 0xFB);                 // PCA1 Module 6 Capture
 338      =3  SFR16 (PCA0CP4, 0xFD);                 // PCA0 Module 4 Capture
 339      =3  SFR16 (PCA1CP10, 0xFD);                 // PCA1 Module 10 Capture
 340      =3  
 341      =3  SFR16 (CAN0ERR, 0x96);                 // Error Counter
 342      =3  SFR16 (CAN0BT, 0x9A);                  // Bit Timing Register
 343      =3  SFR16 (CAN0IID, 0x9C);                 // Interrupt Register
 344      =3  SFR16 (CAN0TR1, 0xA2);                 // Transmission Request 1
 345      =3  SFR16 (CAN0TR2, 0xA4);                 // Transmission Request 2
 346      =3  SFR16 (CAN0ND1, 0xAA);                 // New Data 1
 347      =3  SFR16 (CAN0ND2, 0xAC);                 // New Data 2
 348      =3  SFR16 (CAN0IP1, 0xAE);                 // Interrupt Pending 1
 349      =3  SFR16 (CAN0IP2, 0xB2);                 // Interrupt Pending 2
 350      =3  SFR16 (CAN0MV1, 0xBA);                 // Message Valid 1
 351      =3  SFR16 (CAN0MV2, 0xBC);                 // Message Valid 2
 352      =3  SFR16 (CAN0IF1CR, 0xBE);               // IF1 Command Request
 353      =3  SFR16 (CAN0IF1CM, 0xC2);               // IF1 Command Mask
 354      =3  SFR16 (CAN0IF1M1, 0xC4);               // IF1 Mask 1
 355      =3  SFR16 (CAN0IF1M2, 0xC6);               // IF1 Mask 2
 356      =3  SFR16 (CAN0IF1A1, 0xCA);               // IF1 Arbitration 1
 357      =3  SFR16 (CAN0IF1A2, 0xCC);               // IF1 Arbitration 2
 358      =3  SFR16 (CAN0IF1MC, 0xD2);               // IF1 Message Control
 359      =3  SFR16 (CAN0IF1DA1, 0xD4);              // IF1 Data A 1
 360      =3  SFR16 (CAN0IF1DA2, 0xD6);              // IF1 Data A 2
 361      =3  SFR16 (CAN0IF1DB1, 0xDA);              // IF1 Data B 1
 362      =3  SFR16 (CAN0IF1DB2, 0xDC);              // IF1 Data B 2
 363      =3  SFR16 (CAN0IF2CR, 0xDE);               // IF2 Command Request
 364      =3  SFR16 (CAN0IF2CM, 0xE2);               // IF2 Command Mask
 365      =3  SFR16 (CAN0IF2M1, 0xEA);               // IF2 Mask 1
 366      =3  SFR16 (CAN0IF2M2, 0xEC);               // IF2 Mask 2
 367      =3  SFR16 (CAN0IF2A1, 0xEE);               // IF2 Arbitration 1
 368      =3  SFR16 (CAN0IF2A2, 0xF2);               // IF2 Arbitration 2
 369      =3  SFR16 (CAN0IF2MC, 0xCE);               // IF2 Message Control
 370      =3  SFR16 (CAN0IF2DA1, 0xF6);              // IF2 Data A 1
 371      =3  SFR16 (CAN0IF2DA2, 0xFA);              // IF2 Data A 2
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 41  

 372      =3  SFR16 (CAN0IF2DB1, 0xFC);              // IF2 Data B 1
 373      =3  SFR16 (CAN0IF2DB2, 0xFE);              // IF2 Data B 2
 374      =3  
 375      =3  //-----------------------------------------------------------------------------
 376      =3  // LIN0 Indirect Registers
 377      =3  //-----------------------------------------------------------------------------
 378      =3  
 379      =3  #define  LIN0DT1   0x00                // LIN0 Data Byte 1
 380      =3  #define  LIN0DT2   0x01                // LIN0 Data Byte 2
 381      =3  #define  LIN0DT3   0x02                // LIN0 Data Byte 3
 382      =3  #define  LIN0DT4   0x03                // LIN0 Data Byte 4
 383      =3  #define  LIN0DT5   0x04                // LIN0 Data Byte 5
 384      =3  #define  LIN0DT6   0x05                // LIN0 Data Byte 6
 385      =3  #define  LIN0DT7   0x06                // LIN0 Data Byte 7
 386      =3  #define  LIN0DT8   0x07                // LIN0 Data Byte 8
 387      =3  #define  LIN0CTRL  0x08                // LIN0 Control
 388      =3  #define  LIN0ST    0x09                // LIN0 Status
 389      =3  #define  LIN0ERR   0x0A                // LIN0 Error
 390      =3  #define  LIN0SIZE  0x0B                // LIN0 Message Size
 391      =3  #define  LIN0DIV   0x0C                // LIN0 Divider
 392      =3  #define  LIN0MUL   0x0D                // LIN0 Multiplier
 393      =3  #define  LIN0ID    0x0E                // LIN0 Identifier
 394      =3  
 395      =3  //-----------------------------------------------------------------------------
 396      =3  // Address Definitions for Bit-addressable Registers
 397      =3  //-----------------------------------------------------------------------------
 398      =3  
 399      =3  #define SFR_P0       0x80
 400      =3  #define SFR_TCON     0x88
 401      =3  #define SFR_P1       0x90
 402      =3  #define SFR_SCON0    0x98
 403      =3  #define SFR_SCON1    0x98
 404      =3  #define SFR_P2       0xA0
 405      =3  #define SFR_IE       0xA8
 406      =3  #define SFR_P3       0xB0
 407      =3  #define SFR_IP       0xB8
 408      =3  #define SFR_SMB0CN   0xC0
 409      =3  #define SFR_TMR2CN   0xC8
 410      =3  #define SFR_TMR4CN   0xC8
 411      =3  #define SFR_PSW      0xD0
 412      =3  #define SFR_PCA0CN   0xD8
 413      =3  #define SFR_PCA1CN   0xD8
 414      =3  #define SFR_ACC      0xE0
 415      =3  #define SFR_ADC0CN   0xE8
 416      =3  #define SFR_B        0xF0
 417      =3  #define SFR_SPI0CN   0xF8
 418      =3  
 419      =3  //-----------------------------------------------------------------------------
 420      =3  // Bit Definitions
 421      =3  //-----------------------------------------------------------------------------
 422      =3  
 423      =3  // TCON 0x88
 424      =3  SBIT (TF1, SFR_TCON, 7);               // Timer 1 Overflow Flag
 425      =3  SBIT (TR1, SFR_TCON, 6);               // Timer 1 On/Off Control
 426      =3  SBIT (TF0, SFR_TCON, 5);               // Timer 0 Overflow Flag
 427      =3  SBIT (TR0, SFR_TCON, 4);               // Timer 0 On/Off Control
 428      =3  SBIT (IE1, SFR_TCON, 3);               // Ext. Interrupt 1 Edge Flag
 429      =3  SBIT (IT1, SFR_TCON, 2);               // Ext. Interrupt 1 Type
 430      =3  SBIT (IE0, SFR_TCON, 1);               // Ext. Interrupt 0 Edge Flag
 431      =3  SBIT (IT0, SFR_TCON, 0);               // Ext. Interrupt 0 Type
 432      =3  
 433      =3  // SCON0 0x98
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 42  

 434      =3  SBIT (OVR0, SFR_SCON0, 7);             // UART0 Receive FIFO Overrun Flag
 435      =3  SBIT (PERR0, SFR_SCON0, 6);            // UART0 Parity Error Flag
 436      =3  SBIT (THRE0, SFR_SCON0, 5);            // UART0 Transmit Register Empty Flag
 437      =3  SBIT (REN0, SFR_SCON0, 4);             // UART0 RX Enable
 438      =3  SBIT (TBX0, SFR_SCON0, 3);             // UART0 Extra Transmission Bit
 439      =3  SBIT (RBX0, SFR_SCON0, 2);             // UART0 Extra Receive Bit
 440      =3  SBIT (TI0, SFR_SCON0, 1);              // UART0 TX Interrupt Flag
 441      =3  SBIT (RI0, SFR_SCON0, 0);              // UART0 RX Interrupt Flag
 442      =3  
 443      =3  // SCON1 0x98
 444      =3  SBIT (S1MODE, SFR_SCON1, 7);           // UART1 Mode 0
 445      =3                                         // Bit 6 UNUSED
 446      =3  SBIT (MCE1, SFR_SCON1, 5);             // UART1 Multiprocessor enable
 447      =3  SBIT (REN1, SFR_SCON1, 4);             // UART1 RX Enable
 448      =3  SBIT (TB81, SFR_SCON1, 3);             // UART1 TX Bit 8
 449      =3  SBIT (RB81, SFR_SCON1, 2);             // UART1 RX Bit 8
 450      =3  SBIT (TI1, SFR_SCON1, 1);              // UART1 TX Interrupt Flag
 451      =3  SBIT (RI1, SFR_SCON1, 0);              // UART1 RX Interrupt Flag
 452      =3  
 453      =3  // IE 0xA8
 454      =3  SBIT (EA, SFR_IE, 7);                  // Global Interrupt Enable
 455      =3  SBIT (ESPI0, SFR_IE, 6);               // SPI0 Interrupt Enable
 456      =3  SBIT (ET2, SFR_IE, 5);                 // Timer 2 Interrupt Enable
 457      =3  SBIT (ES0, SFR_IE, 4);                 // UART0 Interrupt Enable
 458      =3  SBIT (ET1, SFR_IE, 3);                 // Timer 1 Interrupt Enable
 459      =3  SBIT (EX1, SFR_IE, 2);                 // External Interrupt 1 Enable
 460      =3  SBIT (ET0, SFR_IE, 1);                 // Timer 0 Interrupt Enable
 461      =3  SBIT (EX0, SFR_IE, 0);                 // External Interrupt 0 Enable
 462      =3  
 463      =3  // IP 0xB8
 464      =3                                         // Bit 7 unused
 465      =3  SBIT (PSPI0, SFR_IP, 6);               // SPI0 Interrupt Priority
 466      =3  SBIT (PT2, SFR_IP, 5);                 // Timer 2 Priority
 467      =3  SBIT (PS0, SFR_IP, 4);                 // UART0 Priority
 468      =3  SBIT (PS, SFR_IP, 4);                  // UART0 Priority
 469      =3  SBIT (PT1, SFR_IP, 3);                 // Timer 1 Priority
 470      =3  SBIT (PX1, SFR_IP, 2);                 // External Interrupt 1 Priority
 471      =3  SBIT (PT0, SFR_IP, 1);                 // Timer 0 Priority
 472      =3  SBIT (PX0, SFR_IP, 0);                 // External Interrupt 0 Priority
 473      =3  
 474      =3  // SMB0CN 0xC0
 475      =3  SBIT (MASTER, SFR_SMB0CN, 7);          // SMBus0 Master/Slave Indicator
 476      =3  SBIT (TXMODE, SFR_SMB0CN, 6);          // SMBus0 Transmit Mode Indicator
 477      =3  SBIT (STA, SFR_SMB0CN, 5);             // SMBus0 Start Flag
 478      =3  SBIT (STO, SFR_SMB0CN, 4);             // SMBus0 Stop Flag
 479      =3  SBIT (ACKRQ, SFR_SMB0CN, 3);           // SMBus0 Acknowledge Request
 480      =3  SBIT (ARBLOST, SFR_SMB0CN, 2);         // SMBus0 Arbitration Lost Indicator
 481      =3  SBIT (ACK, SFR_SMB0CN, 1);             // SMBus0 Acknowledge
 482      =3  SBIT (SI, SFR_SMB0CN, 0);              // SMBus0 Interrupt Flag
 483      =3  
 484      =3  // TMR2CN 0xC8
 485      =3  SBIT (TF2H, SFR_TMR2CN, 7);            // Timer 2 High-Byte Overflow Flag
 486      =3  SBIT (TF2L, SFR_TMR2CN, 6);            // Timer 2 Low-Byte  Overflow Flag
 487      =3  SBIT (TF2LEN, SFR_TMR2CN, 5);          // Timer 2 Low-Byte Flag Enable
 488      =3  SBIT (TF2CEN, SFR_TMR2CN, 4);          // Timer 2 Capture Enable
 489      =3  SBIT (T2SPLIT, SFR_TMR2CN, 3);         // Timer 2 Split-Mode Enable
 490      =3  SBIT (TR2, SFR_TMR2CN, 2);             // Timer 2 Run Enable
 491      =3  SBIT (T2RCLK, SFR_TMR2CN, 1);          // Timer 2 Xclk/Rclk Select
 492      =3  SBIT (T2XCLK, SFR_TMR2CN, 0);          // Timer 2 Clk/8 Clock Source
 493      =3  
 494      =3  // TMR4CN 0xC8
 495      =3  SBIT (TF4, SFR_TMR4CN, 7);             // Timer 4 Overflow/Underflow Flag
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 43  

 496      =3  SBIT (EXF4, SFR_TMR4CN, 6);            // Timer 4 External Flag
 497      =3                                         // Bit 5 unused
 498      =3                                         // Bit 4 unused
 499      =3  SBIT (EXE4, SFR_TMR4CN, 3);            // Timer 4 External Enable
 500      =3  SBIT (TR4, SFR_TMR4CN, 2);             // Timer 4 Run Enable
 501      =3  SBIT (CT4, SFR_TMR4CN, 1);             // Timer 4 Counter/Timer Select
 502      =3  SBIT (CPRL4, SFR_TMR4CN, 0);           // Timer 4 Capture/Reload Select
 503      =3  
 504      =3  // PSW 0xD0
 505      =3  SBIT (CY, SFR_PSW, 7);                 // Carry Flag
 506      =3  SBIT (AC, SFR_PSW, 6);                 // Auxiliary Carry Flag
 507      =3  SBIT (F0, SFR_PSW, 5);                 // User Flag 0
 508      =3  SBIT (RS1, SFR_PSW, 4);                // Register Bank Select 1
 509      =3  SBIT (RS0, SFR_PSW, 3);                // Register Bank Select 0
 510      =3  SBIT (OV, SFR_PSW, 2);                 // Overflow Flag
 511      =3  SBIT (F1, SFR_PSW, 1);                 // User Flag 1
 512      =3  SBIT (P, SFR_PSW, 0);                  // Accumulator Parity Flag
 513      =3  
 514      =3  // PCA0CN 0xD8
 515      =3  SBIT (CF, SFR_PCA0CN, 7);              // PCA0 Counter Overflow Flag
 516      =3  SBIT (CR, SFR_PCA0CN, 6);              // PCA0 Counter Run Control Bit
 517      =3  SBIT (CCF5, SFR_PCA0CN, 5);            // PCA0 Module 5 Interrupt Flag
 518      =3  SBIT (CCF4, SFR_PCA0CN, 4);            // PCA0 Module 4 Interrupt Flag
 519      =3  SBIT (CCF3, SFR_PCA0CN, 3);            // PCA0 Module 3 Interrupt Flag
 520      =3  SBIT (CCF2, SFR_PCA0CN, 2);            // PCA0 Module 2 Interrupt Flag
 521      =3  SBIT (CCF1, SFR_PCA0CN, 1);            // PCA0 Module 1 Interrupt Flag
 522      =3  SBIT (CCF0, SFR_PCA0CN, 0);            // PCA0 Module 0 Interrupt Flag
 523      =3  
 524      =3  // PCA1CN 0xD8
 525      =3  SBIT (CF1, SFR_PCA1CN, 7);             // PCA1 Counter Overflow Flag
 526      =3  SBIT (CR1, SFR_PCA1CN, 6);             // PCA1 Counter Run Control Bit
 527      =3  SBIT (CCF11, SFR_PCA1CN, 5);           // PCA1 Module 11 Interrupt Flag
 528      =3  SBIT (CCF10, SFR_PCA1CN, 4);           // PCA1 Module 10 Interrupt Flag
 529      =3  SBIT (CCF9, SFR_PCA1CN, 3);            // PCA1 Module 9 Interrupt Flag
 530      =3  SBIT (CCF8, SFR_PCA1CN, 2);            // PCA1 Module 8 Interrupt Flag
 531      =3  SBIT (CCF7, SFR_PCA1CN, 1);            // PCA1 Module 7 Interrupt Flag
 532      =3  SBIT (CCF6, SFR_PCA1CN, 0);            // PCA1 Module 6 Interrupt Flag
 533      =3  
 534      =3  // ADC0CN 0xE8
 535      =3  SBIT (AD0EN, SFR_ADC0CN, 7);           // ADC0 Enable
 536      =3  SBIT (BURSTEN, SFR_ADC0CN, 6);         // ADC0 Burst Enable
 537      =3  SBIT (AD0INT, SFR_ADC0CN, 5);          // ADC0 EOC Interrupt Flag
 538      =3  SBIT (AD0BUSY, SFR_ADC0CN, 4);         // ADC0 Busy Flag
 539      =3  SBIT (AD0WINT, SFR_ADC0CN, 3);         // ADC0 Window Compare Interrupt Flag
 540      =3  SBIT (AD0LJST, SFR_ADC0CN, 2);         // ADC0 Left Justified
 541      =3  SBIT (AD0CM1, SFR_ADC0CN, 1);          // ADC0 Start Of Conversion Mode Bit 1
 542      =3  SBIT (AD0CM0, SFR_ADC0CN, 0);          // ADC0 Start Of Conversion Mode Bit 0
 543      =3  
 544      =3  // SPI0CN 0xF8
 545      =3  SBIT (SPIF, SFR_SPI0CN, 7);            // SPI0 Interrupt Flag
 546      =3  SBIT (WCOL, SFR_SPI0CN, 6);            // SPI0 Write Collision Flag
 547      =3  SBIT (MODF, SFR_SPI0CN, 5);            // SPI0 Mode Fault Flag
 548      =3  SBIT (RXOVRN, SFR_SPI0CN, 4);          // SPI0 RX Overrun Flag
 549      =3  SBIT (NSSMD1, SFR_SPI0CN, 3);          // SPI0 Slave Select Mode 1
 550      =3  SBIT (NSSMD0, SFR_SPI0CN, 2);          // SPI0 Slave Select Mode 0
 551      =3  SBIT (TXBMT, SFR_SPI0CN, 1);           // SPI0 TX Buffer Empty Flag
 552      =3  SBIT (SPIEN, SFR_SPI0CN, 0);           // SPI0 Enable
 553      =3  
 554      =3  //-----------------------------------------------------------------------------
 555      =3  // Interrupt Priorities
 556      =3  //-----------------------------------------------------------------------------
 557      =3  
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 44  

 558      =3  #define INTERRUPT_INT0             0   // External Interrupt 0
 559      =3  #define INTERRUPT_TIMER0           1   // Timer 0 Overflow
 560      =3  #define INTERRUPT_INT1             2   // External Interrupt 1
 561      =3  #define INTERRUPT_TIMER1           3   // Timer 1 Overflow
 562      =3  #define INTERRUPT_UART0            4   // UART0
 563      =3  #define INTERRUPT_TIMER2           5   // Timer 2 Overflow
 564      =3  #define INTERRUPT_SPI0             6   // SPI0
 565      =3  #define INTERRUPT_SMBUS0           7   // SMBus0 Interface
 566      =3  #define INTERRUPT_ADC0_WINDOW      8   // ADC0 Window Comparison
 567      =3  #define INTERRUPT_ADC0_EOC         9   // ADC0 End Of Conversion
 568      =3  #define INTERRUPT_PCA0            10   // PCA0 Peripheral
 569      =3  #define INTERRUPT_COMPARATOR0     11   // Comparator 0 Comparison
 570      =3  #define INTERRUPT_COMPARATOR1     12   // Comparator 1 Comparison
 571      =3  #define INTERRUPT_TIMER3          13   // Timer 3 Overflow
 572      =3  #define INTERRUPT_LIN0            14   // LIN Bus Interrupt
 573      =3  #define INTERRUPT_VREG            15   // Voltage Regulator
 574      =3  #define INTERRUPT_CAN0            16   // CAN Bus Interrupt
 575      =3  #define INTERRUPT_PORT_MATCH      17   // Port Match
 576      =3  #define INTERRUPT_UART1           18   // UART1
 577      =3  #define INTERRUPT_PCA1            19   // PCA1 Peripheral
 578      =3  #define INTERRUPT_COMPARATOR2     20   // Comparator 2 Comparison
 579      =3  #define INTERRUPT_TIMER4          21   // Timer 4 Overflow
 580      =3  #define INTERRUPT_TIMER5          22   // Timer 5 Overflow
 581      =3  
 582      =3  
 583      =3  //-----------------------------------------------------------------------------
 584      =3  // SFR Page Definitions
 585      =3  //-----------------------------------------------------------------------------
 586      =3  
 587      =3  #define  CONFIG_PAGE       0x0F        // System and Port Configuration Page
 588      =3  #define  ACTIVE_PAGE       0x00        // Active Use Page
 589      =3  #define  ACTIVE2_PAGE      0x10        // Active Use Page 2
 590      =3  #define  CAN0_PAGE         0x0C        // CAN0 Registers
 591      =3  
 592      =3  //-----------------------------------------------------------------------------
 593      =3  // SDCC PDATA External Memory Paging Support
 594      =3  //-----------------------------------------------------------------------------
 595      =3  
 596      =3  #if defined SDCC
           =3 
           =3 SFR(_XPAGE, 0xAA); // Point to the EMI0CN register
           =3 
           =3 #endif
 601      =3  
 602      =3  //-----------------------------------------------------------------------------
 603      =3  // Header File PreProcessor Directive
 604      =3  //-----------------------------------------------------------------------------
 605      =3  
 606      =3  #endif                                 // #define C8051F580_DEFS_H
 607      =3  
 608      =3  //-----------------------------------------------------------------------------
 609      =3  // End Of File
 610      =3  //-----------------------------------------------------------------------------
 129      =2  #endif
 130      =2  /*****************************************************************************/
 131      =2  #include <stdio.h>
   1      =3  /*--------------------------------------------------------------------------
   2      =3  STDIO.H
   3      =3  
   4      =3  Prototypes for standard I/O functions.
   5      =3  Copyright (c) 1988-2002 Keil Elektronik GmbH and Keil Software, Inc.
   6      =3  All rights reserved.
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 45  

   7      =3  --------------------------------------------------------------------------*/
   8      =3  
   9      =3  #ifndef __STDIO_H__
  10      =3  #define __STDIO_H__
  11      =3  
  12      =3  #ifndef EOF
  13      =3   #define EOF -1
  14      =3  #endif
  15      =3  
  16      =3  #ifndef NULL
           =3  #define NULL ((void *) 0)
           =3 #endif
  19      =3  
  20      =3  #ifndef _SIZE_T
  21      =3   #define _SIZE_T
  22      =3   typedef unsigned int size_t;
  23      =3  #endif
  24      =3  
  25      =3  #pragma SAVE
  26      =3  #pragma REGPARMS
  27      =3  extern char _getkey (void);
  28      =3  extern char getchar (void);
  29      =3  extern char ungetchar (char);
  30      =3  extern char putchar (char);
  31      =3  extern int printf   (const char *, ...);
  32      =3  extern int sprintf  (char *, const char *, ...);
  33      =3  extern int vprintf  (const char *, char *);
  34      =3  extern int vsprintf (char *, const char *, char *);
  35      =3  extern char *gets (char *, int n);
  36      =3  extern int scanf (const char *, ...);
  37      =3  extern int sscanf (char *, const char *, ...);
  38      =3  extern int puts (const char *);
  39      =3  
  40      =3  #pragma RESTORE
  41      =3  
  42      =3  #endif
  43      =3  
 132      =2  #include <stdlib.h> 
   1      =3  /*--------------------------------------------------------------------------
   2      =3  STDLIB.H
   3      =3  
   4      =3  Standard functions.
   5      =3  Copyright (c) 1988-2008 Keil Elektronik GmbH and Keil Software, Inc.
   6      =3  Copyright (c) 2008-2016 ARM Germany GmbH
   7      =3  All rights reserved.
   8      =3  --------------------------------------------------------------------------*/
   9      =3  
  10      =3  #ifndef __STDLIB_H__
  11      =3  #define __STDLIB_H__
  12      =3  
  13      =3  #ifndef _SIZE_T
           =3  #define _SIZE_T
           =3  typedef unsigned int size_t;
           =3 #endif
  17      =3  
  18      =3  #ifndef NULL
           =3  #define NULL ((void *)0)
           =3 #endif
  21      =3  
  22      =3  #ifndef _WCHAR_T_DEFINED_
  23      =3  #define _WCHAR_T_DEFINED_
  24      =3  typedef char wchar_t;
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 46  

  25      =3  #endif
  26      =3  
  27      =3  #if defined (__CX2__)
           =3 #ifndef _DIV_T_DEFINED
           =3 typedef struct _div_t {
           =3         int quot;
           =3         int rem;
           =3 } div_t;
           =3 typedef struct _ldiv_t {
           =3         long quot;
           =3         long rem;
           =3 } ldiv_t;
           =3 #define _DIV_T_DEFINED
           =3 #endif // _DIV_T_DEFINED
           =3 #endif // __CX2__
  40      =3  
  41      =3  #ifndef RAND_MAX
  42      =3   #define RAND_MAX  32767u
  43      =3  #endif
  44      =3  
  45      =3  #if defined (__CX2__)
           =3 #pragma SAVE
           =3 #pragma FUNCTIONS(STATIC)
           =3 /* intrinsic functions are reentrant, but need static attribute */
           =3 extern int    abs  (int   val);
           =3 #pragma RESTORE
           =3 #endif // __CX2__
  52      =3  
  53      =3  #pragma SAVE
  54      =3  #pragma REGPARMS
  55      =3  
  56      =3  extern char   cabs (char  val);
  57      =3  #if !defined (__CX2__)
  58      =3  extern int    abs  (int   val);
  59      =3  #endif // __CX2__
  60      =3  extern long   labs (long  val);
  61      =3  
  62      =3  extern float  atof (const char *s1);
  63      =3  extern long   atol (const char *s1);
  64      =3  extern int    atoi (const char *s1);
  65      =3  extern int    rand (void);
  66      =3  extern void   srand (unsigned int seed);
  67      =3  
  68      =3  #ifdef _DIV_T_DEFINED
           =3 extern div_t  __div (int numer, int denom);
           =3 #define div(numer,denom)  __div((numer),(denom));
           =3 extern ldiv_t ldiv (long numer, long denom);
           =3 #endif // _DIV_T_DEFINED
  73      =3  
  74      =3  extern float         strtod  (const char *nptr, char **endptr);
  75      =3  extern long          strtol  (const char *nptr, char **endptr, unsigned char base);
  76      =3  extern unsigned long strtoul (const char *nptr, char **endptr, unsigned char base);
  77      =3  
  78      =3  #define _MALLOC_MEM_    xdata
  79      =3  
  80      =3  extern void init_mempool          (void _MALLOC_MEM_ *p, size_t size);
  81      =3  extern void _MALLOC_MEM_ *malloc  (size_t size);
  82      =3  extern void free                  (void _MALLOC_MEM_ *p);
  83      =3  extern void _MALLOC_MEM_ *realloc (void _MALLOC_MEM_ *p, size_t size);
  84      =3  extern void _MALLOC_MEM_ *calloc  (size_t nmemb, size_t size);
  85      =3  
  86      =3  #if defined (__CX2__)
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 47  

           =3 extern void abort(void);
           =3 #endif // __CX2__
  89      =3  
  90      =3  #pragma RESTORE
  91      =3  
  92      =3  #endif // __STDLIB_H__
 133      =2  #include <string.h>
   1      =3  /*--------------------------------------------------------------------------
   2      =3  STRING.H
   3      =3  
   4      =3  String functions.
   5      =3  Copyright (c) 1988-2008 Keil Elektronik GmbH and Keil Software, Inc.
   6      =3  Copyright (c) 2008-2016 ARM Germany GmbH
   7      =3  All rights reserved.
   8      =3  --------------------------------------------------------------------------*/
   9      =3  
  10      =3  #ifndef __STRING_H__
  11      =3  #define __STRING_H__
  12      =3  
  13      =3  #ifndef _SIZE_T
           =3  #define _SIZE_T
           =3  typedef unsigned int size_t;
           =3 #endif
  17      =3  
  18      =3  #ifndef NULL
           =3  #define NULL ((void *)0)
           =3 #endif
  21      =3  
  22      =3  #pragma SAVE
  23      =3  #pragma REGPARMS
  24      =3  extern char  *strcat  (char *s1, const char *s2);
  25      =3  extern char  *strncat (char *s1, const char *s2, size_t n);
  26      =3  
  27      =3  extern char   strcmp  (const char *s1, const char *s2);
  28      =3  extern char   strncmp (const char *s1, const char *s2, size_t n);
  29      =3  
  30      =3  extern char  *strcpy  (char *s1, const char *s2);
  31      =3  extern char  *strncpy (char *s1, const char *s2, size_t n);
  32      =3  
  33      =3  extern size_t strlen  (const char *);
  34      =3  
  35      =3  extern char  *strchr  (const char *s, char c);
  36      =3  extern int    strpos  (const char *s, char c);
  37      =3  extern char  *strrchr (const char *s, char c);
  38      =3  extern int    strrpos (const char *s, char c);
  39      =3  
  40      =3  extern size_t strspn  (const char *s, const char *set);
  41      =3  extern size_t strcspn (const char *s, const char *set);
  42      =3  extern char  *strpbrk (const char *s, const char *set);
  43      =3  extern char  *strrpbrk(const char *s, const char *set);
  44      =3  extern char  *strstr  (const char *s, const char *sub);
  45      =3  extern char  *strtok  (char *str, const char *set);
  46      =3  
  47      =3  extern char   memcmp  (const void *s1, const void *s2, size_t n);
  48      =3  extern void  *memcpy  (void *s1, const void *s2, size_t n);
  49      =3  extern void  *memchr  (const void *s, char val, size_t n);
  50      =3  extern void  *memccpy (void *s1, const void *s2, char val, size_t n);
  51      =3  extern void  *memmove (void *s1, const void *s2, size_t n);
  52      =3  extern void  *memset  (void *s, char val, size_t n);
  53      =3  #pragma RESTORE
  54      =3  
  55      =3  #endif
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 48  

 134      =2  #include <INTRINS.H>
   1      =3  /*--------------------------------------------------------------------------
   2      =3  INTRINS.H
   3      =3  
   4      =3  Intrinsic functions for C51.
   5      =3  Copyright (c) 1988-2010 Keil Elektronik GmbH and ARM Germany GmbH
   6      =3  All rights reserved.
   7      =3  --------------------------------------------------------------------------*/
   8      =3  
   9      =3  #ifndef __INTRINS_H__
  10      =3  #define __INTRINS_H__
  11      =3  
  12      =3  #pragma SAVE
  13      =3  
  14      =3  #if defined (__CX2__)
           =3 #pragma FUNCTIONS(STATIC)
           =3 /* intrinsic functions are reentrant, but need static attribute */
           =3 #endif
  18      =3  
  19      =3  extern void          _nop_     (void);
  20      =3  extern bit           _testbit_ (bit);
  21      =3  extern unsigned char _cror_    (unsigned char, unsigned char);
  22      =3  extern unsigned int  _iror_    (unsigned int,  unsigned char);
  23      =3  extern unsigned long _lror_    (unsigned long, unsigned char);
  24      =3  extern unsigned char _crol_    (unsigned char, unsigned char);
  25      =3  extern unsigned int  _irol_    (unsigned int,  unsigned char);
  26      =3  extern unsigned long _lrol_    (unsigned long, unsigned char);
  27      =3  extern unsigned char _chkfloat_(float);
  28      =3  #if defined (__CX2__)
           =3 extern int           abs       (int);
           =3 extern void          _illop_   (void);
           =3 #endif
  32      =3  #if !defined (__CX2__)
  33      =3  extern void          _push_    (unsigned char _sfr);
  34      =3  extern void          _pop_     (unsigned char _sfr);
  35      =3  #endif
  36      =3  
  37      =3  #pragma RESTORE
  38      =3  
  39      =3  #endif
  40      =3  
 135      =2  #include <ctype.h>
   1      =3  /*--------------------------------------------------------------------------
   2      =3  CTYPE.H
   3      =3  
   4      =3  Prototypes for character functions.
   5      =3  Copyright (c) 1988-2002 Keil Elektronik GmbH and Keil Software, Inc.
   6      =3  All rights reserved.
   7      =3  --------------------------------------------------------------------------*/
   8      =3  
   9      =3  #ifndef __CTYPE_H__
  10      =3  #define __CTYPE_H__
  11      =3  
  12      =3  #pragma SAVE
  13      =3  #pragma REGPARMS
  14      =3  extern bit isalpha (unsigned char);
  15      =3  extern bit isalnum (unsigned char);
  16      =3  extern bit iscntrl (unsigned char);
  17      =3  extern bit isdigit (unsigned char);
  18      =3  extern bit isgraph (unsigned char);
  19      =3  extern bit isprint (unsigned char);
  20      =3  extern bit ispunct (unsigned char);
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 49  

  21      =3  extern bit islower (unsigned char);
  22      =3  extern bit isupper (unsigned char);
  23      =3  extern bit isspace (unsigned char);
  24      =3  extern bit isxdigit (unsigned char);
  25      =3  extern unsigned char tolower (unsigned char);
  26      =3  extern unsigned char toupper (unsigned char);
  27      =3  extern unsigned char toint (unsigned char);
  28      =3  
  29      =3  #define _tolower(c) ( (c)-'A'+'a' )
  30      =3  #define _toupper(c) ( (c)-'a'+'A' )
  31      =3  #define toascii(c)  ( (c) & 0x7F )
  32      =3  #pragma RESTORE
  33      =3  
  34      =3  #endif
 136      =2  #include <LIMITS.H>
   1      =3  /*--------------------------------------------------------------------------
   2      =3  LIMITS.H
   3      =3  
   4      =3  ANSI standard include file.
   5      =3  Copyright (c) 1988-2008 Keil Elektronik GmbH and Keil Software, Inc.
   6      =3  Copyright (c) 2009 ARM Germany GmbH
   7      =3  All rights reserved.
   8      =3  --------------------------------------------------------------------------*/
   9      =3  
  10      =3  #ifndef __LIMITS_H__
  11      =3  #define __LIMITS_H__
  12      =3  
  13      =3  #define CHAR_BIT         8              /* Number of bits in any "char" */
  14      =3  #define CHAR_MAX         127            /* Max             "char" value */
  15      =3  #define CHAR_MIN       (-128)           /* Min             "char" value */
  16      =3  #define SCHAR_MAX        127            /* Max "signed"    "char" value */
  17      =3  #define SCHAR_MIN      (-128)           /* Min "signed"    "char" value */
  18      =3  #define UCHAR_MAX        255            /* Max "unsigned"  "char" value */
  19      =3  #define SHRT_MAX         32767          /* Max ("signed") "short" value */
  20      =3  #define SHRT_MIN       (-32767-1)       /* Min ("signed") "short" value */
  21      =3  #define USHRT_MAX        0xFFFF         /* Max "unsigned" "short" value */
  22      =3  #define INT_MAX          32767          /* Max ("signed")   "int" value */
  23      =3  #define INT_MIN        (-32767-1)       /* Min ("signed")   "int" value */
  24      =3  #define UINT_MAX         0xFFFF         /* Max "unsigned"   "int" value */
  25      =3  #define LONG_MAX         2147483647     /* Max ("signed")  "long" value */
  26      =3  #define LONG_MIN   (-2147483647L-1L)    /* Min ("signed")  "long" value */
  27      =3  #define ULONG_MAX        0xFFFFFFFF     /* Max "unsigned"  "long" value */
  28      =3  
  29      =3  #endif
 137      =2  #include <math.h>
   1      =3  /*--------------------------------------------------------------------------
   2      =3  MATH.H
   3      =3  
   4      =3  Prototypes for mathematic functions.
   5      =3  Copyright (c) 1988-2008 Keil Elektronik GmbH and Keil Software, Inc.
   6      =3  Copyright (c) 2008-2016 ARM Germany GmbH
   7      =3  All rights reserved.
   8      =3  --------------------------------------------------------------------------*/
   9      =3  
  10      =3  #ifndef __MATH_H__
  11      =3  #define __MATH_H__
  12      =3  
  13      =3  #if defined __CX2__ && (__CX2__ >= 558 || __CX2__ == 556 && __CX2_MINOR__ >= 207)
           =3 #ifndef HUGE_VAL
           =3 #define HUGE_VAL __inf__
           =3 #endif // HUGE_VAL
           =3 
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 50  

           =3 #ifndef NAN
           =3 #define NAN __nan__
           =3 #endif // NAN
           =3 
           =3 #pragma SAVE
           =3 #pragma FUNCTIONS(STATIC)
           =3 /* intrinsic functions are reentrant, but need static attribute */
           =3 extern int    abs  (int   val);
           =3 #pragma RESTORE
           =3 #endif
  28      =3  
  29      =3  #pragma SAVE
  30      =3  #pragma REGPARMS
  31      =3  #if !defined (__CX2__)
  32      =3  extern char  cabs  (char  val);
  33      =3  extern int    abs  (int   val);
  34      =3  extern long  labs  (long  val);
  35      =3  #endif
  36      =3  
  37      =3  extern float fabs  (float val);
  38      =3  extern float sqrt  (float val);
  39      =3  extern float exp   (float val);
  40      =3  extern float log   (float val);
  41      =3  extern float log10 (float val);
  42      =3  extern float sin   (float val);
  43      =3  extern float cos   (float val);
  44      =3  extern float tan   (float val);
  45      =3  extern float asin  (float val);
  46      =3  extern float acos  (float val);
  47      =3  extern float atan  (float val);
  48      =3  extern float sinh  (float val);
  49      =3  extern float cosh  (float val);
  50      =3  extern float tanh  (float val);
  51      =3  extern float atan2 (float y, float x);
  52      =3  
  53      =3  extern float ceil  (float val);
  54      =3  extern float floor (float val);
  55      =3  extern float modf  (float val, float *n);
  56      =3  extern float fmod  (float x, float y);
  57      =3  extern float pow   (float x, float y);
  58      =3  
  59      =3  #if defined (__CX2__)
           =3 extern float frexp (float val, int *exp);
           =3 extern float ldexp (float val, int exp);
           =3 #endif
  63      =3  
  64      =3  #pragma RESTORE
  65      =3  
  66      =3  #endif
 138      =2  #include "crc32.h"
   1      =3  #ifndef __CRC32_H__
   2      =3  #define __CRC32_H__
   3      =3  
   4      =3  //#ifdef __cplusplus
   5      =3  //extern "C" {
   6      =3  //#endif
   7      =3  /*****************************************************************************/
   8      =3  #include "AppConfig.h"
   1      =4  #ifndef __APPCONFIG_H__
           =4 #define __APPCONFIG_H__
           =4 /*****************************************************************************/
           =4 #define CONFIG_SYSCLK                       (22118400L)
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 51  

           =4 #ifdef C8051F020
           =4 #define SAR_CLK                                                 2000000L//ADC0时钟 <2.5MHz
           =4 #endif
           =4 #define CONFIG_DEBUG                        0//调试功能
           =4 #define CONFIG_USING_WDT                                        0//使能看门狗
           =4 #define CONFIG_USING_RESET                                      0//使能PLC复位MCU功能
           =4 #define CONFIG_LADDER_SECTORS_START                     64//指令起始地址
           =4 #define CONFIG_LADDER_SECTORS_END                       128//指令结束地址
           =4 #define CONFIG_LASERTIMER_OVERFLOW_US           1000L//定时器周期 1mS
           =4 #define CONFIG_VERSION                                          0x0001
           =4 #define CONFIG_CHECK_CODE                                       0x5A7E
           =4 
           =4 /*****************************************************************************/
           =4 #define CONFIG_UART0_BAUDRATE                           57600//串口波特率
           =4 #define CONFIG_UART0_PARITY                                     NONE
           =4 #define CONFIG_UART0_STOPBIT                            1
           =4 #define CONFIG_UART0_DATABIT                            8
           =4 
           =4 #define CONFIG_UART1_BAUDRATE                           115200//串口波特率
           =4 #define CONFIG_UART1_PARITY                                     NONE
           =4 #define CONFIG_UART1_STOPBIT                            1
           =4 #define CONFIG_UART1_DATABIT                            8
           =4 /*****************************************************************************/
           =4 #define CONFIG_I2C0_FREQ                                        (100000L)               
           =4 #define CONFIG_I2C1_FREQ                                        (100000L)
           =4 #define CONFIG_I2C2_FREQ                                        (100000L)
           =4 #define CONFIG_I2C3_FREQ                                        (100000L)
           =4 #define CONFIG_I2C4_FREQ                                        (100000L)
           =4 /*****************************************************************************/
           =4 #define CONFIG_EPROM_SIZE                                       CONFIG_AT24C64_SIZE
           =4 #define CONFIG_AT24C02_SIZE                             256
           =4 #define CONFIG_AT24C04_SIZE                             512
           =4 #define CONFIG_AT24C08_SIZE                             1024
           =4 #define CONFIG_AT24C16_SIZE                             2048
           =4 #define CONFIG_AT24C32_SIZE                             4096
           =4 #define CONFIG_AT24C64_SIZE                                     8192
           =4 #define CONFIG_AT24C128_SIZE                            16384
           =4 #define CONFIG_AT24C256_SIZE                            32768
           =4 #define CONFIG_EPROM_ADDRESS                            0x50
           =4 #define CONFIG_EPROM_FRAM                                       0//铁电存储体无写入等待
           =4 #define CONFIG_EPROM_FREQ                                       1//
           =4 /*****************************************************************************/
           =4 #define CONFIG_USE_IPID                                         1//使能IPID温度控制
           =4 /*****************************************************************************/
           =4 #define CONFIG_USE_HWVER_SHOW                           1//使能固件版本显示
           =4 #define CONFIG_USE_MPD1_SHOW                            1//使能MPD1测量显示
           =4 #define CONFIG_USE_MPD2_SHOW                            1//使能MPD2测量显示
           =4 #define CONFIG_USE_FBS1                                         1//使能FBS1检测
           =4 #define CONFIG_USE_FBS2                                         1//使能FBS2检测
           =4 #define CONFIG_USE_LASER_TEMP                           1//使能激光器温度显示
           =4 #define CONFIG_USE_RADIATOR_TEMP                        1//使能散热器温度显示
           =4 #define CONFIG_USE_ENVI_TEMP                            1//使能环境温度显示
           =4 #define CONFIG_USE_IPID_UPDATE                          1//使能IPID参数更新功能
           =4 #define CONFIG_USE_IPID_OUTSHOW                         1//使能IPID输出显示
           =4 /*****************************************************************************/
           =4 //SPLC设置
           =4 #define CONFIG_SPLC_IO_INPUT_NUM                        16//硬件输入点数
           =4 #define CONFIG_SPLC_IO_OUTPUT_NUM                       16//硬件输出点数
           =4 #define CONFIG_SOFTPLC_HWTIME                           1000L//1mS
           =4 #define CONFIG_INPUT_FILTER_TIME                        3//输入数字滤波扫描周期 1mS * N
           =4 #define CONFIG_IPID_RUN_CYCLE                           40//IPID运行周期 默认 40 * 100mS
           =4 #define CONFIG_IPID_PWM_CYCLE                           20//IPID输出周期 默认 20 * 100mS
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 52  

           =4 /*****************************************************************************/
           =4 #define CONFIG_SPLC_USING_WDT                           0//看门狗启用
           =4 /*****************************************************************************/
           =4 #define CONFIG_SPLC_USING_IO_INPUT                      1//输入IO刷新启用
           =4 /*****************************************************************************/
           =4 #define CONFIG_SPLC_USING_IO_OUTPUT                     1//输出IO刷新启用
           =4 /*****************************************************************************/
           =4 #define CONFIG_SPLC_USING_EPROM                         0//EPROM掉电存储启用
           =4 /*****************************************************************************/
           =4 #define CONFIG_SPLC_USING_ADC                           0//使能ADC模块
           =4 #define CONFIG_SPLC_ADC_FILTER_TAP                      48//ADC位移滤波次数
           =4 #define CONFIG_SPLC_ADC_CHANNLE                         9//ADC通道数
           =4 #define CONFIG_SPLC_ADC_TEMP_SENSOR_GAIN    3330L// Temp Sensor Gain in (uV / degC)
           =4 #define CONFIG_SPLC_ADC_TEMP_SENSOR_OFFSET  856L// Temp Sensor Offset in mV
           =4 #define CONFIG_SPLC_ADC_INTERNAL_VREF           2200L// ADC Voltage Reference (mV)
           =4 #define CONFIG_SPLC_ADC_AMBIENT             25L// Ambient temp in deg C
           =4 /*****************************************************************************/
           =4 #define CONFIG_SPLC_USING_DAC                           1//是能DAC模块
           =4 /*****************************************************************************/
           =4 #define CONFIG_SPLC_USING_MB_RTU_SLAVE          1//是能MODBUS RTU从站
           =4 #define CONFIG_MB_RTU_SLAVE_TIMER                       1000L//1000uS
           =4 #define CONFIG_MB_RTU_SLAVE_ADDRESS                     0x01//从设备地址
           =4 #define CONFIG_MB_RTU_SLAVE_BUFFER_SIZE         256//发送接收缓冲区
           =4 #define CONFIG_MB_RTU_SLAVE_TIMEOUT                     100//接收通讯超时 10mS
           =4 #define CONFIG_MB_RTU_SLAVE_IO_DELAY            1//RX TX切换延时
           =4 /*****************************************************************************/
           =4 
           =4 /*****************************************************************************/
           =4 #define ID_ONLY_1_CHANNEL                                       4321
           =4 #define ID_ONLY_2_CHANNEL                                       8765
           =4 #define ID_BOTH_CHANNEL                                         9431
           =4 #define ID_LASER_MODE_CW                                        7631
           =4 #define ID_LASER_MODE_SP                                        8934
           =4 #define ID_LASER_MODE_MP                                        2453
           =4 #define ID_LASER_MODE_GP                                        3876
           =4 /*****************************************************************************/
           =4 #define FBS1_IN_PORT                                            3
           =4 #define FBS2_IN_PORT                                            2
           =4 #define COOLON_OUT_PORT                                         (1 * 8 + 3)
           =4 /*****************************************************************************/
           =4 //PID FUZZY 模糊PID配置
           =4 #define CONFIG_TECOUT_CYCLE                                     4000//PID输出转PWM周期
           =4 /*****************************************************************************/
           =4 /*****************************************************************************/
           =4 #define DISABLE_MODBUS_SERIAL_INTERRUPT         ES0 = 0;
           =4 #define ENABLE_MODBUS_SERIAL_INTERRUPT          ES0 = 1;
           =4 #define DISABLE_INTERRUPT                                       EA = 0;
           =4 #define ENABLE_INTERRUPT                                        EA = 1;
           =4 /*****************************************************************************/
           =4 #include "stdint.h"
           =4 #include "stdbool.h"
           =4 #include "endian.h"
           =4 #include "si_toolchain.h"
           =4 #include "compiler_defs.h"
           =4 #ifdef C8051F020
           =4 #include "C8051F020_defs.h"
           =4 #endif
           =4 #ifdef C8051F340
           =4 #include "C8051F340_defs.h"
           =4 #endif
           =4 #ifdef C8051F580
           =4 #include "C8051F580_defs.h"
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 53  

           =4 #endif
           =4 /*****************************************************************************/
           =4 #include <stdio.h>
           =4 #include <stdlib.h> 
           =4 #include <string.h>
           =4 #include <INTRINS.H>
           =4 #include <ctype.h>
           =4 #include <LIMITS.H>
           =4 #include <math.h>
           =4 #include "crc32.h"
           =4 /*****************************************************************************/
           =4 #ifdef C8051F020
           =4 #include "InitDeviceF020.h"
           =4 #endif
           =4 #ifdef C8051F580
           =4 #include "InitDeviceF580.h"
           =4 #endif
           =4 
           =4 #include "delay.h"
           =4 #include "i2c0.h"
           =4 #include "i2c1.h"
           =4 #include "i2c2.h"
           =4 #include "i2c3.h"
           =4 #include "i2c4.h"
           =4 #include "i2c5.h"
           =4 #include "i2c6.h"
           =4 #include "eprom.h"
           =4 #include "mcp47x6.h"
           =4 #include "inPca9554.h"
           =4 #include "outPca9554.h"
           =4 /*****************************************************************************/
           =4 #include "Modbus.h"
           =4 #include "ModbusPort.h"
           =4 /*****************************************************************************/
           =4 #include "sPlc.h"
           =4 #include "sPlcLaser.h"
           =4 //#include "pidFuzzy.h"
           =4 /*****************************************************************************/
           =4 //#include "AppMath.h"
           =4 //#include "chipAdc.h"
           =4 //#include "ad5621.h"
           =4 //#include "chipBeem.h"
           =4 
           =4 /*****************************************************************************/
           =4 #endif
   9      =3  /*****************************************************************************/
  10      =3  uint32_t crc32Calculate(uint8_t *buf, uint32_t len);//CRC32 计算数组
  11      =3  uint32_t crc32CalculateAdd(uint8_t dat);//CRC32 计算连续字节
  12      =3  void crc32Clear(void);//清空旧CRC32结果
  13      =3  void crc32SetCrcOld(uint32_t old);
  14      =3  /*****************************************************************************/
  15      =3  //#ifdef __cplusplus
  16      =3  //}
  17      =3  //#endif
  18      =3  #endif
  19      =3  
  20      =3  
  21      =3  
 139      =2  /*****************************************************************************/
 140      =2  #ifdef C8051F020
           =2 #include "InitDeviceF020.h"
           =2 #endif
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 54  

 143      =2  #ifdef C8051F580
 144      =2  #include "InitDeviceF580.h"
   1      =3  #ifndef __INITDEVICEF020_H__
   2      =3  #define __INITDEVICEF020_H__
   3      =3  /*****************************************************************************/
   4      =3  #include "compiler_defs.h"
   1      =4  //-----------------------------------------------------------------------------
   2      =4  // compiler_defs.h
   3      =4  //-----------------------------------------------------------------------------
   4      =4  // Portions of this file are copyright Maarten Brock
   5      =4  // http://sdcc.sourceforge.net
   6      =4  // Portions of this file are Copyright 2014 Silicon Laboratories, Inc.
   7      =4  // http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   8      =4  //
   9      =4  // GNU LGPL boilerplate:
  10      =4  /** This library is free software; you can redistribute it and/or
  11      =4    * modify it under the terms of the GNU Lesser General Public
  12      =4    * License as published by the Free Software Foundation; either
  13      =4    * version 2.1 of the License, or (at your option) any later version.
  14      =4    *
  15      =4    * This library is distributed in the hope that it will be useful,
  16      =4    * but WITHOUT ANY WARRANTY; without even the implied warranty of
  17      =4    * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
  18      =4    * Lesser General Public License for more details.
  19      =4    *
  20      =4    * You should have received a copy of the GNU Lesser General Public
  21      =4    * License along with this library; if not, write to the Free Software
  22      =4    * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  23      =4    *
  24      =4    * In other words, you are welcome to use, share and improve this program.
  25      =4    * You are forbidden to forbid anyone else to use, share and improve
  26      =4    * what you give them. Help stamp out software-hoarding!
  27      =4  **/
  28      =4  // Program Description:
  29      =4  //
  30      =4  // **Important Note**: This header file should be included before including
  31      =4  // a device-specific header file such as C8051F300_defs.h.
  32      =4  //
  33      =4  // Macro definitions to accomodate 8051 compiler differences in specifying
  34      =4  // special function registers and other 8051-specific features such as NOP
  35      =4  // generation, and locating variables in memory-specific segments.  The
  36      =4  // compilers are identified by their unique predefined macros. See also:
  37      =4  // http://predef.sourceforge.net/precomp.html
  38      =4  //
  39      =4  // SBIT and SFR define special bit and special function registers at the given
  40      =4  // address. SFR16 and SFR32 define sfr combinations at adjacent addresses in
  41      =4  // little-endian format. SFR16E and SFR32E define sfr combinations without
  42      =4  // prerequisite byte order or adjacency. None of these multi-byte sfr
  43      =4  // combinations will guarantee the order in which they are accessed when read
  44      =4  // or written.
  45      =4  //
  46      =4  // SFR16X and SFR32X for 16 bit and 32 bit xdata registers are not defined
  47      =4  // to avoid portability issues because of compiler endianness.
  48      =4  //
  49      =4  // Example:
  50      =4  // // my_mcu.c: main 'c' file for my mcu
  51      =4  // #include <compiler_defs.h>  // this file
  52      =4  // #include <C8051xxxx_defs.h> // SFR definitions for specific MCU target
  53      =4  //
  54      =4  // SBIT  (P0_1, 0x80, 1);      // Port 0 pin 1
  55      =4  // SFR   (P0, 0x80);           // Port 0
  56      =4  // SFRX  (CPUCS, 0xE600);      // Cypress FX2 Control and Status register in
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 55  

  57      =4  //                             // xdata memory at 0xE600
  58      =4  // SFR16 (TMR2, 0xCC);         // Timer 2, lsb at 0xCC, msb at 0xCD
  59      =4  // SFR16E(TMR0, 0x8C8A);       // Timer 0, lsb at 0x8A, msb at 0x8C
  60      =4  // SFR32 (MAC0ACC, 0x93);      // SiLabs C8051F120 32 bits MAC0 Accumulator,
  61      =4  //                             // lsb at 0x93, msb at 0x96
  62      =4  // SFR32E(SUMR, 0xE5E4E3E2);   // TI MSC1210 SUMR 32 bits Summation register,
  63      =4  //                             // lsb at 0xE2, msb at 0xE5
  64      =4  //
  65      =4  // Target:         C8051xxxx
  66      =4  // Tool chain:     Generic
  67      =4  // Command Line:   None
  68      =4  // 
  69      =4  // Release 2.7 - 25 JUN 2014 (JM)
  70      =4  //    -Added SI_GENERIC_PTR struct for accessing generic pointers
  71      =4  //    -Added SI_GPTR_MTYPE_XXXX definitions for determining the memory type
  72      =4  //     pointed at by a generic poitner
  73      =4  // Release 2.6 - 14 DEC 2012 (GO)
  74      =4  //        -Added define for deprecated SDCC keyword 'at'
  75      =4  // Release 2.5 - 12 SEP 2012 (TP)
  76      =4  //    -Added defines for deprecated SDCC keywords bit and code
  77      =4  // Release 2.4 - 27 AUG 2012 (TP)
  78      =4  //    -Added defines for deprecated SDCC keywords interrupt, _asm, and _endasm
  79      =4  // Release 2.3 - 27 MAY 2010 (DM)
  80      =4  //    -Removed 'LOCATED_VARIABLE' pragma from Keil because it is not supported
  81      =4  // Release 2.2 - 06 APR 2010 (ES)
  82      =4  //    -Removed 'PATHINCLUDE' pragma from Raisonance section
  83      =4  // Release 2.1 - 16 JUL 2009 (ES)
  84      =4  //    -Added SEGMENT_POINTER macro definitions for SDCC, Keil, and Raisonance
  85      =4  //    -Added LOCATED_VARIABLE_NO_INIT macro definitions for Raisonance
  86      =4  // Release 2.0 - 19 MAY 2009 (ES)
  87      =4  //    -Added LOCATED_VARIABLE_NO_INIT macro definitions for SDCC and Keil
  88      =4  // Release 1.9 - 23 OCT 2008 (ES)
  89      =4  //    -Updated Hi-Tech INTERRUPT and INTERRUPT_USING macro definitions
  90      =4  //    -Added SFR16 macro defintion for Hi-Tech
  91      =4  // Release 1.8 - 31 JUL 2008 (ES)
  92      =4  //    -Added INTERRUPT_USING and FUNCTION_USING macro's
  93      =4  //    -Added macro's for IAR
  94      =4  //    -Corrected Union definitions for Hi-Tech and added SFR16 macro defintion
  95      =4  // Release 1.7 - 11 SEP 2007 (BW)
  96      =4  //    -Added support for Raisonance EVAL 03.03.42 and Tasking Eval 7.2r1
  97      =4  // Release 1.6 - 27 AUG 2007 (BW)
  98      =4  //    -Updated copyright notice per agreement with Maartin Brock
  99      =4  //    -Added SDCC 2.7.0 "compiler.h" bug fixes
 100      =4  //    -Added memory segment defines (SEG_XDATA, for example)
 101      =4  // Release 1.5 - 24 AUG 2007 (BW)
 102      =4  //    -Added support for NOP () macro
 103      =4  //    -Added support for Hi-Tech ver 9.01
 104      =4  // Release 1.4 - 07 AUG 2007 (PKC)
 105      =4  //    -Removed FID and fixed formatting.
 106      =4  // Release 1.3 - 30 SEP 2007 (TP)
 107      =4  //    -Added INTERRUPT_PROTO_USING to properly support ISR context switching
 108      =4  //     under SDCC.
 109      =4  // Release 1.2 - (BW)
 110      =4  //    -Added support for U8,U16,U32,S8,S16,S32,UU16,UU32 data types
 111      =4  // Release 1.1 - (BW)
 112      =4  //    -Added support for INTERRUPT, INTERRUPT_USING, INTERRUPT_PROTO,
 113      =4  //     SEGMENT_VARIABLE, VARIABLE_SEGMENT_POINTER,
 114      =4  //     SEGMENT_VARIABLE_SEGMENT_POINTER, and LOCATED_VARIABLE
 115      =4  // Release 1.0 - 29 SEP 2006 (PKC)
 116      =4  //    -Initial revision
 117      =4  
 118      =4  //-----------------------------------------------------------------------------
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 56  

 119      =4  // Header File Preprocessor Directive
 120      =4  //-----------------------------------------------------------------------------
 121      =4  
 122      =4  #ifndef COMPILER_DEFS_H
           =4 #define COMPILER_DEFS_H
           =4 
           =4 #include "stdbool.h"
           =4 #include "stdint.h"
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 // Macro definitions
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 //SDK Version
           =4 #define SDK_VERSION   2
           =4 
           =4 #ifndef NULL
           =4 #define NULL ((void*) 0)
           =4 #endif
           =4 
           =4 
           =4 // SDCC - Small Device C Compiler
           =4 // http://sdcc.sourceforge.net
           =4 
           =4 #if defined SDCC
           =4 
           =4 #if (SDCC >= 300)
           =4 
           =4 #define interrupt __interrupt
           =4 #define _asm __asm
           =4 #define _endasm __endasm
           =4 #define bit __bit
           =4 #define code __code
           =4 #define at __at
           =4 
           =4 #endif
           =4 
           =4 # define SEG_GENERIC
           =4 # define SEG_FAR   __xdata
           =4 # define SEG_DATA  __data
           =4 # define SEG_NEAR  __data
           =4 # define SEG_IDATA __idata
           =4 # define SEG_XDATA __xdata
           =4 # define SEG_PDATA __pdata
           =4 # define SEG_CODE  __code
           =4 # define SEG_BDATA __bdata
           =4 
           =4 # define SBIT(name, addr, bit)  __sbit  __at(addr+bit)                  name
           =4 # define SFR(name, addr)        __sfr   __at(addr)                      name
           =4 # define SFRX(name, addr)       xdata volatile unsigned char __at(addr) name
           =4 # define SFR16(name, addr)      __sfr16 __at(((addr+1U)<<8) | addr)     name
           =4 # define SFR16E(name, fulladdr) __sfr16 __at(fulladdr)                  name
           =4 # define SFR32(name, addr)      __sfr32 __at(((addr+3UL)<<24) | ((addr+2UL)<<16) | ((addr+1UL)<<8) | addr)
             - name
           =4 # define SFR32E(name, fulladdr) __sfr32 __at(fulladdr)                  name
           =4 
           =4 # define INTERRUPT(name, vector) void name (void) interrupt (vector)
           =4 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt (vector) using (regnum)
           =4 # define INTERRUPT_PROTO(name, vector) void name (void) interrupt (vector)
           =4 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void) interrupt (vector) using (regnum)
           =4 
           =4 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using (regnum
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 57  

             -)
           =4 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter) using (
             -regnum)
           =4 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =4 
           =4 # define SEGMENT_VARIABLE(name, vartype, locsegment) locsegment vartype name
           =4 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) targsegment vartype * name
           =4 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) targsegment vartype * lo
             -csegment name
           =4 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
           =4 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment at (addr) vartype name = init
           =4 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) locsegment at (addr) vartype name
           =4 
           =4 // used with UU16
           =4 # define LSB 0
           =4 # define MSB 1
           =4 
           =4 // used with UU32 (b0 is least-significant byte)
           =4 # define b0 0
           =4 # define b1 1
           =4 # define b2 2
           =4 # define b3 3
           =4 
           =4 typedef unsigned char U8;
           =4 typedef unsigned int U16;
           =4 typedef unsigned long U32;
           =4 
           =4 typedef signed char S8;
           =4 typedef signed int S16;
           =4 typedef signed long S32;
           =4 
           =4 typedef union UU16
           =4 {
           =4    U16 U16;
           =4    S16 S16;
           =4    U8 U8[2];
           =4    S8 S8[2];
           =4 } UU16;
           =4 
           =4 typedef union UU32
           =4 {
           =4    U32 U32;
           =4    S32 S32;
           =4    UU16 UU16[2];
           =4    U16 U16[2];
           =4    S16 S16[2];
           =4    U8 U8[4];
           =4    S8 S8[4];
           =4 } UU32;
           =4 
           =4 // NOP () macro support
           =4 #define NOP() _asm NOP _endasm
           =4 
           =4 // generic pointer memory type specifiers
           =4 #define SI_GPTR
           =4 #define SI_GPTR_MTYPE_DATA       0x40
           =4 #define SI_GPTR_MTYPE_IDATA      0x40
           =4 #define SI_GPTR_MTYPE_BDATA      0x40
           =4 #define SI_GPTR_MTYPE_PDATA      0x60
           =4 #define SI_GPTR_MTYPE_XDATA      0x00
           =4 #define SI_GPTR_MTYPE_CODE       0x80
           =4 
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 58  

           =4 // generic pointer access struct
           =4 typedef union SI_GENERIC_PTR
           =4 {
           =4     U8 U8[3];
           =4     struct
           =4     {
           =4         UU16 ADDR;
           =4         U8 MTYPE;
           =4     } GPTR;
           =4 } SI_GENERIC_PTR;
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 // Raisonance (must be placed before Keil C51)
           =4 // http://www.raisonance.com
           =4 
           =4 #elif defined __RC51__
           =4 
           =4 //#error Raisonance C51 detected.
           =4 
           =4 # define SEG_GENERIC generic     //SEG_GENERIC only applies to pointers in Raisonance, not variables.
           =4 # define SEG_FAR   xdata
           =4 # define SEG_DATA  data
           =4 # define SEG_NEAR  data
           =4 # define SEG_IDATA idata
           =4 # define SEG_XDATA xdata
           =4 # define SEG_PDATA pdata
           =4 # define SEG_CODE  code
           =4 # define SEG_BDATA bdata
           =4 
           =4 # define SBIT(name, addr, bit)  at (addr+bit) sbit         name
           =4 # define SFR(name, addr)        sfr at addr                name
           =4 # define SFR16(name, addr)      sfr16 at addr              name
           =4 # define SFR16E(name, fulladdr) /* not supported */
           =4 # define SFR32(name, fulladdr)  /* not supported */
           =4 # define SFR32E(name, fulladdr) /* not supported */
           =4 
           =4 # define INTERRUPT(name, vector) void name (void) interrupt vector
           =4 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
           =4 # define INTERRUPT_PROTO(name, vector) void name (void)
           =4 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
           =4 
           =4 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using regnum
           =4 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =4 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =4 
           =4 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =4 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =4 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =4 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
           =4 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) at addr locsegment vartype name
           =4 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) at addr locsegment vartype name
           =4 
           =4 
           =4 // used with UU16
           =4 # define LSB 1
           =4 # define MSB 0
           =4 
           =4 // used with UU32 (b0 is least-significant byte)
           =4 # define b0 3
           =4 # define b1 2
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 59  

           =4 # define b2 1
           =4 # define b3 0
           =4 
           =4 typedef unsigned char U8;
           =4 typedef unsigned int U16;
           =4 typedef unsigned long U32;
           =4 
           =4 typedef signed char S8;
           =4 typedef signed int S16;
           =4 typedef signed long S32;
           =4 
           =4 typedef union UU16
           =4 {
           =4    U16 U16;
           =4    S16 S16;
           =4    U8 U8[2];
           =4    S8 S8[2];
           =4 } UU16;
           =4 
           =4 typedef union UU32
           =4 {
           =4    U32 U32;
           =4    S32 S32;
           =4    UU16 UU16[2];
           =4    U16 U16[2];
           =4    S16 S16[2];
           =4    U8 U8[4];
           =4    S8 S8[4];
           =4 } UU32;
           =4 
           =4 // NOP () macro support -- NOP is opcode 0x00
           =4 #define NOP() asm { 0x00 }
           =4 
           =4 // generic pointer memory type specifiers
           =4 #define SI_GPTR
           =4 #define SI_GPTR_MTYPE_DATA       0x04
           =4 #define SI_GPTR_MTYPE_IDATA      0x01
           =4 #define SI_GPTR_MTYPE_BDATA      0x04
           =4 #define SI_GPTR_MTYPE_PDATA      0x03
           =4 #define SI_GPTR_MTYPE_XDATA      0x02
           =4 #define SI_GPTR_MTYPE_CODE       0x05
           =4 
           =4 // generic pointer access struct
           =4 typedef union SI_GENERIC_PTR
           =4 {
           =4     U8 U8[3];
           =4     struct
           =4     {
           =4         U8 MTYPE;
           =4         UU16 ADDR;
           =4     } GPTR;
           =4 } SI_GENERIC_PTR;
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 
           =4 // Keil C51
           =4 // http://www.keil.com
           =4 
           =4 #elif defined __C51__
           =4 
           =4 //#error Keil C51 detected.
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 60  

           =4 
           =4 # define SEG_GENERIC
           =4 # define SEG_FAR   xdata
           =4 # define SEG_DATA  data
           =4 # define SEG_NEAR  data
           =4 # define SEG_IDATA idata
           =4 # define SEG_XDATA xdata
           =4 # define SEG_PDATA pdata
           =4 # define SEG_CODE  code
           =4 # define SEG_BDATA bdata
           =4 
           =4 # define SBIT(name, addr, bit)  sbit  name = addr^bit
           =4 # define SFR(name, addr)        sfr   name = addr
           =4 # define SFR16(name, addr)      sfr16 name = addr
           =4 # define SFR16E(name, fulladdr) /* not supported */
           =4 # define SFR32(name, fulladdr)  /* not supported */
           =4 # define SFR32E(name, fulladdr) /* not supported */
           =4 
           =4 # ifndef __SLS_IDE__
           =4 
           =4 # define INTERRUPT(name, vector) void name (void) interrupt vector
           =4 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
           =4 # define INTERRUPT_PROTO(name, vector) void name (void)
           =4 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
           =4 
           =4 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using regnum
           =4 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =4 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =4 
           =4 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =4 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =4 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =4 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
           =4 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) vartype locsegment name _at_ addr
           =4 
           =4 # else  // __SLS_IDE__
           =4 
           =4 # define INTERRUPT(name, vector) void name (void)
           =4 # define INTERRUPT_USING(name, vector, regnum) void name (void)
           =4 # define INTERRUPT_PROTO(name, vector) void name (void)
           =4 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
           =4 
           =4 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =4 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =4 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =4 
           =4 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype name
           =4 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype * name
           =4 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype * name
           =4 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * name
           =4 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) vartype name
           =4 
           =4 # endif // __SLS_IDE__
           =4 
           =4 // used with UU16
           =4 # define LSB 1
           =4 # define MSB 0
           =4 
           =4 // used with UU32 (b0 is least-significant byte)
           =4 # define b0 3
           =4 # define b1 2
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 61  

           =4 # define b2 1
           =4 # define b3 0
           =4 
           =4 typedef unsigned char U8;
           =4 typedef unsigned int U16;
           =4 typedef unsigned long U32;
           =4 
           =4 typedef signed char S8;
           =4 typedef signed int S16;
           =4 typedef signed long S32;
           =4 
           =4 typedef union UU16
           =4 {
           =4    U16 U16;
           =4    S16 S16;
           =4    U8 U8[2];
           =4    S8 S8[2];
           =4 } UU16;
           =4 
           =4 typedef union UU32
           =4 {
           =4    U32 U32;
           =4    S32 S32;
           =4    UU16 UU16[2];
           =4    U16 U16[2];
           =4    S16 S16[2];
           =4    U8 U8[4];
           =4    S8 S8[4];
           =4 } UU32;
           =4 
           =4 // NOP () macro support
           =4 extern void _nop_ (void);
           =4 #define NOP() _nop_()
           =4 
           =4 // generic pointer memory type specifiers
           =4 #define SI_GPTR
           =4 #define SI_GPTR_MTYPE_DATA      0x00
           =4 #define SI_GPTR_MTYPE_IDATA     0x00
           =4 #define SI_GPTR_MTYPE_BDATA     0x00
           =4 #define SI_GPTR_MTYPE_PDATA     0xFE
           =4 #define SI_GPTR_MTYPE_XDATA     0x01
           =4 #define SI_GPTR_MTYPE_CODE      0xFF
           =4 
           =4 // generic pointer access struct
           =4 typedef union SI_GENERIC_PTR
           =4 {
           =4     U8 U8[3];
           =4     struct
           =4     {
           =4         U8 MTYPE;
           =4         UU16 ADDR;
           =4     } GPTR;
           =4 } SI_GENERIC_PTR;
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 // Hi-Tech 8051
           =4 // http://www.htsoft.com
           =4 
           =4 #elif defined HI_TECH_C
           =4 
           =4 # define SEG_GENERIC
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 62  

           =4 # define SEG_FAR   far
           =4 # define SEG_DATA  data
           =4 # define SEG_NEAR  near
           =4 # define SEG_IDATA idata
           =4 # define SEG_XDATA xdata
           =4 # define SEG_PDATA pdata
           =4 # define SEG_CODE  code
           =4 # define SEG_BDATA bdata
           =4 
           =4 
           =4 # define SBIT(name, addr, thebit) static volatile bit name @ (addr + thebit)
           =4 # define SFR(name, addr)          static volatile unsigned char name @ addr
           =4 # define SFR16(name, addr)        static volatile unsigned int name @ addr
           =4 # define SFR16E(name, fulladdr) /* not supported */
           =4 # define SFR32(name, fulladdr)  /* not supported */
           =4 # define SFR32E(name, fulladdr) /* not supported */
           =4 
           =4 # define INTERRUPT(name, vector)       void name (void) interrupt vector
           =4 # define INTERRUPT_PROTO(name, vector)
           =4 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
           =4 # define INTERRUPT_PROTO_USING(name, vector, regnum)
           =4 
           =4 # define FUNCTION_USING(name, return_value, parameter, regnum) /* not supported */
           =4 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) /* not supported */
           =4 // Note: Hi-Tech does not support functions using different register banks. Register
           =4 //       banks can only be specified in interrupts. If a function is called from
           =4 //       inside an interrupt, it will use the same register bank as the interrupt.
           =4 
           =4 # define SEGMENT_VARIABLE(name, vartype, locsegment) locsegment vartype name
           =4 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) targsegment vartype * name
           =4 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) targsegment vartype * lo
             -csegment name
           =4 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment vartype name @ addr
           =4 
           =4 // used with UU16
           =4 # define LSB 0
           =4 # define MSB 1
           =4 
           =4 // used with UU32 (b0 is least-significant byte)
           =4 # define b0 0
           =4 # define b1 1
           =4 # define b2 2
           =4 # define b3 3
           =4 
           =4 typedef unsigned char U8;
           =4 typedef unsigned int U16;
           =4 typedef unsigned long U32;
           =4 
           =4 typedef signed char S8;
           =4 typedef signed int S16;
           =4 typedef signed long S32;
           =4 
           =4 typedef union UU16
           =4 {
           =4    U16 U16;
           =4    S16 S16;
           =4    U8 U8[2];
           =4    S8 S8[2];
           =4 } UU16;
           =4 
           =4 typedef union UU32
           =4 {
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 63  

           =4    U32 U32;
           =4    S32 S32;
           =4    UU16 UU16[2];
           =4    U16 U16[2];
           =4    S16 S16[2];
           =4    U8 U8[4];
           =4    S8 S8[4];
           =4 } UU32;
           =4 
           =4 // NOP () macro support
           =4 #define NOP() asm(" nop ")
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 // Tasking / Altium
           =4 // http://www.altium.com/tasking
           =4 
           =4 
           =4 #elif defined _CC51
           =4 
           =4 # define SEG_GENERIC
           =4 # define SEG_FAR   _xdat
           =4 # define SEG_DATA  _data
           =4 # define SEG_NEAR  _data
           =4 # define SEG_IDATA _idat
           =4 # define SEG_XDATA _xdat
           =4 # define SEG_PDATA _pdat
           =4 # define SEG_CODE  _rom
           =4 # define SEG_BDATA _bdat
           =4 
           =4 # define SBIT(name, addr, bit)  _sfrbit  name _at(addr+bit)
           =4 # define SFR(name, addr)        _sfrbyte name _at(addr)
           =4 # define SFRX(name, addr)       _xdat volatile unsigned char name _at(addr)
           =4 #if _CC51 > 71
           =4 # define SFR16(name, addr)      _sfrword _little name _at(addr)
           =4 #else
           =4 # define SFR16(name, addr)      /* not supported */
           =4 #endif
           =4 # define SFR16E(name, fulladdr) /* not supported */
           =4 # define SFR32(name, fulladdr)  /* not supported */
           =4 # define SFR32E(name, fulladdr) /* not supported */
           =4 
           =4 # define INTERRUPT(name, vector) _interrupt (vector) void name (void)
           =4 # define INTERRUPT_USING(name, vector, regnum) _interrupt (vector) _using(regnum) void name (void)
           =4 # define INTERRUPT_PROTO(name, vector) _interrupt (vector) void name (void)
           =4 # define INTERRUPT_PROTO_USING(name, vector, regnum) _interrupt (vector) _using(regnum) void name (void)
           =4 
           =4 // When calling FUNCTION_USING in Tasking, the function must be called from an interrupt or Main which
           =4 // is also using the same register bank. If not, the compiler will generate an error.
           =4 # define FUNCTION_USING(name, return_value, parameter, regnum) _using(regnum) return_value name (parameter
             -)
           =4 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) _using(regnum) return_value name (par
             -ameter)
           =4 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =4 
           =4 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =4 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =4 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =4 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) vartype locsegment name _at( addr )
           =4 
           =4 // used with UU16
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 64  

           =4 # define LSB 1
           =4 # define MSB 0
           =4 
           =4 // used with UU32 (b0 is least-significant byte)
           =4 # define b0 3
           =4 # define b1 2
           =4 # define b2 1
           =4 # define b3 0
           =4 
           =4 typedef unsigned char U8;
           =4 typedef unsigned int U16;
           =4 typedef unsigned long U32;
           =4 
           =4 typedef signed char S8;
           =4 typedef signed int S16;
           =4 typedef signed long S32;
           =4 
           =4 typedef union UU16
           =4 {
           =4    U16 U16;
           =4    S16 S16;
           =4    U8 U8[2];
           =4    S8 S8[2];
           =4 } UU16;
           =4 
           =4 typedef union UU32
           =4 {
           =4    U32 U32;
           =4    S32 S32;
           =4    UU16 UU16[2];
           =4    U16 U16[2];
           =4    S16 S16[2];
           =4    U8 U8[4];
           =4    S8 S8[4];
           =4 } UU32;
           =4 
           =4 // NOP () macro support
           =4 extern void _nop (void);
           =4 #define NOP() _nop()
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 
           =4 // IAR 8051
           =4 // http://www.iar.com
           =4 
           =4 #elif defined __ICC8051__
           =4 
           =4 #include <stdbool.h>
           =4 #include <intrinsics.h>
           =4 
           =4 # define SBIT(name, addr, bit)  __bit __no_init volatile bool name @ (addr+bit)
           =4 # define SFR(name, addr)        __sfr __no_init volatile unsigned char name @ addr
           =4 # define SFRX(name, addr)       __xdata __no_init volatile unsigned char name @ addr
           =4 # define SFR16(name, addr)      __sfr __no_init volatile unsigned int  name @ addr
           =4 # define SFR16E(name, fulladdr) /* not supported */
           =4 # define SFR32(name, fulladdr) /* not supported */
           =4 # define SFR32E(name, fulladdr) /* not supported */
           =4 
           =4 # define SEG_GENERIC __generic
           =4 # define SEG_FAR  __xdata
           =4 # define SEG_DATA __data
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 65  

           =4 # define SEG_NEAR __data
           =4 # define SEG_IDATA __idata
           =4 # define SEG_XDATA __xdata
           =4 # define SEG_PDATA __pdata
           =4 # define SEG_CODE  __code
           =4 # define SEG_BDATA __bdata
           =4 
           =4 #define bit bool
           =4 
           =4 # define _PPTOSTR_(x) #x
           =4 # define _PPARAM_(address) _PPTOSTR_(vector=address * 8 + 3)
           =4 # define _PPARAM2_(regbank) _PPTOSTR_(register_bank=regbank)
           =4 # define INTERRUPT(name, vector) _Pragma(_PPARAM_(vector)) __interrupt void name(void)
           =4 # define INTERRUPT_PROTO(name, vector)  __interrupt void name(void)
           =4 # define INTERRUPT_USING(name, vector, regnum) _Pragma(_PPARAM2_(regnum)) _Pragma(_PPARAM_(vector)) __inte
             -rrupt void name(void)
           =4 # define INTERRUPT_PROTO_USING(name, vector, regnum) __interrupt void name(void)
           =4 
           =4 # define FUNCTION_USING(name, return_value, parameter, regnum) /* not supported */
           =4 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) /* not supported */
           =4 // Note: IAR does not support functions using different register banks. Register
           =4 //       banks can only be specified in interrupts. If a function is called from
           =4 //       inside an interrupt, it will use the same register bank as the interrupt.
           =4 
           =4 # define SEGMENT_VARIABLE(name, vartype, locsegment)  locsegment vartype name
           =4 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment  * name
           =4 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =4 
           =4 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment __no_init vartype name @ addr
           =4 
           =4 // used with UU16
           =4 # define LSB 0
           =4 # define MSB 1
           =4 
           =4 // used with UU32 (b0 is least-significant byte)
           =4 # define b0 0
           =4 # define b1 1
           =4 # define b2 2
           =4 # define b3 3
           =4 
           =4 typedef unsigned char U8;
           =4 typedef unsigned int U16;
           =4 typedef unsigned long U32;
           =4 
           =4 typedef signed char S8;
           =4 typedef signed int S16;
           =4 typedef signed long S32;
           =4 
           =4 typedef union UU16
           =4 {
           =4    U16 U16;
           =4    S16 S16;
           =4    U8 U8[2];
           =4    S8 S8[2];
           =4 } UU16;
           =4 
           =4 typedef union UU32
           =4 {
           =4    U32 U32;
           =4    S32 S32;
           =4    UU16 UU16[2];
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 66  

           =4    U16 U16[2];
           =4    S16 S16[2];
           =4    U8 U8[4];
           =4    S8 S8[4];
           =4 } UU32;
           =4 
           =4 
           =4 #define NOP() __no_operation();
           =4 
           =4 // generic pointer memory type specifiers
           =4 #define SI_GPTR
           =4 #define SI_GPTR_MTYPE_DATA       0x01
           =4 #define SI_GPTR_MTYPE_IDATA      0x01
           =4 #define SI_GPTR_MTYPE_BDATA      0x01
           =4 #define SI_GPTR_MTYPE_PDATA      0x00
           =4 #define SI_GPTR_MTYPE_XDATA      0x00
           =4 #define SI_GPTR_MTYPE_CODE       0x80
           =4 
           =4 // generic pointer access struct
           =4 typedef union SI_GENERIC_PTR
           =4 {
           =4     U8 U8[3];
           =4     struct
           =4     {
           =4         UU16 ADDR;
           =4         U8 MTYPE;
           =4     } GPTR;
           =4 } SI_GENERIC_PTR;
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 // Crossware
           =4 // http://www.crossware.com
           =4 
           =4 #elif defined _XC51_VER
           =4 # define SBIT(name, addr, bit)  _sfrbit  name = (addr+bit)
           =4 # define SFR(name, addr)        _sfr     name = addr
           =4 # define SFR16(name, addr)      _sfrword name = addr
           =4 # define SFR16E(name, fulladdr) /* not supported */
           =4 # define SFR32(name, fulladdr)  /* not supported */
           =4 # define SFR32E(name, fulladdr) /* not supported */
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 // Wickenh盲user
           =4 // http://www.wickenhaeuser.de
           =4 
           =4 #elif defined __UC__
           =4 # define SBIT(name, addr, bit)  unsigned char bit  name @ (addr+bit)
           =4 # define SFR(name, addr)        near unsigned char name @ addr
           =4 # define SFR16(name, addr)      /* not supported */
           =4 # define SFR16E(name, fulladdr) /* not supported */
           =4 # define SFR32(name, fulladdr)  /* not supported */
           =4 # define SFR32E(name, fulladdr) /* not supported */
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 // Default
           =4 // Unknown compiler
           =4 
           =4 #else
           =4 # warning unrecognized compiler
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 67  

           =4 # define SBIT(name, addr, bit)  volatile bool           name
           =4 # define SFR(name, addr)        volatile unsigned char  name
           =4 # define SFRX(name, addr)       volatile unsigned char  name
           =4 # define SFR16(name, addr)      volatile unsigned short name
           =4 # define SFR16E(name, fulladdr) volatile unsigned short name
           =4 # define SFR32(name, fulladdr)  volatile unsigned long  name
           =4 # define SFR32E(name, fulladdr) volatile unsigned long  name
           =4 
           =4 #endif
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 // Header File PreProcessor Directive
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 #endif                                 // #define COMPILER_DEFS_H
 804      =4  
 805      =4  //-----------------------------------------------------------------------------
 806      =4  // End Of File
 807      =4  //-----------------------------------------------------------------------------
   5      =3  #include "C8051F580_defs.h"
   1      =4  //-----------------------------------------------------------------------------
   2      =4  // C8051F580_defs.h
   3      =4  //-----------------------------------------------------------------------------
   4      =4  // Copyright 2008, Silicon Laboratories, Inc.
   5      =4  // http://www.silabs.com
   6      =4  //
   7      =4  // Program Description:
   8      =4  //
   9      =4  // Register/bit definitions for the C8051F58x family.
  10      =4  // **Important Note**: The compiler_defs.h header file should be included
  11      =4  // before including this header file.
  12      =4  //
  13      =4  // Target:         C8051F580/1/2/3/4/5/6/7,8/9-F590/1
  14      =4  // Tool chain:     Generic
  15      =4  // Command Line:   None
  16      =4  //
  17      =4  // Release 0.6 - 20 AUG 2012 (TP)
  18      =4  //    -Added #define for _XPAGE to provide support for SDCC memory paging
  19      =4  //     (pdata)
  20      =4  //
  21      =4  // Release 0.5 - 10 SEP 2011 (GP)
  22      =4  //    - Fixed SFR16 definition for CAN0IF2MC
  23      =4  //
  24      =4  // Release 0.4 - 08 OCT 2010 (TP)
  25      =4  //    - Fixed bit definitions for SCON0
  26      =4  //
  27      =4  // Release 0.3 - 01 APR 2009 (GP)
  28      =4  //    - Added SN0-SN3
  29      =4  //
  30      =4  // Release 0.2 - 29 JUL 2008 (ADT)
  31      =4  //    - Added Timer 4 bit definitions
  32      =4  //
  33      =4  // Release 0.1 - 09 JUL 2008 (GP)
  34      =4  //    - Initial Revision
  35      =4  //
  36      =4  //-----------------------------------------------------------------------------
  37      =4  // Header File Preprocessor Directive
  38      =4  //-----------------------------------------------------------------------------
  39      =4  
  40      =4  #ifndef C8051F580_DEFS_H
           =4 #define C8051F580_DEFS_H
           =4 
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 68  

           =4 //-----------------------------------------------------------------------------
           =4 // Page 0, Page 1 and Page F Registers
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 SFR (P0, 0x80);                        // Port 0 Latch
           =4 SFR (SP, 0x81);                        // Stack Pointer
           =4 SFR (DPL, 0x82);                       // Data Pointer Low
           =4 SFR (DPH, 0x83);                       // Data Pointer High
           =4 SFR (SFR0CN, 0x84);                    // SFR Page Control
           =4 SFR (SFRNEXT, 0x85);                   // SFR stack next page
           =4 SFR (SFRLAST, 0x86);                   // SFR stack last page
           =4 SFR (PCON, 0x87);                      // Power Control
           =4 SFR (TCON, 0x88);                      // Timer/Counter Control
           =4 SFR (TMOD, 0x89);                      // Timer/Counter Mode
           =4 SFR (TL0, 0x8A);                       // Timer/Counter 0 Low
           =4 SFR (TL1, 0x8B);                       // Timer/Counter 1 Low
           =4 SFR (TH0, 0x8C);                       // Timer/Counter 0 High
           =4 SFR (TH1, 0x8D);                       // Timer/Counter 1 High
           =4 SFR (CKCON, 0x8E);                     // Clock Control
           =4 SFR (PSCTL, 0x8F);                     // Program Store R/W Control
           =4 SFR (CLKSEL, 0x8F);                    // System clock select
           =4 SFR (P1, 0x90);                        // Port 1 Latch
           =4 SFR (TMR3CN, 0x91);                    // Timer/Counter 3 Control
           =4 SFR (TMR5CN, 0x91);                    // Timer/Counter 5 Control
           =4 SFR (TMR3RLL, 0x92);                   // Timer/Counter 3 Reload Low
           =4 SFR (TMR5CAPL, 0x92);                  // Timer/Counter 5 Capture Low
           =4 SFR (TMR3RLH, 0x93);                   // Timer/Counter 3 Reload High
           =4 SFR (TMR5CAPH, 0x93);                  // Timer/Counter 5 Capture High
           =4 SFR (TMR3L, 0x94);                     // Timer/Counter 3 Low
           =4 SFR (TMR5L, 0x94);                     // Timer/Counter 5 Low
           =4 SFR (TMR3H, 0x95);                     // Timer/Counter 3 High
           =4 SFR (TMR5H, 0x95);                     // Timer/Counter 5 High
           =4 SFR (TMR5CF, 0x96);                    // Timer/Counter 5 Configuration
           =4 SFR (CLKMUL, 0x97);                    // Clock Multiplier
           =4 SFR (SCON0, 0x98);                     // UART0 Control
           =4 SFR (SCON1, 0x98);                     // UART1 Control
           =4 SFR (SBUF0, 0x99);                     // UART0 Data Buffer
           =4 SFR (SBUF1, 0x99);                     // UART1 Data Buffer
           =4 SFR (CPT0CN, 0x9A);                    // Comparator 0 Control
           =4 SFR (CPT2CN, 0x9A);                    // Comparator 2 Control
           =4 SFR (CPT0MD, 0x9B);                    // Comparator 0 Mode
           =4 SFR (CPT2MD, 0x9B);                    // Comparator 2 Mode
           =4 SFR (CPT0MX, 0x9C);                    // Comparator 0 Mux
           =4 SFR (CPT2MX, 0x9C);                    // Comparator 2 Mux
           =4 SFR (CPT1CN, 0x9D);                    // Comparator 1 Control
           =4 SFR (CPT1MD, 0x9E);                    // Comparator 0 Mode
           =4 SFR (OSCIFIN, 0x9E);                   // Internal Oscillator Fine Control
           =4 SFR (CPT1MX, 0x9F);                    // Comparator 1 Mux
           =4 SFR (OSCXCN, 0x9F);                    // External Oscillator Control
           =4 SFR (P2, 0xA0);                        // Port 2 Latch
           =4 SFR (SPI0CFG, 0xA1);                   // SPI0 Configuration
           =4 SFR (OSCICN, 0xA1);                    // Internal Oscillator Control
           =4 SFR (SPI0CKR, 0xA2);                   // SPI0 Clock rate control
           =4 SFR (OSCICRS, 0xA2);                   // Internal Oscillator Coarse Control
           =4 SFR (SPI0DAT, 0xA3);                   // SPI0 Data Buffer
           =4 SFR (P0MDOUT, 0xA4);                   // Port 0 Output Mode
           =4 SFR (P1MDOUT, 0xA5);                   // Port 1 Output Mode
           =4 SFR (P2MDOUT, 0xA6);                   // Port 2 Output Mode
           =4 SFR (SFRPAGE, 0xA7);                   // SFR Page Select
           =4 SFR (IE, 0xA8);                        // Interrupt Enable
           =4 SFR (SMOD0, 0xA9);                     // Serial Port 0 Control
           =4 SFR (EMI0CN, 0xAA);                    // EMIF Control
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 69  

           =4 SFR (EMI0TC, 0xAA);                    // EMIF Timing control
           =4 SFR (SBCON0, 0xAB);                    // UART0 Baud Rate Generator Control
           =4 SFR (SBRLL0, 0xAC);                    // UART0 Baud Rate Generator Low
           =4 SFR (SBRLH0, 0xAD);                    // UART0 Baud Rate Generator High
           =4 SFR (P3MAT, 0xAE);                     // Port 3 Match
           =4 SFR (P3MDOUT, 0xAE);                   // Port 3 Mode
           =4 SFR (P3MASK, 0xAF);                    // Port 3 Mask
           =4 SFR (P4MDOUT, 0xAF);                   // Port 4 Mode
           =4 SFR (P3, 0xB0);                        // Port 3 Latch
           =4 SFR (P2MAT, 0xB1);                     // Port 2 Match
           =4 SFR (P2MASK, 0xB2);                    // Port 2 Mask
           =4 SFR (EMI0CF, 0xB2);                    // EMIF Configuration
           =4 SFR (P4, 0xB5);                        // Port 4 Latch
           =4 SFR (FLSCL, 0xB6);                     // Flash Scale
           =4 SFR (FLKEY, 0xB7);                     // Flash access limit
           =4 SFR (IP, 0xB8);                        // Interrupt Priority
           =4 SFR (SMB0ADR, 0xB9);                   // SMBus0 Slave address
           =4 SFR (ADC0TK, 0xBA);                    // ADC0 Tracking Mode Select
           =4 SFR (SMB0ADM, 0xBA);                   // SMBus0 Address Mask
           =4 SFR (ADC0MX, 0xBB);                    // AMUX0 Channel select
           =4 SFR (ADC0CF, 0xBC);                    // AMUX0 Channel configuration
           =4 SFR (ADC0L, 0xBD);                     // ADC0 Data Low
           =4 SFR (ADC0H, 0xBE);                     // ADC0 Data High
           =4 SFR (SMB0CN, 0xC0);                    // SMBus0 Control
           =4 SFR (SMB0CF, 0xC1);                    // SMBus0 Configuration
           =4 SFR (SMB0DAT, 0xC2);                   // SMBus0 Data
           =4 SFR (ADC0GTL, 0xC3);                   // ADC0 Greater-Than Compare Low
           =4 SFR (ADC0GTH, 0xC4);                   // ADC0 Greater-Than Compare High
           =4 SFR (ADC0LTL, 0xC5);                   // ADC0 Less-Than Compare Word Low
           =4 SFR (ADC0LTH, 0xC6);                   // ADC0 Less-Than Compare Word High
           =4 SFR (XBR3, 0xC6);                      // Port I/O Crossbar Control 3
           =4 SFR (XBR2, 0xC7);                      // Port I/O Crossbar Control 2
           =4 SFR (TMR2CN, 0xC8);                    // Timer/Counter 2 Control
           =4 SFR (TMR4CN, 0xC8);                    // Timer/Counter 4 Control
           =4 SFR (REG0CN, 0xC9);                    // Regulator Control
           =4 SFR (LIN0CF, 0xC9);                    // LIN 0 Configuration
           =4 SFR (TMR4CF, 0xC9);                    // Timer/Counter 4 Configuration
           =4 SFR (TMR2RLL, 0xCA);                   // Timer/Counter 2 Reload Low
           =4 SFR (TMR4CAPL, 0xCA);                  // Timer/Counter 4 Capture Low
           =4 SFR (TMR2RLH, 0xCB);                   // Timer/Counter 2 Reload High
           =4 SFR (TMR4CAPH, 0xCB);                  // Timer/Counter 4 Capture High
           =4 SFR (TMR2L, 0xCC);                     // Timer/Counter 2 Low
           =4 SFR (TMR4L, 0xCC);                     // Timer/Counter 4 Low
           =4 SFR (TMR2H, 0xCD);                     // Timer/Counter 2 High
           =4 SFR (TMR4H, 0xCD);                     // Timer/Counter 4 High
           =4 SFR (PCA0CPL5, 0xCE);                  // PCA0 Capture 5 Low
           =4 SFR (PCA1CPL11, 0xCE);                 // PCA1 Capture 11 Low
           =4 SFR (PCA0CPH5, 0xCF);                  // PCA0 Capture 5 High
           =4 SFR (PCA1CPH11, 0xCF);                 // PCA1 Capture 11 High
           =4 SFR (PSW, 0xD0);                       // Program Status Word
           =4 SFR (REF0CN, 0xD1);                    // Voltage Reference Control
           =4 SFR (LIN0DAT, 0xD2);                   // LIN0 Data
           =4 SFR (LIN0ADR, 0xD3);                   // LIN0 Address
           =4 SFR (P0SKIP, 0xD4);                    // Port 0 Skip
           =4 SFR (P1SKIP, 0xD5);                    // Port 1 Skip
           =4 SFR (P2SKIP, 0xD6);                    // Port 2 Skip
           =4 SFR (P3SKIP, 0xD7);                    // Port 3 Skip
           =4 SFR (PCA0CN, 0xD8);                    // PCA0 Control
           =4 SFR (PCA1CN, 0xD8);                    // PCA1 Control
           =4 SFR (PCA0MD, 0xD9);                    // PCA0 Mode
           =4 SFR (PCA1MD, 0xD9);                    // PCA1 Mode
           =4 SFR (PCA0PWM, 0xD9);                   // PCA0 PWM Control
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 70  

           =4 SFR (PCA0CPM0, 0xDA);                  // PCA0 Module 0 Mode
           =4 SFR (PCA1CPM6, 0xDA);                  // PCA1 Module 6 Mode
           =4 SFR (PCA1PWM, 0xDA);                   // PCA1 PWM Control
           =4 SFR (PCA0CPM1, 0xDB);                  // PCA0 Module 1  Mode
           =4 SFR (PCA1CPM7, 0xDB);                  // PCA1 Module 7  Mode
           =4 SFR (PCA0CPM2, 0xDC);                  // PCA0 Module 2  Mode
           =4 SFR (PCA1CPM8, 0xDC);                  // PCA1 Module 8  Mode
           =4 SFR (PCA0CPM3, 0xDD);                  // PCA0 Module 3  Mode
           =4 SFR (PCA1CPM9, 0xDD);                  // PCA1 Module 9  Mode
           =4 SFR (PCA0CPM4, 0xDE);                  // PCA0 Module 4  Mode
           =4 SFR (PCA1CPM10, 0xDE);                  // PCA1 Module 10 Mode
           =4 SFR (PCA0CPM5, 0xDF);                  // PCA0 Module 5  Mode
           =4 SFR (PCA1CPM11, 0xDF);                  // PCA1 Module 11 Mode
           =4 SFR (ACC, 0xE0);                       // Accumulator
           =4 SFR (XBR0, 0xE1);                      // Port I/O Crossbar Control 0
           =4 SFR (XBR1, 0xE2);                      // Port I/O Crossbar Control 1
           =4 SFR (CCH0CN, 0xE3);                    // Cache control
           =4 SFR (IT01CF, 0xE4);                    // INT0/INT1 Configuration
           =4 SFR (EIE1, 0xE6);                      // Extended Interrupt Enable 2
           =4 SFR (EIE2, 0xE7);                      // Extended Interrupt Enable 2
           =4 SFR (ADC0CN, 0xE8);                    // ADC0 Control
           =4 SFR (PCA0CPL1, 0xE9);                  // PCA0 Capture 1 Low
           =4 SFR (PCA1CPL1, 0xE9);                  // PCA1 Capture 7 Low
           =4 SFR (PCA0CPH1, 0xEA);                  // PCA0 Capture 1 High
           =4 SFR (PCA1CPH1, 0xEA);                  // PCA1 Capture 7 High
           =4 SFR (PCA0CPL2, 0xEB);                  // PCA0 Capture 2 Low
           =4 SFR (PCA1CPL2, 0xEB);                  // PCA1 Capture 8 Low
           =4 SFR (PCA0CPH2, 0xEC);                  // PCA0 Capture 2 High
           =4 SFR (PCA1CPH2, 0xEC);                  // PCA1 Capture 8 High
           =4 SFR (PCA0CPL3, 0xED);                  // PCA0 Capture 3 Low
           =4 SFR (PCA1CPL3, 0xED);                  // PCA1 Capture 9 Low
           =4 SFR (PCA0CPH3, 0xEE);                  // PCA0 Capture 3 High
           =4 SFR (PCA1CPH3, 0xEE);                  // PCA1 Capture 9 High
           =4 SFR (RSTSRC, 0xEF);                    // Reset Source Configuration/Status
           =4 SFR (B, 0xF0);                         // B Register
           =4 SFR (P0MAT, 0xF1);                     // Port 0 Match
           =4 SFR (P0MDIN, 0xF1);                    // Port 0 Input Mode
           =4 SFR (P0MASK, 0xF2);                    // Port 0 Mask
           =4 SFR (P1MDIN, 0xF2);                    // Port 1 Input Mode
           =4 SFR (P1MAT, 0xF3);                     // Port 1 Match
           =4 SFR (P2MDIN, 0xF3);                    // Port 2 Input Mode
           =4 SFR (P1MASK, 0xF4);                    // Port 1 Mask
           =4 SFR (P3MDIN, 0xF4);                    // Port 3 Input Mode
           =4 SFR (PSBANK, 0xF5);                    // Program Space Bank Select
           =4 SFR (EIP1, 0xF6);                      // External Interrupt Priority 1
           =4 SFR (EIP2, 0xF7);                      // External Interrupt Priority 2
           =4 SFR (SPI0CN, 0xF8);                    // SPI0 Control
           =4 SFR (PCA0L, 0xF9);                     // PCA0 Counter Low
           =4 SFR (PCA1L, 0xF9);                     // PCA1 Counter Low
           =4 SFR (SN0, 0xF9);                       // Serial Number 0
           =4 SFR (PCA0H, 0xFA);                     // PCA0 Counter High
           =4 SFR (PCA1H, 0xFA);                     // PCA1 Counter High
           =4 SFR (SN1, 0xFA);                       // Serial Number 1
           =4 SFR (PCA0CPL0, 0xFB);                  // PCA0 Capture 0 Low
           =4 SFR (PCA1CPL6, 0xFB);                  // PCA1 Capture 6 Low
           =4 SFR (SN2, 0xFB);                       // Serial Number 2
           =4 SFR (PCA0CPH0, 0xFC);                  // PCA0 Capture 0 High
           =4 SFR (PCA1CPH6, 0xFC);                  // PCA1 Capture 6 High
           =4 SFR (SN3, 0xFC);                       // Serial Number 3
           =4 SFR (PCA0CPL4, 0xFD);                  // PCA0 Capture 4 Low
           =4 SFR (PCA1CPL10, 0xFD);                 // PCA1 Capture 10 Low
           =4 SFR (PCA0CPH4, 0xFE);                  // PCA0 Capture 4 High
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 71  

           =4 SFR (PCA1CPH10, 0xFE);                 // PCA1 Capture 10 High
           =4 SFR (VDM0CN, 0xFF);                    // VDD Monitor Control
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 // Page C (CAN0) Registers
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 SFR (CAN0CFG, 0x92);                   // CAN0 Clock Configuration
           =4 SFR (CAN0STAT, 0x94);                  // Status Register Low Byte
           =4 SFR (CAN0ERRL, 0x96);                  // Error Counter Low Byte
           =4 SFR (CAN0ERRH, 0x97);                  // Error Counter High Byte
           =4 SFR (CAN0BTL, 0x9A);                   // Bit Timing Register Low Byte
           =4 SFR (CAN0BTH, 0x9B);                   // Bit Timing Register High Byte
           =4 SFR (CAN0IIDL, 0x9C);                  // Interrupt Register Low Byte
           =4 SFR (CAN0IIDH, 0x9D);                  // Interrupt Register High Byte
           =4 SFR (CAN0TST, 0x9E);                   // Test Register Low Byte
           =4 SFR (CAN0BRPE, 0xA1);                  // BRP Extension Register Low Byte
           =4 SFR (CAN0TR1L, 0xA2);                  // Transmission Request 1 Low Byte
           =4 SFR (CAN0TR1H, 0xA3);                  // Transmission Request 1 High Byte
           =4 SFR (CAN0TR2L, 0xA4);                  // Transmission Request 2 Low Byte
           =4 SFR (CAN0TR2H, 0xA5);                  // Transmission Request 2 High Byte
           =4 SFR (CAN0ND1L, 0xAA);                  // New Data 1 Low Byte
           =4 SFR (CAN0ND1H, 0xAB);                  // New Data 1 High Byte
           =4 SFR (CAN0ND2L, 0xAC);                  // New Data 2 Low Byte
           =4 SFR (CAN0ND2H, 0xAD);                  // New Data 2 High Byte
           =4 SFR (CAN0IP1L, 0xAE);                  // Interrupt Pending 1 Low Byte
           =4 SFR (CAN0IP1H, 0xAF);                  // Interrupt Pending 1 High Byte
           =4 SFR (CAN0IP2L, 0xB2);                  // Interrupt Pending 2 Low Byte
           =4 SFR (CAN0IP2H, 0xB3);                  // Interrupt Pending 2 High Byte
           =4 SFR (CAN0MV1L, 0xBA);                  // Message Valid 1 Low Byte
           =4 SFR (CAN0MV1H, 0xBB);                  // Message Valid 1 High Byte
           =4 SFR (CAN0MV2L, 0xBC);                  // Message Valid 2 Low Byte
           =4 SFR (CAN0MV2H, 0xBD);                  // Message Valid 2 High Byte
           =4 SFR (CAN0IF1CRL, 0xBE);                // IF1 Command Request Low Byte
           =4 SFR (CAN0IF1CRH, 0xBF);                // IF1 Command Request High Byte
           =4 SFR (CAN0CN, 0xC0);                    // CAN Control Register Low Byte
           =4 SFR (CAN0IF1CML, 0xC2);                // IF1 Command Mask Low Byte
           =4 SFR (CAN0IF1CMH, 0xC3);                // IF1 Command Mask High Byte
           =4 SFR (CAN0IF1M1L, 0xC4);                // IF1 Mask 1 Low Byte
           =4 SFR (CAN0IF1M1H, 0xC5);                // IF1 Mask 1 High Byte
           =4 SFR (CAN0IF1M2L, 0xC6);                // IF1 Mask 2 Low Byte
           =4 SFR (CAN0IF1M2H, 0xC7);                // IF1 Mask 2 High Byte
           =4 SFR (CAN0IF1A1L, 0xCA);                // IF1 Arbitration 1 Low Byte
           =4 SFR (CAN0IF1A1H, 0xCB);                // IF1 Arbitration 1 High Byte
           =4 SFR (CAN0IF1A2L, 0xCC);                // IF1 Arbitration 2 Low Byte
           =4 SFR (CAN0IF1A2H, 0xCD);                // IF1 Arbitration 2 High Byte
           =4 SFR (CAN0IF2MCL, 0xCE);                // IF2 Message Control Low Byte
           =4 SFR (CAN0IF2MCH, 0xCF);                // IF2 Message Control High Byte
           =4 SFR (CAN0IF1MCL, 0xD2);                // IF1 Message Control Low Byte
           =4 SFR (CAN0IF1MCH, 0xD3);                // IF1 Message Control High Byte
           =4 SFR (CAN0IF1DA1L, 0xD4);               // IF1 Data A 1 Low Byte
           =4 SFR (CAN0IF1DA1H, 0xD5);               // IF1 Data A 1 High Byte
           =4 SFR (CAN0IF1DA2L, 0xD6);               // IF1 Data A 2 Low Byte
           =4 SFR (CAN0IF1DA2H, 0xD7);               // IF1 Data A 2 High Byte
           =4 SFR (CAN0IF1DB1L, 0xDA);               // IF1 Data B 1 Low Byte
           =4 SFR (CAN0IF1DB1H, 0xDB);               // IF1 Data B 1 High Byte
           =4 SFR (CAN0IF1DB2L, 0xDC);               // IF1 Data B 2 Low Byte
           =4 SFR (CAN0IF1DB2H, 0xDD);               // IF1 Data B 2 High Byte
           =4 SFR (CAN0IF2CRL, 0xDE);                // IF2 Command Request Low Byte
           =4 SFR (CAN0IF2CRH, 0xDF);                // IF2 Command Request High Byte
           =4 SFR (CAN0IF2CML, 0xE2);                // IF2 Command Mask Low Byte
           =4 SFR (CAN0IF2CMH, 0xE3);                // IF2 Command Mask High Byte
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 72  

           =4 SFR (CAN0IF2M1L, 0xEA);                // IF2 Mask 1 Low Byte
           =4 SFR (CAN0IF2M1H, 0xEB);                // IF2 Mask 1 High Byte
           =4 SFR (CAN0IF2M2L, 0xEC);                // IF2 Mask 2 Low Byte
           =4 SFR (CAN0IF2M2H, 0xED);                // IF2 Mask 2 High Byte
           =4 SFR (CAN0IF2A1L, 0xEE);                // IF2 Arbitration 1 Low Byte
           =4 SFR (CAN0IF2A1H, 0xEF);                // IF2 Arbitration 1 High Byte
           =4 SFR (CAN0IF2A2L, 0xF2);                // IF2 Arbitration 2 Low Byte
           =4 SFR (CAN0IF2A2H, 0xF3);                // IF2 Arbitration 2 High Byte
           =4 SFR (CAN0IF2DA1L, 0xF6);               // IF2 Data A 1 Low Byte
           =4 SFR (CAN0IF2DA1H, 0xF7);               // IF2 Data A 1 High Byte
           =4 SFR (CAN0IF2DA2L, 0xFA);               // IF2 Data A 2 Low Byte
           =4 SFR (CAN0IF2DA2H, 0xFB);               // IF2 Data A 2 High Byte
           =4 SFR (CAN0IF2DB1L, 0xFC);               // IF2 Data B 1 Low Byte
           =4 SFR (CAN0IF2DB1H, 0xFD);               // IF2 Data B 1 High Byte
           =4 SFR (CAN0IF2DB2L, 0xFE);               // IF2 Data B 2 Low Byte
           =4 SFR (CAN0IF2DB2H, 0xFF);               // IF2 Data B 2 High Byte
           =4 
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 // 16-bit Register Definitions (might not be supported by all compilers)
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 SFR16 (DP, 0x82);                      // Data Pointer
           =4 SFR16 (TMR3RL, 0x92);                  // Timer 3 Reload
           =4 SFR16 (TMR5CAP, 0x92);                 // Timer 5 Capture
           =4 SFR16 (TMR3, 0x94);                    // Timer 3 Capture / Reload
           =4 SFR16 (TMR5, 0x94);                    // Timer 5
           =4 SFR16 (SBRL0, 0xAC);                   // UART0 Reload
           =4 SFR16 (ADC0, 0xBD);                    // ADC0 data
           =4 SFR16 (ADC0GT, 0xC3);                  // ADC0 Greater Than Window
           =4 SFR16 (ADC0LT, 0xC5);                  // ADC0 Less Than Window
           =4 SFR16 (TMR2RL, 0xCA);                  // Timer 2 Reload
           =4 SFR16 (TMR4CAP, 0xCA);                 // Timer 4 Capture
           =4 SFR16 (TMR2, 0xCC);                    // Timer 2 Capture / Reload
           =4 SFR16 (TMR4, 0xCC);                    // Timer 4
           =4 SFR16 (PCA0CP5, 0xCE);                 // PCA0 Module 5 Capture
           =4 SFR16 (PCA1CP11, 0xCE);                // PCA1 Module 11 Capture
           =4 SFR16 (PCA0CP1, 0xE9);                 // PCA0 Module 1 Capture
           =4 SFR16 (PCA1CP7, 0xE9);                 // PCA1 Module 7 Capture
           =4 SFR16 (PCA0CP2, 0xEB);                 // PCA0 Module 2 Capture
           =4 SFR16 (PCA1CP8, 0xEB);                 // PCA1 Module 8 Capture
           =4 SFR16 (PCA0CP3, 0xED);                 // PCA0 Module 3 Capture
           =4 SFR16 (PCA1CP9, 0xED);                 // PCA1 Module 9 Capture
           =4 SFR16 (PCA0, 0xF9);                    // PCA0 Counter
           =4 SFR16 (PCA1, 0xF9);                    // PCA1 Counter
           =4 SFR16 (PCA0CP0, 0xFB);                 // PCA0 Module 0 Capture
           =4 SFR16 (PCA1CP6, 0xFB);                 // PCA1 Module 6 Capture
           =4 SFR16 (PCA0CP4, 0xFD);                 // PCA0 Module 4 Capture
           =4 SFR16 (PCA1CP10, 0xFD);                 // PCA1 Module 10 Capture
           =4 
           =4 SFR16 (CAN0ERR, 0x96);                 // Error Counter
           =4 SFR16 (CAN0BT, 0x9A);                  // Bit Timing Register
           =4 SFR16 (CAN0IID, 0x9C);                 // Interrupt Register
           =4 SFR16 (CAN0TR1, 0xA2);                 // Transmission Request 1
           =4 SFR16 (CAN0TR2, 0xA4);                 // Transmission Request 2
           =4 SFR16 (CAN0ND1, 0xAA);                 // New Data 1
           =4 SFR16 (CAN0ND2, 0xAC);                 // New Data 2
           =4 SFR16 (CAN0IP1, 0xAE);                 // Interrupt Pending 1
           =4 SFR16 (CAN0IP2, 0xB2);                 // Interrupt Pending 2
           =4 SFR16 (CAN0MV1, 0xBA);                 // Message Valid 1
           =4 SFR16 (CAN0MV2, 0xBC);                 // Message Valid 2
           =4 SFR16 (CAN0IF1CR, 0xBE);               // IF1 Command Request
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 73  

           =4 SFR16 (CAN0IF1CM, 0xC2);               // IF1 Command Mask
           =4 SFR16 (CAN0IF1M1, 0xC4);               // IF1 Mask 1
           =4 SFR16 (CAN0IF1M2, 0xC6);               // IF1 Mask 2
           =4 SFR16 (CAN0IF1A1, 0xCA);               // IF1 Arbitration 1
           =4 SFR16 (CAN0IF1A2, 0xCC);               // IF1 Arbitration 2
           =4 SFR16 (CAN0IF1MC, 0xD2);               // IF1 Message Control
           =4 SFR16 (CAN0IF1DA1, 0xD4);              // IF1 Data A 1
           =4 SFR16 (CAN0IF1DA2, 0xD6);              // IF1 Data A 2
           =4 SFR16 (CAN0IF1DB1, 0xDA);              // IF1 Data B 1
           =4 SFR16 (CAN0IF1DB2, 0xDC);              // IF1 Data B 2
           =4 SFR16 (CAN0IF2CR, 0xDE);               // IF2 Command Request
           =4 SFR16 (CAN0IF2CM, 0xE2);               // IF2 Command Mask
           =4 SFR16 (CAN0IF2M1, 0xEA);               // IF2 Mask 1
           =4 SFR16 (CAN0IF2M2, 0xEC);               // IF2 Mask 2
           =4 SFR16 (CAN0IF2A1, 0xEE);               // IF2 Arbitration 1
           =4 SFR16 (CAN0IF2A2, 0xF2);               // IF2 Arbitration 2
           =4 SFR16 (CAN0IF2MC, 0xCE);               // IF2 Message Control
           =4 SFR16 (CAN0IF2DA1, 0xF6);              // IF2 Data A 1
           =4 SFR16 (CAN0IF2DA2, 0xFA);              // IF2 Data A 2
           =4 SFR16 (CAN0IF2DB1, 0xFC);              // IF2 Data B 1
           =4 SFR16 (CAN0IF2DB2, 0xFE);              // IF2 Data B 2
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 // LIN0 Indirect Registers
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 #define  LIN0DT1   0x00                // LIN0 Data Byte 1
           =4 #define  LIN0DT2   0x01                // LIN0 Data Byte 2
           =4 #define  LIN0DT3   0x02                // LIN0 Data Byte 3
           =4 #define  LIN0DT4   0x03                // LIN0 Data Byte 4
           =4 #define  LIN0DT5   0x04                // LIN0 Data Byte 5
           =4 #define  LIN0DT6   0x05                // LIN0 Data Byte 6
           =4 #define  LIN0DT7   0x06                // LIN0 Data Byte 7
           =4 #define  LIN0DT8   0x07                // LIN0 Data Byte 8
           =4 #define  LIN0CTRL  0x08                // LIN0 Control
           =4 #define  LIN0ST    0x09                // LIN0 Status
           =4 #define  LIN0ERR   0x0A                // LIN0 Error
           =4 #define  LIN0SIZE  0x0B                // LIN0 Message Size
           =4 #define  LIN0DIV   0x0C                // LIN0 Divider
           =4 #define  LIN0MUL   0x0D                // LIN0 Multiplier
           =4 #define  LIN0ID    0x0E                // LIN0 Identifier
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 // Address Definitions for Bit-addressable Registers
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 #define SFR_P0       0x80
           =4 #define SFR_TCON     0x88
           =4 #define SFR_P1       0x90
           =4 #define SFR_SCON0    0x98
           =4 #define SFR_SCON1    0x98
           =4 #define SFR_P2       0xA0
           =4 #define SFR_IE       0xA8
           =4 #define SFR_P3       0xB0
           =4 #define SFR_IP       0xB8
           =4 #define SFR_SMB0CN   0xC0
           =4 #define SFR_TMR2CN   0xC8
           =4 #define SFR_TMR4CN   0xC8
           =4 #define SFR_PSW      0xD0
           =4 #define SFR_PCA0CN   0xD8
           =4 #define SFR_PCA1CN   0xD8
           =4 #define SFR_ACC      0xE0
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 74  

           =4 #define SFR_ADC0CN   0xE8
           =4 #define SFR_B        0xF0
           =4 #define SFR_SPI0CN   0xF8
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 // Bit Definitions
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 // TCON 0x88
           =4 SBIT (TF1, SFR_TCON, 7);               // Timer 1 Overflow Flag
           =4 SBIT (TR1, SFR_TCON, 6);               // Timer 1 On/Off Control
           =4 SBIT (TF0, SFR_TCON, 5);               // Timer 0 Overflow Flag
           =4 SBIT (TR0, SFR_TCON, 4);               // Timer 0 On/Off Control
           =4 SBIT (IE1, SFR_TCON, 3);               // Ext. Interrupt 1 Edge Flag
           =4 SBIT (IT1, SFR_TCON, 2);               // Ext. Interrupt 1 Type
           =4 SBIT (IE0, SFR_TCON, 1);               // Ext. Interrupt 0 Edge Flag
           =4 SBIT (IT0, SFR_TCON, 0);               // Ext. Interrupt 0 Type
           =4 
           =4 // SCON0 0x98
           =4 SBIT (OVR0, SFR_SCON0, 7);             // UART0 Receive FIFO Overrun Flag
           =4 SBIT (PERR0, SFR_SCON0, 6);            // UART0 Parity Error Flag
           =4 SBIT (THRE0, SFR_SCON0, 5);            // UART0 Transmit Register Empty Flag
           =4 SBIT (REN0, SFR_SCON0, 4);             // UART0 RX Enable
           =4 SBIT (TBX0, SFR_SCON0, 3);             // UART0 Extra Transmission Bit
           =4 SBIT (RBX0, SFR_SCON0, 2);             // UART0 Extra Receive Bit
           =4 SBIT (TI0, SFR_SCON0, 1);              // UART0 TX Interrupt Flag
           =4 SBIT (RI0, SFR_SCON0, 0);              // UART0 RX Interrupt Flag
           =4 
           =4 // SCON1 0x98
           =4 SBIT (S1MODE, SFR_SCON1, 7);           // UART1 Mode 0
           =4                                        // Bit 6 UNUSED
           =4 SBIT (MCE1, SFR_SCON1, 5);             // UART1 Multiprocessor enable
           =4 SBIT (REN1, SFR_SCON1, 4);             // UART1 RX Enable
           =4 SBIT (TB81, SFR_SCON1, 3);             // UART1 TX Bit 8
           =4 SBIT (RB81, SFR_SCON1, 2);             // UART1 RX Bit 8
           =4 SBIT (TI1, SFR_SCON1, 1);              // UART1 TX Interrupt Flag
           =4 SBIT (RI1, SFR_SCON1, 0);              // UART1 RX Interrupt Flag
           =4 
           =4 // IE 0xA8
           =4 SBIT (EA, SFR_IE, 7);                  // Global Interrupt Enable
           =4 SBIT (ESPI0, SFR_IE, 6);               // SPI0 Interrupt Enable
           =4 SBIT (ET2, SFR_IE, 5);                 // Timer 2 Interrupt Enable
           =4 SBIT (ES0, SFR_IE, 4);                 // UART0 Interrupt Enable
           =4 SBIT (ET1, SFR_IE, 3);                 // Timer 1 Interrupt Enable
           =4 SBIT (EX1, SFR_IE, 2);                 // External Interrupt 1 Enable
           =4 SBIT (ET0, SFR_IE, 1);                 // Timer 0 Interrupt Enable
           =4 SBIT (EX0, SFR_IE, 0);                 // External Interrupt 0 Enable
           =4 
           =4 // IP 0xB8
           =4                                        // Bit 7 unused
           =4 SBIT (PSPI0, SFR_IP, 6);               // SPI0 Interrupt Priority
           =4 SBIT (PT2, SFR_IP, 5);                 // Timer 2 Priority
           =4 SBIT (PS0, SFR_IP, 4);                 // UART0 Priority
           =4 SBIT (PS, SFR_IP, 4);                  // UART0 Priority
           =4 SBIT (PT1, SFR_IP, 3);                 // Timer 1 Priority
           =4 SBIT (PX1, SFR_IP, 2);                 // External Interrupt 1 Priority
           =4 SBIT (PT0, SFR_IP, 1);                 // Timer 0 Priority
           =4 SBIT (PX0, SFR_IP, 0);                 // External Interrupt 0 Priority
           =4 
           =4 // SMB0CN 0xC0
           =4 SBIT (MASTER, SFR_SMB0CN, 7);          // SMBus0 Master/Slave Indicator
           =4 SBIT (TXMODE, SFR_SMB0CN, 6);          // SMBus0 Transmit Mode Indicator
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 75  

           =4 SBIT (STA, SFR_SMB0CN, 5);             // SMBus0 Start Flag
           =4 SBIT (STO, SFR_SMB0CN, 4);             // SMBus0 Stop Flag
           =4 SBIT (ACKRQ, SFR_SMB0CN, 3);           // SMBus0 Acknowledge Request
           =4 SBIT (ARBLOST, SFR_SMB0CN, 2);         // SMBus0 Arbitration Lost Indicator
           =4 SBIT (ACK, SFR_SMB0CN, 1);             // SMBus0 Acknowledge
           =4 SBIT (SI, SFR_SMB0CN, 0);              // SMBus0 Interrupt Flag
           =4 
           =4 // TMR2CN 0xC8
           =4 SBIT (TF2H, SFR_TMR2CN, 7);            // Timer 2 High-Byte Overflow Flag
           =4 SBIT (TF2L, SFR_TMR2CN, 6);            // Timer 2 Low-Byte  Overflow Flag
           =4 SBIT (TF2LEN, SFR_TMR2CN, 5);          // Timer 2 Low-Byte Flag Enable
           =4 SBIT (TF2CEN, SFR_TMR2CN, 4);          // Timer 2 Capture Enable
           =4 SBIT (T2SPLIT, SFR_TMR2CN, 3);         // Timer 2 Split-Mode Enable
           =4 SBIT (TR2, SFR_TMR2CN, 2);             // Timer 2 Run Enable
           =4 SBIT (T2RCLK, SFR_TMR2CN, 1);          // Timer 2 Xclk/Rclk Select
           =4 SBIT (T2XCLK, SFR_TMR2CN, 0);          // Timer 2 Clk/8 Clock Source
           =4 
           =4 // TMR4CN 0xC8
           =4 SBIT (TF4, SFR_TMR4CN, 7);             // Timer 4 Overflow/Underflow Flag
           =4 SBIT (EXF4, SFR_TMR4CN, 6);            // Timer 4 External Flag
           =4                                        // Bit 5 unused
           =4                                        // Bit 4 unused
           =4 SBIT (EXE4, SFR_TMR4CN, 3);            // Timer 4 External Enable
           =4 SBIT (TR4, SFR_TMR4CN, 2);             // Timer 4 Run Enable
           =4 SBIT (CT4, SFR_TMR4CN, 1);             // Timer 4 Counter/Timer Select
           =4 SBIT (CPRL4, SFR_TMR4CN, 0);           // Timer 4 Capture/Reload Select
           =4 
           =4 // PSW 0xD0
           =4 SBIT (CY, SFR_PSW, 7);                 // Carry Flag
           =4 SBIT (AC, SFR_PSW, 6);                 // Auxiliary Carry Flag
           =4 SBIT (F0, SFR_PSW, 5);                 // User Flag 0
           =4 SBIT (RS1, SFR_PSW, 4);                // Register Bank Select 1
           =4 SBIT (RS0, SFR_PSW, 3);                // Register Bank Select 0
           =4 SBIT (OV, SFR_PSW, 2);                 // Overflow Flag
           =4 SBIT (F1, SFR_PSW, 1);                 // User Flag 1
           =4 SBIT (P, SFR_PSW, 0);                  // Accumulator Parity Flag
           =4 
           =4 // PCA0CN 0xD8
           =4 SBIT (CF, SFR_PCA0CN, 7);              // PCA0 Counter Overflow Flag
           =4 SBIT (CR, SFR_PCA0CN, 6);              // PCA0 Counter Run Control Bit
           =4 SBIT (CCF5, SFR_PCA0CN, 5);            // PCA0 Module 5 Interrupt Flag
           =4 SBIT (CCF4, SFR_PCA0CN, 4);            // PCA0 Module 4 Interrupt Flag
           =4 SBIT (CCF3, SFR_PCA0CN, 3);            // PCA0 Module 3 Interrupt Flag
           =4 SBIT (CCF2, SFR_PCA0CN, 2);            // PCA0 Module 2 Interrupt Flag
           =4 SBIT (CCF1, SFR_PCA0CN, 1);            // PCA0 Module 1 Interrupt Flag
           =4 SBIT (CCF0, SFR_PCA0CN, 0);            // PCA0 Module 0 Interrupt Flag
           =4 
           =4 // PCA1CN 0xD8
           =4 SBIT (CF1, SFR_PCA1CN, 7);             // PCA1 Counter Overflow Flag
           =4 SBIT (CR1, SFR_PCA1CN, 6);             // PCA1 Counter Run Control Bit
           =4 SBIT (CCF11, SFR_PCA1CN, 5);           // PCA1 Module 11 Interrupt Flag
           =4 SBIT (CCF10, SFR_PCA1CN, 4);           // PCA1 Module 10 Interrupt Flag
           =4 SBIT (CCF9, SFR_PCA1CN, 3);            // PCA1 Module 9 Interrupt Flag
           =4 SBIT (CCF8, SFR_PCA1CN, 2);            // PCA1 Module 8 Interrupt Flag
           =4 SBIT (CCF7, SFR_PCA1CN, 1);            // PCA1 Module 7 Interrupt Flag
           =4 SBIT (CCF6, SFR_PCA1CN, 0);            // PCA1 Module 6 Interrupt Flag
           =4 
           =4 // ADC0CN 0xE8
           =4 SBIT (AD0EN, SFR_ADC0CN, 7);           // ADC0 Enable
           =4 SBIT (BURSTEN, SFR_ADC0CN, 6);         // ADC0 Burst Enable
           =4 SBIT (AD0INT, SFR_ADC0CN, 5);          // ADC0 EOC Interrupt Flag
           =4 SBIT (AD0BUSY, SFR_ADC0CN, 4);         // ADC0 Busy Flag
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 76  

           =4 SBIT (AD0WINT, SFR_ADC0CN, 3);         // ADC0 Window Compare Interrupt Flag
           =4 SBIT (AD0LJST, SFR_ADC0CN, 2);         // ADC0 Left Justified
           =4 SBIT (AD0CM1, SFR_ADC0CN, 1);          // ADC0 Start Of Conversion Mode Bit 1
           =4 SBIT (AD0CM0, SFR_ADC0CN, 0);          // ADC0 Start Of Conversion Mode Bit 0
           =4 
           =4 // SPI0CN 0xF8
           =4 SBIT (SPIF, SFR_SPI0CN, 7);            // SPI0 Interrupt Flag
           =4 SBIT (WCOL, SFR_SPI0CN, 6);            // SPI0 Write Collision Flag
           =4 SBIT (MODF, SFR_SPI0CN, 5);            // SPI0 Mode Fault Flag
           =4 SBIT (RXOVRN, SFR_SPI0CN, 4);          // SPI0 RX Overrun Flag
           =4 SBIT (NSSMD1, SFR_SPI0CN, 3);          // SPI0 Slave Select Mode 1
           =4 SBIT (NSSMD0, SFR_SPI0CN, 2);          // SPI0 Slave Select Mode 0
           =4 SBIT (TXBMT, SFR_SPI0CN, 1);           // SPI0 TX Buffer Empty Flag
           =4 SBIT (SPIEN, SFR_SPI0CN, 0);           // SPI0 Enable
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 // Interrupt Priorities
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 #define INTERRUPT_INT0             0   // External Interrupt 0
           =4 #define INTERRUPT_TIMER0           1   // Timer 0 Overflow
           =4 #define INTERRUPT_INT1             2   // External Interrupt 1
           =4 #define INTERRUPT_TIMER1           3   // Timer 1 Overflow
           =4 #define INTERRUPT_UART0            4   // UART0
           =4 #define INTERRUPT_TIMER2           5   // Timer 2 Overflow
           =4 #define INTERRUPT_SPI0             6   // SPI0
           =4 #define INTERRUPT_SMBUS0           7   // SMBus0 Interface
           =4 #define INTERRUPT_ADC0_WINDOW      8   // ADC0 Window Comparison
           =4 #define INTERRUPT_ADC0_EOC         9   // ADC0 End Of Conversion
           =4 #define INTERRUPT_PCA0            10   // PCA0 Peripheral
           =4 #define INTERRUPT_COMPARATOR0     11   // Comparator 0 Comparison
           =4 #define INTERRUPT_COMPARATOR1     12   // Comparator 1 Comparison
           =4 #define INTERRUPT_TIMER3          13   // Timer 3 Overflow
           =4 #define INTERRUPT_LIN0            14   // LIN Bus Interrupt
           =4 #define INTERRUPT_VREG            15   // Voltage Regulator
           =4 #define INTERRUPT_CAN0            16   // CAN Bus Interrupt
           =4 #define INTERRUPT_PORT_MATCH      17   // Port Match
           =4 #define INTERRUPT_UART1           18   // UART1
           =4 #define INTERRUPT_PCA1            19   // PCA1 Peripheral
           =4 #define INTERRUPT_COMPARATOR2     20   // Comparator 2 Comparison
           =4 #define INTERRUPT_TIMER4          21   // Timer 4 Overflow
           =4 #define INTERRUPT_TIMER5          22   // Timer 5 Overflow
           =4 
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 // SFR Page Definitions
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 #define  CONFIG_PAGE       0x0F        // System and Port Configuration Page
           =4 #define  ACTIVE_PAGE       0x00        // Active Use Page
           =4 #define  ACTIVE2_PAGE      0x10        // Active Use Page 2
           =4 #define  CAN0_PAGE         0x0C        // CAN0 Registers
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 // SDCC PDATA External Memory Paging Support
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 #if defined SDCC
           =4 
           =4 SFR(_XPAGE, 0xAA); // Point to the EMI0CN register
           =4 
           =4 #endif
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 77  

           =4 
           =4 //-----------------------------------------------------------------------------
           =4 // Header File PreProcessor Directive
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 #endif                                 // #define C8051F580_DEFS_H
 607      =4  
 608      =4  //-----------------------------------------------------------------------------
 609      =4  // End Of File
 610      =4  //-----------------------------------------------------------------------------
   6      =3  /*****************************************************************************/
   7      =3  void initDeviceF580(void);
   8      =3  #endif
 145      =2  #endif
 146      =2  
 147      =2  #include "delay.h"
   1      =3  #ifndef __DELAY_H__
   2      =3  #define __DELAY_H__
   3      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
           =2 #include "i2c0.h"
           =2 #include "i2c1.h"
           =2 #include "i2c2.h"
           =2 #include "i2c3.h"
           =2 #include "i2c4.h"
           =2 #include "i2c5.h"
           =2 #include "i2c6.h"
           =2 #include "eprom.h"
           =2 #include "mcp47x6.h"
           =2 #include "inPca9554.h"
           =2 #include "outPca9554.h"
           =2 /*****************************************************************************/
           =2 #include "Modbus.h"
           =2 #include "ModbusPort.h"
           =2 /*****************************************************************************/
           =2 #include "sPlc.h"
           =2 #include "sPlcLaser.h"
           =2 //#include "pidFuzzy.h"
           =2 /*****************************************************************************/
           =2 //#include "AppMath.h"
           =2 //#include "chipAdc.h"
           =2 //#include "ad5621.h"
           =2 //#include "chipBeem.h"
           =2 
           =2 /*****************************************************************************/
           =2 #endif
   4      =3  #ifndef __DELAY_H__
   4      =3  #define __DELAY_H__
   4      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   5      =3  /*****************************************************************************/
   6      =3  void delayMs(uint8_t ms) reentrant;
   7      =3  void delayUs(uint8_t us) reentrant;
   8      =3  void hwDelayInit(uint8_t reload_h, uint8_t reload_l);
   9      =3  void hwDelay(uint8_t control, uint8_t reload_h, uint8_t reload_l);
  10      =3  /*****************************************************************************/
  11      =3  #endif
  12      =3  
   1      =3  #ifndef __I2C0_H__
   2      =3  #define __I2C0_H__
   3      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 78  

   4      =3  #ifndef __I2C0_H__
   4      =3  #define __I2C0_H__
   4      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   5      =3  /*****************************************************************************/
   6      =3  
   7      =3  /*****************************************************************************/
   8      =3  void iic0Init(void);
   9      =3  void iic0Start(void);
  10      =3  void iic0Stop(void);
  11      =3  uint8_t iic0WaitAck(void);
  12      =3  void iic0Ack(void);
  13      =3  void iic0NAck(void);
  14      =3  void iic0SendByte(uint8_t txd);
  15      =3  uint8_t iic0ReadByte(uint8_t ack);
  16      =3  
  17      =3  #endif
  18      =3  
  19      =3  
   1      =3  #ifndef __I2C1_H__
   2      =3  #define __I2C1_H__
   3      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   4      =3  #ifndef __I2C1_H__
   4      =3  #define __I2C1_H__
   4      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   5      =3  /*****************************************************************************/
   6      =3  
   7      =3  /*****************************************************************************/
   8      =3  void iic1Init(void);
   9      =3  void iic1Start(void);
  10      =3  void iic1Stop(void);
  11      =3  uint8_t iic1WaitAck(void);
  12      =3  void iic1Ack(void);
  13      =3  void iic1NAck(void);
  14      =3  void iic1SendByte(uint8_t txd);
  15      =3  uint8_t iic1ReadByte(uint8_t ack);
  16      =3  
  17      =3  #endif
  18      =3  
  19      =3  
   1      =3  #ifndef __I2C2_H__
   2      =3  #define __I2C2_H__
   3      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   4      =3  #ifndef __I2C2_H__
   4      =3  #define __I2C2_H__
   4      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   5      =3  /*****************************************************************************/
   6      =3  
   7      =3  /*****************************************************************************/
   8      =3  void iic2Init(void);
   9      =3  void iic2Start(void);
  10      =3  void iic2Stop(void);
  11      =3  uint8_t iic2WaitAck(void);
  12      =3  void iic2Ack(void);
  13      =3  void iic2NAck(void);
  14      =3  void iic2SendByte(uint8_t txd);
  15      =3  uint8_t iic2ReadByte(uint8_t ack);
  16      =3  
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 79  

  17      =3  #endif
  18      =3  
  19      =3  
   1      =3  #ifndef __I2C3_H__
   2      =3  #define __I2C3_H__
   3      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   4      =3  #ifndef __I2C3_H__
   4      =3  #define __I2C3_H__
   4      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   5      =3  /*****************************************************************************/
   6      =3  
   7      =3  /*****************************************************************************/
   8      =3  void iic3Init(void);
   9      =3  void iic3Start(void);
  10      =3  void iic3Stop(void);
  11      =3  uint8_t iic3WaitAck(void);
  12      =3  void iic3Ack(void);
  13      =3  void iic3NAck(void);
  14      =3  void iic3SendByte(uint8_t txd);
  15      =3  uint8_t iic3ReadByte(uint8_t ack);
  16      =3  
  17      =3  #endif
  18      =3  
  19      =3  
   1      =3  #ifndef __I2C4_H__
   2      =3  #define __I2C4_H__
   3      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   4      =3  #ifndef __I2C4_H__
   4      =3  #define __I2C4_H__
   4      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   5      =3  /*****************************************************************************/
   6      =3  
   7      =3  /*****************************************************************************/
   8      =3  void iic4Init(void);
   9      =3  void iic4Start(void);
  10      =3  void iic4Stop(void);
  11      =3  uint8_t iic4WaitAck(void);
  12      =3  void iic4Ack(void);
  13      =3  void iic4NAck(void);
  14      =3  void iic4SendByte(uint8_t txd);
  15      =3  uint8_t iic4ReadByte(uint8_t ack);
  16      =3  
  17      =3  #endif
  18      =3  
  19      =3  
   1      =3  #ifndef __I2C5_H__
   2      =3  #define __I2C5_H__
   3      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   4      =3  #ifndef __I2C5_H__
   4      =3  #define __I2C5_H__
   4      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   5      =3  /*****************************************************************************/
   6      =3  
   7      =3  /*****************************************************************************/
   8      =3  void iic5Init(void);
   9      =3  void iic5Start(void);
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 80  

  10      =3  void iic5Stop(void);
  11      =3  uint8_t iic5WaitAck(void);
  12      =3  void iic5Ack(void);
  13      =3  void iic5NAck(void);
  14      =3  void iic5SendByte(uint8_t txd);
  15      =3  uint8_t iic5ReadByte(uint8_t ack);
  16      =3  
  17      =3  #endif
  18      =3  
  19      =3  
   1      =3  #ifndef __I2C6_H__
   2      =3  #define __I2C6_H__
   3      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   4      =3  #ifndef __I2C6_H__
   4      =3  #define __I2C6_H__
   4      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   5      =3  /*****************************************************************************/
   6      =3  
   7      =3  /*****************************************************************************/
   8      =3  void iic6Init(void);
   9      =3  void iic6Start(void);
  10      =3  void iic6Stop(void);
  11      =3  uint8_t iic6WaitAck(void);
  12      =3  void iic6Ack(void);
  13      =3  void iic6NAck(void);
  14      =3  void iic6SendByte(uint8_t txd);
  15      =3  uint8_t iic6ReadByte(uint8_t ack);
  16      =3  
  17      =3  #endif
  18      =3  
  19      =3  
   1      =3  #ifndef __EPROM_H__
   2      =3  #define __EPROM_H__
   3      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   4      =3  #ifndef __EPROM_H__
   4      =3  #define __EPROM_H__
   4      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   5      =3  /*****************************************************************************/
   6      =3  /*****************************************************************************/
   7      =3  void epromInit(void);
   8      =3  uint8_t epromReadOneByte(uint16_t ReadAddr);
   9      =3  void epromWriteOneByte(uint16_t WriteAddr, uint8_t DataToWrite);
  10      =3  void epromWriteLenByte(uint16_t WriteAddr, uint32_t DataToWrite, uint8_t Len);
  11      =3  uint32_t epromReadLenByte(uint16_t ReadAddr, uint8_t Len);
  12      =3  void epromRead(uint16_t ReadAddr,uint8_t *pBuffer,uint16_t NumToRead);
  13      =3  void epromWrite(uint16_t WriteAddr, uint8_t *pBuffer, uint16_t NumToWrite);
  14      =3  void epromTest(void);
  15      =3  #endif
   1      =3  #ifndef __MCP47X6_H__
   2      =3  #define __MCP47X6_H__
   3      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   4      =3  #ifndef __MCP47X6_H__
   4      =3  #define __MCP47X6_H__
   4      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   5      =3  /*****************************************************************************/
   6      =3  uint8_t mcp47x6Init(void);
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 81  

   7      =3  void mcp47x6Write(uint8_t channel, uint16_t dat);
   8      =3  #endif
   9      =3          
  10      =3  
  11      =3  
  12      =3  
  13      =3  
  14      =3  
  15      =3  
  16      =3  
  17      =3  
  18      =3  
  19      =3  
  20      =3  
   1      =3  #ifndef __INPCA9554_H__
   2      =3  #define __INPCA9554_H__
   3      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   4      =3  #ifndef __INPCA9554_H__
   4      =3  #define __INPCA9554_H__
   4      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   5      =3  /*****************************************************************************/
   6      =3  void inPca9554Init(void);
   7      =3  uint8_t inPca9554Read(void);
   8      =3  void inPca9554Write(uint8_t wdata);
   9      =3  
  10      =3  #endif
   1      =3  #ifndef __OUTPCA9554_H__
   2      =3  #define __OUTPCA9554_H__
   3      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   4      =3  #ifndef __OUTPCA9554_H__
   4      =3  #define __OUTPCA9554_H__
   4      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   5      =3  /*****************************************************************************/
   6      =3  void outPca9554Init(void);
   7      =3  uint8_t outPca9554Read(void);
   8      =3  void outPca9554Write(uint8_t wdata);
   9      =3  
  10      =3  #endif
   1      =3  #ifndef __MODBUS__H__
           =3 #define __MODBUS__H__
           =3 /*****************************************************************************/
           =3 #include "appConfig.h"
           =3 /*****************************************************************************/
           =3 extern volatile uint16_t modbusTimerValue;
           =3 extern volatile uint8_t modbusReceiveCounter;// Collected data number
           =3 extern xdata volatile uint8_t modbusReceiveBuffer[CONFIG_MB_RTU_SLAVE_BUFFER_SIZE];
           =3 /*****************************************************************************/
           =3 extern void initModbus(uint8_t modbusSlaveAddress, uint32_t bd);
           =3 extern void modbusPorcess(void);
           =3 #endif
   1      =3  #ifndef __MODBUSPORT__H__
   2      =3  #define __MODBUSPORT__H__
   3      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   4      =3  #ifndef __MODBUSPORT__H__
   4      =3  #define __MODBUSPORT__H__
   4      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 82  

   5      =3  /*****************************************************************************/
   6      =3  extern void modBusUartInitialise(uint32_t baudrate);
   7      =3  extern void modBusTimerInitialise(void);
   8      =3  extern void modBusUartPutch(uint8_t c);
   9      =3  extern uint8_t modBusUartString(uint8_t *s, uint16_t Length);
  10      =3  extern void receiveInterrupt(uint8_t Data);
  11      =3  /*****************************************************************************/
  12      =3  #endif
   1      =3  #ifndef __SPLC_H__
   2      =3  #define __SPLC_H__
   3      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   1      =4  #ifndef __APPCONFIG_H__
           =4 #define __APPCONFIG_H__
           =4 /*****************************************************************************/
           =4 #define CONFIG_SYSCLK                       (22118400L)
           =4 #ifdef C8051F020
           =4 #define SAR_CLK                                                 2000000L//ADC0时钟 <2.5MHz
           =4 #endif
           =4 #define CONFIG_DEBUG                        0//调试功能
           =4 #define CONFIG_USING_WDT                                        0//使能看门狗
           =4 #define CONFIG_USING_RESET                                      0//使能PLC复位MCU功能
           =4 #define CONFIG_LADDER_SECTORS_START                     64//指令起始地址
           =4 #define CONFIG_LADDER_SECTORS_END                       128//指令结束地址
           =4 #define CONFIG_LASERTIMER_OVERFLOW_US           1000L//定时器周期 1mS
           =4 #define CONFIG_VERSION                                          0x0001
           =4 #define CONFIG_CHECK_CODE                                       0x5A7E
           =4 
           =4 /*****************************************************************************/
           =4 #define CONFIG_UART0_BAUDRATE                           57600//串口波特率
           =4 #define CONFIG_UART0_PARITY                                     NONE
           =4 #define CONFIG_UART0_STOPBIT                            1
           =4 #define CONFIG_UART0_DATABIT                            8
           =4 
           =4 #define CONFIG_UART1_BAUDRATE                           115200//串口波特率
           =4 #define CONFIG_UART1_PARITY                                     NONE
           =4 #define CONFIG_UART1_STOPBIT                            1
           =4 #define CONFIG_UART1_DATABIT                            8
           =4 /*****************************************************************************/
           =4 #define CONFIG_I2C0_FREQ                                        (100000L)               
           =4 #define CONFIG_I2C1_FREQ                                        (100000L)
           =4 #define CONFIG_I2C2_FREQ                                        (100000L)
           =4 #define CONFIG_I2C3_FREQ                                        (100000L)
           =4 #define CONFIG_I2C4_FREQ                                        (100000L)
           =4 /*****************************************************************************/
           =4 #define CONFIG_EPROM_SIZE                                       CONFIG_AT24C64_SIZE
           =4 #define CONFIG_AT24C02_SIZE                             256
           =4 #define CONFIG_AT24C04_SIZE                             512
           =4 #define CONFIG_AT24C08_SIZE                             1024
           =4 #define CONFIG_AT24C16_SIZE                             2048
           =4 #define CONFIG_AT24C32_SIZE                             4096
           =4 #define CONFIG_AT24C64_SIZE                                     8192
           =4 #define CONFIG_AT24C128_SIZE                            16384
           =4 #define CONFIG_AT24C256_SIZE                            32768
           =4 #define CONFIG_EPROM_ADDRESS                            0x50
           =4 #define CONFIG_EPROM_FRAM                                       0//铁电存储体无写入等待
           =4 #define CONFIG_EPROM_FREQ                                       1//
           =4 /*****************************************************************************/
           =4 #define CONFIG_USE_IPID                                         1//使能IPID温度控制
           =4 /*****************************************************************************/
           =4 #define CONFIG_USE_HWVER_SHOW                           1//使能固件版本显示
           =4 #define CONFIG_USE_MPD1_SHOW                            1//使能MPD1测量显示
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 83  

           =4 #define CONFIG_USE_MPD2_SHOW                            1//使能MPD2测量显示
           =4 #define CONFIG_USE_FBS1                                         1//使能FBS1检测
           =4 #define CONFIG_USE_FBS2                                         1//使能FBS2检测
           =4 #define CONFIG_USE_LASER_TEMP                           1//使能激光器温度显示
           =4 #define CONFIG_USE_RADIATOR_TEMP                        1//使能散热器温度显示
           =4 #define CONFIG_USE_ENVI_TEMP                            1//使能环境温度显示
           =4 #define CONFIG_USE_IPID_UPDATE                          1//使能IPID参数更新功能
           =4 #define CONFIG_USE_IPID_OUTSHOW                         1//使能IPID输出显示
           =4 /*****************************************************************************/
           =4 //SPLC设置
           =4 #define CONFIG_SPLC_IO_INPUT_NUM                        16//硬件输入点数
           =4 #define CONFIG_SPLC_IO_OUTPUT_NUM                       16//硬件输出点数
           =4 #define CONFIG_SOFTPLC_HWTIME                           1000L//1mS
           =4 #define CONFIG_INPUT_FILTER_TIME                        3//输入数字滤波扫描周期 1mS * N
           =4 #define CONFIG_IPID_RUN_CYCLE                           40//IPID运行周期 默认 40 * 100mS
           =4 #define CONFIG_IPID_PWM_CYCLE                           20//IPID输出周期 默认 20 * 100mS
           =4 /*****************************************************************************/
           =4 #define CONFIG_SPLC_USING_WDT                           0//看门狗启用
           =4 /*****************************************************************************/
           =4 #define CONFIG_SPLC_USING_IO_INPUT                      1//输入IO刷新启用
           =4 /*****************************************************************************/
           =4 #define CONFIG_SPLC_USING_IO_OUTPUT                     1//输出IO刷新启用
           =4 /*****************************************************************************/
           =4 #define CONFIG_SPLC_USING_EPROM                         0//EPROM掉电存储启用
           =4 /*****************************************************************************/
           =4 #define CONFIG_SPLC_USING_ADC                           0//使能ADC模块
           =4 #define CONFIG_SPLC_ADC_FILTER_TAP                      48//ADC位移滤波次数
           =4 #define CONFIG_SPLC_ADC_CHANNLE                         9//ADC通道数
           =4 #define CONFIG_SPLC_ADC_TEMP_SENSOR_GAIN    3330L// Temp Sensor Gain in (uV / degC)
           =4 #define CONFIG_SPLC_ADC_TEMP_SENSOR_OFFSET  856L// Temp Sensor Offset in mV
           =4 #define CONFIG_SPLC_ADC_INTERNAL_VREF           2200L// ADC Voltage Reference (mV)
           =4 #define CONFIG_SPLC_ADC_AMBIENT             25L// Ambient temp in deg C
           =4 /*****************************************************************************/
           =4 #define CONFIG_SPLC_USING_DAC                           1//是能DAC模块
           =4 /*****************************************************************************/
           =4 #define CONFIG_SPLC_USING_MB_RTU_SLAVE          1//是能MODBUS RTU从站
           =4 #define CONFIG_MB_RTU_SLAVE_TIMER                       1000L//1000uS
           =4 #define CONFIG_MB_RTU_SLAVE_ADDRESS                     0x01//从设备地址
           =4 #define CONFIG_MB_RTU_SLAVE_BUFFER_SIZE         256//发送接收缓冲区
           =4 #define CONFIG_MB_RTU_SLAVE_TIMEOUT                     100//接收通讯超时 10mS
           =4 #define CONFIG_MB_RTU_SLAVE_IO_DELAY            1//RX TX切换延时
           =4 /*****************************************************************************/
           =4 
           =4 /*****************************************************************************/
           =4 #define ID_ONLY_1_CHANNEL                                       4321
           =4 #define ID_ONLY_2_CHANNEL                                       8765
           =4 #define ID_BOTH_CHANNEL                                         9431
           =4 #define ID_LASER_MODE_CW                                        7631
           =4 #define ID_LASER_MODE_SP                                        8934
           =4 #define ID_LASER_MODE_MP                                        2453
           =4 #define ID_LASER_MODE_GP                                        3876
           =4 /*****************************************************************************/
           =4 #define FBS1_IN_PORT                                            3
           =4 #define FBS2_IN_PORT                                            2
           =4 #define COOLON_OUT_PORT                                         (1 * 8 + 3)
           =4 /*****************************************************************************/
           =4 //PID FUZZY 模糊PID配置
           =4 #define CONFIG_TECOUT_CYCLE                                     4000//PID输出转PWM周期
           =4 /*****************************************************************************/
           =4 /*****************************************************************************/
           =4 #define DISABLE_MODBUS_SERIAL_INTERRUPT         ES0 = 0;
           =4 #define ENABLE_MODBUS_SERIAL_INTERRUPT          ES0 = 1;
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 84  

           =4 #define DISABLE_INTERRUPT                                       EA = 0;
           =4 #define ENABLE_INTERRUPT                                        EA = 1;
           =4 /*****************************************************************************/
           =4 #include "stdint.h"
           =4 #include "stdbool.h"
           =4 #include "endian.h"
           =4 #include "si_toolchain.h"
           =4 #include "compiler_defs.h"
           =4 #ifdef C8051F020
           =4 #include "C8051F020_defs.h"
           =4 #endif
           =4 #ifdef C8051F340
           =4 #include "C8051F340_defs.h"
           =4 #endif
           =4 #ifdef C8051F580
           =4 #include "C8051F580_defs.h"
           =4 #endif
           =4 /*****************************************************************************/
           =4 #include <stdio.h>
           =4 #include <stdlib.h> 
           =4 #include <string.h>
           =4 #include <INTRINS.H>
           =4 #include <ctype.h>
           =4 #include <LIMITS.H>
           =4 #include <math.h>
           =4 #include "crc32.h"
           =4 /*****************************************************************************/
           =4 #ifdef C8051F020
           =4 #include "InitDeviceF020.h"
           =4 #endif
           =4 #ifdef C8051F580
           =4 #include "InitDeviceF580.h"
           =4 #endif
           =4 
           =4 #include "delay.h"
           =4 #include "i2c0.h"
           =4 #include "i2c1.h"
           =4 #include "i2c2.h"
           =4 #include "i2c3.h"
           =4 #include "i2c4.h"
           =4 #include "i2c5.h"
           =4 #include "i2c6.h"
           =4 #include "eprom.h"
           =4 #include "mcp47x6.h"
           =4 #include "inPca9554.h"
           =4 #include "outPca9554.h"
           =4 /*****************************************************************************/
           =4 #include "Modbus.h"
           =4 #include "ModbusPort.h"
           =4 /*****************************************************************************/
           =4 #include "sPlc.h"
           =4 #include "sPlcLaser.h"
           =4 //#include "pidFuzzy.h"
           =4 /*****************************************************************************/
           =4 //#include "AppMath.h"
           =4 //#include "chipAdc.h"
           =4 //#include "ad5621.h"
           =4 //#include "chipBeem.h"
           =4 
           =4 /*****************************************************************************/
           =4 #endif
   5      =3  /*****************************************************************************/
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 85  

   6      =3  /*****************************************************************************/
   7      =3  //线圈 保持 16 * 16 = 256BIT
   8      =3  #define MR_START                                                0
   9      =3  #define MR_END                                                  15
  10      =3  //线圈寄存器 非保持 16 * 16 = 256BIT
  11      =3  #define R_START                                                 16
  12      =3  #define R_END                                                   31
  13      =3  //数据寄存器 保持 256
  14      =3  #define DM_START                                                32
  15      =3  #define DM_END                                                  287
  16      =3  //数据寄存器 非保持 256个字
  17      =3  #define EM_START                                                288
  18      =3  #define EM_END                                                  543
  19      =3  //延时线圈
  20      =3  #define T_1MS_START                                             544//32个1mS
  21      =3  #define T_1MS_END                                               545
  22      =3  #define T_10MS_START                                    546//32个10mS
  23      =3  #define T_10MS_END                                              547
  24      =3  #define T_100MS_START                                   548//32个100mS
  25      =3  #define T_100MS_END                                             549
  26      =3  //延时计时器 
  27      =3  #define TD_1MS_START                                    550//32个1mS
  28      =3  #define TD_1MS_END                                              581
  29      =3  #define TD_10MS_START                                   582//32个10mS
  30      =3  #define TD_10MS_END                                             613
  31      =3  #define TD_100MS_START                                  614//32个100mS
  32      =3  #define TD_100MS_END                                    645
  33      =3  //计数器
  34      =3  #define C_START                                                 646//16个计数器
  35      =3  #define C_END                                                   661//
  36      =3  //输入位寄存器 16 * 16 = 256个
  37      =3  #define X_START                                                 662//
  38      =3  #define X_END                                                   677// 
  39      =3  //输出位寄存器 16 * 16 = 256个
  40      =3  #define Y_START                                                 678// 
  41      =3  #define Y_END                                                   693//
  42      =3  //特殊寄存器 64个字
  43      =3  #define SPREG_START                                             694//
  44      =3  #define SPREG_END                                               757//
  45      =3  //特殊线圈      16 * 16 = 256个
  46      =3  #define SPCOIL_START                                    758
  47      =3  #define SPCOIL_END                                              773
  48      =3  /*****************************************************************************/
  49      =3  #define CONFIG_NVRAM_SIZE                               (SPCOIL_END + 1)
  50      =3  /*****************************************************************************/
  51      =3  #define SPREG_ADC_0                                             (SPREG_START + 0)
  52      =3  #define SPREG_ADC_1                                             (SPREG_START + 1)
  53      =3  #define SPREG_ADC_2                                             (SPREG_START + 2)
  54      =3  #define SPREG_ADC_3                                             (SPREG_START + 3)
  55      =3  #define SPREG_DAC_0                                             (SPREG_START + 4)
  56      =3  #define SPREG_DAC_1                                             (SPREG_START + 5)
  57      =3  #define SPREG_DAC_2                                             (SPREG_START + 6)
  58      =3  #define SPREG_DAC_3                                             (SPREG_START + 7)
  59      =3  
  60      =3  #define SPCOIL_ON                                               (SPCOIL_START + 0)//长通线圈
  61      =3  #define SPCOIL_PS1MS                                    (SPCOIL_START + 1)//1mS间隔 50%占空比脉冲
  62      =3  #define SPCOIL_PS10MS                                   (SPCOIL_START + 2)//10mS 50%占空比脉冲
  63      =3  #define SPCOIL_PS100MS                                  (SPCOIL_START + 3)//100mS 50%占空比脉冲
  64      =3  /*****************************************************************************/
  65      =3  
  66      =3  /*****************************************************************************/
  67      =3  extern uint16_t ModbusSlaveAsciiOverTimeCounter;//Modbus Slave通信超时计时器
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 86  

  68      =3  extern xdata int16_t NVRAM0[CONFIG_NVRAM_SIZE];//掉电保持寄存器 当前
  69      =3  extern xdata int16_t NVRAM1[CONFIG_NVRAM_SIZE];//掉电保持寄存器 上一次
  70      =3  /*****************************************************************************/
  71      =3  void wdtDisable(void);//看门狗屏蔽
  72      =3  
  73      =3  void sPlcInit(void);//软逻辑初始化
  74      =3  void sPlcProcessStart(void);//sPLC轮询起始
  75      =3  void sPlcProcessEnd(void);//sPLC轮询结束
  76      =3  /*****************************************************************************/
  77      =3  void assertCoilAddress(uint16_t adr);
  78      =3  void assertRegisterAddress(uint16_t adr);
  79      =3  /*****************************************************************************/
  80      =3  void nvramUpdata(void);
  81      =3  void clearDM(void);
  82      =3  void clearEM(void);
  83      =3  void clearR(void);
  84      =3  void clearT(void);
  85      =3  void clearTD(void);
  86      =3  void clearC(void);
  87      =3  void nvramLoad(void);
  88      =3  void nvramSave(void);
  89      =3  void nvramUpdata(void);
  90      =3  /*****************************************************************************/
  91      =3  int16_t ADD(int16_t A, int16_t B);//加法指令
  92      =3  void SET(uint16_t A);//置位
  93      =3  void RES(uint16_t A);//复位
  94      =3  void FLIP(uint16_t A);//翻转
  95      =3  uint8_t LD(uint16_t A);//载入
  96      =3  uint8_t LDP(uint16_t A);//脉冲上升沿
  97      =3  uint8_t LDF(uint16_t A);//脉冲下降沿
  98      =3  uint8_t LDB(uint16_t A);//取反载入
  99      =3  //void T100US(uint8_t A, uint8_t start, uint16_t value);
 100      =3  void T1MS(uint8_t A, uint8_t start, uint16_t value);//1mS延时器启动
 101      =3  void T10MS(uint8_t A, uint8_t start, uint16_t value);//10mS延时器启动
 102      =3  void T100MS(uint8_t A, uint8_t start, uint16_t value);//100mS延时器启动
 103      =3  void UPDAC(uint16_t dat);//立即更新DAC输出
 104      =3  void REBOOT(void);//SPLC复位指令
 105      =3  /*****************************************************************************/
 106      =3  void chipDacInit(void);
 107      =3  void chipAdcInit(void);
 108      =3  void sPlcInit(void);
 109      =3  void refreshInput(void);
 110      =3  void refreshOutput(void);
 111      =3  void refreshDac(void);
 112      =3  /*****************************************************************************/
 113      =3  #endif
   1      =3  #ifndef __SPLCLASER_H__
   2      =3  #define __SPLCLASER_H__
   3      =3  /*****************************************************************************/
   4      =3  #include "appConfig.h"
   1      =4  #ifndef __APPCONFIG_H__
           =4 #define __APPCONFIG_H__
           =4 /*****************************************************************************/
           =4 #define CONFIG_SYSCLK                       (22118400L)
           =4 #ifdef C8051F020
           =4 #define SAR_CLK                                                 2000000L//ADC0时钟 <2.5MHz
           =4 #endif
           =4 #define CONFIG_DEBUG                        0//调试功能
           =4 #define CONFIG_USING_WDT                                        0//使能看门狗
           =4 #define CONFIG_USING_RESET                                      0//使能PLC复位MCU功能
           =4 #define CONFIG_LADDER_SECTORS_START                     64//指令起始地址
           =4 #define CONFIG_LADDER_SECTORS_END                       128//指令结束地址
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 87  

           =4 #define CONFIG_LASERTIMER_OVERFLOW_US           1000L//定时器周期 1mS
           =4 #define CONFIG_VERSION                                          0x0001
           =4 #define CONFIG_CHECK_CODE                                       0x5A7E
           =4 
           =4 /*****************************************************************************/
           =4 #define CONFIG_UART0_BAUDRATE                           57600//串口波特率
           =4 #define CONFIG_UART0_PARITY                                     NONE
           =4 #define CONFIG_UART0_STOPBIT                            1
           =4 #define CONFIG_UART0_DATABIT                            8
           =4 
           =4 #define CONFIG_UART1_BAUDRATE                           115200//串口波特率
           =4 #define CONFIG_UART1_PARITY                                     NONE
           =4 #define CONFIG_UART1_STOPBIT                            1
           =4 #define CONFIG_UART1_DATABIT                            8
           =4 /*****************************************************************************/
           =4 #define CONFIG_I2C0_FREQ                                        (100000L)               
           =4 #define CONFIG_I2C1_FREQ                                        (100000L)
           =4 #define CONFIG_I2C2_FREQ                                        (100000L)
           =4 #define CONFIG_I2C3_FREQ                                        (100000L)
           =4 #define CONFIG_I2C4_FREQ                                        (100000L)
           =4 /*****************************************************************************/
           =4 #define CONFIG_EPROM_SIZE                                       CONFIG_AT24C64_SIZE
           =4 #define CONFIG_AT24C02_SIZE                             256
           =4 #define CONFIG_AT24C04_SIZE                             512
           =4 #define CONFIG_AT24C08_SIZE                             1024
           =4 #define CONFIG_AT24C16_SIZE                             2048
           =4 #define CONFIG_AT24C32_SIZE                             4096
           =4 #define CONFIG_AT24C64_SIZE                                     8192
           =4 #define CONFIG_AT24C128_SIZE                            16384
           =4 #define CONFIG_AT24C256_SIZE                            32768
           =4 #define CONFIG_EPROM_ADDRESS                            0x50
           =4 #define CONFIG_EPROM_FRAM                                       0//铁电存储体无写入等待
           =4 #define CONFIG_EPROM_FREQ                                       1//
           =4 /*****************************************************************************/
           =4 #define CONFIG_USE_IPID                                         1//使能IPID温度控制
           =4 /*****************************************************************************/
           =4 #define CONFIG_USE_HWVER_SHOW                           1//使能固件版本显示
           =4 #define CONFIG_USE_MPD1_SHOW                            1//使能MPD1测量显示
           =4 #define CONFIG_USE_MPD2_SHOW                            1//使能MPD2测量显示
           =4 #define CONFIG_USE_FBS1                                         1//使能FBS1检测
           =4 #define CONFIG_USE_FBS2                                         1//使能FBS2检测
           =4 #define CONFIG_USE_LASER_TEMP                           1//使能激光器温度显示
           =4 #define CONFIG_USE_RADIATOR_TEMP                        1//使能散热器温度显示
           =4 #define CONFIG_USE_ENVI_TEMP                            1//使能环境温度显示
           =4 #define CONFIG_USE_IPID_UPDATE                          1//使能IPID参数更新功能
           =4 #define CONFIG_USE_IPID_OUTSHOW                         1//使能IPID输出显示
           =4 /*****************************************************************************/
           =4 //SPLC设置
           =4 #define CONFIG_SPLC_IO_INPUT_NUM                        16//硬件输入点数
           =4 #define CONFIG_SPLC_IO_OUTPUT_NUM                       16//硬件输出点数
           =4 #define CONFIG_SOFTPLC_HWTIME                           1000L//1mS
           =4 #define CONFIG_INPUT_FILTER_TIME                        3//输入数字滤波扫描周期 1mS * N
           =4 #define CONFIG_IPID_RUN_CYCLE                           40//IPID运行周期 默认 40 * 100mS
           =4 #define CONFIG_IPID_PWM_CYCLE                           20//IPID输出周期 默认 20 * 100mS
           =4 /*****************************************************************************/
           =4 #define CONFIG_SPLC_USING_WDT                           0//看门狗启用
           =4 /*****************************************************************************/
           =4 #define CONFIG_SPLC_USING_IO_INPUT                      1//输入IO刷新启用
           =4 /*****************************************************************************/
           =4 #define CONFIG_SPLC_USING_IO_OUTPUT                     1//输出IO刷新启用
           =4 /*****************************************************************************/
           =4 #define CONFIG_SPLC_USING_EPROM                         0//EPROM掉电存储启用
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 88  

           =4 /*****************************************************************************/
           =4 #define CONFIG_SPLC_USING_ADC                           0//使能ADC模块
           =4 #define CONFIG_SPLC_ADC_FILTER_TAP                      48//ADC位移滤波次数
           =4 #define CONFIG_SPLC_ADC_CHANNLE                         9//ADC通道数
           =4 #define CONFIG_SPLC_ADC_TEMP_SENSOR_GAIN    3330L// Temp Sensor Gain in (uV / degC)
           =4 #define CONFIG_SPLC_ADC_TEMP_SENSOR_OFFSET  856L// Temp Sensor Offset in mV
           =4 #define CONFIG_SPLC_ADC_INTERNAL_VREF           2200L// ADC Voltage Reference (mV)
           =4 #define CONFIG_SPLC_ADC_AMBIENT             25L// Ambient temp in deg C
           =4 /*****************************************************************************/
           =4 #define CONFIG_SPLC_USING_DAC                           1//是能DAC模块
           =4 /*****************************************************************************/
           =4 #define CONFIG_SPLC_USING_MB_RTU_SLAVE          1//是能MODBUS RTU从站
           =4 #define CONFIG_MB_RTU_SLAVE_TIMER                       1000L//1000uS
           =4 #define CONFIG_MB_RTU_SLAVE_ADDRESS                     0x01//从设备地址
           =4 #define CONFIG_MB_RTU_SLAVE_BUFFER_SIZE         256//发送接收缓冲区
           =4 #define CONFIG_MB_RTU_SLAVE_TIMEOUT                     100//接收通讯超时 10mS
           =4 #define CONFIG_MB_RTU_SLAVE_IO_DELAY            1//RX TX切换延时
           =4 /*****************************************************************************/
           =4 
           =4 /*****************************************************************************/
           =4 #define ID_ONLY_1_CHANNEL                                       4321
           =4 #define ID_ONLY_2_CHANNEL                                       8765
           =4 #define ID_BOTH_CHANNEL                                         9431
           =4 #define ID_LASER_MODE_CW                                        7631
           =4 #define ID_LASER_MODE_SP                                        8934
           =4 #define ID_LASER_MODE_MP                                        2453
           =4 #define ID_LASER_MODE_GP                                        3876
           =4 /*****************************************************************************/
           =4 #define FBS1_IN_PORT                                            3
           =4 #define FBS2_IN_PORT                                            2
           =4 #define COOLON_OUT_PORT                                         (1 * 8 + 3)
           =4 /*****************************************************************************/
           =4 //PID FUZZY 模糊PID配置
           =4 #define CONFIG_TECOUT_CYCLE                                     4000//PID输出转PWM周期
           =4 /*****************************************************************************/
           =4 /*****************************************************************************/
           =4 #define DISABLE_MODBUS_SERIAL_INTERRUPT         ES0 = 0;
           =4 #define ENABLE_MODBUS_SERIAL_INTERRUPT          ES0 = 1;
           =4 #define DISABLE_INTERRUPT                                       EA = 0;
           =4 #define ENABLE_INTERRUPT                                        EA = 1;
           =4 /*****************************************************************************/
           =4 #include "stdint.h"
           =4 #include "stdbool.h"
           =4 #include "endian.h"
           =4 #include "si_toolchain.h"
           =4 #include "compiler_defs.h"
           =4 #ifdef C8051F020
           =4 #include "C8051F020_defs.h"
           =4 #endif
           =4 #ifdef C8051F340
           =4 #include "C8051F340_defs.h"
           =4 #endif
           =4 #ifdef C8051F580
           =4 #include "C8051F580_defs.h"
           =4 #endif
           =4 /*****************************************************************************/
           =4 #include <stdio.h>
           =4 #include <stdlib.h> 
           =4 #include <string.h>
           =4 #include <INTRINS.H>
           =4 #include <ctype.h>
           =4 #include <LIMITS.H>
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 89  

           =4 #include <math.h>
           =4 #include "crc32.h"
           =4 /*****************************************************************************/
           =4 #ifdef C8051F020
           =4 #include "InitDeviceF020.h"
           =4 #endif
           =4 #ifdef C8051F580
           =4 #include "InitDeviceF580.h"
           =4 #endif
           =4 
           =4 #include "delay.h"
           =4 #include "i2c0.h"
           =4 #include "i2c1.h"
           =4 #include "i2c2.h"
           =4 #include "i2c3.h"
           =4 #include "i2c4.h"
           =4 #include "i2c5.h"
           =4 #include "i2c6.h"
           =4 #include "eprom.h"
           =4 #include "mcp47x6.h"
           =4 #include "inPca9554.h"
           =4 #include "outPca9554.h"
           =4 /*****************************************************************************/
           =4 #include "Modbus.h"
           =4 #include "ModbusPort.h"
           =4 /*****************************************************************************/
           =4 #include "sPlc.h"
           =4 #include "sPlcLaser.h"
           =4 //#include "pidFuzzy.h"
           =4 /*****************************************************************************/
           =4 //#include "AppMath.h"
           =4 //#include "chipAdc.h"
           =4 //#include "ad5621.h"
           =4 //#include "chipBeem.h"
           =4 
           =4 /*****************************************************************************/
           =4 #endif
   5      =3  /*****************************************************************************/
   6      =3  #define MCP47X6_LASER_CHANNEL_CH1                                       0
   7      =3  #define MCP47X6_LASER_CHANNEL_CH2                                       1
   8      =3  #define LASER_MODE_CW                                                           0//连续模式
   9      =3  #define LASER_MODE_SP                                                           1//单脉冲模式
  10      =3  #define LASER_MODE_MP                                                           2//多脉冲模式
  11      =3  #define LASER_MODE_GP                                                           3//群脉冲模式
  12      =3  
  13      =3  //R 线圈定义
  14      =3  #define R_MCU_RESET                                                                     (R_START * 16 + 0)//MCU复位请求
  15      =3  #define R_MCU_ERROR_CLEAR                                                       (R_START * 16 + 1)//MCU错误清除
  16      =3  #define R_LASER_START                                                           (R_START * 16 + 2)//激光发射按键
  17      =3  #define R_LASER_STOP                                                            (R_START * 16 + 3)//激光停止按键
  18      =3  #define R_LASER_READY                                                           (R_START * 16 + 4)//准备按键
  19      =3  #define R_LASER_SELECT_CH1                                                      (R_START * 16 + 5)//激光选择CH1按键
  20      =3  #define R_LASER_SELECT_CH2                                                      (R_START * 16 + 6)//激光选择CH2按键
  21      =3  #define R_LASER_SELECT_BOTH                                                     (R_START * 16 + 7)//激光旋转CH1+CH2按键
  22      =3  #define R_INFO_RESET                                                            (R_START * 16 + 8)//激光发射信息复位按键
  23      =3  #define R_PARA_SAVE                                                                     (R_START * 16 + 9)//参数储存按键
  24      =3  #define R_LASER_MODE_CW                                                         (R_START * 16 + 10)//激光模式连续按键
  25      =3  #define R_LASER_MODE_PULSE                                                      (R_START * 16 + 11)//激光模式脉冲连续按键
  26      =3  #define R_LASER_MODE_GP                                                         (R_START * 16 + 12)//激光模式可编程脉冲按键
  27      =3  #define R_LASER_ERROR_CLEAR                                                     (R_START * 16 + 13)//激光错误清除
  28      =3  #define R_FLAG_COOLING                                                          (R_START * 16 + 13)//冷却指示
  29      =3  #define R_FLAG_LASER_EMITING                                            (R_START * 16 + 14)//激光发射指示
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 90  

  30      =3  #define R_FLAG_LASER_EMITOVER                                           (R_START * 16 + 15)//激光发射完毕
  31      =3  #define R_FLAG_LASER_TIGGER                                                     (R_START * 16 + 16)//激光发射触发
  32      =3  #define R_FLAG_READY                                                            (R_START * 16 + 17)//准备状态
  33      =3  #define R_FLAG_STANDBY                                                          (R_START * 16 + 18)//待机状态
  34      =3  #define R_FLAG_FIBER_MECH_DETECT                                        (R_START * 16 + 19)//光纤机械传感器
  35      =3  #define R_FLAG_FIBER_MECH_DETECT_IGNORE                         (R_START * 16 + 20)//光纤机械传感器忽略
  36      =3  #define R_FLAG_FIBER_NFC_DETECT                                         (R_START * 16 + 20)//光纤NFC传感器
  37      =3  #define R_FLAG_FIBER_NFC_DETECT_IGNORE                          (R_START * 16 + 21)//光纤NFC传感器忽略
  38      =3  #define R_FLAG_OPENCASE_DETECT                                          (R_START * 16 + 21)//开箱检测
  39      =3  #define R_FLAG_FOOTSWITCH                                                       (R_START * 16 + 22)//脚踏状态
  40      =3  #define R_FLAG_WIRE_FOOTSWITCH                                          (R_START * 16 + 23)//有线脚踏状态
  41      =3  #define R_FLAG_WIRELESS_FOOTSWITCH                                      (R_START * 16 + 24)//无线脚踏状态
  42      =3  #define R_FLAG_MCU_HEART                                                        (R_START * 16 + 25)//MCU心跳
  43      =3  #define R_FLAG_BEEM                                                                     (R_START * 16 + 26)//蜂鸣器状态
  44      =3  #define R_FLAG_SAFE_FAULT                                                       (R_START * 16 + 27)//安全故障
  45      =3  #define R_FLAG_TEMP_FAULT                                                       (R_START * 16 + 28)//温度故障
  46      =3  #define R_FLAG_DRIVER_LTEMP_FAULT                                       (R_START * 16 + 29)
  47      =3  #define R_FLAG_DRIVER_HTEMP_FAULT                                       (R_START * 16 + 30)
  48      =3  #define R_FLAG_DRIVER_TEMP_FAULT_IGNORE                         (R_START * 16 + 30)
  49      =3  #define R_FLAG_MCHIP_LTEMP_FAULT                                        (R_START * 16 + 31)
  50      =3  #define R_FLAG_MCHIP_HTEMP_FAULT                                        (R_START * 16 + 32)
  51      =3  #define R_FLAG_MCHIP_TEMP_FAULT_IGNORE                          (R_START * 16 + 30)
  52      =3  #define R_FLAG_LASER_LTEMP_FAULT                                        (R_START * 16 + 33)
  53      =3  #define R_FLAG_LASER_HTEMP_FAULT                                        (R_START * 16 + 34)
  54      =3  #define R_FLAG_LASER_TEMP_FAULT_IGNORE                          (R_START * 16 + 30)
  55      =3  //MR 线圈定义
  56      =3  #define MR_FIBER_MECH_DETECT_IGNORE                                     (MR_START + 0)//光纤探测机械忽略
  57      =3  #define MR_FIBER_NFC_DETCET_IGNORE                                      (MR_START + 1)//光纤探测NFC忽略
  58      =3  #define MR_OPENCASE_DETECT_IGNORE                                       (MR_START + 2)//开箱检测忽略
  59      =3  #define MR_AIM_ENABLE                                                           (MR_START + 3)//指示激光使能                                                    
  60      =3  #define MR_BEEM_ENABLE                                                          (MR_START + 4)//蜂鸣器使能
  61      =3  //EM 寄存器定义
  62      =3  #define EM_MCU_CHECKCODE                                                        (EM_START + 0)//MCU校验码
  63      =3  #define EM_MCU_HW_VER                                                           (EM_START + 1)//MCU硬件版本
  64      =3  #define EM_MCU_FW_VER                                                           (EM_START + 2)//MCU软件版本
  65      =3  #define EM_STEP_NUM                                                                     (EM_START + 3)//激光发射步骤号码
  66      =3  #define EM_LASER_POSWIDTH                                                       (EM_START + 4)//激光正脉宽
  67      =3  #define EM_LASER_NEGWIDTH                                                       (EM_START + 5)//激光负脉宽
  68      =3  #define EM_LASER_GROUP_SPACE                                            (EM_START + 6)//分组间隔//激光群脉冲间隔
  69      =3  #define EM_LASER_GROUP_NUM                                                      (EM_START + 7)//分组脉冲数//激光群脉冲个数
  70      =3  #define EM_LASER_POWER_CH1                                                      (EM_START + 8)//激光通道1功率设置
  71      =3  #define EM_LASER_POWER_CH2                                                      (EM_START + 9)//激光通道2功率设置
  72      =3  #define EM_LASER_POWER_TOTAL                                            (EM_START + 10)//激光总功率显示
  73      =3  #define EM_LASER_POWER_RATIO                                            (EM_START + 11)//激光功率比例显示
  74      =3  #define EM_LASER_RELEASE_ENERY                                          (EM_START + 13)//激光发射能量显示
  75      =3  #define EM_LASER_RELEASE_TIME                                           (EM_START + 14)//激光发射时间显示
  76      =3  #define EM_LASER_CURRENT_CH1                                            (EM_START + 15)//激光器电流0
  77      =3  #define EM_LASER_CURRENT_CH2                                            (EM_START + 16)//激光器电流1
  78      =3  #define EM_LASER_PD_CH1                                                         (EM_START + 17)//激光器反馈0
  79      =3  #define EM_LASER_PD_CH2                                                         (EM_START + 18)//激光器反馈1
  80      =3  #define EM_LASER_MODE                                                           (EM_START + 19)//激光发射模式
  81      =3  #define EM_LASER_SELECT_CHANNLE                                         (EM_START + 20)//激光通道选择
  82      =3  #define EM_LASER_TEMPERATURE                                            (EM_START + 21)//激光器温度
  83      =3  #define EM_LASER_TMATE                                                          (EM_START + 22)//计时器匹配值
  84      =3  #define EM_LASER_PMATE                                                          (EM_START + 23)//脉冲个数匹配值
  85      =3  #define EM_LASER_SMATE                                                          (EM_START + 24)//脉冲个数溢出值
  86      =3  #define EM_LASER_TOVERFLOW                                                      (EM_START + 25)//计时器溢出值
  87      =3  #define EM_LASER_TCOUNTER                                                       (EM_START + 26)//计时器计数值
  88      =3  #define EM_LASER_PCOUNTER                                                       (EM_START + 27)//脉冲个数计数值
  89      =3  #define EM_LASER_SCOUNTER                                                       (EM_START + 28)//脉冲间隔计数值
  90      =3  #define EM_FAN_GET_SPEED_0                                                      (EM_START + 29)//风扇0转速读取
  91      =3  #define EM_FAN_GET_SPEED_1                                                      (EM_START + 30)//风扇1转速读取
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 91  

  92      =3  #define EM_FAN_GET_SPEED_2                                                      (EM_START + 31)//风扇2转速读取
  93      =3  #define EM_DRIVER_TEMPERATURE                                           (EM_START + 32)//驱动器温度
  94      =3  #define EM_MCHIP_TEMPERATURE                                            (EM_START + 33)//板卡温度
  95      =3  //DM 寄存器定义
  96      =3  #define DM_PID_REF_TEMP                                                         (DM_START + 0)//冷却温度设定
  97      =3  #define DM_PID_ON_TIME                                                          (DM_START + 1)//PID输出开通时间
  98      =3  #define DM_PID_OFF_TIME                                                         (DM_START + 2)//PID输出关闭时间
  99      =3  #define DM_PID_COEF_KP                                                          (DM_START + 3)//PID系数比例KP
 100      =3  #define DM_PID_COEF_TI                                                          (DM_START + 4)//PID系数积分时间TI
 101      =3  #define DM_PID_COEF_TD                                                          (DM_START + 5)//PID系数微分时间TD
 102      =3  #define DM_FAN_SET_SPEED_0                                                      (DM_START + 6)//风扇0转速设置
 103      =3  #define DM_FAN_SET_SPEED_1                                                      (DM_START + 7)//风扇1转速设置
 104      =3  #define DM_FAN_SET_SPEED_2                                                      (DM_START + 8)//风扇2转速设置
 105      =3  #define DM_SET_AIM_BRIGHT                                                       (DM_START + 9)//指示激光亮度
 106      =3  #define DM_SET_BEEM_VOLUME                                                      (DM_START + 10)//蜂鸣器音量
 107      =3  #define DM_SET_LCD_BRIGHT                                                       (DM_START + 11)//液晶屏亮度
 108      =3  #define DM_LASER_PROTECT_HTEMP                                          (DM_START + 12)//激光器高温保护
 109      =3  #define DM_LASER_PROTCET_LTEMP                                          (DM_START + 13)//激光器低温保护
 110      =3  #define DM_DRIVE_PROTECT_HTEMP                                          (DM_START + 14)//驱动器高温保护
 111      =3  #define DM_DRIVE_PROTECT_LTEMP                                          (DM_START + 15)//驱动器低温保护
 112      =3  #define DM_MCHIP_PROTECT_HTEMP                                          (DM_START + 16)//芯片高温保护
 113      =3  #define DM_MCHIP_PROTECT_LTEMP                                          (DM_START + 17)//芯片低温保护
 114      =3  /*****************************************************************************/
 115      =3  #define X_FOOTSWITCH                                                            (X_START * 16 + 0)
 116      =3  #define X_OPENCASE_DETECT                                                       (X_START * 16 + 1)
 117      =3  #define X_INTERLOCK                                                                     (X_START * 16 + 2)
 118      =3  #define X_MECH_FIBER_DETECT                                                     (X_START * 16 + 2)
 119      =3  void sPlcLaser(void);//
 120      =3  #endif
   5      =1  /*****************************************************************************/
   6      =1  extern volatile uint16_t modbusTimerValue;
   7      =1  extern volatile uint8_t modbusReceiveCounter;// Collected data number
   8      =1  extern xdata volatile uint8_t modbusReceiveBuffer[CONFIG_MB_RTU_SLAVE_BUFFER_SIZE];
   9      =1  /*****************************************************************************/
  10      =1  extern void initModbus(uint8_t modbusSlaveAddress, uint32_t bd);
  11      =1  extern void modbusPorcess(void);
  12      =1  #endif
   2          /*******************************ModBus Functions*******************************/
   3          #define MODBUS_READ_COILS                                               1
   4          #define MODBUS_READ_DISCRETE_INPUTS                                     2
   5          #define MODBUS_READ_HOLDING_REGISTERS                                   3
   6          #define MODBUS_READ_INPUT_REGISTERS                                     4
   7          #define MODBUS_WRITE_SINGLE_COIL                                        5
   8          #define MODBUS_WRITE_SINGLE_REGISTER                                    6
   9          #define MODBUS_WRITE_MULTIPLE_COILS                                     15
  10          #define MODBUS_WRITE_MULTIPLE_REGISTERS                                 16
  11          /****************************End of ModBus Functions***************************/
  12          #define FALSE_FUNCTION                                                  0
  13          #define FALSE_SLAVE_ADDRESS                                             1
  14          #define DATA_NOT_READY                                                  2
  15          #define DATA_READY                                                      3
  16          #define ERROR_CODE_01                                                   0x01// function code is not supported
  17          #define ERROR_CODE_02                                                   0x02// Register address is not allowed or write-protected
  18          #define ERROR_CODE_03                                                   0x03//Some data values are out of range, invalid number of r
             -egister
  19          /*****************************************************************************/
  20          typedef enum{
  21              RXTX_IDLE,
  22              RXTX_START,
  23              RXTX_DATABUF,
  24              RXTX_WAIT_ANSWER,
  25              RXTX_TIMEOUT
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 92  

  26          }MODBUS_RXTX_STATE;
  27          typedef struct{
  28                  uint8_t address;
  29                  uint8_t function;
  30                  uint8_t dataBuf[CONFIG_MB_RTU_SLAVE_BUFFER_SIZE];
  31                  uint16_t dataLen;
  32          }modbusRxTxData_t;
  33          /**********************Slave Transmit and Receive Variables********************/
  34          data uint8_t ModbusSlaveAddress = 1;
  35          xdata modbusRxTxData_t Tx_Data;
  36          data uint32_t Tx_Current = 0;
  37          data uint32_t Tx_CRC16 = 0xFFFF;
  38          data MODBUS_RXTX_STATE Tx_State = RXTX_IDLE;
  39          xdata uint8_t Tx_Buf[CONFIG_MB_RTU_SLAVE_BUFFER_SIZE];
  40          data uint32_t Tx_Buf_Size = 0;
  41          /*****************************************************************************/
  42          xdata modbusRxTxData_t Rx_Data;
  43          data uint32_t Rx_CRC16 = 0xFFFF;
  44          data MODBUS_RXTX_STATE Rx_State = RXTX_IDLE;
  45          data uint8_t Rx_Data_Available = false;
  46          /*****************************************************************************/
  47          volatile uint16_t modbusTimerValue = 0;
  48          volatile uint8_t modbusReceiveCounter = 0;// Collected data number
  49          xdata volatile uint8_t modbusReceiveBuffer[CONFIG_MB_RTU_SLAVE_BUFFER_SIZE];// Buffer to collect data from
             - hardware
  50          /*****************************************************************************/
  51          void modbusCrc16(const uint8_t Data, uint32_t* CRC){
  52   1          data uint32_t i;
  53   1          *CRC = *CRC ^(uint32_t) Data;
  54   1          for (i = 8; i > 0; i--){
  55   2              if (*CRC & 0x0001)
  56   2                  *CRC = (*CRC >> 1) ^ 0xA001;
  57   2              else
  58   2                  *CRC >>= 1;
  59   2          }
  60   1      }
  61          uint8_t DoSlaveTX(void){//It is used for send data package over physical layer
  62   1          modBusUartString(Tx_Buf, Tx_Buf_Size);
  63   1          Tx_Buf_Size = 0;
  64   1          return true;
  65   1      }
  66          uint8_t SendMessage(void){//This function start to sending messages
  67   1          if (Tx_State != RXTX_IDLE){
  68   2              return false;
  69   2              }
  70   1          Tx_Current  =0;
  71   1          Tx_State    =RXTX_START;
  72   1          return true;
  73   1      }
  74          void HandleModbusError(char ErrorCode){// Initialise the output buffer. The first byte in the buffer says 
             -how many registers we have read
  75   1          Tx_Data.function = ErrorCode | 0x80;
  76   1          Tx_Data.address = ModbusSlaveAddress;
  77   1          Tx_Data.dataLen = 0;
  78   1          SendMessage();
  79   1      }
  80          
  81          void HandleModbusReadCoils(void){//Modbus function 01 - 读取线圈状态
  82   1              uint16_t startAddress, numberOfCoil, byteCount, tempAddr, i, j;
  83   1              uint8_t tempData = 0;
  84   1              // The message contains the requested start address and number of registers
  85   1          startAddress = ((uint16_t) (Rx_Data.dataBuf[0]) << 8) + (uint16_t) (Rx_Data.dataBuf[1]);
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 93  

  86   1          numberOfCoil = ((uint16_t) (Rx_Data.dataBuf[2]) << 8) + (uint16_t) (Rx_Data.dataBuf[3]);
  87   1              if((startAddress + numberOfCoil) > (CONFIG_NVRAM_SIZE * 16)){//If it is bigger than RegisterNumber return
             - error to Modbus Master
  88   2              HandleModbusError(ERROR_CODE_02);
  89   2              }
  90   1              else{
  91   2                      byteCount = numberOfCoil / 8;
  92   2                      if((numberOfCoil % 8) != 0){
  93   3                              byteCount += 1;
  94   3                      }
  95   2                      Tx_Data.function = MODBUS_READ_COILS;
  96   2                      Tx_Data.address = ModbusSlaveAddress;
  97   2                      Tx_Data.dataLen = 1;
  98   2                      tempAddr = startAddress;
  99   2                      for(i = 0; i < byteCount; i ++){
 100   3                              Tx_Data.dataBuf[Tx_Data.dataLen] = 0;
 101   3                              for(j = 0; j < 8; j ++){
 102   4                                      tempData = (NVRAM0[(tempAddr / 16)] >> (tempAddr % 16)) & 0x01;
 103   4                                      Tx_Data.dataBuf[Tx_Data.dataLen] |= (uint8_t)(tempData << j);
 104   4                                      tempAddr++;     
 105   4                                      //if(tempAddr >= startAddress + numberOfCoil){//读完
 106   4                                      //      exit = 1;
 107   4                                      //      break;
 108   4                                      //} 
 109   4                              }
 110   3                              Tx_Data.dataLen ++;     
 111   3                      }
 112   2                      Tx_Data.dataBuf[0] = Tx_Data.dataLen - 1;
 113   2                      SendMessage();
 114   2              }
 115   1      }
 116          void HandleModbusReadInputCoil(void){//Modbus function 02 - 读取输入线圈状态
 117   1      }
 118          void HandleModbusReadHoldingRegisters(void){//Modbus function 03 - Read holding registers
 119   1          uint16_t startAddress, numberOfRegisters, i, currentData;
 120   1              // The message contains the requested start address and number of registers
 121   1          startAddress = ((uint16_t) (Rx_Data.dataBuf[0]) << 8) + (uint16_t) (Rx_Data.dataBuf[1]);
 122   1          numberOfRegisters = ((uint16_t) (Rx_Data.dataBuf[2]) << 8) + (uint16_t) (Rx_Data.dataBuf[3]);
 123   1              if((startAddress + numberOfRegisters) > CONFIG_NVRAM_SIZE){//If it is bigger than RegisterNumber return e
             -rror to Modbus Master
 124   2              HandleModbusError(ERROR_CODE_02);
 125   2              }
 126   1          else{//Initialise the output buffer. The first byte in the buffer says how many registers we have read
 127   2              Tx_Data.function = MODBUS_READ_HOLDING_REGISTERS;
 128   2              Tx_Data.address = ModbusSlaveAddress;
 129   2              Tx_Data.dataLen = 1;
 130   2              Tx_Data.dataBuf[0] = 0;
 131   2              for (i = 0;i < numberOfRegisters;i ++){
 132   3                  currentData = (uint16_t)NVRAM0[startAddress + i];
 133   3                  Tx_Data.dataBuf[Tx_Data.dataLen] = (uint8_t)((currentData & 0xFF00) >> 8);
 134   3                  Tx_Data.dataBuf[Tx_Data.dataLen + 1] = (uint8_t)(currentData & 0x00FF);
 135   3                  Tx_Data.dataLen += 2;
 136   3                  Tx_Data.dataBuf[0] = Tx_Data.dataLen - 1;
 137   3              }
 138   2              SendMessage();
 139   2          }
 140   1      }
 141          void HandleModbusWriteSingleCoil(void){//Modbus function 05 -强置单线圈
 142   1              uint16_t startAddress, value;
 143   1              // The message contains the requested start address and number of registers
 144   1          startAddress = ((uint16_t) (Rx_Data.dataBuf[0]) << 8) + (uint16_t) (Rx_Data.dataBuf[1]);
 145   1              value = ((uint16_t) (Rx_Data.dataBuf[2]) << 8) + (uint16_t)(Rx_Data.dataBuf[3]);
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 94  

 146   1              if((startAddress) > (CONFIG_NVRAM_SIZE * 16)){//If it is bigger than RegisterNumber return error to Modbu
             -s Master
 147   2              HandleModbusError(ERROR_CODE_02);
 148   2              }
 149   1              else{
 150   2                      Tx_Data.function = MODBUS_WRITE_SINGLE_COIL;
 151   2                      Tx_Data.address = ModbusSlaveAddress;
 152   2                      Tx_Data.dataLen = 4;
 153   2                      Tx_Data.dataBuf[0] = Rx_Data.dataBuf[0];
 154   2                      Tx_Data.dataBuf[1] = Rx_Data.dataBuf[1];
 155   2                      if(value == 0x0000){//0
 156   3                              NVRAM0[(startAddress / 16)] &= ~((uint16_t)(1 << (startAddress % 16)));
 157   3                              Tx_Data.dataBuf[2] = 0x00;
 158   3                              Tx_Data.dataBuf[3] = 0x00;
 159   3                      }
 160   2                      else if(value == 0xFF00){//1
 161   3                              NVRAM0[(startAddress / 16)] |= (uint16_t)(1 << (startAddress % 16));
 162   3                              Tx_Data.dataBuf[2] = 0xFF;
 163   3                              Tx_Data.dataBuf[3] = 0x00;
 164   3                      }
 165   2                      else{           
 166   3                      }
 167   2                      SendMessage();
 168   2              }
 169   1      }
 170          void HandleModbusWriteSingleRegister(void){//Modbus function 06 - Write single register
 171   1          uint16_t address, value,i;
 172   1          // The message contains the requested start address and number of registers
 173   1          address = ((uint16_t) (Rx_Data.dataBuf[0]) << 8) + (uint16_t)(Rx_Data.dataBuf[1]);
 174   1          value = ((uint16_t) (Rx_Data.dataBuf[2]) << 8) + (uint16_t)(Rx_Data.dataBuf[3]);
 175   1          // Initialise the output buffer. The first byte in the buffer says how many registers we have read
 176   1          Tx_Data.function = MODBUS_WRITE_SINGLE_REGISTER;
 177   1          Tx_Data.address = ModbusSlaveAddress;
 178   1          Tx_Data.dataLen = 4;
 179   1          if(address >= CONFIG_NVRAM_SIZE){
 180   2              HandleModbusError(ERROR_CODE_03);
 181   2              }
 182   1          else{
 183   2                      NVRAM0[address] = (int16_t)value;
 184   2              // Output data buffer is exact copy of input buffer
 185   2              for (i = 0; i < 4; ++i){
 186   3                  Tx_Data.dataBuf[i] = Rx_Data.dataBuf[i];
 187   3                      }
 188   2          }
 189   1          SendMessage();
 190   1      }
 191          void HandleModbusWriteMultipleCoils(void){//Modbus function 15 - Write multiple coils
 192   1              uint16_t startAddress, numberOfCoil, byteCount, tempAddr, i, j;
 193   1              uint8_t tempData = 0;
 194   1              // The message contains the requested start address and number of registers
 195   1          startAddress = ((uint16_t) (Rx_Data.dataBuf[0]) << 8) + (uint16_t) (Rx_Data.dataBuf[1]);
 196   1          numberOfCoil = ((uint16_t) (Rx_Data.dataBuf[2]) << 8) + (uint16_t) (Rx_Data.dataBuf[3]);
 197   1              if((startAddress + numberOfCoil) > (CONFIG_NVRAM_SIZE * 16)){//If it is bigger than RegisterNumber return
             - error to Modbus Master
 198   2              HandleModbusError(ERROR_CODE_02);
 199   2              }
 200   1              else{
 201   2                      byteCount = numberOfCoil / 8;
 202   2                      if((numberOfCoil % 8) != 0){
 203   3                              byteCount += 1;
 204   3                      }
 205   2                      Tx_Data.function = MODBUS_WRITE_MULTIPLE_COILS;
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 95  

 206   2                      Tx_Data.address = ModbusSlaveAddress;
 207   2                      Tx_Data.dataLen = 4;
 208   2                      Tx_Data.dataBuf[0] = Rx_Data.dataBuf[0];
 209   2                      Tx_Data.dataBuf[1] = Rx_Data.dataBuf[1];
 210   2                      Tx_Data.dataBuf[2] = Rx_Data.dataBuf[2];
 211   2                      Tx_Data.dataBuf[3] = Rx_Data.dataBuf[3];
 212   2                      tempAddr = startAddress;
 213   2                      for(i = 0;i < byteCount;i ++){
 214   3                              for(j = 0;j < 8;j ++){
 215   4                                      tempData = (uint8_t)((Rx_Data.dataBuf[(5 + i)] >> j) & 0x01);
 216   4                                      if(tempData){//ON
 217   5                                              NVRAM0[(tempAddr / 16)] |= (uint16_t)(1 << (tempAddr % 16));
 218   5                                      }
 219   4                                      else{//OFF
 220   5                                              NVRAM0[(tempAddr / 16)] &= ~((uint16_t)(1 << (tempAddr % 16)));
 221   5                                      }
 222   4                                      tempAddr ++;
 223   4                                      numberOfCoil --;
 224   4                                      if(numberOfCoil == 0){
 225   5                                              break;
 226   5                                      }
 227   4                              }
 228   3                              
 229   3                      }
 230   2                      SendMessage();
 231   2              }
 232   1      }
 233          void HandleModbusWriteMultipleRegisters(void){//Modbus function 16 - Write multiple registers
 234   1          // Write single numerical output
 235   1          data uint16_t startAddress, numberOfRegisters, value;
 236   1          data uint8_t byteCount , i;
 237   1          // The message contains the requested start address and number of registers
 238   1          startAddress = ((uint16_t)(Rx_Data.dataBuf[0]) << 8) + (uint16_t)(Rx_Data.dataBuf[1]);
 239   1          numberOfRegisters = ((uint16_t)(Rx_Data.dataBuf[2]) << 8) + (uint16_t)(Rx_Data.dataBuf[3]);
 240   1          byteCount = Rx_Data.dataBuf[4];
 241   1          // If it is bigger than RegisterNumber return error to Modbus Master
 242   1          if((startAddress+numberOfRegisters) > CONFIG_NVRAM_SIZE){
 243   2              HandleModbusError(ERROR_CODE_03);
 244   2              }
 245   1          else{
 246   2              // Initialise the output buffer. The first byte in the buffer says how many outputs we have set
 247   2              Tx_Data.function = MODBUS_WRITE_MULTIPLE_REGISTERS;
 248   2              Tx_Data.address = ModbusSlaveAddress;
 249   2              Tx_Data.dataLen = 4;
 250   2              Tx_Data.dataBuf[0] = Rx_Data.dataBuf[0];
 251   2              Tx_Data.dataBuf[1] = Rx_Data.dataBuf[1];
 252   2              Tx_Data.dataBuf[2] = Rx_Data.dataBuf[2];
 253   2              Tx_Data.dataBuf[3] = Rx_Data.dataBuf[3];
 254   2              // Output data buffer is exact copy of input buffer
 255   2              for (i = 0;i < numberOfRegisters;i ++){
 256   3                  value = (uint16_t)((Rx_Data.dataBuf[5 + 2 * i] << 8) & 0xFF00) + (uint16_t)((Rx_Data.dataBuf[6
             - + 2 * i]) & 0x00FF);
 257   3                  NVRAM0[startAddress + i] = (int16_t)value;
 258   3              }
 259   2              SendMessage();
 260   2          }
 261   1      }
 262          uint8_t RxDataAvailable(void){//RxDataAvailable
 263   1          uint8_t Result = Rx_Data_Available;   
 264   1          Rx_Data_Available = false;
 265   1          return Result;
 266   1      }
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 96  

 267          uint8_t CheckRxTimeout(void){//CheckRxTimeout
 268   1          // A return value of true indicates there is a timeout    
 269   1          if (modbusTimerValue >= CONFIG_MB_RTU_SLAVE_BUFFER_SIZE){
 270   2              modbusTimerValue = 0;
 271   2              modbusReceiveCounter = 0;
 272   2              return true;
 273   2          }
 274   1          return false;
 275   1      }
 276          uint8_t checkModbusBufferComplete(void){//CheckBufferComplete
 277   1          data int32_t expectedReceiveCount=0;
 278   1          if(modbusReceiveCounter > 4)
 279   1          {
 280   2              if(modbusReceiveBuffer[0] == ModbusSlaveAddress)
 281   2              {
 282   3                  if(modbusReceiveBuffer[1]==0x01 || modbusReceiveBuffer[1]==0x02 || modbusReceiveBuffer[1]==0x0
             -3 || modbusReceiveBuffer[1]==0x04 || modbusReceiveBuffer[1]==0x05 || modbusReceiveBuffer[1]==0x06)  // RHR
 283   3                  {
 284   4                      expectedReceiveCount = 8;
 285   4                  }
 286   3                  else if(modbusReceiveBuffer[1] == 0x0F || modbusReceiveBuffer[1] == 0x10)
 287   3                  {
 288   4                      expectedReceiveCount=modbusReceiveBuffer[6] + 9;
 289   4                  }
 290   3                  else{
 291   4                      modbusReceiveCounter = 0;
 292   4                      return FALSE_FUNCTION;
 293   4                  }
 294   3              }
 295   2              else
 296   2              {
 297   3                  modbusReceiveCounter=0;
 298   3                  return FALSE_SLAVE_ADDRESS;
 299   3              }
 300   2          }
 301   1          else
 302   1              return DATA_NOT_READY;
 303   1      
 304   1          if(modbusReceiveCounter==expectedReceiveCount)
 305   1          {
 306   2              return DATA_READY;
 307   2          }
 308   1      
 309   1          return DATA_NOT_READY;
 310   1      }
 311          void RxRTU(void){//Check for data ready, if it is good return answer
 312   1          uint8_t i;
 313   1          uint8_t receiveBufferControl=0;
 314   1          receiveBufferControl = checkModbusBufferComplete();
 315   1          if(receiveBufferControl == DATA_READY){
 316   2              Rx_Data.address               =modbusReceiveBuffer[0];
 317   2              Rx_CRC16                      = 0xffff;
 318   2              modbusCrc16(Rx_Data.address, &Rx_CRC16);
 319   2              Rx_Data.function              =modbusReceiveBuffer[1];
 320   2              modbusCrc16(Rx_Data.function, &Rx_CRC16);
 321   2      
 322   2              Rx_Data.dataLen=0;
 323   2      
 324   2              for(i=2;i<modbusReceiveCounter;i++)
 325   2                  Rx_Data.dataBuf[Rx_Data.dataLen++]=modbusReceiveBuffer[i];
 326   2      
 327   2              Rx_State =RXTX_DATABUF;
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 97  

 328   2      
 329   2              modbusReceiveCounter=0;
 330   2          }
 331   1      
 332   1          CheckRxTimeout();
 333   1      
 334   1          if ((Rx_State == RXTX_DATABUF) && (Rx_Data.dataLen >= 2))
 335   1          {
 336   2              // Finish off our CRC check
 337   2              Rx_Data.dataLen -= 2;
 338   2              for (i = 0; i < Rx_Data.dataLen; ++i)
 339   2              {
 340   3                  modbusCrc16(Rx_Data.dataBuf[i], &Rx_CRC16);
 341   3              }
 342   2              
 343   2              if (((uint32_t) Rx_Data.dataBuf[Rx_Data.dataLen] + ((uint32_t) Rx_Data.dataBuf[Rx_Data.dataLen + 1
             -] << 8)) == Rx_CRC16)
 344   2              {
 345   3                  // Valid message!
 346   3                  Rx_Data_Available = true;
 347   3              }
 348   2      
 349   2              Rx_State = RXTX_IDLE;
 350   2          }
 351   1      }
 352          void TxRTU(void){//If it is ready send answers!
 353   1          Tx_CRC16 = 0xFFFF;
 354   1          Tx_Buf_Size = 0;
 355   1          Tx_Buf[Tx_Buf_Size++] = Tx_Data.address;
 356   1          modbusCrc16(Tx_Data.address, &Tx_CRC16);
 357   1          Tx_Buf[Tx_Buf_Size++] = Tx_Data.function;
 358   1          modbusCrc16(Tx_Data.function, &Tx_CRC16);
 359   1          for(Tx_Current=0; Tx_Current < Tx_Data.dataLen; Tx_Current++){
 360   2              Tx_Buf[Tx_Buf_Size++] = Tx_Data.dataBuf[Tx_Current];
 361   2              modbusCrc16(Tx_Data.dataBuf[Tx_Current], &Tx_CRC16);
 362   2          }
 363   1          Tx_Buf[Tx_Buf_Size++] = Tx_CRC16 & 0x00FF;
 364   1          Tx_Buf[Tx_Buf_Size++] = (Tx_CRC16 & 0xFF00) >> 8;
 365   1          DoSlaveTX();
 366   1          Tx_State = RXTX_IDLE;
 367   1      }
 368          void modbusPorcess(void){//ModBus main core! Call this function into main!
 369   1          if (Tx_State != RXTX_IDLE){                                      // If answer is ready, send it!
 370   2              TxRTU();
 371   2              }
 372   1          RxRTU();                                                              // Call this function every cycl
             -e
 373   1          if (RxDataAvailable()){
 374   2              if (Rx_Data.address == ModbusSlaveAddress){
 375   3                  switch (Rx_Data.function)                                     // Data is for us but which func
             -tion?
 376   3                  {
 377   4                                      case MODBUS_READ_COILS:{//FUN 01
 378   5                                              HandleModbusReadCoils();
 379   5                                              break;
 380   5                                      }
 381   4                      case MODBUS_READ_HOLDING_REGISTERS:{//FUN 03
 382   5                                              HandleModbusReadHoldingRegisters();
 383   5                                              break;  
 384   5                                      }
 385   4                                      case MODBUS_WRITE_SINGLE_COIL:{//FUN 05
 386   5                                              HandleModbusWriteSingleCoil();
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 98  

 387   5                                              break;
 388   5                                      }
 389   4                      case MODBUS_WRITE_SINGLE_REGISTER:{//FUN 06
 390   5                                              HandleModbusWriteSingleRegister();
 391   5                                              break;
 392   5                                      }
 393   4                                      case MODBUS_WRITE_MULTIPLE_COILS:{//FUN 15
 394   5                                              HandleModbusWriteMultipleCoils();
 395   5                                              break;
 396   5                                      }
 397   4                      case MODBUS_WRITE_MULTIPLE_REGISTERS:{//FUN 16
 398   5                                              HandleModbusWriteMultipleRegisters();
 399   5                                              break;
 400   5                                      }
 401   4                      default:{
 402   5                                              HandleModbusError(ERROR_CODE_01);
 403   5                                              break;
 404   5                                      }
 405   4                  }
 406   3              }
 407   2          }
 408   1      }
 409          void InitModbus(uint8_t modbusSlaveAddress, uint32_t baudrate){//ModBus slave initialize
 410   1          ModbusSlaveAddress = modbusSlaveAddress;
 411   1          modBusUartInitialise(baudrate);
 412   1          modBusTimerInitialise();
 413   1      }
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 99  

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION _modbusCrc16 (BEGIN)
                                           ; SOURCE LINE # 51
;---- Variable 'Data' assigned to Register 'R7' ----
                 R     MOV     CRC,R3
                 R     MOV     CRC+01H,R2
                 R     MOV     CRC+02H,R1
                                           ; SOURCE LINE # 53
                       CLR     A
                       MOV     R4,A
                       MOV     R5,A
                       MOV     R6,A
                 E     CALL    ?C?LLDPTR0
                       MOV     A,R7
                       XRL     A,R3
                       MOV     R7,A
                       MOV     A,R2
                       MOV     R6,A
                       MOV     A,R1
                       MOV     R5,A
                       MOV     A,R0
                       MOV     R4,A
                 R     MOV     R3,CRC
                 R     MOV     R2,CRC+01H
                 R     MOV     R1,CRC+02H
                 E     CALL    ?C?LSTPTR
                                           ; SOURCE LINE # 54
                       CLR     A
                 R     MOV     i+03H,#08H
                 R     MOV     i+02H,A
                 R     MOV     i+01H,A
                 R     MOV     i,A
             ?C0001:
                       CLR     A
                       MOV     R7,A
                       MOV     R6,A
                       MOV     R5,A
                       MOV     R4,A
                 R     MOV     R3,i+03H
                 R     MOV     R2,i+02H
                 R     MOV     R1,i+01H
                 R     MOV     R0,i
                       SETB    C
                 E     CALL    ?C?ULCMP
                 R     xJLT    ?C0006
                                           ; SOURCE LINE # 55
                 R     MOV     R3,CRC
                 R     MOV     R2,CRC+01H
                 R     MOV     R1,CRC+02H
                 E     CALL    ?C?LLDPTR
                       MOV     A,R7
                       ANL     A,#01H
                       MOV     R7,A
                       CLR     A
                       MOV     R6,A
                       MOV     R5,A
                       MOV     R4,A
                       MOV     A,R7
                 R     xJZ     ?C0004
                                           ; SOURCE LINE # 56
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 100 

                 E     CALL    ?C?LLDPTR
                       MOV     R0,#01H
                 E     CALL    ?C?ULSHR
                       MOV     A,R7
                       XRL     A,#01H
                       MOV     R7,A
                       MOV     A,R6
                       XRL     A,#0A0H
                       MOV     R6,A
                       MOV     A,R4
                 R     xJMP    ?C0131
             ?C0004:
                                           ; SOURCE LINE # 58
                 E     CALL    ?C?LLDPTR
                       MOV     R0,#01H
                 E     CALL    ?C?ULSHR
             ?C0131:
                 E     CALL    ?C?LSTPTR
                                           ; SOURCE LINE # 59
             ?C0003:
                 R     MOV     A,i+03H
                       ADD     A,#0FFH
                 R     MOV     i+03H,A
                 R     MOV     A,i+02H
                       ADDC    A,#0FFH
                 R     MOV     i+02H,A
                 R     MOV     A,i+01H
                       ADDC    A,#0FFH
                 R     MOV     i+01H,A
                 R     MOV     A,i
                       ADDC    A,#0FFH
                 R     MOV     i,A
                 R     xJMP    ?C0001
                                           ; SOURCE LINE # 60
             ?C0006:
                       RET     
             ; FUNCTION _modbusCrc16 (END)

             ; FUNCTION DoSlaveTX (BEGIN)
                                           ; SOURCE LINE # 61
                                           ; SOURCE LINE # 62
                       MOV     R3,#01H
                 R     MOV     R2,#HIGH Tx_Buf
                 R     MOV     R1,#LOW Tx_Buf
                 R     MOV     R4,Tx_Buf_Size+02H
                 R     MOV     R5,Tx_Buf_Size+03H
                 E     CALL    _modBusUartString
                                           ; SOURCE LINE # 63
                       CLR     A
                 R     MOV     Tx_Buf_Size+03H,A
                 R     MOV     Tx_Buf_Size+02H,A
                 R     MOV     Tx_Buf_Size+01H,A
                 R     MOV     Tx_Buf_Size,A
                                           ; SOURCE LINE # 64
                       MOV     R7,#01H
                                           ; SOURCE LINE # 65
                       RET     
             ; FUNCTION DoSlaveTX (END)

             ; FUNCTION SendMessage (BEGIN)
                                           ; SOURCE LINE # 66
                                           ; SOURCE LINE # 67
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 101 

                 R     MOV     A,Tx_State
                 R     xJZ     ?C0008
                                           ; SOURCE LINE # 68
                       MOV     R7,#00H
                       RET     
                                           ; SOURCE LINE # 69
             ?C0008:
                                           ; SOURCE LINE # 70
                       CLR     A
                 R     MOV     Tx_Current+03H,A
                 R     MOV     Tx_Current+02H,A
                 R     MOV     Tx_Current+01H,A
                 R     MOV     Tx_Current,A
                                           ; SOURCE LINE # 71
                 R     MOV     Tx_State,#01H
                                           ; SOURCE LINE # 72
                       MOV     R7,#01H
                                           ; SOURCE LINE # 73
             ?C0009:
                       RET     
             ; FUNCTION SendMessage (END)

             ; FUNCTION _HandleModbusError (BEGIN)
                                           ; SOURCE LINE # 74
;---- Variable 'ErrorCode' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 75
                       MOV     A,R7
                       ORL     A,#080H
                 R     MOV     DPTR,#Tx_Data+01H
                       MOVX    @DPTR,A
                                           ; SOURCE LINE # 76
                 R     MOV     DPTR,#Tx_Data
                 R     MOV     A,ModbusSlaveAddress
                       MOVX    @DPTR,A
                                           ; SOURCE LINE # 77
                       CLR     A
                 R     MOV     DPTR,#Tx_Data+0102H
                       MOVX    @DPTR,A
                       INC     DPTR
                       MOVX    @DPTR,A
                                           ; SOURCE LINE # 78
                 R     JMP     SendMessage
             ; FUNCTION _HandleModbusError (END)

             ; FUNCTION HandleModbusReadCoils (BEGIN)
                                           ; SOURCE LINE # 81
                                           ; SOURCE LINE # 83
;---- Variable 'tempData' assigned to Register 'R1' ----
                       CLR     A
                       MOV     R1,A
                                           ; SOURCE LINE # 85
                 R     MOV     DPTR,#Rx_Data+02H
                       MOVX    A,@DPTR
                       MOV     R6,A
                       INC     DPTR
                       MOVX    A,@DPTR
                       MOV     R4,#00H
                       ADD     A,#00H
                       MOV     R7,A
                       MOV     A,R4
                       ADDC    A,R6
;---- Variable 'startAddress' assigned to Register 'R4/R5' ----
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 102 

                       MOV     R5,AR7
                       MOV     R4,A
                                           ; SOURCE LINE # 86
                       INC     DPTR
                       MOVX    A,@DPTR
                       MOV     R6,A
                       INC     DPTR
                       MOVX    A,@DPTR
                       MOV     R2,#00H
                       ADD     A,#00H
                       MOV     R7,A
                       MOV     A,R2
                       ADDC    A,R6
;---- Variable 'numberOfCoil' assigned to Register 'R2/R3' ----
                       MOV     R3,AR7
                       MOV     R2,A
                                           ; SOURCE LINE # 87
                       MOV     A,R5
                       ADD     A,R3
                       MOV     R7,A
                       MOV     A,R4
                       ADDC    A,R2
                       MOV     R6,A
                       SETB    C
                       MOV     A,R7
                       SUBB    A,#060H
                       MOV     A,R6
                       SUBB    A,#030H
                 R     xJLT    ?C0011
                                           ; SOURCE LINE # 88
                       MOV     R7,#02H
                 R     JMP     _HandleModbusError
                                           ; SOURCE LINE # 89
             ?C0011:
                                           ; SOURCE LINE # 90
                                           ; SOURCE LINE # 91
                       MOV     R6,AR2
                       MOV     A,R3
                       MOV     R0,#03H
             ?C0102:
                       XCH     A,R6
                       CLR     C
                       RRC     A
                       XCH     A,R6
                       RRC     A
                 R     DJNZ    R0,?C0102
                 R     MOV     byteCount+01H,A
                 R     MOV     byteCount,R6
                                           ; SOURCE LINE # 92
                       MOV     A,R3
                       ANL     A,#07H
                 R     xJZ     ?C0013
                                           ; SOURCE LINE # 93
                 R     INC     byteCount+01H
                 R     MOV     A,byteCount+01H
                 R     JNZ     ?C0103
                 R     INC     byteCount
             ?C0103:
                                           ; SOURCE LINE # 94
             ?C0013:
                                           ; SOURCE LINE # 95
                 R     MOV     DPTR,#Tx_Data+01H
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 103 

                       MOV     A,#01H
                       MOVX    @DPTR,A
                                           ; SOURCE LINE # 96
                 R     MOV     DPTR,#Tx_Data
                 R     MOV     A,ModbusSlaveAddress
                       MOVX    @DPTR,A
                                           ; SOURCE LINE # 97
                 R     MOV     DPTR,#Tx_Data+0102H
                       CLR     A
                       MOVX    @DPTR,A
                       INC     DPTR
                       INC     A
                       MOVX    @DPTR,A
                                           ; SOURCE LINE # 98
                 R     MOV     tempAddr,R4
                 R     MOV     tempAddr+01H,R5
                                           ; SOURCE LINE # 99
                       CLR     A
                 R     MOV     i,A
                 R     MOV     i+01H,A
             ?C0014:
                       CLR     C
                 R     MOV     A,i+01H
                 R     SUBB    A,byteCount+01H
                 R     MOV     A,i
                 R     SUBB    A,byteCount
                 R     xJGE    ?C0015
                                           ; SOURCE LINE # 100
                 R     MOV     DPTR,#Tx_Data+0102H
                       MOVX    A,@DPTR
                       MOV     R6,A
                       INC     DPTR
                       MOVX    A,@DPTR
                 R     ADD     A,#LOW Tx_Data+02H
                       MOV     DPL,A
                 R     MOV     A,#HIGH Tx_Data+02H
                       ADDC    A,R6
                       MOV     DPH,A
                       CLR     A
                       MOVX    @DPTR,A
                                           ; SOURCE LINE # 101
;---- Variable 'j' assigned to Register 'R4/R5' ----
                       MOV     R5,A
                       MOV     R4,A
             ?C0017:
                                           ; SOURCE LINE # 102
                 R     MOV     A,tempAddr
                       SWAP    A
                       MOV     R0,A
                       ANL     A,#0F0H
                       XCH     A,R0
                       XRL     A,R0
                       MOV     R6,A
                 R     MOV     A,tempAddr+01H
                       SWAP    A
                       ANL     A,#0FH
                       ORL     A,R0
                       ADD     A,ACC
                       MOV     R7,A
                       MOV     A,R6
                       RLC     A
                       MOV     R6,A
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 104 

                 E     MOV     A,#LOW NVRAM0
                       ADD     A,R7
                       MOV     DPL,A
                 E     MOV     A,#HIGH NVRAM0
                       ADDC    A,R6
                       MOV     DPH,A
                       MOVX    A,@DPTR
                       MOV     R6,A
                       INC     DPTR
                       MOVX    A,@DPTR
                       MOV     R7,A
                 R     MOV     A,tempAddr+01H
                       ANL     A,#0FH
                       MOV     R3,A
                       MOV     A,R7
                       MOV     R0,AR3
                       INC     R0
                 R     xJMP    ?C0105
             ?C0104:
                       XCH     A,R6
                       MOV     C,ACC.7
                       RRC     A
                       XCH     A,R6
                       RRC     A
             ?C0105:
                 R     DJNZ    R0,?C0104
                       ANL     A,#01H
                       MOV     R1,A
                                           ; SOURCE LINE # 103
                 R     MOV     DPTR,#Tx_Data+0102H
                       MOVX    A,@DPTR
                       MOV     R6,A
                       INC     DPTR
                       MOVX    A,@DPTR
                 R     ADD     A,#LOW Tx_Data+02H
                       MOV     DPL,A
                 R     MOV     A,#HIGH Tx_Data+02H
                       ADDC    A,R6
                       MOV     DPH,A
                       MOVX    A,@DPTR
                       MOV     R7,A
                       MOV     R6,AR5
                       MOV     R0,AR6
                       MOV     A,R1
                       INC     R0
                 R     xJMP    ?C0107
             ?C0106:
                       CLR     C
                       RLC     A
             ?C0107:
                 R     DJNZ    R0,?C0106
                       ORL     A,R7
                       MOVX    @DPTR,A
                                           ; SOURCE LINE # 104
                 R     INC     tempAddr+01H
                 R     MOV     A,tempAddr+01H
                 R     JNZ     ?C0108
                 R     INC     tempAddr
             ?C0108:
                                           ; SOURCE LINE # 109
                       INC     R5
                 R     CJNE    R5,#00H,?C0109
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 105 

                       INC     R4
             ?C0109:
                       MOV     A,R5
                       XRL     A,#08H
                       ORL     A,R4
                 R     xJNZ    ?C0017
             ?C0018:
                                           ; SOURCE LINE # 110
                 R     MOV     DPTR,#Tx_Data+0103H
                       MOVX    A,@DPTR
                       INC     A
                       MOVX    @DPTR,A
                 R     JNZ     ?C0110
                 R     MOV     DPTR,#Tx_Data+0102H
                       MOVX    A,@DPTR
                       INC     A
                       MOVX    @DPTR,A
             ?C0110:
                                           ; SOURCE LINE # 111
                 R     INC     i+01H
                 R     MOV     A,i+01H
                 R     JNZ     ?C0111
                 R     INC     i
             ?C0111:
                 R     xJMP    ?C0014
             ?C0015:
                                           ; SOURCE LINE # 112
                 R     MOV     DPTR,#Tx_Data+0102H
                       INC     DPTR
                       MOVX    A,@DPTR
                       DEC     A
                 R     MOV     DPTR,#Tx_Data+02H
                       MOVX    @DPTR,A
                                           ; SOURCE LINE # 113
                 R     CALL    SendMessage
                                           ; SOURCE LINE # 114
                                           ; SOURCE LINE # 115
             ?C0020:
                       RET     
             ; FUNCTION HandleModbusReadCoils (END)

             ; FUNCTION HandleModbusReadInputCoil (BEGIN)
                                           ; SOURCE LINE # 116
                                           ; SOURCE LINE # 117
                       RET     
             ; FUNCTION HandleModbusReadInputCoil (END)

             ; FUNCTION HandleModbusReadHoldingRegisters (BEGIN)
                                           ; SOURCE LINE # 118
                                           ; SOURCE LINE # 121
                 R     MOV     DPTR,#Rx_Data+02H
                       MOVX    A,@DPTR
                       MOV     R6,A
                       INC     DPTR
                       MOVX    A,@DPTR
                       MOV     R4,#00H
                       ADD     A,#00H
                 R     MOV     startAddress+01H,A
                       MOV     A,R4
                       ADDC    A,R6
                 R     MOV     startAddress,A
                                           ; SOURCE LINE # 122
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 106 

                       INC     DPTR
                       MOVX    A,@DPTR
                       MOV     R6,A
                       INC     DPTR
                       MOVX    A,@DPTR
                       ADD     A,#00H
                 R     MOV     numberOfRegisters+01H,A
                       MOV     A,R4
                       ADDC    A,R6
                 R     MOV     numberOfRegisters,A
                                           ; SOURCE LINE # 123
                 R     MOV     A,startAddress+01H
                 R     ADD     A,numberOfRegisters+01H
                       MOV     R7,A
                 R     MOV     A,startAddress
                 R     ADDC    A,numberOfRegisters
                       MOV     R6,A
                       SETB    C
                       MOV     A,R7
                       SUBB    A,#06H
                       MOV     A,R6
                       SUBB    A,#03H
                 R     xJLT    ?C0022
                                           ; SOURCE LINE # 124
                       MOV     R7,#02H
                 R     JMP     _HandleModbusError
                                           ; SOURCE LINE # 125
             ?C0022:
                                           ; SOURCE LINE # 126
                                           ; SOURCE LINE # 127
                 R     MOV     DPTR,#Tx_Data+01H
                       MOV     A,#03H
                       MOVX    @DPTR,A
                                           ; SOURCE LINE # 128
                 R     MOV     DPTR,#Tx_Data
                 R     MOV     A,ModbusSlaveAddress
                       MOVX    @DPTR,A
                                           ; SOURCE LINE # 129
                 R     MOV     DPTR,#Tx_Data+0102H
                       CLR     A
                       MOVX    @DPTR,A
                       INC     DPTR
                       INC     A
                       MOVX    @DPTR,A
                                           ; SOURCE LINE # 130
                       CLR     A
                 R     MOV     DPTR,#Tx_Data+02H
                       MOVX    @DPTR,A
                                           ; SOURCE LINE # 131
;---- Variable 'i' assigned to Register 'R4/R5' ----
                       MOV     R5,A
                       MOV     R4,A
             ?C0024:
                       CLR     C
                       MOV     A,R5
                 R     SUBB    A,numberOfRegisters+01H
                       MOV     A,R4
                 R     SUBB    A,numberOfRegisters
                 R     xJGE    ?C0025
                                           ; SOURCE LINE # 132
                 R     MOV     A,startAddress+01H
                       ADD     A,R5
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 107 

                       MOV     R7,A
                 R     MOV     A,startAddress
                       ADDC    A,R4
                       MOV     R6,A
                       MOV     A,R7
                       ADD     A,ACC
                       MOV     R7,A
                       MOV     A,R6
                       RLC     A
                       MOV     R6,A
                 E     MOV     A,#LOW NVRAM0
                       ADD     A,R7
                       MOV     DPL,A
                 E     MOV     A,#HIGH NVRAM0
                       ADDC    A,R6
                       MOV     DPH,A
                       MOVX    A,@DPTR
                       MOV     R6,A
                       INC     DPTR
                       MOVX    A,@DPTR
                 R     MOV     currentData,R6
                 R     MOV     currentData+01H,A
                                           ; SOURCE LINE # 133
                       MOV     A,R6
                       MOV     R7,A
                 R     MOV     DPTR,#Tx_Data+0102H
                       MOVX    A,@DPTR
                       MOV     R2,A
                       INC     DPTR
                       MOVX    A,@DPTR
                       MOV     R3,A
                 R     ADD     A,#LOW Tx_Data+02H
                       MOV     DPL,A
                 R     MOV     A,#HIGH Tx_Data+02H
                       ADDC    A,R2
                       MOV     DPH,A
                       MOV     A,R7
                       MOVX    @DPTR,A
                                           ; SOURCE LINE # 134
                 R     MOV     A,#LOW Tx_Data+03H
                       ADD     A,R3
                       MOV     DPL,A
                 R     MOV     A,#HIGH Tx_Data+03H
                       ADDC    A,R2
                       MOV     DPH,A
                 R     MOV     A,currentData+01H
                       MOVX    @DPTR,A
                                           ; SOURCE LINE # 135
                 R     MOV     DPTR,#Tx_Data+0103H
                       MOVX    A,@DPTR
                       ADD     A,#02H
                       MOVX    @DPTR,A
                 R     MOV     DPTR,#Tx_Data+0102H
                       MOVX    A,@DPTR
                       ADDC    A,#00H
                       MOVX    @DPTR,A
                                           ; SOURCE LINE # 136
                       INC     DPTR
                       MOVX    A,@DPTR
                       DEC     A
                 R     MOV     DPTR,#Tx_Data+02H
                       MOVX    @DPTR,A
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 108 

                                           ; SOURCE LINE # 137
                       INC     R5
                 R     CJNE    R5,#00H,?C0112
                       INC     R4
             ?C0112:
                 R     xJMP    ?C0024
             ?C0025:
                                           ; SOURCE LINE # 138
                 R     CALL    SendMessage
                                           ; SOURCE LINE # 139
                                           ; SOURCE LINE # 140
             ?C0027:
                       RET     
             ; FUNCTION HandleModbusReadHoldingRegisters (END)

             ; FUNCTION HandleModbusWriteSingleCoil (BEGIN)
                                           ; SOURCE LINE # 141
                                           ; SOURCE LINE # 144
                 R     MOV     DPTR,#Rx_Data+02H
                       MOVX    A,@DPTR
                       MOV     R6,A
                       INC     DPTR
                       MOVX    A,@DPTR
                       MOV     R4,#00H
                       ADD     A,#00H
                 R     MOV     startAddress+01H,A
                       MOV     A,R4
                       ADDC    A,R6
                 R     MOV     startAddress,A
                                           ; SOURCE LINE # 145
                       INC     DPTR
                       MOVX    A,@DPTR
                       MOV     R6,A
                       INC     DPTR
                       MOVX    A,@DPTR
                       ADD     A,#00H
                 R     MOV     value+01H,A
                       MOV     A,R4
                       ADDC    A,R6
                 R     MOV     value,A
                                           ; SOURCE LINE # 146
                       SETB    C
                 R     MOV     A,startAddress+01H
                       SUBB    A,#060H
                 R     MOV     A,startAddress
                       SUBB    A,#030H
                 R     xJLT    ?C0028
                                           ; SOURCE LINE # 147
                       MOV     R7,#02H
                 R     JMP     _HandleModbusError
                                           ; SOURCE LINE # 148
             ?C0028:
                                           ; SOURCE LINE # 149
                                           ; SOURCE LINE # 150
                 R     MOV     DPTR,#Tx_Data+01H
                       MOV     A,#05H
                       MOVX    @DPTR,A
                                           ; SOURCE LINE # 151
                 R     MOV     DPTR,#Tx_Data
                 R     MOV     A,ModbusSlaveAddress
                       MOVX    @DPTR,A
                                           ; SOURCE LINE # 152
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 109 

                 R     MOV     DPTR,#Tx_Data+0102H
                       CLR     A
                       MOVX    @DPTR,A
                       INC     DPTR
                       MOV     A,#04H
                       MOVX    @DPTR,A
                                           ; SOURCE LINE # 153
                 R     MOV     DPTR,#Rx_Data+02H
                       MOVX    A,@DPTR
                 R     MOV     DPTR,#Tx_Data+02H
                       MOVX    @DPTR,A
                                           ; SOURCE LINE # 154
                 R     MOV     DPTR,#Rx_Data+03H
                       MOVX    A,@DPTR
                 R     MOV     DPTR,#Tx_Data+03H
                       MOVX    @DPTR,A
                                           ; SOURCE LINE # 155
                 R     MOV     A,value+01H
                 R     ORL     A,value
                 R     xJNZ    ?C0030
                                           ; SOURCE LINE # 156
                 R     MOV     A,startAddress
                       SWAP    A
                       MOV     R0,A
                       ANL     A,#0F0H
                       XCH     A,R0
                       XRL     A,R0
                       MOV     R6,A
                 R     MOV     A,startAddress+01H
                       SWAP    A
                       ANL     A,#0FH
                       ORL     A,R0
                       ADD     A,ACC
                       MOV     R7,A
                       MOV     A,R6
                       RLC     A
                       MOV     R6,A
                 E     MOV     A,#LOW NVRAM0
                       ADD     A,R7
                       MOV     DPL,A
                 E     MOV     A,#HIGH NVRAM0
                       ADDC    A,R6
                       MOV     DPH,A
                       PUSH    DPH
                       PUSH    DPL
                       MOVX    A,@DPTR
                       MOV     R4,A
                       INC     DPTR
                       MOVX    A,@DPTR
                       MOV     R5,A
                 R     MOV     A,startAddress+01H
                       ANL     A,#0FH
                       MOV     R7,A
                       MOV     R6,#00H
                       MOV     A,#01H
                       MOV     R0,AR7
                       INC     R0
                 R     xJMP    ?C0114
             ?C0113:
                       CLR     C
                       RLC     A
                       XCH     A,R6
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 110 

                       RLC     A
                       XCH     A,R6
             ?C0114:
                 R     DJNZ    R0,?C0113
                       CPL     A
                       MOV     R7,A
                       MOV     A,R6
                       CPL     A
                       ANL     A,R4
                       MOV     R6,A
                       MOV     A,R5
                       ANL     A,R7
                       MOV     R7,A
                       POP     DPL
                       POP     DPH
                       MOV     A,R6
                       MOVX    @DPTR,A
                       INC     DPTR
                       MOV     A,R7
                       MOVX    @DPTR,A
                                           ; SOURCE LINE # 157
                       CLR     A
                 R     MOV     DPTR,#Tx_Data+04H
                       MOVX    @DPTR,A
                                           ; SOURCE LINE # 158
                       INC     DPTR
                       MOVX    @DPTR,A
                                           ; SOURCE LINE # 159
                 R     xJMP    ?C0031
             ?C0030:
                                           ; SOURCE LINE # 160
                       CLR     A
                 R     xJNE    A,value+01H,?C0031
                 R     MOV     A,value
                 R     xJNE    A,#0FFH,?C0031
                                           ; SOURCE LINE # 161
                 R     MOV     A,startAddress
                       SWAP    A
                       MOV     R0,A
                       ANL     A,#0F0H
                       XCH     A,R0
                       XRL     A,R0
                       MOV     R6,A
                 R     MOV     A,startAddress+01H
                       SWAP    A
                       ANL     A,#0FH
                       ORL     A,R0
                       ADD     A,ACC
                       MOV     R7,A
                       MOV     A,R6
                       RLC     A
                       MOV     R6,A
                 E     MOV     A,#LOW NVRAM0
                       ADD     A,R7
                       MOV     DPL,A
                 E     MOV     A,#HIGH NVRAM0
                       ADDC    A,R6
                       MOV     DPH,A
                       PUSH    DPH
                       PUSH    DPL
                       MOVX    A,@DPTR
                       MOV     R4,A
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 111 

                       INC     DPTR
                       MOVX    A,@DPTR
                       MOV     R5,A
                 R     MOV     A,startAddress+01H
                       ANL     A,#0FH
                       MOV     R7,A
                       MOV     R6,#00H
                       MOV     A,#01H
                       MOV     R0,AR7
                       INC     R0
                 R     xJMP    ?C0117
             ?C0116:
                       CLR     C
                       RLC     A
                       XCH     A,R6
                       RLC     A
                       XCH     A,R6
             ?C0117:
                 R     DJNZ    R0,?C0116
                       MOV     R7,A
                       MOV     A,R4
                       ORL     A,R6
                       MOV     R6,A
                       MOV     A,R5
                       ORL     A,R7
                       MOV     R7,A
                       POP     DPL
                       POP     DPH
                       MOV     A,R6
                       MOVX    @DPTR,A
                       INC     DPTR
                       MOV     A,R7
                       MOVX    @DPTR,A
                                           ; SOURCE LINE # 162
                 R     MOV     DPTR,#Tx_Data+04H
                       MOV     A,#0FFH
                       MOVX    @DPTR,A
                                           ; SOURCE LINE # 163
                       CLR     A
                       INC     DPTR
                       MOVX    @DPTR,A
                                           ; SOURCE LINE # 164
                                           ; SOURCE LINE # 165
                                           ; SOURCE LINE # 166
             ?C0031:
                                           ; SOURCE LINE # 167
                 R     CALL    SendMessage
                                           ; SOURCE LINE # 168
                                           ; SOURCE LINE # 169
             ?C0034:
                       RET     
             ; FUNCTION HandleModbusWriteSingleCoil (END)

             ; FUNCTION HandleModbusWriteSingleRegister (BEGIN)
                                           ; SOURCE LINE # 170
                                           ; SOURCE LINE # 173
                 R     MOV     DPTR,#Rx_Data+02H
                       MOVX    A,@DPTR
                       MOV     R6,A
                       INC     DPTR
                       MOVX    A,@DPTR
                       MOV     R4,#00H
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 112 

                       ADD     A,#00H
                       MOV     R7,A
                       MOV     A,R4
                       ADDC    A,R6
;---- Variable 'address' assigned to Register 'R4/R5' ----
                       MOV     R5,AR7
                       MOV     R4,A
                                           ; SOURCE LINE # 174
                       INC     DPTR
                       MOVX    A,@DPTR
                       MOV     R6,A
                       INC     DPTR
                       MOVX    A,@DPTR
                       MOV     R2,#00H
                       ADD     A,#00H
                       MOV     R7,A
                       MOV     A,R2
                       ADDC    A,R6
                       MOV     R6,A
;---- Variable 'value' assigned to Register 'R6/R7' ----
                                           ; SOURCE LINE # 176
                 R     MOV     DPTR,#Tx_Data+01H
                       MOV     A,#06H
                       MOVX    @DPTR,A
                                           ; SOURCE LINE # 177
                 R     MOV     DPTR,#Tx_Data
                 R     MOV     A,ModbusSlaveAddress
                       MOVX    @DPTR,A
                                           ; SOURCE LINE # 178
                 R     MOV     DPTR,#Tx_Data+0102H
                       CLR     A
                       MOVX    @DPTR,A
                       INC     DPTR
                       MOV     A,#04H
                       MOVX    @DPTR,A
                                           ; SOURCE LINE # 179
                       CLR     C
                       MOV     A,R5
                       SUBB    A,#06H
                       MOV     A,R4
                       SUBB    A,#03H
                 R     xJLT    ?C0035
                                           ; SOURCE LINE # 180
                       MOV     R7,#03H
                 R     CALL    _HandleModbusError
                                           ; SOURCE LINE # 181
                 R     xJMP    ?C0036
             ?C0035:
                                           ; SOURCE LINE # 182
                                           ; SOURCE LINE # 183
                       MOV     R2,AR6
                       MOV     R3,AR7
                       MOV     A,R5
                       ADD     A,ACC
                       MOV     R7,A
                       MOV     A,R4
                       RLC     A
                       MOV     R6,A
                 E     MOV     A,#LOW NVRAM0
                       ADD     A,R7
                       MOV     DPL,A
                 E     MOV     A,#HIGH NVRAM0
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 113 

                       ADDC    A,R6
                       MOV     DPH,A
                       MOV     A,R2
                       MOVX    @DPTR,A
                       INC     DPTR
                       MOV     A,R3
                       MOVX    @DPTR,A
                                           ; SOURCE LINE # 185
;---- Variable 'i' assigned to Register 'R6/R7' ----
                       CLR     A
                       MOV     R7,A
                       MOV     R6,A
             ?C0037:
                                           ; SOURCE LINE # 186
                 R     MOV     A,#LOW Rx_Data+02H
                       ADD     A,R7
                       MOV     DPL,A
                 R     MOV     A,#HIGH Rx_Data+02H
                       ADDC    A,R6
                       MOV     DPH,A
                       MOVX    A,@DPTR
                       MOV     R5,A
                 R     MOV     A,#LOW Tx_Data+02H
                       ADD     A,R7
                       MOV     DPL,A
                 R     MOV     A,#HIGH Tx_Data+02H
                       ADDC    A,R6
                       MOV     DPH,A
                       MOV     A,R5
                       MOVX    @DPTR,A
                                           ; SOURCE LINE # 187
                       INC     R7
                 R     CJNE    R7,#00H,?C0118
                       INC     R6
             ?C0118:
                       MOV     A,R7
                       XRL     A,#04H
                       ORL     A,R6
                 R     xJNZ    ?C0037
                                           ; SOURCE LINE # 188
             ?C0036:
                                           ; SOURCE LINE # 189
                 R     JMP     SendMessage
             ; FUNCTION HandleModbusWriteSingleRegister (END)

             ; FUNCTION HandleModbusWriteMultipleCoils (BEGIN)
                                           ; SOURCE LINE # 191
                                           ; SOURCE LINE # 193
                       CLR     A
                 R     MOV     tempData,A
                                           ; SOURCE LINE # 195
                 R     MOV     DPTR,#Rx_Data+02H
                       MOVX    A,@DPTR
                       MOV     R6,A
                       INC     DPTR
                       MOVX    A,@DPTR
                       MOV     R4,#00H
                       ADD     A,#00H
                       MOV     R7,A
                       MOV     A,R4
                       ADDC    A,R6
;---- Variable 'startAddress' assigned to Register 'R4/R5' ----
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 114 

                       MOV     R5,AR7
                       MOV     R4,A
                                           ; SOURCE LINE # 196
                       INC     DPTR
                       MOVX    A,@DPTR
                       MOV     R6,A
                       INC     DPTR
                       MOVX    A,@DPTR
                       MOV     R1,A
                       MOV     R2,#00H
                       ADD     A,#00H
                 R     MOV     numberOfCoil+01H,A
                       MOV     A,R2
                       ADDC    A,R6
                 R     MOV     numberOfCoil,A
                                           ; SOURCE LINE # 197
                 R     MOV     A,numberOfCoil+01H
                       ADD     A,R5
                       MOV     R7,A
                 R     MOV     A,numberOfCoil
                       ADDC    A,R4
                       MOV     R6,A
                       SETB    C
                       MOV     A,R7
                       SUBB    A,#060H
                       MOV     A,R6
                       SUBB    A,#030H
                 R     xJLT    ?C0041
                                           ; SOURCE LINE # 198
                       MOV     R7,#02H
                 R     JMP     _HandleModbusError
                                           ; SOURCE LINE # 199
             ?C0041:
                                           ; SOURCE LINE # 200
                                           ; SOURCE LINE # 201
                 R     MOV     R6,numberOfCoil
                 R     MOV     A,numberOfCoil+01H
                       MOV     R0,#03H
             ?C0119:
                       XCH     A,R6
                       CLR     C
                       RRC     A
                       XCH     A,R6
                       RRC     A
                 R     DJNZ    R0,?C0119
                 R     MOV     byteCount+01H,A
                 R     MOV     byteCount,R6
                                           ; SOURCE LINE # 202
                 R     MOV     A,numberOfCoil+01H
                       ANL     A,#07H
                 R     xJZ     ?C0043
                                           ; SOURCE LINE # 203
                 R     INC     byteCount+01H
                 R     MOV     A,byteCount+01H
                 R     JNZ     ?C0120
                 R     INC     byteCount
             ?C0120:
                                           ; SOURCE LINE # 204
             ?C0043:
                                           ; SOURCE LINE # 205
                 R     MOV     DPTR,#Tx_Data+01H
                       MOV     A,#0FH
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 115 

                       MOVX    @DPTR,A
                                           ; SOURCE LINE # 206
                 R     MOV     DPTR,#Tx_Data
                 R     MOV     A,ModbusSlaveAddress
                       MOVX    @DPTR,A
                                           ; SOURCE LINE # 207
                 R     MOV     DPTR,#Tx_Data+0102H
                       CLR     A
                       MOVX    @DPTR,A
                       INC     DPTR
                       MOV     A,#04H
                       MOVX    @DPTR,A
                                           ; SOURCE LINE # 208
                 R     MOV     DPTR,#Rx_Data+02H
                       MOVX    A,@DPTR
                 R     MOV     DPTR,#Tx_Data+02H
                       MOVX    @DPTR,A
                                           ; SOURCE LINE # 209
                 R     MOV     DPTR,#Rx_Data+03H
                       MOVX    A,@DPTR
                 R     MOV     DPTR,#Tx_Data+03H
                       MOVX    @DPTR,A
                                           ; SOURCE LINE # 210
                 R     MOV     DPTR,#Rx_Data+04H
                       MOVX    A,@DPTR
                 R     MOV     DPTR,#Tx_Data+04H
                       MOVX    @DPTR,A
                                           ; SOURCE LINE # 211
                       INC     DPTR
                       MOV     A,R1
                       MOVX    @DPTR,A
                                           ; SOURCE LINE # 212
                 R     MOV     tempAddr,R4
                 R     MOV     tempAddr+01H,R5
                                           ; SOURCE LINE # 213
                       CLR     A
                 R     MOV     i,A
                 R     MOV     i+01H,A
             ?C0044:
                       CLR     C
                 R     MOV     A,i+01H
                 R     SUBB    A,byteCount+01H
                 R     MOV     A,i
                 R     SUBB    A,byteCount
                 R     xJGE    ?C0045
                                           ; SOURCE LINE # 214
                       CLR     A
                 R     MOV     j,A
                 R     MOV     j+01H,A
             ?C0047:
                                           ; SOURCE LINE # 215
                 R     MOV     R7,j+01H
                 R     MOV     A,#LOW Rx_Data+07H
                 R     ADD     A,i+01H
                       MOV     DPL,A
                 R     MOV     A,#HIGH Rx_Data+07H
                 R     ADDC    A,i
                       MOV     DPH,A
                       MOVX    A,@DPTR
                       MOV     R6,A
                       MOV     R0,AR7
                       INC     R0
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 116 

                 R     xJMP    ?C0122
             ?C0121:
                       CLR     C
                       RRC     A
             ?C0122:
                 R     DJNZ    R0,?C0121
                       ANL     A,#01H
                 R     MOV     tempData,A
                                           ; SOURCE LINE # 216
                 R     xJZ     ?C0050
                                           ; SOURCE LINE # 217
                 R     MOV     A,tempAddr
                       SWAP    A
                       MOV     R0,A
                       ANL     A,#0F0H
                       XCH     A,R0
                       XRL     A,R0
                       MOV     R6,A
                 R     MOV     A,tempAddr+01H
                       SWAP    A
                       ANL     A,#0FH
                       ORL     A,R0
                       ADD     A,ACC
                       MOV     R7,A
                       MOV     A,R6
                       RLC     A
                       MOV     R6,A
                 E     MOV     A,#LOW NVRAM0
                       ADD     A,R7
                       MOV     DPL,A
                 E     MOV     A,#HIGH NVRAM0
                       ADDC    A,R6
                       MOV     DPH,A
                       PUSH    DPH
                       PUSH    DPL
                       MOVX    A,@DPTR
                       MOV     R4,A
                       INC     DPTR
                       MOVX    A,@DPTR
                       MOV     R5,A
                 R     MOV     A,tempAddr+01H
                       ANL     A,#0FH
                       MOV     R7,A
                       MOV     R6,#00H
                       MOV     A,#01H
                       MOV     R0,AR7
                       INC     R0
                 R     xJMP    ?C0124
             ?C0123:
                       CLR     C
                       RLC     A
                       XCH     A,R6
                       RLC     A
                       XCH     A,R6
             ?C0124:
                 R     DJNZ    R0,?C0123
                       MOV     R7,A
                       MOV     A,R4
                       ORL     A,R6
                       MOV     R6,A
                       MOV     A,R5
                       ORL     A,R7
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 117 

                                           ; SOURCE LINE # 218
                 R     xJMP    ?C0132
             ?C0050:
                                           ; SOURCE LINE # 219
                                           ; SOURCE LINE # 220
                 R     MOV     A,tempAddr
                       SWAP    A
                       MOV     R0,A
                       ANL     A,#0F0H
                       XCH     A,R0
                       XRL     A,R0
                       MOV     R6,A
                 R     MOV     A,tempAddr+01H
                       SWAP    A
                       ANL     A,#0FH
                       ORL     A,R0
                       ADD     A,ACC
                       MOV     R7,A
                       MOV     A,R6
                       RLC     A
                       MOV     R6,A
                 E     MOV     A,#LOW NVRAM0
                       ADD     A,R7
                       MOV     DPL,A
                 E     MOV     A,#HIGH NVRAM0
                       ADDC    A,R6
                       MOV     DPH,A
                       PUSH    DPH
                       PUSH    DPL
                       MOVX    A,@DPTR
                       MOV     R4,A
                       INC     DPTR
                       MOVX    A,@DPTR
                       MOV     R5,A
                 R     MOV     A,tempAddr+01H
                       ANL     A,#0FH
                       MOV     R7,A
                       MOV     R6,#00H
                       MOV     A,#01H
                       MOV     R0,AR7
                       INC     R0
                 R     xJMP    ?C0126
             ?C0125:
                       CLR     C
                       RLC     A
                       XCH     A,R6
                       RLC     A
                       XCH     A,R6
             ?C0126:
                 R     DJNZ    R0,?C0125
                       CPL     A
                       MOV     R7,A
                       MOV     A,R6
                       CPL     A
                       ANL     A,R4
                       MOV     R6,A
                       MOV     A,R5
                       ANL     A,R7
             ?C0132:
                       MOV     R7,A
                       POP     DPL
                       POP     DPH
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 118 

                       MOV     A,R6
                       MOVX    @DPTR,A
                       INC     DPTR
                       MOV     A,R7
                       MOVX    @DPTR,A
                                           ; SOURCE LINE # 221
             ?C0051:
                                           ; SOURCE LINE # 222
                 R     INC     tempAddr+01H
                 R     MOV     A,tempAddr+01H
                 R     JNZ     ?C0127
                 R     INC     tempAddr
             ?C0127:
                                           ; SOURCE LINE # 223
                 R     MOV     A,numberOfCoil+01H
                 R     DEC     numberOfCoil+01H
                 R     JNZ     ?C0128
                 R     DEC     numberOfCoil
             ?C0128:
                                           ; SOURCE LINE # 224
                 R     MOV     A,numberOfCoil+01H
                 R     ORL     A,numberOfCoil
                 R     xJZ     ?C0046
                                           ; SOURCE LINE # 225
                                           ; SOURCE LINE # 226
                                           ; SOURCE LINE # 227
                 R     INC     j+01H
                 R     MOV     A,j+01H
                 R     JNZ     ?C0129
                 R     INC     j
             ?C0129:
                       XRL     A,#08H
                 R     ORL     A,j
                 R     xJNZ    ?C0047
                                           ; SOURCE LINE # 229
             ?C0046:
                 R     INC     i+01H
                 R     MOV     A,i+01H
                 R     JNZ     ?C0130
                 R     INC     i
             ?C0130:
                 R     xJMP    ?C0044
             ?C0045:
                                           ; SOURCE LINE # 230
                 R     CALL    SendMessage
                                           ; SOURCE LINE # 231
                                           ; SOURCE LINE # 232
             ?C0053:
                       RET     
             ; FUNCTION HandleModbusWriteMultipleCoils (END)

             ; FUNCTION HandleModbusWriteMultipleRegisters (BEGIN)
                                           ; SOURCE LINE # 233
                                           ; SOURCE LINE # 238
                 R     MOV     DPTR,#Rx_Data+02H
                       MOVX    A,@DPTR
                       MOV     R6,A
                       INC     DPTR
                       MOVX    A,@DPTR
                       MOV     R4,#00H
                       ADD     A,#00H
                 R     MOV     startAddress+01H,A
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 119 

                       MOV     A,R4
                       ADDC    A,R6
                 R     MOV     startAddress,A
                                           ; SOURCE LINE # 239
                       INC     DPTR
                       MOVX    A,@DPTR
                       MOV     R1,A
                       MOV     R6,A
                       INC     DPTR
                       MOVX    A,@DPTR
                       MOV     R5,A
                       MOV     R2,#00H
                       ADD     A,#00H
                 R     MOV     numberOfRegisters+01H,A
                       MOV     A,R2
                       ADDC    A,R6
                 R     MOV     numberOfRegisters,A
                                           ; SOURCE LINE # 240
                       INC     DPTR
                       MOVX    A,@DPTR
                 R     MOV     byteCount,A
                                           ; SOURCE LINE # 242
                 R     MOV     A,startAddress+01H
                 R     ADD     A,numberOfRegisters+01H
                       MOV     R7,A
                 R     MOV     A,startAddress
                 R     ADDC    A,numberOfRegisters
                       MOV     R6,A
                       SETB    C
                       MOV     A,R7
                       SUBB    A,#06H
                       MOV     A,R6
                       SUBB    A,#03H
                 R     xJLT    ?C0054
                                           ; SOURCE LINE # 243
                       MOV     R7,#03H
                 R     JMP     _HandleModbusError
                                           ; SOURCE LINE # 244
             ?C0054:
                                           ; SOURCE LINE # 245
                                           ; SOURCE LINE # 247
                 R     MOV     DPTR,#Tx_Data+01H
                       MOV     A,#010H
                       MOVX    @DPTR,A
                                           ; SOURCE LINE # 248
                 R     MOV     DPTR,#Tx_Data
                 R     MOV     A,ModbusSlaveAddress
                       MOVX    @DPTR,A
                                           ; SOURCE LINE # 249
                 R     MOV     DPTR,#Tx_Data+0102H
                       CLR     A
                       MOVX    @DPTR,A
                       INC     DPTR
                       MOV     A,#04H
                       MOVX    @DPTR,A
                                           ; SOURCE LINE # 250
                 R     MOV     DPTR,#Rx_Data+02H
                       MOVX    A,@DPTR
                 R     MOV     DPTR,#Tx_Data+02H
                       MOVX    @DPTR,A
                                           ; SOURCE LINE # 251
                 R     MOV     DPTR,#Rx_Data+03H
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 120 

                       MOVX    A,@DPTR
                 R     MOV     DPTR,#Tx_Data+03H
                       MOVX    @DPTR,A
                                           ; SOURCE LINE # 252
                       INC     DPTR
                       MOV     A,R1
                       MOVX    @DPTR,A
                                           ; SOURCE LINE # 253
                       INC     DPTR
                       MOV     A,R5
                       MOVX    @DPTR,A
                                           ; SOURCE LINE # 255
;---- Variable 'i' assigned to Register 'R5' ----
                       CLR     A
                       MOV     R5,A
             ?C0056:
                       MOV     A,R5
                       CLR     C
                 R     SUBB    A,numberOfRegisters+01H
                       CLR     A
                 R     SUBB    A,numberOfRegisters
                 R     xJGE    ?C0057
                                           ; SOURCE LINE # 256
                       MOV     B,#02H
                       MOV     A,R5
                       MUL     AB
                 R     ADD     A,#LOW Rx_Data+07H
                       MOV     DPL,A
                       MOV     A,B
                 R     ADDC    A,#HIGH Rx_Data+07H
                       MOV     DPH,A
                       MOVX    A,@DPTR
                       MOV     R6,A
                       MOV     B,#02H
                       MOV     A,R5
                       MUL     AB
                 R     ADD     A,#LOW Rx_Data+08H
                       MOV     DPL,A
                       MOV     A,B
                 R     ADDC    A,#HIGH Rx_Data+08H
                       MOV     DPH,A
                       MOVX    A,@DPTR
                       MOV     R2,#00H
                       ADD     A,#00H
                 R     MOV     value+01H,A
                       MOV     A,R2
                       ADDC    A,R6
                 R     MOV     value,A
                                           ; SOURCE LINE # 257
                       MOV     R2,A
                       MOV     A,R5
                       MOV     R6,#00H
                 R     ADD     A,startAddress+01H
                       MOV     R7,A
                       MOV     A,R6
                 R     ADDC    A,startAddress
                       MOV     R6,A
                       MOV     A,R7
                       ADD     A,ACC
                       MOV     R7,A
                       MOV     A,R6
                       RLC     A
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 121 

                       MOV     R6,A
                 E     MOV     A,#LOW NVRAM0
                       ADD     A,R7
                       MOV     DPL,A
                 E     MOV     A,#HIGH NVRAM0
                       ADDC    A,R6
                       MOV     DPH,A
                       MOV     A,R2
                       MOVX    @DPTR,A
                       INC     DPTR
                 R     MOV     A,value+01H
                       MOVX    @DPTR,A
                                           ; SOURCE LINE # 258
                       INC     R5
                 R     xJMP    ?C0056
             ?C0057:
                                           ; SOURCE LINE # 259
                 R     CALL    SendMessage
                                           ; SOURCE LINE # 260
                                           ; SOURCE LINE # 261
             ?C0059:
                       RET     
             ; FUNCTION HandleModbusWriteMultipleRegisters (END)

             ; FUNCTION RxDataAvailable (BEGIN)
                                           ; SOURCE LINE # 262
                                           ; SOURCE LINE # 263
;---- Variable 'Result' assigned to Register 'R7' ----
                 R     MOV     R7,Rx_Data_Available
                                           ; SOURCE LINE # 264
                       CLR     A
                 R     MOV     Rx_Data_Available,A
                                           ; SOURCE LINE # 265
                                           ; SOURCE LINE # 266
                       RET     
             ; FUNCTION RxDataAvailable (END)

             ; FUNCTION CheckRxTimeout (BEGIN)
                                           ; SOURCE LINE # 267
                                           ; SOURCE LINE # 269
                       CLR     C
                 R     MOV     A,modbusTimerValue
                       SUBB    A,#01H
                 R     xJLT    ?C0061
                                           ; SOURCE LINE # 270
                       CLR     A
                 R     MOV     modbusTimerValue,A
                 R     MOV     modbusTimerValue+01H,A
                                           ; SOURCE LINE # 271
                 R     MOV     modbusReceiveCounter,A
                                           ; SOURCE LINE # 272
                       MOV     R7,#01H
                       RET     
                                           ; SOURCE LINE # 273
             ?C0061:
                                           ; SOURCE LINE # 274
                       MOV     R7,#00H
                                           ; SOURCE LINE # 275
             ?C0062:
                       RET     
             ; FUNCTION CheckRxTimeout (END)

C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 122 

             ; FUNCTION checkModbusBufferComplete (BEGIN)
                                           ; SOURCE LINE # 276
                                           ; SOURCE LINE # 277
                       CLR     A
                 R     MOV     expectedReceiveCount+03H,A
                 R     MOV     expectedReceiveCount+02H,A
                 R     MOV     expectedReceiveCount+01H,A
                 R     MOV     expectedReceiveCount,A
                                           ; SOURCE LINE # 278
                 R     MOV     R7,modbusReceiveCounter
                       SETB    C
                       MOV     A,R7
                       SUBB    A,#04H
                       MOV     A,#080H
                       SUBB    A,#080H
                 R     xJLT    ?C0063
                                           ; SOURCE LINE # 279
                                           ; SOURCE LINE # 280
                 R     MOV     DPTR,#modbusReceiveBuffer
                       MOVX    A,@DPTR
                 R     XRL     A,ModbusSlaveAddress
                 R     xJNZ    ?C0064
                                           ; SOURCE LINE # 281
                                           ; SOURCE LINE # 282
                       INC     DPTR
                       MOVX    A,@DPTR
                       XRL     A,#01H
                 R     xJZ     ?C0066
                       MOVX    A,@DPTR
                       XRL     A,#02H
                 R     xJZ     ?C0066
                       MOVX    A,@DPTR
                       XRL     A,#03H
                 R     xJZ     ?C0066
                       MOVX    A,@DPTR
                       XRL     A,#04H
                 R     xJZ     ?C0066
                       MOVX    A,@DPTR
                       XRL     A,#05H
                 R     xJZ     ?C0066
                       MOVX    A,@DPTR
                       XRL     A,#06H
                 R     xJNZ    ?C0065
             ?C0066:
                                           ; SOURCE LINE # 283
                                           ; SOURCE LINE # 284
                       CLR     A
                 R     MOV     expectedReceiveCount+03H,#08H
                 R     MOV     expectedReceiveCount+02H,A
                                           ; SOURCE LINE # 285
                 R     xJMP    ?C0133
             ?C0065:
                                           ; SOURCE LINE # 286
                 R     MOV     DPTR,#modbusReceiveBuffer+01H
                       MOVX    A,@DPTR
                       XRL     A,#0FH
                 R     xJZ     ?C0069
                       MOVX    A,@DPTR
                       XRL     A,#010H
                 R     xJNZ    ?C0068
             ?C0069:
                                           ; SOURCE LINE # 287
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 123 

                                           ; SOURCE LINE # 288
                 R     MOV     DPTR,#modbusReceiveBuffer+06H
                       MOVX    A,@DPTR
                       ADD     A,#09H
                       MOV     R7,A
                       CLR     A
                       RLC     A
                       MOV     R6,A
                       RLC     A
                       SUBB    A,ACC
                 R     MOV     expectedReceiveCount+03H,R7
                 R     MOV     expectedReceiveCount+02H,R6
             ?C0133:
                 R     MOV     expectedReceiveCount+01H,A
                 R     MOV     expectedReceiveCount,A
                                           ; SOURCE LINE # 289
                 R     xJMP    ?C0073
             ?C0068:
                                           ; SOURCE LINE # 290
                                           ; SOURCE LINE # 291
                       CLR     A
                 R     MOV     modbusReceiveCounter,A
                                           ; SOURCE LINE # 292
                       MOV     R7,A
                       RET     
                                           ; SOURCE LINE # 293
                                           ; SOURCE LINE # 294
             ?C0064:
                                           ; SOURCE LINE # 296
                                           ; SOURCE LINE # 297
                       CLR     A
                 R     MOV     modbusReceiveCounter,A
                                           ; SOURCE LINE # 298
                       MOV     R7,#01H
                       RET     
                                           ; SOURCE LINE # 299
                                           ; SOURCE LINE # 300
             ?C0063:
                                           ; SOURCE LINE # 302
                       MOV     R7,#02H
                       RET     
             ?C0073:
                                           ; SOURCE LINE # 304
                 R     MOV     R7,modbusReceiveCounter
                       CLR     A
                       MOV     R4,A
                       MOV     R5,A
                       MOV     R6,A
                 R     MOV     R3,expectedReceiveCount+03H
                 R     MOV     R2,expectedReceiveCount+02H
                 R     MOV     R1,expectedReceiveCount+01H
                 R     MOV     R0,expectedReceiveCount
                       CLR     C
                 E     CALL    ?C?SLCMP
                       MOV     R7,#02H
                 R     xJNZ    ?C0074
                                           ; SOURCE LINE # 305
                                           ; SOURCE LINE # 306
                       MOV     R7,#03H
                                           ; SOURCE LINE # 307
             ?C0074:
                                           ; SOURCE LINE # 309
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 124 

                                           ; SOURCE LINE # 310
             ?C0071:
                       RET     
             ; FUNCTION checkModbusBufferComplete (END)

             ; FUNCTION RxRTU (BEGIN)
                                           ; SOURCE LINE # 311
                                           ; SOURCE LINE # 313
;---- Variable 'receiveBufferControl' assigned to Register 'R7' ----
                       CLR     A
                       MOV     R7,A
                                           ; SOURCE LINE # 314
                 R     CALL    checkModbusBufferComplete
                                           ; SOURCE LINE # 315
                       MOV     A,R7
                       XRL     A,#03H
                 R     xJNZ    ?C0075
                                           ; SOURCE LINE # 316
                 R     MOV     DPTR,#modbusReceiveBuffer
                       MOVX    A,@DPTR
                 R     MOV     DPTR,#Rx_Data
                       MOVX    @DPTR,A
                                           ; SOURCE LINE # 317
                       CLR     A
                 R     MOV     Rx_CRC16+03H,#0FFH
                 R     MOV     Rx_CRC16+02H,#0FFH
                 R     MOV     Rx_CRC16+01H,A
                 R     MOV     Rx_CRC16,A
                                           ; SOURCE LINE # 318
                       MOVX    A,@DPTR
                       MOV     R7,A
                       MOV     R3,#00H
                 R     MOV     R2,#HIGH Rx_CRC16
                 R     MOV     R1,#LOW Rx_CRC16
                 R     CALL    _modbusCrc16
                                           ; SOURCE LINE # 319
                 R     MOV     DPTR,#modbusReceiveBuffer+01H
                       MOVX    A,@DPTR
                 R     MOV     DPTR,#Rx_Data+01H
                       MOVX    @DPTR,A
                                           ; SOURCE LINE # 320
                       MOVX    A,@DPTR
                       MOV     R7,A
                       MOV     R3,#00H
                 R     MOV     R2,#HIGH Rx_CRC16
                 R     MOV     R1,#LOW Rx_CRC16
                 R     CALL    _modbusCrc16
                                           ; SOURCE LINE # 322
                       CLR     A
                 R     MOV     DPTR,#Rx_Data+0102H
                       MOVX    @DPTR,A
                       INC     DPTR
                       MOVX    @DPTR,A
                                           ; SOURCE LINE # 324
                 R     MOV     i,#02H
             ?C0076:
                 R     MOV     A,i
                       CLR     C
                 R     SUBB    A,modbusReceiveCounter
                 R     xJGE    ?C0077
                                           ; SOURCE LINE # 325
                 R     MOV     A,#LOW modbusReceiveBuffer
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 125 

                 R     ADD     A,i
                       MOV     DPL,A
                       CLR     A
                 R     ADDC    A,#HIGH modbusReceiveBuffer
                       MOV     DPH,A
                       MOVX    A,@DPTR
                       MOV     R7,A
                 R     MOV     DPTR,#Rx_Data+0102H
                       CLR     A
                       MOV     B,#01H
                 E     CALL    ?C?ILDIX
                       MOV     R4,A
                 R     MOV     A,#LOW Rx_Data+02H
                       ADD     A,B
                       MOV     DPL,A
                 R     MOV     A,#HIGH Rx_Data+02H
                       ADDC    A,R4
                       MOV     DPH,A
                       MOV     A,R7
                       MOVX    @DPTR,A
                 R     INC     i
                 R     xJMP    ?C0076
             ?C0077:
                                           ; SOURCE LINE # 327
                 R     MOV     Rx_State,#02H
                                           ; SOURCE LINE # 329
                       CLR     A
                 R     MOV     modbusReceiveCounter,A
                                           ; SOURCE LINE # 330
             ?C0075:
                                           ; SOURCE LINE # 332
                 R     CALL    CheckRxTimeout
                                           ; SOURCE LINE # 334
                 R     MOV     A,Rx_State
                       XRL     A,#02H
                 R     xJNZ    ?C0084
                       CLR     C
                 R     MOV     DPTR,#Rx_Data+0103H
                       MOVX    A,@DPTR
                       SUBB    A,#02H
                 R     MOV     DPTR,#Rx_Data+0102H
                       MOVX    A,@DPTR
                       SUBB    A,#00H
                 R     xJLT    ?C0084
                                           ; SOURCE LINE # 335
                                           ; SOURCE LINE # 337
                       INC     DPTR
                       MOVX    A,@DPTR
                       ADD     A,#0FEH
                       MOVX    @DPTR,A
                 R     MOV     DPTR,#Rx_Data+0102H
                       MOVX    A,@DPTR
                       ADDC    A,#0FFH
                       MOVX    @DPTR,A
                                           ; SOURCE LINE # 338
                       CLR     A
                 R     MOV     i,A
             ?C0080:
                       SETB    C
                 R     MOV     DPTR,#Rx_Data+0103H
                       MOVX    A,@DPTR
                 R     SUBB    A,i
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 126 

                 R     MOV     DPTR,#Rx_Data+0102H
                       MOVX    A,@DPTR
                       SUBB    A,#00H
                 R     xJLT    ?C0081
                                           ; SOURCE LINE # 339
                                           ; SOURCE LINE # 340
                 R     MOV     A,#LOW Rx_Data+02H
                 R     ADD     A,i
                       MOV     DPL,A
                       CLR     A
                 R     ADDC    A,#HIGH Rx_Data+02H
                       MOV     DPH,A
                       MOVX    A,@DPTR
                       MOV     R7,A
                       MOV     R3,#00H
                 R     MOV     R2,#HIGH Rx_CRC16
                 R     MOV     R1,#LOW Rx_CRC16
                 R     CALL    _modbusCrc16
                                           ; SOURCE LINE # 341
                 R     INC     i
                 R     xJMP    ?C0080
             ?C0081:
                                           ; SOURCE LINE # 343
                 R     MOV     DPTR,#Rx_Data+0102H
                       MOVX    A,@DPTR
                       MOV     R6,A
                       INC     DPTR
                       MOVX    A,@DPTR
                 R     ADD     A,#LOW Rx_Data+03H
                       MOV     DPL,A
                 R     MOV     A,#HIGH Rx_Data+03H
                       ADDC    A,R6
                       MOV     DPH,A
                       MOVX    A,@DPTR
                       MOV     R7,A
                       CLR     A
                       MOV     R4,A
                       MOV     R5,A
                       MOV     R6,A
                       MOV     R0,#08H
                 E     CALL    ?C?LSHL
                       MOV     R0,AR4
                       MOV     R1,AR5
                       MOV     R2,AR6
                       MOV     R3,AR7
                 R     MOV     DPTR,#Rx_Data+0102H
                       MOVX    A,@DPTR
                       MOV     R6,A
                       INC     DPTR
                       MOVX    A,@DPTR
                 R     ADD     A,#LOW Rx_Data+02H
                       MOV     DPL,A
                 R     MOV     A,#HIGH Rx_Data+02H
                       ADDC    A,R6
                       MOV     DPH,A
                       MOVX    A,@DPTR
                       MOV     R7,A
                       CLR     A
                       MOV     R4,A
                       MOV     R5,A
                       MOV     R6,A
                       MOV     A,R3
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 127 

                       ADD     A,R7
                       MOV     R7,A
                       MOV     A,R6
                       ADDC    A,R2
                       MOV     R6,A
                       MOV     A,R5
                       ADDC    A,R1
                       MOV     R5,A
                       MOV     A,R4
                       ADDC    A,R0
                       MOV     R4,A
                 R     MOV     R3,Rx_CRC16+03H
                 R     MOV     R2,Rx_CRC16+02H
                 R     MOV     R1,Rx_CRC16+01H
                 R     MOV     R0,Rx_CRC16
                       CLR     C
                 E     CALL    ?C?ULCMP
                 R     xJNZ    ?C0083
                                           ; SOURCE LINE # 344
                                           ; SOURCE LINE # 346
                 R     MOV     Rx_Data_Available,#01H
                                           ; SOURCE LINE # 347
             ?C0083:
                                           ; SOURCE LINE # 349
                       CLR     A
                 R     MOV     Rx_State,A
                                           ; SOURCE LINE # 350
                                           ; SOURCE LINE # 351
             ?C0084:
                       RET     
             ; FUNCTION RxRTU (END)

             ; FUNCTION TxRTU (BEGIN)
                                           ; SOURCE LINE # 352
                                           ; SOURCE LINE # 353
                       CLR     A
                 R     MOV     Tx_CRC16+03H,#0FFH
                 R     MOV     Tx_CRC16+02H,#0FFH
                 R     MOV     Tx_CRC16+01H,A
                 R     MOV     Tx_CRC16,A
                                           ; SOURCE LINE # 354
                 R     MOV     Tx_Buf_Size+03H,A
                 R     MOV     Tx_Buf_Size+02H,A
                 R     MOV     Tx_Buf_Size+01H,A
                 R     MOV     Tx_Buf_Size,A
                                           ; SOURCE LINE # 355
                 R     MOV     DPTR,#Tx_Data
                       MOVX    A,@DPTR
                       MOV     R3,A
                 R     MOV     R0,#LOW Tx_Buf_Size
                 E     CALL    ?C?LLDIIDATA1
                 R     MOV     A,#LOW Tx_Buf
                       ADD     A,R7
                       MOV     DPL,A
                 R     MOV     A,#HIGH Tx_Buf
                       ADDC    A,R6
                       MOV     DPH,A
                       MOV     A,R3
                       MOVX    @DPTR,A
                                           ; SOURCE LINE # 356
                       MOV     R7,AR3
                       MOV     R3,#00H
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 128 

                 R     MOV     R2,#HIGH Tx_CRC16
                 R     MOV     R1,#LOW Tx_CRC16
                 R     CALL    _modbusCrc16
                                           ; SOURCE LINE # 357
                 R     MOV     DPTR,#Tx_Data+01H
                       MOVX    A,@DPTR
                       MOV     R3,A
                 R     MOV     R0,#LOW Tx_Buf_Size
                 E     CALL    ?C?LLDIIDATA1
                 R     MOV     A,#LOW Tx_Buf
                       ADD     A,R7
                       MOV     DPL,A
                 R     MOV     A,#HIGH Tx_Buf
                       ADDC    A,R6
                       MOV     DPH,A
                       MOV     A,R3
                       MOVX    @DPTR,A
                                           ; SOURCE LINE # 358
                       MOV     R7,AR3
                       MOV     R3,#00H
                 R     MOV     R2,#HIGH Tx_CRC16
                 R     MOV     R1,#LOW Tx_CRC16
                 R     CALL    _modbusCrc16
                                           ; SOURCE LINE # 359
                       CLR     A
                 R     MOV     Tx_Current+03H,A
                 R     MOV     Tx_Current+02H,A
                 R     MOV     Tx_Current+01H,A
                 R     MOV     Tx_Current,A
             ?C0085:
                 R     MOV     DPTR,#Tx_Data+0102H
                       MOVX    A,@DPTR
                       MOV     R6,A
                       INC     DPTR
                       MOVX    A,@DPTR
                       MOV     R7,A
                       CLR     A
                       MOV     R4,A
                       MOV     R5,A
                 R     MOV     R3,Tx_Current+03H
                 R     MOV     R2,Tx_Current+02H
                 R     MOV     R1,Tx_Current+01H
                 R     MOV     R0,Tx_Current
                       CLR     C
                 E     CALL    ?C?ULCMP
                 R     xJGE    ?C0086
                                           ; SOURCE LINE # 360
                 R     MOV     A,#LOW Tx_Data+02H
                       ADD     A,R3
                       MOV     DPL,A
                       CLR     A
                 R     ADDC    A,#HIGH Tx_Data+02H
                       MOV     DPH,A
                       MOVX    A,@DPTR
                       MOV     R2,A
                 R     MOV     R0,#LOW Tx_Buf_Size
                 E     CALL    ?C?LLDIIDATA1
                 R     MOV     A,#LOW Tx_Buf
                       ADD     A,R7
                       MOV     DPL,A
                 R     MOV     A,#HIGH Tx_Buf
                       ADDC    A,R6
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 129 

                       MOV     DPH,A
                       MOV     A,R2
                       MOVX    @DPTR,A
                                           ; SOURCE LINE # 361
                 R     MOV     A,#LOW Tx_Data+02H
                       ADD     A,R3
                       MOV     DPL,A
                       CLR     A
                 R     ADDC    A,#HIGH Tx_Data+02H
                       MOV     DPH,A
                       MOVX    A,@DPTR
                       MOV     R7,A
                       MOV     R3,#00H
                 R     MOV     R2,#HIGH Tx_CRC16
                 R     MOV     R1,#LOW Tx_CRC16
                 R     CALL    _modbusCrc16
                                           ; SOURCE LINE # 362
                 R     MOV     A,Tx_Current+03H
                       ADD     A,#01H
                 R     MOV     Tx_Current+03H,A
                       CLR     A
                 R     ADDC    A,Tx_Current+02H
                 R     MOV     Tx_Current+02H,A
                       CLR     A
                 R     ADDC    A,Tx_Current+01H
                 R     MOV     Tx_Current+01H,A
                       CLR     A
                 R     ADDC    A,Tx_Current
                 R     MOV     Tx_Current,A
                 R     xJMP    ?C0085
             ?C0086:
                                           ; SOURCE LINE # 363
                 R     MOV     A,Tx_CRC16+03H
                       MOV     R7,A
                       CLR     A
                       MOV     R3,AR7
                 R     MOV     R0,#LOW Tx_Buf_Size
                 E     CALL    ?C?LLDIIDATA1
                 R     MOV     A,#LOW Tx_Buf
                       ADD     A,R7
                       MOV     DPL,A
                 R     MOV     A,#HIGH Tx_Buf
                       ADDC    A,R6
                       MOV     DPH,A
                       MOV     A,R3
                       MOVX    @DPTR,A
                                           ; SOURCE LINE # 364
                       CLR     A
                       MOV     R7,A
                 R     MOV     A,Tx_CRC16+02H
                       MOV     R6,A
                       CLR     A
                       MOV     R5,A
                       MOV     R4,A
                       MOV     R0,#08H
                 E     CALL    ?C?ULSHR
                       MOV     R3,AR7
                 R     MOV     R0,#LOW Tx_Buf_Size
                 E     CALL    ?C?LLDIIDATA1
                 R     MOV     A,#LOW Tx_Buf
                       ADD     A,R7
                       MOV     DPL,A
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 130 

                 R     MOV     A,#HIGH Tx_Buf
                       ADDC    A,R6
                       MOV     DPH,A
                       MOV     A,R3
                       MOVX    @DPTR,A
                                           ; SOURCE LINE # 365
                 R     CALL    DoSlaveTX
                                           ; SOURCE LINE # 366
                       CLR     A
                 R     MOV     Tx_State,A
                                           ; SOURCE LINE # 367
                       RET     
             ; FUNCTION TxRTU (END)

             ; FUNCTION modbusPorcess (BEGIN)
                                           ; SOURCE LINE # 368
                                           ; SOURCE LINE # 369
                 R     MOV     A,Tx_State
                 R     xJZ     ?C0089
                                           ; SOURCE LINE # 370
                 R     CALL    TxRTU
                                           ; SOURCE LINE # 371
             ?C0089:
                                           ; SOURCE LINE # 372
                 R     CALL    RxRTU
                                           ; SOURCE LINE # 373
                 R     CALL    RxDataAvailable
                       MOV     A,R7
                 R     xJZ     ?C0100
                                           ; SOURCE LINE # 374
                 R     MOV     DPTR,#Rx_Data
                       MOVX    A,@DPTR
                 R     XRL     A,ModbusSlaveAddress
                 R     xJNZ    ?C0100
                                           ; SOURCE LINE # 375
                       INC     DPTR
                       MOVX    A,@DPTR
                       ADD     A,#0FDH
                 R     xJZ     ?C0094
                       ADD     A,#0FEH
                 R     xJZ     ?C0095
                       DEC     A
                 R     xJZ     ?C0096
                       ADD     A,#0F7H
                 R     xJZ     ?C0097
                       DEC     A
                 R     xJZ     ?C0098
                       ADD     A,#0FH
                 R     xJNZ    ?C0099
                                           ; SOURCE LINE # 376
                                           ; SOURCE LINE # 377
             ?C0093:
                                           ; SOURCE LINE # 378
                 R     JMP     HandleModbusReadCoils
                                           ; SOURCE LINE # 379
                                           ; SOURCE LINE # 380
                                           ; SOURCE LINE # 381
             ?C0094:
                                           ; SOURCE LINE # 382
                 R     JMP     HandleModbusReadHoldingRegisters
                                           ; SOURCE LINE # 383
                                           ; SOURCE LINE # 384
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 131 

                                           ; SOURCE LINE # 385
             ?C0095:
                                           ; SOURCE LINE # 386
                 R     JMP     HandleModbusWriteSingleCoil
                                           ; SOURCE LINE # 387
                                           ; SOURCE LINE # 388
                                           ; SOURCE LINE # 389
             ?C0096:
                                           ; SOURCE LINE # 390
                 R     JMP     HandleModbusWriteSingleRegister
                                           ; SOURCE LINE # 391
                                           ; SOURCE LINE # 392
                                           ; SOURCE LINE # 393
             ?C0097:
                                           ; SOURCE LINE # 394
                 R     JMP     HandleModbusWriteMultipleCoils
                                           ; SOURCE LINE # 395
                                           ; SOURCE LINE # 396
                                           ; SOURCE LINE # 397
             ?C0098:
                                           ; SOURCE LINE # 398
                 R     JMP     HandleModbusWriteMultipleRegisters
                                           ; SOURCE LINE # 399
                                           ; SOURCE LINE # 400
                                           ; SOURCE LINE # 401
             ?C0099:
                                           ; SOURCE LINE # 402
                       MOV     R7,#01H
                 R     CALL    _HandleModbusError
                                           ; SOURCE LINE # 403
                                           ; SOURCE LINE # 404
                                           ; SOURCE LINE # 405
                                           ; SOURCE LINE # 406
                                           ; SOURCE LINE # 407
                                           ; SOURCE LINE # 408
             ?C0100:
                       RET     
             ; FUNCTION modbusPorcess (END)

             ; FUNCTION _InitModbus (BEGIN)
                                           ; SOURCE LINE # 409
;---- Variable 'modbusSlaveAddress' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 410
                 R     MOV     ModbusSlaveAddress,R7
                                           ; SOURCE LINE # 411
                 R     MOV     R7,baudrate+03H
                 R     MOV     R6,baudrate+02H
                 R     MOV     R5,baudrate+01H
                 R     MOV     R4,baudrate
                 E     CALL    _modBusUartInitialise
                                           ; SOURCE LINE # 412
                 E     JMP     modBusTimerInitialise
             ; FUNCTION _InitModbus (END)

C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 132 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


uint8_t. . . . . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
uint16_t . . . . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
uint32_t . . . . . . . . . . . . . . .  TYPEDEF  -----  U_LONG   -----  4
uint64_t . . . . . . . . . . . . . . .  TYPEDEF  -----  ARRAY    -----  8
int8_t . . . . . . . . . . . . . . . .  TYPEDEF  -----  CHAR     -----  1
int16_t. . . . . . . . . . . . . . . .  TYPEDEF  -----  INT      -----  2
int32_t. . . . . . . . . . . . . . . .  TYPEDEF  -----  LONG     -----  4
int64_t. . . . . . . . . . . . . . . .  TYPEDEF  -----  ARRAY    -----  8
fp32_t . . . . . . . . . . . . . . . .  TYPEDEF  -----  FLOAT    -----  4
fp64_t . . . . . . . . . . . . . . . .  TYPEDEF  -----  FLOAT    -----  4
bool . . . . . . . . . . . . . . . . .  TYPEDEF  -----  BIT      -----  1
false. . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
true . . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
SI_UU16. . . . . . . . . . . . . . . .  * TAG *  -----  UNION    -----  2
  u16. . . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0000H  2
  s16. . . . . . . . . . . . . . . . .  MEMBER   -----  INT      0000H  2
  u8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
  s8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
SI_UU16_t. . . . . . . . . . . . . . .  TYPEDEF  -----  UNION    -----  2
  u16. . . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0000H  2
  s16. . . . . . . . . . . . . . . . .  MEMBER   -----  INT      0000H  2
  u8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
  s8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
SI_UU32. . . . . . . . . . . . . . . .  * TAG *  -----  UNION    -----  4
  u32. . . . . . . . . . . . . . . . .  MEMBER   -----  U_LONG   0000H  4
  s32. . . . . . . . . . . . . . . . .  MEMBER   -----  LONG     0000H  4
  uu16 . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  u16. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  s16. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  u8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  s8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
SI_UU32_t. . . . . . . . . . . . . . .  TYPEDEF  -----  UNION    -----  4
  u32. . . . . . . . . . . . . . . . .  MEMBER   -----  U_LONG   0000H  4
  s32. . . . . . . . . . . . . . . . .  MEMBER   -----  LONG     0000H  4
  uu16 . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  u16. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  s16. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  u8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  s8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
GPTR_t . . . . . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  3
  memtype. . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  address. . . . . . . . . . . . . . .  MEMBER   -----  UNION    0001H  2
SI_GEN_PTR . . . . . . . . . . . . . .  * TAG *  -----  UNION    -----  3
  u8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  3
  gptr . . . . . . . . . . . . . . . .  MEMBER   -----  STRUCT   0000H  3
SI_GEN_PTR_t . . . . . . . . . . . . .  TYPEDEF  -----  UNION    -----  3
  u8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  3
  gptr . . . . . . . . . . . . . . . .  MEMBER   -----  STRUCT   0000H  3
U8 . . . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
U16. . . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
U32. . . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_LONG   -----  4
S8 . . . . . . . . . . . . . . . . . .  TYPEDEF  -----  CHAR     -----  1
S16. . . . . . . . . . . . . . . . . .  TYPEDEF  -----  INT      -----  2
S32. . . . . . . . . . . . . . . . . .  TYPEDEF  -----  LONG     -----  4
UU16 . . . . . . . . . . . . . . . . .  * TAG *  -----  UNION    -----  2
  U16. . . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0000H  2
  S16. . . . . . . . . . . . . . . . .  MEMBER   -----  INT      0000H  2
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 133 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


  U8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
  S8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
UU16 . . . . . . . . . . . . . . . . .  TYPEDEF  -----  UNION    -----  2
  U16. . . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0000H  2
  S16. . . . . . . . . . . . . . . . .  MEMBER   -----  INT      0000H  2
  U8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
  S8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
UU32 . . . . . . . . . . . . . . . . .  * TAG *  -----  UNION    -----  4
  U32. . . . . . . . . . . . . . . . .  MEMBER   -----  U_LONG   0000H  4
  S32. . . . . . . . . . . . . . . . .  MEMBER   -----  LONG     0000H  4
  UU16 . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  U16. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  S16. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  U8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  S8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
UU32 . . . . . . . . . . . . . . . . .  TYPEDEF  -----  UNION    -----  4
  U32. . . . . . . . . . . . . . . . .  MEMBER   -----  U_LONG   0000H  4
  S32. . . . . . . . . . . . . . . . .  MEMBER   -----  LONG     0000H  4
  UU16 . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  U16. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  S16. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  U8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  S8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
SI_GENERIC_PTR . . . . . . . . . . . .  * TAG *  -----  UNION    -----  3
  U8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  3
  GPTR . . . . . . . . . . . . . . . .  MEMBER   -----  STRUCT   0000H  3
SI_GENERIC_PTR . . . . . . . . . . . .  TYPEDEF  -----  UNION    -----  3
  U8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  3
  GPTR . . . . . . . . . . . . . . . .  MEMBER   -----  STRUCT   0000H  3
P0 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0080H  1
SP . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0081H  1
DPL. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0082H  1
DPH. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0083H  1
SFR0CN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0084H  1
SFRNEXT. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0085H  1
SFRLAST. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0086H  1
PCON . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0087H  1
TCON . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0088H  1
TMOD . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0089H  1
TL0. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008AH  1
TL1. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008BH  1
TH0. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008CH  1
TH1. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008DH  1
CKCON. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008EH  1
PSCTL. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008FH  1
CLKSEL . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008FH  1
P1 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0090H  1
TMR3CN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0091H  1
TMR5CN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0091H  1
TMR3RLL. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0092H  1
TMR5CAPL . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0092H  1
TMR3RLH. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0093H  1
TMR5CAPH . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0093H  1
TMR3L. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0094H  1
TMR5L. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0094H  1
TMR3H. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0095H  1
TMR5H. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0095H  1
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 134 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


TMR5CF . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0096H  1
CLKMUL . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0097H  1
SCON0. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0098H  1
SCON1. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0098H  1
SBUF0. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0099H  1
SBUF1. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0099H  1
CPT0CN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   009AH  1
CPT2CN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   009AH  1
CPT0MD . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   009BH  1
CPT2MD . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   009BH  1
CPT0MX . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   009CH  1
CPT2MX . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   009CH  1
CPT1CN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   009DH  1
CPT1MD . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   009EH  1
OSCIFIN. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   009EH  1
CPT1MX . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   009FH  1
OSCXCN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   009FH  1
P2 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A0H  1
SPI0CFG. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A1H  1
OSCICN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A1H  1
SPI0CKR. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A2H  1
OSCICRS. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A2H  1
SPI0DAT. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A3H  1
P0MDOUT. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A4H  1
P1MDOUT. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A5H  1
P2MDOUT. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A6H  1
SFRPAGE. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A7H  1
IE . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A8H  1
SMOD0. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A9H  1
EMI0CN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00AAH  1
EMI0TC . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00AAH  1
SBCON0 . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00ABH  1
SBRLL0 . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00ACH  1
SBRLH0 . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00ADH  1
P3MAT. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00AEH  1
P3MDOUT. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00AEH  1
P3MASK . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00AFH  1
P4MDOUT. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00AFH  1
P3 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B0H  1
P2MAT. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B1H  1
P2MASK . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B2H  1
EMI0CF . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B2H  1
P4 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B5H  1
FLSCL. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B6H  1
FLKEY. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B7H  1
IP . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B8H  1
SMB0ADR. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B9H  1
ADC0TK . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00BAH  1
SMB0ADM. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00BAH  1
ADC0MX . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00BBH  1
ADC0CF . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00BCH  1
ADC0L. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00BDH  1
ADC0H. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00BEH  1
SMB0CN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C0H  1
SMB0CF . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C1H  1
SMB0DAT. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C2H  1
ADC0GTL. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C3H  1
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 135 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


ADC0GTH. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C4H  1
ADC0LTL. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C5H  1
ADC0LTH. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C6H  1
XBR3 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C6H  1
XBR2 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C7H  1
TMR2CN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C8H  1
TMR4CN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C8H  1
REG0CN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C9H  1
LIN0CF . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C9H  1
TMR4CF . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C9H  1
TMR2RLL. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CAH  1
TMR4CAPL . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CAH  1
TMR2RLH. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CBH  1
TMR4CAPH . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CBH  1
TMR2L. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CCH  1
TMR4L. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CCH  1
TMR2H. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CDH  1
TMR4H. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CDH  1
PCA0CPL5 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CEH  1
PCA1CPL11. . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CEH  1
PCA0CPH5 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CFH  1
PCA1CPH11. . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CFH  1
PSW. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D0H  1
REF0CN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D1H  1
LIN0DAT. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D2H  1
LIN0ADR. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D3H  1
P0SKIP . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D4H  1
P1SKIP . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D5H  1
P2SKIP . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D6H  1
P3SKIP . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D7H  1
PCA0CN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D8H  1
PCA1CN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D8H  1
PCA0MD . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D9H  1
PCA1MD . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D9H  1
PCA0PWM. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D9H  1
PCA0CPM0 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DAH  1
PCA1CPM6 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DAH  1
PCA1PWM. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DAH  1
PCA0CPM1 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DBH  1
PCA1CPM7 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DBH  1
PCA0CPM2 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DCH  1
PCA1CPM8 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DCH  1
PCA0CPM3 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DDH  1
PCA1CPM9 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DDH  1
PCA0CPM4 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DEH  1
PCA1CPM10. . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DEH  1
PCA0CPM5 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DFH  1
PCA1CPM11. . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DFH  1
ACC. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E0H  1
XBR0 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E1H  1
XBR1 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E2H  1
CCH0CN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E3H  1
IT01CF . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E4H  1
EIE1 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E6H  1
EIE2 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E7H  1
ADC0CN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E8H  1
PCA0CPL1 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E9H  1
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 136 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


PCA1CPL1 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E9H  1
PCA0CPH1 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00EAH  1
PCA1CPH1 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00EAH  1
PCA0CPL2 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00EBH  1
PCA1CPL2 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00EBH  1
PCA0CPH2 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00ECH  1
PCA1CPH2 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00ECH  1
PCA0CPL3 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00EDH  1
PCA1CPL3 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00EDH  1
PCA0CPH3 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00EEH  1
PCA1CPH3 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00EEH  1
RSTSRC . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00EFH  1
B. . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F0H  1
P0MAT. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F1H  1
P0MDIN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F1H  1
P0MASK . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F2H  1
P1MDIN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F2H  1
P1MAT. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F3H  1
P2MDIN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F3H  1
P1MASK . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F4H  1
P3MDIN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F4H  1
PSBANK . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F5H  1
EIP1 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F6H  1
EIP2 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F7H  1
SPI0CN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F8H  1
PCA0L. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F9H  1
PCA1L. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F9H  1
SN0. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F9H  1
PCA0H. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FAH  1
PCA1H. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FAH  1
SN1. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FAH  1
PCA0CPL0 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FBH  1
PCA1CPL6 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FBH  1
SN2. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FBH  1
PCA0CPH0 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FCH  1
PCA1CPH6 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FCH  1
SN3. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FCH  1
PCA0CPL4 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FDH  1
PCA1CPL10. . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FDH  1
PCA0CPH4 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FEH  1
PCA1CPH10. . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FEH  1
VDM0CN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FFH  1
CAN0CFG. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0092H  1
CAN0STAT . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0094H  1
CAN0ERRL . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0096H  1
CAN0ERRH . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0097H  1
CAN0BTL. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   009AH  1
CAN0BTH. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   009BH  1
CAN0IIDL . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   009CH  1
CAN0IIDH . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   009DH  1
CAN0TST. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   009EH  1
CAN0BRPE . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A1H  1
CAN0TR1L . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A2H  1
CAN0TR1H . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A3H  1
CAN0TR2L . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A4H  1
CAN0TR2H . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A5H  1
CAN0ND1L . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00AAH  1
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 137 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


CAN0ND1H . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00ABH  1
CAN0ND2L . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00ACH  1
CAN0ND2H . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00ADH  1
CAN0IP1L . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00AEH  1
CAN0IP1H . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00AFH  1
CAN0IP2L . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B2H  1
CAN0IP2H . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B3H  1
CAN0MV1L . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00BAH  1
CAN0MV1H . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00BBH  1
CAN0MV2L . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00BCH  1
CAN0MV2H . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00BDH  1
CAN0IF1CRL . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00BEH  1
CAN0IF1CRH . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00BFH  1
CAN0CN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C0H  1
CAN0IF1CML . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C2H  1
CAN0IF1CMH . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C3H  1
CAN0IF1M1L . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C4H  1
CAN0IF1M1H . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C5H  1
CAN0IF1M2L . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C6H  1
CAN0IF1M2H . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C7H  1
CAN0IF1A1L . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CAH  1
CAN0IF1A1H . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CBH  1
CAN0IF1A2L . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CCH  1
CAN0IF1A2H . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CDH  1
CAN0IF2MCL . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CEH  1
CAN0IF2MCH . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CFH  1
CAN0IF1MCL . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D2H  1
CAN0IF1MCH . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D3H  1
CAN0IF1DA1L. . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D4H  1
CAN0IF1DA1H. . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D5H  1
CAN0IF1DA2L. . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D6H  1
CAN0IF1DA2H. . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D7H  1
CAN0IF1DB1L. . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DAH  1
CAN0IF1DB1H. . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DBH  1
CAN0IF1DB2L. . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DCH  1
CAN0IF1DB2H. . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DDH  1
CAN0IF2CRL . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DEH  1
CAN0IF2CRH . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DFH  1
CAN0IF2CML . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E2H  1
CAN0IF2CMH . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E3H  1
CAN0IF2M1L . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00EAH  1
CAN0IF2M1H . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00EBH  1
CAN0IF2M2L . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00ECH  1
CAN0IF2M2H . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00EDH  1
CAN0IF2A1L . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00EEH  1
CAN0IF2A1H . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00EFH  1
CAN0IF2A2L . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F2H  1
CAN0IF2A2H . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F3H  1
CAN0IF2DA1L. . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F6H  1
CAN0IF2DA1H. . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F7H  1
CAN0IF2DA2L. . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FAH  1
CAN0IF2DA2H. . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FBH  1
CAN0IF2DB1L. . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FCH  1
CAN0IF2DB1H. . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FDH  1
CAN0IF2DB2L. . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FEH  1
CAN0IF2DB2H. . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FFH  1
DP . . . . . . . . . . . . . . . . . .  SFR      DATA   U_INT    0082H  2
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 138 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


TMR3RL . . . . . . . . . . . . . . . .  SFR      DATA   U_INT    0092H  2
TMR5CAP. . . . . . . . . . . . . . . .  SFR      DATA   U_INT    0092H  2
TMR3 . . . . . . . . . . . . . . . . .  SFR      DATA   U_INT    0094H  2
TMR5 . . . . . . . . . . . . . . . . .  SFR      DATA   U_INT    0094H  2
SBRL0. . . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00ACH  2
ADC0 . . . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00BDH  2
ADC0GT . . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00C3H  2
ADC0LT . . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00C5H  2
TMR2RL . . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00CAH  2
TMR4CAP. . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00CAH  2
TMR2 . . . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00CCH  2
TMR4 . . . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00CCH  2
PCA0CP5. . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00CEH  2
PCA1CP11 . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00CEH  2
PCA0CP1. . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00E9H  2
PCA1CP7. . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00E9H  2
PCA0CP2. . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00EBH  2
PCA1CP8. . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00EBH  2
PCA0CP3. . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00EDH  2
PCA1CP9. . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00EDH  2
PCA0 . . . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00F9H  2
PCA1 . . . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00F9H  2
PCA0CP0. . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00FBH  2
PCA1CP6. . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00FBH  2
PCA0CP4. . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00FDH  2
PCA1CP10 . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00FDH  2
CAN0ERR. . . . . . . . . . . . . . . .  SFR      DATA   U_INT    0096H  2
CAN0BT . . . . . . . . . . . . . . . .  SFR      DATA   U_INT    009AH  2
CAN0IID. . . . . . . . . . . . . . . .  SFR      DATA   U_INT    009CH  2
CAN0TR1. . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00A2H  2
CAN0TR2. . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00A4H  2
CAN0ND1. . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00AAH  2
CAN0ND2. . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00ACH  2
CAN0IP1. . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00AEH  2
CAN0IP2. . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00B2H  2
CAN0MV1. . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00BAH  2
CAN0MV2. . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00BCH  2
CAN0IF1CR. . . . . . . . . . . . . . .  SFR      DATA   U_INT    00BEH  2
CAN0IF1CM. . . . . . . . . . . . . . .  SFR      DATA   U_INT    00C2H  2
CAN0IF1M1. . . . . . . . . . . . . . .  SFR      DATA   U_INT    00C4H  2
CAN0IF1M2. . . . . . . . . . . . . . .  SFR      DATA   U_INT    00C6H  2
CAN0IF1A1. . . . . . . . . . . . . . .  SFR      DATA   U_INT    00CAH  2
CAN0IF1A2. . . . . . . . . . . . . . .  SFR      DATA   U_INT    00CCH  2
CAN0IF1MC. . . . . . . . . . . . . . .  SFR      DATA   U_INT    00D2H  2
CAN0IF1DA1 . . . . . . . . . . . . . .  SFR      DATA   U_INT    00D4H  2
CAN0IF1DA2 . . . . . . . . . . . . . .  SFR      DATA   U_INT    00D6H  2
CAN0IF1DB1 . . . . . . . . . . . . . .  SFR      DATA   U_INT    00DAH  2
CAN0IF1DB2 . . . . . . . . . . . . . .  SFR      DATA   U_INT    00DCH  2
CAN0IF2CR. . . . . . . . . . . . . . .  SFR      DATA   U_INT    00DEH  2
CAN0IF2CM. . . . . . . . . . . . . . .  SFR      DATA   U_INT    00E2H  2
CAN0IF2M1. . . . . . . . . . . . . . .  SFR      DATA   U_INT    00EAH  2
CAN0IF2M2. . . . . . . . . . . . . . .  SFR      DATA   U_INT    00ECH  2
CAN0IF2A1. . . . . . . . . . . . . . .  SFR      DATA   U_INT    00EEH  2
CAN0IF2A2. . . . . . . . . . . . . . .  SFR      DATA   U_INT    00F2H  2
CAN0IF2MC. . . . . . . . . . . . . . .  SFR      DATA   U_INT    00CEH  2
CAN0IF2DA1 . . . . . . . . . . . . . .  SFR      DATA   U_INT    00F6H  2
CAN0IF2DA2 . . . . . . . . . . . . . .  SFR      DATA   U_INT    00FAH  2
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 139 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


CAN0IF2DB1 . . . . . . . . . . . . . .  SFR      DATA   U_INT    00FCH  2
CAN0IF2DB2 . . . . . . . . . . . . . .  SFR      DATA   U_INT    00FEH  2
TF1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008FH  1
TR1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008EH  1
TF0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008DH  1
TR0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008CH  1
IE1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008BH  1
IT1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008AH  1
IE0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0089H  1
IT0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0088H  1
OVR0 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009FH  1
PERR0. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009EH  1
THRE0. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009DH  1
REN0 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009CH  1
TBX0 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009BH  1
RBX0 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009AH  1
TI0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0099H  1
RI0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0098H  1
S1MODE . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009FH  1
MCE1 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009DH  1
REN1 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009CH  1
TB81 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009BH  1
RB81 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009AH  1
TI1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0099H  1
RI1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0098H  1
EA . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00AFH  1
ESPI0. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00AEH  1
ET2. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00ADH  1
ES0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00ACH  1
ET1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00ABH  1
EX1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00AAH  1
ET0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A9H  1
EX0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A8H  1
PSPI0. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BEH  1
PT2. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BDH  1
PS0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BCH  1
PS . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BCH  1
PT1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BBH  1
PX1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BAH  1
PT0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B9H  1
PX0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B8H  1
MASTER . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C7H  1
TXMODE . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C6H  1
STA. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C5H  1
STO. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C4H  1
ACKRQ. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C3H  1
ARBLOST. . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C2H  1
ACK. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C1H  1
SI . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C0H  1
TF2H . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CFH  1
TF2L . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CEH  1
TF2LEN . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CDH  1
TF2CEN . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CCH  1
T2SPLIT. . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CBH  1
TR2. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CAH  1
T2RCLK . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C9H  1
T2XCLK . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C8H  1
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 140 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


TF4. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CFH  1
EXF4 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CEH  1
EXE4 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CBH  1
TR4. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CAH  1
CT4. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C9H  1
CPRL4. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C8H  1
CY . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D7H  1
AC . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D6H  1
F0 . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D5H  1
RS1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D4H  1
RS0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D3H  1
OV . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D2H  1
F1 . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D1H  1
P. . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D0H  1
CF . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00DFH  1
CR . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00DEH  1
CCF5 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00DDH  1
CCF4 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00DCH  1
CCF3 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00DBH  1
CCF2 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00DAH  1
CCF1 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D9H  1
CCF0 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D8H  1
CF1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00DFH  1
CR1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00DEH  1
CCF11. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00DDH  1
CCF10. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00DCH  1
CCF9 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00DBH  1
CCF8 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00DAH  1
CCF7 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D9H  1
CCF6 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D8H  1
AD0EN. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00EFH  1
BURSTEN. . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00EEH  1
AD0INT . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00EDH  1
AD0BUSY. . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00ECH  1
AD0WINT. . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00EBH  1
AD0LJST. . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00EAH  1
AD0CM1 . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00E9H  1
AD0CM0 . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00E8H  1
SPIF . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00FFH  1
WCOL . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00FEH  1
MODF . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00FDH  1
RXOVRN . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00FCH  1
NSSMD1 . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00FBH  1
NSSMD0 . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00FAH  1
TXBMT. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00F9H  1
SPIEN. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00F8H  1
size_t . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
wchar_t. . . . . . . . . . . . . . . .  TYPEDEF  -----  CHAR     -----  1
_modBusUartInitialise. . . . . . . . .  EXTERN   CODE   PROC     -----  -----
modBusTimerInitialise. . . . . . . . .  EXTERN   CODE   PROC     -----  -----
_modBusUartString. . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
NVRAM0 . . . . . . . . . . . . . . . .  EXTERN   XDATA  ARRAY    -----  1548
modbusTimerValue . . . . . . . . . . .  PUBLIC   DATA   U_INT    0000H  2
modbusReceiveCounter . . . . . . . . .  PUBLIC   DATA   U_CHAR   0002H  1
modbusReceiveBuffer. . . . . . . . . .  PUBLIC   XDATA  ARRAY    0000H  256
modbusPorcess. . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
RXTX_IDLE. . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 141 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


RXTX_START . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
RXTX_DATABUF . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
RXTX_WAIT_ANSWER . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
RXTX_TIMEOUT . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
MODBUS_RXTX_STATE. . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
modbusRxTxData_t . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  260
  address. . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  function . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  dataBuf. . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0002H  256
  dataLen. . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0102H  2
ModbusSlaveAddress . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0003H  1
Tx_Data. . . . . . . . . . . . . . . .  PUBLIC   XDATA  STRUCT   0100H  260
Tx_Current . . . . . . . . . . . . . .  PUBLIC   DATA   U_LONG   0004H  4
Tx_CRC16 . . . . . . . . . . . . . . .  PUBLIC   DATA   U_LONG   0008H  4
Tx_State . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   000CH  1
Tx_Buf . . . . . . . . . . . . . . . .  PUBLIC   XDATA  ARRAY    0204H  256
Tx_Buf_Size. . . . . . . . . . . . . .  PUBLIC   DATA   U_LONG   000DH  4
Rx_Data. . . . . . . . . . . . . . . .  PUBLIC   XDATA  STRUCT   0304H  260
Rx_CRC16 . . . . . . . . . . . . . . .  PUBLIC   DATA   U_LONG   0011H  4
Rx_State . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0015H  1
Rx_Data_Available. . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0016H  1
_modbusCrc16 . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  Data . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
  CRC. . . . . . . . . . . . . . . . .  AUTO     DATA   PTR      0000H  3
  i. . . . . . . . . . . . . . . . . .  AUTO     DATA   U_LONG   0003H  4
DoSlaveTX. . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
SendMessage. . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
_HandleModbusError . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  ErrorCode. . . . . . . . . . . . . .  * REG *  DATA   CHAR     0007H  1
HandleModbusReadCoils. . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  startAddress . . . . . . . . . . . .  * REG *  DATA   U_INT    0004H  2
  numberOfCoil . . . . . . . . . . . .  * REG *  DATA   U_INT    0002H  2
  byteCount. . . . . . . . . . . . . .  AUTO     DATA   U_INT    0000H  2
  tempAddr . . . . . . . . . . . . . .  AUTO     DATA   U_INT    0002H  2
  i. . . . . . . . . . . . . . . . . .  AUTO     DATA   U_INT    0004H  2
  j. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0004H  2
  tempData . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0001H  1
HandleModbusReadInputCoil. . . . . . .  PUBLIC   CODE   PROC     0000H  -----
HandleModbusReadHoldingRegisters . . .  PUBLIC   CODE   PROC     0000H  -----
  startAddress . . . . . . . . . . . .  AUTO     DATA   U_INT    0000H  2
  numberOfRegisters. . . . . . . . . .  AUTO     DATA   U_INT    0002H  2
  i. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0004H  2
  currentData. . . . . . . . . . . . .  AUTO     DATA   U_INT    0004H  2
HandleModbusWriteSingleCoil. . . . . .  PUBLIC   CODE   PROC     0000H  -----
  startAddress . . . . . . . . . . . .  AUTO     DATA   U_INT    0000H  2
  value. . . . . . . . . . . . . . . .  AUTO     DATA   U_INT    0002H  2
HandleModbusWriteSingleRegister. . . .  PUBLIC   CODE   PROC     0000H  -----
  address. . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0004H  2
  value. . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0006H  2
  i. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0006H  2
HandleModbusWriteMultipleCoils . . . .  PUBLIC   CODE   PROC     0000H  -----
  startAddress . . . . . . . . . . . .  * REG *  DATA   U_INT    0004H  2
  numberOfCoil . . . . . . . . . . . .  AUTO     DATA   U_INT    0000H  2
  byteCount. . . . . . . . . . . . . .  AUTO     DATA   U_INT    0002H  2
  tempAddr . . . . . . . . . . . . . .  AUTO     DATA   U_INT    0004H  2
  i. . . . . . . . . . . . . . . . . .  AUTO     DATA   U_INT    0006H  2
  j. . . . . . . . . . . . . . . . . .  AUTO     DATA   U_INT    0008H  2
C51 COMPILER V9.59.0.0   MODBUS                                                            01/08/2019 22:45:47 PAGE 142 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


  tempData . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   000AH  1
HandleModbusWriteMultipleRegisters . .  PUBLIC   CODE   PROC     0000H  -----
  startAddress . . . . . . . . . . . .  AUTO     DATA   U_INT    0000H  2
  numberOfRegisters. . . . . . . . . .  AUTO     DATA   U_INT    0002H  2
  value. . . . . . . . . . . . . . . .  AUTO     DATA   U_INT    0004H  2
  byteCount. . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0006H  1
  i. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0005H  1
RxDataAvailable. . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  Result . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
CheckRxTimeout . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
checkModbusBufferComplete. . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  expectedReceiveCount . . . . . . . .  AUTO     DATA   LONG     0000H  4
RxRTU. . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  i. . . . . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0000H  1
  receiveBufferControl . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
TxRTU. . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
_InitModbus. . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  modbusSlaveAddress . . . . . . . . .  AUTO     DATA   U_CHAR   0007H  1
  baudrate . . . . . . . . . . . . . .  AUTO     DATA   U_LONG   0001H  4


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2670    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   1032    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     23      51
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
