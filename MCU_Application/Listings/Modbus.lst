C51 COMPILER V9.59.0.0   MODBUS                                                            01/29/2019 14:24:58 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MODBUS
OBJECT MODULE PLACED IN .\Objects\Modbus.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Modbus\Modbus.c OPTIMIZE(8,SPEED) BROWSE INCDIR(.\Lib;.\Driver;.\MainApp
                    -\sPlc;.\MainApp\sPlc_Port;.\Modbus;.\MainApp) DEBUG OBJECTEXTEND CODE LISTINCLUDE SYMBOLS PRINT(.\Listings\Modbus.lst) P
                    -REPRINT(.\Listings\Modbus.i) OBJECT(.\Objects\Modbus.obj)

line level    source

   1          #include "modbus.h"
   1      =1  #ifndef __MODBUS__H__
   2      =1  #define __MODBUS__H__
   3      =1  /*****************************************************************************/
   4      =1  #include "appConfig.h"
   1      =2  #ifndef __APPCONFIG_H__
   2      =2  #define __APPCONFIG_H__
   3      =2  /*****************************************************************************/
   4      =2  #define DEBUG_LED_ON                                            0
   5      =2  #define DEBUG_LED_OFF                                           1
   6      =2  <<<<<<< HEAD
*** ERROR C141 IN LINE 6 OF .\MainApp\appConfig.h: syntax error near '<<', expected 'hdata'
   7      =2  #define CONFIG_SYSCLK                       (48000000L)//F580内部48M
   8      =2  =======
*** ERROR C129 IN LINE 8 OF .\MainApp\appConfig.h: missing ';' before '=='
   9      =2  #define CONFIG_SYSCLK                       (22118400L)
*** WARNING C317 IN LINE 9 OF .\MainApp\appConfig.h: attempt to redefine macro 'CONFIG_SYSCLK'
  10      =2  #ifdef C8051F020
           =2 >>>>>>> MCFCL_25MP
           =2 #define SAR_CLK                                                 2000000L//ADC0时钟 <2.5MHz
           =2 #define CONFIG_DEBUG                        0//调试功能
           =2 <<<<<<< HEAD
           =2 #define CONFIG_USING_WDT                                        0//使能看门狗
           =2 #define CONFIG_USING_RESET                                      0//使能PLC复位MCU功能
           =2 #define CONFIG_LADDER_SECTORS_START                     64//指令起始地址
           =2 #define CONFIG_LADDER_SECTORS_END                       128//指令结束地址
           =2 #define CONFIG_LASERTIMER_OVERFLOW_US           1000L//定时器周期 1mS
           =2 #define CONFIG_VERSION                                          0x0001
           =2 #define CONFIG_CHECK_CODE                                       0x5A7E
           =2 
           =2 =======
           =2 >>>>>>> MCFCL_25MP
           =2 /*****************************************************************************/
           =2 #define CONFIG_UART0_BAUDRATE                           115200//串口波特率
           =2 #define CONFIG_UART0_PARITY                                     NONE
           =2 #define CONFIG_UART0_STOPBIT                            1
           =2 #define CONFIG_UART0_DATABIT                            8
           =2 
           =2 #define CONFIG_UART1_BAUDRATE                           9600//串口波特率
           =2 #define CONFIG_UART1_PARITY                                     NONE
           =2 #define CONFIG_UART1_STOPBIT                            1
           =2 #define CONFIG_UART1_DATABIT                            8
           =2 /*****************************************************************************/
           =2 <<<<<<< HEAD
           =2 #define CONFIG_I2C0_FREQ                                        1            
           =2 #define CONFIG_I2C1_FREQ                                        1
           =2 #define CONFIG_I2C2_FREQ                                        1
           =2 #define CONFIG_I2C3_FREQ                                        1
           =2 #define CONFIG_I2C4_FREQ                                        1
           =2 =======
           =2 #define CONFIG_I2C0_FREQ                                        1 
           =2 >>>>>>> MCFCL_25MP
           =2 #define CONFIG_I2C_WAITACT_TIME                         250
C51 COMPILER V9.59.0.0   MODBUS                                                            01/29/2019 14:24:58 PAGE 2   

           =2 /*****************************************************************************/
           =2 #define CONFIG_EPROM_DEBUG                                      0
           =2 #define CONFIG_EPROM_SIZE                                       CONFIG_AT24C64_SIZE
           =2 #define CONFIG_AT24C02_SIZE                             256
           =2 #define CONFIG_AT24C04_SIZE                             512
           =2 #define CONFIG_AT24C08_SIZE                             1024
           =2 #define CONFIG_AT24C16_SIZE                             2048
           =2 #define CONFIG_AT24C32_SIZE                             4096
           =2 #define CONFIG_AT24C64_SIZE                                     8192
           =2 #define CONFIG_AT24C128_SIZE                            16384
           =2 #define CONFIG_AT24C256_SIZE                            32768
           =2 #define CONFIG_EPROM_ADDRESS                            0x50
           =2 #define CONFIG_EPROM_FRAM                                       0//铁电存储体无写入等待
           =2 <<<<<<< HEAD
           =2 #define CONFIG_EPROM_FREQ                                       1//
           =2 #define CONFIG_EPROM_PAGEWRITE                          0//页写入
           =2 /*****************************************************************************/
           =2 #define CONFIG_USE_IPID                                         1//使能IPID温度控制
           =2 /*****************************************************************************/
           =2 #define CONFIG_USE_HWVER_SHOW                           1//使能固件版本显示
           =2 #define CONFIG_USE_MPD1_SHOW                            1//使能MPD1测量显示
           =2 #define CONFIG_USE_MPD2_SHOW                            1//使能MPD2测量显示
           =2 #define CONFIG_USE_FBS1                                         1//使能FBS1检测
           =2 #define CONFIG_USE_FBS2                                         1//使能FBS2检测
           =2 #define CONFIG_USE_LASER_TEMP                           1//使能激光器温度显示
           =2 #define CONFIG_USE_RADIATOR_TEMP                        1//使能散热器温度显示
           =2 #define CONFIG_USE_ENVI_TEMP                            1//使能环境温度显示
           =2 #define CONFIG_USE_IPID_UPDATE                          1//使能IPID参数更新功能
           =2 #define CONFIG_USE_IPID_OUTSHOW                         1//使能IPID输出显示
           =2 =======
           =2 #define CONFIG_EPROM_PAGEWRITE                          0//页写入
           =2 >>>>>>> MCFCL_25MP
           =2 /*****************************************************************************/
           =2 //SPLC设置
           =2 #define CONFIG_SPLC_ASSERT                                      1//检查地址范围
           =2 #define CONFIG_SPLC_DEV                                         0x0A01//设备号
           =2 #define CONFIG_SPLC_CLEAR_CODE                          0xA58E
           =2 #define CONFIG_SOFTPLC_HWTIME                           1000L//1mS
           =2 #define CONFIG_INPUT_FILTER_TIME                        3//输入数字滤波扫描周期 1mS * N
           =2 /*****************************************************************************/
           =2 #define CONFIG_SPLC_USING_CLEAR_NVRAM           1//启用清除NVRAM功能
           =2 /*****************************************************************************/
           =2 #define CONFIG_SPLC_USING_WDT                           1//看门狗启用
           =2 /*****************************************************************************/
           =2 #define CONFIG_SPLC_USING_IO_INPUT                      1//输入IO刷新启用
           =2 /*****************************************************************************/
           =2 #define CONFIG_SPLC_USING_IO_OUTPUT                     1//输出IO刷新启用
           =2 /*****************************************************************************/
           =2 #define CONFIG_SPLC_USING_EPROM                         1//EPROM掉电存储启用
           =2 /*****************************************************************************/
           =2 #define CONFIG_SPLC_USING_UART1                         1//UART1串口启用
           =2 #if CONFIG_SPLC_USING_UART1 == 1
           =2 #define SPLC_UART1                                                      1
           =2 #endif
           =2 /*****************************************************************************/
           =2 #define CONFIG_SPLC_USING_CADC                          1//使能ADC模块
           =2 #define CONFIG_SPLC_ADC_FILTER_TAP                      14//ADC位移滤波次数
           =2 #define CONFIG_SPLC_ADC_CHANNLE                         64//ADC通道数
           =2 #define CONFIG_SPLC_ADC_TEMP_SENSOR_GAIN    3330L// Temp Sensor Gain in (uV / degC)
           =2 #define CONFIG_SPLC_ADC_TEMP_SENSOR_OFFSET  856L// Temp Sensor Offset in mV
           =2 #define CONFIG_SPLC_ADC_INTERNAL_VREF           2400L// ADC Voltage Reference (mV)
           =2 #define CONFIG_SPLC_ADC_AMBIENT             25L// Ambient temp in deg C
C51 COMPILER V9.59.0.0   MODBUS                                                            01/29/2019 14:24:58 PAGE 3   

           =2 /*****************************************************************************/
           =2 #define CONFIG_SPLC_USING_DAC                           1//是能DAC模块
           =2 /*****************************************************************************/
           =2 #define CONFIG_SPLC_USING_MB_RTU_SLAVE          1//是能MODBUS RTU从站
           =2 #define CONFIG_MB_RTU_SLAVE_TIMER                       1000L//1000uS
           =2 #define CONFIG_MB_RTU_SLAVE_ADDRESS                     0x01//从设备地址
           =2 #define CONFIG_MB_RTU_SLAVE_BUFFER_SIZE         256//发送接收缓冲区
           =2 #define CONFIG_MB_RTU_SLAVE_TIMEOUT                     100//接收通讯超时 10mS
           =2 #define CONFIG_MB_RTU_SLAVE_IO_DELAY            1//RX TX切换延时
           =2 /*****************************************************************************/
           =2 <<<<<<< HEAD
           =2 /*****************************************************************************/
           =2 #define DISABLE_MODBUS_SERIAL_INTERRUPT         ES0 = 0;
           =2 #define ENABLE_MODBUS_SERIAL_INTERRUPT          ES0 = 1;
           =2 #define DISABLE_INTERRUPT                                       EA = 0;
           =2 #define ENABLE_INTERRUPT                                        EA = 1;
           =2 /*****************************************************************************/
           =2 
           =2 /*****************************************************************************/
           =2 #define ID_ONLY_1_CHANNEL                                       4321
           =2 #define ID_ONLY_2_CHANNEL                                       8765
           =2 #define ID_BOTH_CHANNEL                                         9431
           =2 #define ID_LASER_MODE_CW                                        7631
           =2 #define ID_LASER_MODE_SP                                        8934
           =2 #define ID_LASER_MODE_MP                                        2453
           =2 #define ID_LASER_MODE_GP                                        3876
           =2 /*****************************************************************************/
           =2 #define FBS1_IN_PORT                                            3
           =2 #define FBS2_IN_PORT                                            2
           =2 #define COOLON_OUT_PORT                                         (1 * 8 + 3)
           =2 /*****************************************************************************/
           =2 //PID FUZZY 模糊PID配置
           =2 #define CONFIG_TECOUT_CYCLE                                     4000//PID输出转PWM周期
           =2 /*****************************************************************************/
           =2 =======
           =2 >>>>>>> MCFCL_25MP
           =2 /*****************************************************************************/
           =2 #define DISABLE_MODBUS_SERIAL_INTERRUPT         ES0 = 0;
           =2 #define ENABLE_MODBUS_SERIAL_INTERRUPT          ES0 = 1;
           =2 #define DISABLE_INTERRUPT                                       EA = 0;
           =2 #define ENABLE_INTERRUPT                                        EA = 1;
           =2 /*****************************************************************************/
           =2 //指示盒子
           =2 #define R_BOX_RED_SENDED                                        (R_START * 16 + 126)//190
           =2 #define R_BOX_GREEN_SENDED                                      (R_START * 16 + 127)//191
           =2 #define BOX_CMD_STX                                                     0x81
           =2 #define BOX_CMD_ETX                                                     0x84
           =2 #define BOX_SEND_BFADDR                                         (EM_START + 100)//发送缓冲区位置
           =2 #define BOX_SEND_LENGTH                                         29//发送数据量
           =2 /*****************************************************************************/
           =2 #include "stdint.h"
           =2 #include "stdbool.h"
           =2 #include "endian.h"
           =2 #include "si_toolchain.h"
           =2 #include "compiler_defs.h"
           =2 <<<<<<< HEAD
           =2 #include "C8051F580_defs.h"
           =2 =======
           =2 #include "C8051F020_defs.h"
           =2 >>>>>>> MCFCL_25MP
           =2 /*****************************************************************************/
           =2 #include <stdio.h>
C51 COMPILER V9.59.0.0   MODBUS                                                            01/29/2019 14:24:58 PAGE 4   

           =2 #include <stdlib.h> 
           =2 #include <string.h>
           =2 #include <INTRINS.H>
           =2 #include <ctype.h>
           =2 #include <LIMITS.H>
           =2 #include <math.h>
           =2 <<<<<<< HEAD
           =2 /*****************************************************************************/
           =2 #include "InitDeviceF580.h"
           =2 #include "delay.h"
           =2 #include "i2c0.h"
           =2 #include "i2c1.h"
           =2 #include "i2c2.h"
           =2 #include "i2c3.h"
           =2 #include "i2c4.h"
           =2 #include "i2c5.h"
           =2 #include "i2c6.h"
           =2 #include "eprom.h"
           =2 #include "mcp47x6.h"
           =2 #include "inPca9554.h"
           =2 #include "outPca9554.h"
           =2 
           =2 =======
           =2 //#include "crc32.h"
           =2 /*****************************************************************************/
           =2 #include "InitDeviceF020.h"
           =2 #include "delay.h"
           =2 #include "i2c0.h"
           =2 #include "eprom.h"
           =2 #include "dac8568_0.h"
           =2 #include "dac8568_1.h"
           =2 #include "dac8568_2.h"
           =2 #include "dac8568_3.h"
           =2 >>>>>>> MCFCL_25MP
           =2 #if CONFIG_SPLC_USING_UART1 == 1
           =2 #include "sPlcUart.h"
           =2 #endif
           =2 #if CONFIG_SPLC_USING_CADC == 1
           =2 #include "sPlcChipAdc.h"
           =2 #endif
           =2 #if CONFIG_SPLC_USING_DAC == 1
           =2 #include "sPlcDac.h"
           =2 #endif
           =2 /*****************************************************************************/
           =2 #include "Modbus.h"
           =2 #include "ModbusPort.h"
           =2 /*****************************************************************************/
           =2 #include "sPLC.h"
           =2 <<<<<<< HEAD
           =2 #include "sPlcFun.h"
           =2 =======
           =2 #include "sPlcTimer.h"
           =2 #include "sPlcFun.h"
           =2 #include "sPlcLed.h"
           =2 #include "sPlcIo.h"
           =2 #include "sPlcWatchDog.h"
           =2 >>>>>>> MCFCL_25MP
           =2 /*****************************************************************************/
           =2 #endif
   5      =1  /*****************************************************************************/
   6      =1  extern idata volatile uint16_t modbusTimerValue;
   7      =1  extern idata volatile uint8_t modbusReceiveCounter;// Collected data number
C51 COMPILER V9.59.0.0   MODBUS                                                            01/29/2019 14:24:58 PAGE 5   

   8      =1  extern xdata volatile uint8_t modbusReceiveBuffer[CONFIG_MB_RTU_SLAVE_BUFFER_SIZE];
   9      =1  /*****************************************************************************/
  10      =1  extern void initModbus(uint8_t modbusSlaveAddress, uint32_t bd);
  11      =1  extern void modbusPorcess(void);
  12      =1  #endif
   2          /*******************************ModBus Functions*******************************/
   3          #define MODBUS_READ_COILS                                               1
   4          #define MODBUS_READ_DISCRETE_INPUTS                                     2
   5          #define MODBUS_READ_HOLDING_REGISTERS                                   3
   6          #define MODBUS_READ_INPUT_REGISTERS                                     4
   7          #define MODBUS_WRITE_SINGLE_COIL                                        5
   8          #define MODBUS_WRITE_SINGLE_REGISTER                                    6
   9          #define MODBUS_WRITE_MULTIPLE_COILS                                     15
  10          #define MODBUS_WRITE_MULTIPLE_REGISTERS                                 16
  11          /****************************End of ModBus Functions***************************/
  12          #define FALSE_FUNCTION                                                  0
  13          #define FALSE_SLAVE_ADDRESS                                             1
  14          #define DATA_NOT_READY                                                  2
  15          #define DATA_READY                                                      3
  16          #define ERROR_CODE_01                                                   0x01// function code is not supported
  17          #define ERROR_CODE_02                                                   0x02// Register address is not allowed or write-protected
  18          #define ERROR_CODE_03                                                   0x03//Some data values are out of range, invalid number of r
             -egister
  19          /*****************************************************************************/
  20          typedef enum{
  21              RXTX_IDLE,
  22              RXTX_START,
  23              RXTX_DATABUF,
  24              RXTX_WAIT_ANSWER,
  25              RXTX_TIMEOUT
  26          }MODBUS_RXTX_STATE;
  27          typedef struct{
  28                  uint8_t address;
  29                  uint8_t function;
  30                  uint8_t dataBuf[CONFIG_MB_RTU_SLAVE_BUFFER_SIZE];
  31                  uint16_t dataLen;
  32          }modbusRxTxData_t;
  33          /**********************Slave Transmit and Receive Variables********************/
  34          idata uint8_t ModbusSlaveAddress = 1;
  35          xdata modbusRxTxData_t Tx_Data;
  36          idata uint32_t Tx_Current = 0;
  37          idata uint32_t Tx_CRC16 = 0xFFFF;
  38          idata MODBUS_RXTX_STATE Tx_State = RXTX_IDLE;
  39          xdata uint8_t Tx_Buf[CONFIG_MB_RTU_SLAVE_BUFFER_SIZE];
  40          idata uint32_t Tx_Buf_Size = 0;
  41          /*****************************************************************************/
  42          xdata modbusRxTxData_t Rx_Data;
  43          idata uint32_t Rx_CRC16 = 0xFFFF;
  44          idata MODBUS_RXTX_STATE Rx_State = RXTX_IDLE;
  45          idata uint8_t Rx_Data_Available = false;
  46          /*****************************************************************************/
  47          idata volatile uint16_t modbusTimerValue = 0;
  48          idata volatile uint8_t modbusReceiveCounter = 0;// Collected data number
  49          xdata volatile uint8_t modbusReceiveBuffer[CONFIG_MB_RTU_SLAVE_BUFFER_SIZE];// Buffer to collect data from
             - hardware
  50          /*****************************************************************************/
  51          void modbusCrc16(const uint8_t Data, uint32_t* CRC){
  52              idata uint32_t i;
  53              *CRC = *CRC ^(uint32_t) Data;
  54              for (i = 8; i > 0; i--){
  55                  if (*CRC & 0x0001)
  56                      *CRC = (*CRC >> 1) ^ 0xA001;
C51 COMPILER V9.59.0.0   MODBUS                                                            01/29/2019 14:24:58 PAGE 6   

  57                  else
  58                      *CRC >>= 1;
  59              }
  60          }
  61          uint8_t DoSlaveTX(void){//It is used for send data package over physical layer
  62              modBusUartString(Tx_Buf, Tx_Buf_Size);
  63              Tx_Buf_Size = 0;
  64              return true;
  65          }
  66          uint8_t SendMessage(void){//This function start to sending messages
  67              if (Tx_State != RXTX_IDLE){
  68                  return false;
  69                  }
  70              Tx_Current  =0;
  71              Tx_State    =RXTX_START;
  72              return true;
  73          }
  74          void HandleModbusError(char ErrorCode){// Initialise the output buffer. The first byte in the buffer says 
             -how many registers we have read
  75              setLedError(DEBUG_LED_ON);
  76                  Tx_Data.function = ErrorCode | 0x80;
  77              Tx_Data.address = ModbusSlaveAddress;
  78              Tx_Data.dataLen = 0; 
  79                  SendMessage();
  80                  setLedError(DEBUG_LED_OFF);
  81          }
  82          
  83          void HandleModbusReadCoils(void){//Modbus function 01 - 读取线圈状态
  84                  idata uint16_t startAddress, numberOfCoil, byteCount, tempAddr, i, j;
  85                  idata uint8_t tempData = 0;
  86                  // The message contains the requested start address and number of registers
  87              startAddress = ((uint16_t) (Rx_Data.dataBuf[0]) << 8) + (uint16_t) (Rx_Data.dataBuf[1]);
  88              numberOfCoil = ((uint16_t) (Rx_Data.dataBuf[2]) << 8) + (uint16_t) (Rx_Data.dataBuf[3]);
  89                  if((startAddress + numberOfCoil) > (CONFIG_NVRAM_SIZE * 16)){//If it is bigger than RegisterNumber return
             - error to Modbus Master
  90                  HandleModbusError(ERROR_CODE_02);
  91                  }
  92                  else{
  93                          byteCount = numberOfCoil / 8;
  94                          if((numberOfCoil % 8) != 0){
  95                                  byteCount += 1;
  96                          }
  97                          Tx_Data.function = MODBUS_READ_COILS;
  98                          Tx_Data.address = ModbusSlaveAddress;
  99                          Tx_Data.dataLen = 1;
 100                          tempAddr = startAddress;
 101                          for(i = 0; i < byteCount; i ++){
 102                                  Tx_Data.dataBuf[Tx_Data.dataLen] = 0;
 103                                  for(j = 0; j < 8; j ++){
 104                                          tempData = (NVRAM0[(tempAddr / 16)] >> (tempAddr % 16)) & 0x01;
 105                                          Tx_Data.dataBuf[Tx_Data.dataLen] |= (uint8_t)(tempData << j);
 106                                          tempAddr++;     
 107                                          //if(tempAddr >= startAddress + numberOfCoil){//读完
 108                                          //      exit = 1;
 109                                          //      break;
 110                                          //} 
 111                                  }
 112                                  Tx_Data.dataLen ++;     
 113                          }
 114                          Tx_Data.dataBuf[0] = Tx_Data.dataLen - 1;
 115                          SendMessage();
 116                  }
C51 COMPILER V9.59.0.0   MODBUS                                                            01/29/2019 14:24:58 PAGE 7   

 117          }
 118          void HandleModbusReadInputCoil(void){//Modbus function 02 - 读取输入线圈状态
 119          }
 120          void HandleModbusReadHoldingRegisters(void){//Modbus function 03 - Read holding registers
 121              idata uint16_t startAddress, numberOfRegisters, i, currentData;
 122                  // The message contains the requested start address and number of registers
 123              startAddress = ((uint16_t) (Rx_Data.dataBuf[0]) << 8) + (uint16_t) (Rx_Data.dataBuf[1]);
 124              numberOfRegisters = ((uint16_t) (Rx_Data.dataBuf[2]) << 8) + (uint16_t) (Rx_Data.dataBuf[3]);
 125                  if((startAddress + numberOfRegisters) > CONFIG_NVRAM_SIZE){//If it is bigger than RegisterNumber return e
             -rror to Modbus Master
 126                  HandleModbusError(ERROR_CODE_02);
 127                  }
 128              else{//Initialise the output buffer. The first byte in the buffer says how many registers we have read
 129                  Tx_Data.function = MODBUS_READ_HOLDING_REGISTERS;
 130                  Tx_Data.address = ModbusSlaveAddress;
 131                  Tx_Data.dataLen = 1;
 132                  Tx_Data.dataBuf[0] = 0;
 133                  for (i = 0;i < numberOfRegisters;i ++){
 134                      currentData = (uint16_t)NVRAM0[startAddress + i];
 135                      Tx_Data.dataBuf[Tx_Data.dataLen] = (uint8_t)((currentData & 0xFF00) >> 8);
 136                      Tx_Data.dataBuf[Tx_Data.dataLen + 1] = (uint8_t)(currentData & 0x00FF);
 137                      Tx_Data.dataLen += 2;
 138                      Tx_Data.dataBuf[0] = Tx_Data.dataLen - 1;
 139                  }
 140                  SendMessage();
 141              }
 142          }
 143          void HandleModbusWriteSingleCoil(void){//Modbus function 05 -强置单线圈
 144                  idata uint16_t startAddress, value;
 145                  // The message contains the requested start address and number of registers
 146              startAddress = ((uint16_t) (Rx_Data.dataBuf[0]) << 8) + (uint16_t) (Rx_Data.dataBuf[1]);
 147                  value = ((uint16_t) (Rx_Data.dataBuf[2]) << 8) + (uint16_t)(Rx_Data.dataBuf[3]);
 148                  if((startAddress) > (CONFIG_NVRAM_SIZE * 16)){//If it is bigger than RegisterNumber return error to Modbu
             -s Master
 149                  HandleModbusError(ERROR_CODE_02);
 150                  }
 151                  else{
 152                          Tx_Data.function = MODBUS_WRITE_SINGLE_COIL;
 153                          Tx_Data.address = ModbusSlaveAddress;
 154                          Tx_Data.dataLen = 4;
 155                          Tx_Data.dataBuf[0] = Rx_Data.dataBuf[0];
 156                          Tx_Data.dataBuf[1] = Rx_Data.dataBuf[1];
 157                          if(value == 0x0000){//0
 158                                  NVRAM0[(startAddress / 16)] &= ~((uint16_t)(1 << (startAddress % 16)));
 159                                  Tx_Data.dataBuf[2] = 0x00;
 160                                  Tx_Data.dataBuf[3] = 0x00;
 161                          }
 162                          else if(value == 0xFF00){//1
 163                                  NVRAM0[(startAddress / 16)] |= (uint16_t)(1 << (startAddress % 16));
 164                                  Tx_Data.dataBuf[2] = 0xFF;
 165                                  Tx_Data.dataBuf[3] = 0x00;
 166                          }
 167                          else{           
 168                          }
 169                          SendMessage();
 170                  }
 171          }
 172          void HandleModbusWriteSingleRegister(void){//Modbus function 06 - Write single register
 173              idata uint16_t address, value,i;
 174              // The message contains the requested start address and number of registers
 175              address = ((uint16_t) (Rx_Data.dataBuf[0]) << 8) + (uint16_t)(Rx_Data.dataBuf[1]);
 176              value = ((uint16_t) (Rx_Data.dataBuf[2]) << 8) + (uint16_t)(Rx_Data.dataBuf[3]);
C51 COMPILER V9.59.0.0   MODBUS                                                            01/29/2019 14:24:58 PAGE 8   

 177              // Initialise the output buffer. The first byte in the buffer says how many registers we have read
 178              Tx_Data.function = MODBUS_WRITE_SINGLE_REGISTER;
 179              Tx_Data.address = ModbusSlaveAddress;
 180              Tx_Data.dataLen = 4;
 181              if(address >= CONFIG_NVRAM_SIZE){
 182                  HandleModbusError(ERROR_CODE_03);
 183                  }
 184              else{
 185                          NVRAM0[address] = (int16_t)value;
 186                  for (i = 0; i < 4; ++i){
 187                      Tx_Data.dataBuf[i] = Rx_Data.dataBuf[i];
 188                          }
 189              }
 190              SendMessage();
 191          }
 192          void HandleModbusWriteMultipleCoils(void){//Modbus function 15 - Write multiple coils
 193                  idata uint16_t startAddress, numberOfCoil, byteCount, tempAddr, i, j;
 194                  idata uint8_t tempData = 0;
 195                  // The message contains the requested start address and number of registers
 196              startAddress = ((uint16_t) (Rx_Data.dataBuf[0]) << 8) + (uint16_t) (Rx_Data.dataBuf[1]);
 197              numberOfCoil = ((uint16_t) (Rx_Data.dataBuf[2]) << 8) + (uint16_t) (Rx_Data.dataBuf[3]);
 198                  if((startAddress + numberOfCoil) > (CONFIG_NVRAM_SIZE * 16)){//If it is bigger than RegisterNumber return
             - error to Modbus Master
 199                  HandleModbusError(ERROR_CODE_02);
 200                  }
 201                  else{
 202                          byteCount = numberOfCoil / 8;
 203                          if((numberOfCoil % 8) != 0){
 204                                  byteCount += 1;
 205                          }
 206                          Tx_Data.function = MODBUS_WRITE_MULTIPLE_COILS;
 207                          Tx_Data.address = ModbusSlaveAddress;
 208                          Tx_Data.dataLen = 4;
 209                          Tx_Data.dataBuf[0] = Rx_Data.dataBuf[0];
 210                          Tx_Data.dataBuf[1] = Rx_Data.dataBuf[1];
 211                          Tx_Data.dataBuf[2] = Rx_Data.dataBuf[2];
 212                          Tx_Data.dataBuf[3] = Rx_Data.dataBuf[3];
 213                          tempAddr = startAddress;
 214                          for(i = 0;i < byteCount;i ++){
 215                                  for(j = 0;j < 8;j ++){
 216                                          tempData = (uint8_t)((Rx_Data.dataBuf[(5 + i)] >> j) & 0x01);
 217                                          if(tempData){//ON
 218                                                  NVRAM0[(tempAddr / 16)] |= (uint16_t)(1 << (tempAddr % 16));
 219                                          }
 220                                          else{//OFF
 221                                                  NVRAM0[(tempAddr / 16)] &= ~((uint16_t)(1 << (tempAddr % 16)));
 222                                          }
 223                                          tempAddr ++;
 224                                          numberOfCoil --;
 225                                          if(numberOfCoil == 0){
 226                                                  break;
 227                                          }
 228                                  }
 229                                  
 230                          }
 231                          SendMessage();
 232                  }
 233          }
 234          void HandleModbusWriteMultipleRegisters(void){//Modbus function 16 - Write multiple registers
 235              // Write single numerical output
 236              idata uint16_t startAddress, numberOfRegisters, value;
 237              idata uint8_t byteCount , i;
C51 COMPILER V9.59.0.0   MODBUS                                                            01/29/2019 14:24:58 PAGE 9   

 238              // The message contains the requested start address and number of registers
 239              startAddress = ((uint16_t)(Rx_Data.dataBuf[0]) << 8) + (uint16_t)(Rx_Data.dataBuf[1]);
 240              numberOfRegisters = ((uint16_t)(Rx_Data.dataBuf[2]) << 8) + (uint16_t)(Rx_Data.dataBuf[3]);
 241              byteCount = Rx_Data.dataBuf[4];
 242              // If it is bigger than RegisterNumber return error to Modbus Master
 243              if((startAddress+numberOfRegisters) > CONFIG_NVRAM_SIZE){
 244                  HandleModbusError(ERROR_CODE_03);
 245                  }
 246              else{
 247                  // Initialise the output buffer. The first byte in the buffer says how many outputs we have set
 248                  Tx_Data.function = MODBUS_WRITE_MULTIPLE_REGISTERS;
 249                  Tx_Data.address = ModbusSlaveAddress;
 250                  Tx_Data.dataLen = 4;
 251                  Tx_Data.dataBuf[0] = Rx_Data.dataBuf[0];
 252                  Tx_Data.dataBuf[1] = Rx_Data.dataBuf[1];
 253                  Tx_Data.dataBuf[2] = Rx_Data.dataBuf[2];
 254                  Tx_Data.dataBuf[3] = Rx_Data.dataBuf[3];
 255                  // Output data buffer is exact copy of input buffer
 256                  for (i = 0;i < numberOfRegisters;i ++){
 257                      value = (uint16_t)((Rx_Data.dataBuf[5 + 2 * i] << 8) & 0xFF00) + (uint16_t)((Rx_Data.dataBuf[6
             - + 2 * i]) & 0x00FF);
 258                      NVRAM0[startAddress + i] = (int16_t)value;
 259                  }
 260                  SendMessage();
 261              }
 262          }
 263          uint8_t RxDataAvailable(void){//RxDataAvailable
 264              idata uint8_t Result = Rx_Data_Available;   
 265              Rx_Data_Available = false;
 266              return Result;
 267          }
 268          uint8_t CheckRxTimeout(void){//CheckRxTimeout
 269              // A return value of true indicates there is a timeout    
 270              if (modbusTimerValue >= CONFIG_MB_RTU_SLAVE_BUFFER_SIZE){
 271                  modbusTimerValue = 0;
 272                  modbusReceiveCounter = 0;
 273                  return true;
 274              }
 275              return false;
 276          }
 277          uint8_t checkModbusBufferComplete(void){//CheckBufferComplete
 278              idata int32_t expectedReceiveCount=0;
 279              if(modbusReceiveCounter > 4)
 280              {
 281                  if(modbusReceiveBuffer[0] == ModbusSlaveAddress)
 282                  {
 283                      if(modbusReceiveBuffer[1]==0x01 || modbusReceiveBuffer[1]==0x02 || modbusReceiveBuffer[1]==0x0
             -3 || modbusReceiveBuffer[1]==0x04 || modbusReceiveBuffer[1]==0x05 || modbusReceiveBuffer[1]==0x06)  // RHR
 284                      {
 285                          expectedReceiveCount = 8;
 286                      }
 287                      else if(modbusReceiveBuffer[1] == 0x0F || modbusReceiveBuffer[1] == 0x10)
 288                      {
 289                          expectedReceiveCount=modbusReceiveBuffer[6] + 9;
 290                      }
 291                      else{
 292                          modbusReceiveCounter = 0;
 293                          return FALSE_FUNCTION;
 294                      }
 295                  }
 296                  else
 297                  {
C51 COMPILER V9.59.0.0   MODBUS                                                            01/29/2019 14:24:58 PAGE 10  

 298                      modbusReceiveCounter=0;
 299                      return FALSE_SLAVE_ADDRESS;
 300                  }
 301              }
 302              else
 303                  return DATA_NOT_READY;
 304          
 305              if(modbusReceiveCounter==expectedReceiveCount)
 306              {
 307                  return DATA_READY;
 308              }
 309          
 310              return DATA_NOT_READY;
 311          }
 312          void RxRTU(void){//Check for data ready, if it is good return answer
 313              idata uint8_t i;
 314              idata uint8_t receiveBufferControl=0;
 315              receiveBufferControl = checkModbusBufferComplete();
 316              if(receiveBufferControl == DATA_READY){
 317                  Rx_Data.address               =modbusReceiveBuffer[0];
 318                  Rx_CRC16                      = 0xffff;
 319                  modbusCrc16(Rx_Data.address, &Rx_CRC16);
 320                  Rx_Data.function              =modbusReceiveBuffer[1];
 321                  modbusCrc16(Rx_Data.function, &Rx_CRC16);
 322          
 323                  Rx_Data.dataLen=0;
 324          
 325                  for(i=2;i<modbusReceiveCounter;i++)
 326                      Rx_Data.dataBuf[Rx_Data.dataLen++]=modbusReceiveBuffer[i];
 327          
 328                  Rx_State =RXTX_DATABUF;
 329          
 330                  modbusReceiveCounter=0;
 331              }
 332          
 333              CheckRxTimeout();
 334          
 335              if ((Rx_State == RXTX_DATABUF) && (Rx_Data.dataLen >= 2))
 336              {
 337                  // Finish off our CRC check
 338                  Rx_Data.dataLen -= 2;
 339                  for (i = 0; i < Rx_Data.dataLen; ++i)
 340                  {
 341                      modbusCrc16(Rx_Data.dataBuf[i], &Rx_CRC16);
 342                  }
 343                  
 344                  if (((uint32_t) Rx_Data.dataBuf[Rx_Data.dataLen] + ((uint32_t) Rx_Data.dataBuf[Rx_Data.dataLen + 1
             -] << 8)) == Rx_CRC16)
 345                  {
 346                      // Valid message!
 347                      Rx_Data_Available = true;
 348                  }
 349          
 350                  Rx_State = RXTX_IDLE;
 351              }
 352          }
 353          void TxRTU(void){//If it is ready send answers!
 354              Tx_CRC16 = 0xFFFF;
 355              Tx_Buf_Size = 0;
 356              Tx_Buf[Tx_Buf_Size++] = Tx_Data.address;
 357              modbusCrc16(Tx_Data.address, &Tx_CRC16);
 358              Tx_Buf[Tx_Buf_Size++] = Tx_Data.function;
C51 COMPILER V9.59.0.0   MODBUS                                                            01/29/2019 14:24:58 PAGE 11  

 359              modbusCrc16(Tx_Data.function, &Tx_CRC16);
 360              for(Tx_Current=0; Tx_Current < Tx_Data.dataLen; Tx_Current++){
 361                  Tx_Buf[Tx_Buf_Size++] = Tx_Data.dataBuf[Tx_Current];
 362                  modbusCrc16(Tx_Data.dataBuf[Tx_Current], &Tx_CRC16);
 363              }
 364              Tx_Buf[Tx_Buf_Size++] = Tx_CRC16 & 0x00FF;
 365              Tx_Buf[Tx_Buf_Size++] = (Tx_CRC16 & 0xFF00) >> 8;
 366              DoSlaveTX();
 367              Tx_State = RXTX_IDLE;
 368          }
 369          void modbusPorcess(void){//ModBus main core! Call this function into main!
 370              if (Tx_State != RXTX_IDLE){                                      // If answer is ready, send it!
 371                  TxRTU();
 372                  }
 373              RxRTU();                                                              // Call this function every cycl
             -e
 374              if (RxDataAvailable()){
 375                  if (Rx_Data.address == ModbusSlaveAddress){
 376                      switch (Rx_Data.function)                                     // Data is for us but which func
             -tion?
 377                      {
 378                                          case MODBUS_READ_COILS:{//FUN 01
 379                                                  HandleModbusReadCoils();
 380                                                  break;
 381                                          }
 382                          case MODBUS_READ_HOLDING_REGISTERS:{//FUN 03
 383                                                  HandleModbusReadHoldingRegisters();
 384                                                  break;  
 385                                          }
 386                                          case MODBUS_WRITE_SINGLE_COIL:{//FUN 05
 387                                                  HandleModbusWriteSingleCoil();
 388                                                  break;
 389                                          }
 390                          case MODBUS_WRITE_SINGLE_REGISTER:{//FUN 06
 391                                                  HandleModbusWriteSingleRegister();
 392                                                  break;
 393                                          }
 394                                          case MODBUS_WRITE_MULTIPLE_COILS:{//FUN 15
 395                                                  HandleModbusWriteMultipleCoils();
 396                                                  break;
 397                                          }
 398                          case MODBUS_WRITE_MULTIPLE_REGISTERS:{//FUN 16
 399                                                  HandleModbusWriteMultipleRegisters();
 400                                                  break;
 401                                          }
 402                          default:{
 403                                                  HandleModbusError(ERROR_CODE_01);
 404                                                  break;
 405                                          }
 406                      }
 407                  }
 408              }
 409          }
 410          void InitModbus(uint8_t modbusSlaveAddress, uint32_t baudrate){//ModBus slave initialize
 411              ModbusSlaveAddress = modbusSlaveAddress;
 412              modBusUartInitialise(baudrate);
 413              modBusTimerInitialise();
 414          }
*** WARNING C316 IN LINE 414 OF Modbus\Modbus.c: unterminated conditionals

C51 COMPILATION COMPLETE.  2 WARNING(S),  2 ERROR(S)
