#include "dcHmiApp.h"
/*****************************************************************************/
#define WORKSTEP_POWERUP							0//上电
//自检状态
#define WORKSTEP_CHECK_EPROM						100//单片机自检
#define WORKSTEP_CHECK_INTBUS						101//触摸屏通信自检
#define WORKSTEP_CHECK_LDR							102//激光驱动器自检
#define WORKSTEP_CHECK_TEMPER						103//温度自检
#define WORKSTEP_CHECK_USBHOST						104//USBHOST模块自检
#define WORKSTEP_CHECK_NFC							105//NFC模块自检
#define WORKSTEP_CHECK_NRF24L01						106//无线脚踏RF自检
//密码输入状态
#define WORKSTEP_PASSWORD_INPUT						200//密码输入状态
#define WORKSTEP_PASSWORD_NEW						201//密码更改状态


#define WORKSTEP_STANDBY							100//等待状态
#define WORKSTEP_READY_LOAD_PARA					101//载入参数
#define WORKSTEP_READY_LOAD_DONE					102//载入参数完毕
#define WORKSTEP_LASER_TRIGGER						103//激光触发
#define WORKSTEP_LASER_EMITING						104//激光发射中
#define WORKSTEP_LASER_STOP							105//激光发射结束

#define WORKSTEP_OPTION								200//选项菜单
#define WORKSTEP_FAULT								-1//故障状态
/*****************************************************************************/
#if CONFIG_USING_DCHMI_APP == 1
void dcHmiLoopInit(void){//初始化模块
	NVRAM0[EM_HMI_OPERA_STEP] = 0;
}
void dcHmiLoop(void){//HMI轮训程序
	uint8_t cTemp0, cTemp1, cTemp2, cTemp3;
	if(NVRAM0[EM_HMI_OPERA_STEP] == WORKSTEP_FAULT){//故障步骤
		if(LD(R_SAFE_FAULT)){
			NVRAM0[EM_HMI_OPERA_STEP] = WORKSTEP_FAULT;
			SET(Y_LED_ALARM);//故障灯亮
			SET(SPCOIL_BEEM_ENABLE);//蜂鸣器常响
		}
		else{
			RES(Y_LED_ALARM);//故障灯亮
			RES(SPCOIL_BEEM_ENABLE);//蜂鸣器常响
			NVRAM0[EM_HMI_OPERA_STEP] = WORKSTEP_STANDBY;
		}
	}
	if(NVRAM0[EM_HMI_OPERA_STEP] == WORKSTEP_POWERUP){//上电步骤
		NVRAM0[EM_HMI_PAGE] = 0x0;//HMI页面
		NVRAM0[EM_START_PROGRESS_BAR] = 0x0;//开机进度条
		//设置默认密码
		NVRAM0[EM_DEFAULT_PASSWORD0] = (CONFIG_DEFAULT_PASSSWORD0 << 8) | CONFIG_DEFAULT_PASSSWORD0;
		NVRAM0[EM_DEFAULT_PASSWORD1] = (CONFIG_DEFAULT_PASSSWORD1 << 8) | CONFIG_DEFAULT_PASSSWORD1;
		loadScheme();//从掉电存储寄存器中恢复方案参数
		NVRAM0[EM_HMI_OPERA_STEP] = WORKSTEP_CHECK_EPROM;
		RES(R_CHECK_EPROM_DONE);
		RES(R_CHECK_INTBUS_DONE);			
		RES(R_CHECK_LDR_DONE);			
		RES(R_CHECK_TEMPER_DONE);				
		RES(R_CHECK_USBHOST_DONE);		
		RES(R_CHECK_NFC_DONE);			
		RES(R_CHECK_NRF24L01_DONE);	

		RES(R_CHECK_EPROM_PASS);				
		RES(R_CHECK_INTBUS_PASS);						
		RES(R_CHECK_LDR_PASS);						
		RES(R_CHECK_TEMPER_PASS);					
		RES(R_CHECK_USBHOST_PASS);					
		RES(R_CHECK_NFC_PASS);						
		RES(R_CHECK_NRF24L01_PASS);					

		RES(R_CHECK_EPROM_FAIL);						
		RES(R_CHECK_INTBUS_FAIL);						
		RES(R_CHECK_LDR_FAIL);						
		RES(R_CHECK_TEMPER_FAIL);						
		RES(R_CHECK_USBHOST_FAIL);					
		RES(R_CHECK_NFC_FAIL);						
		RES(R_CHECK_NRF24L01_FAIL);					
		return;
	}
	if(NVRAM0[EM_HMI_OPERA_STEP] == WORKSTEP_CHECK_EPROM){//EPROM自检步骤
		//测试FM24C64
		if(LDB(R_CHECK_EPROM_PASS) && LDB(R_CHECK_EPROM_FAIL)){
#if CONFIG_SPLC_USING_EPROM == 1
			epromWriteOneByte((CONFIG_EPROM_SIZE - 1), 0x12);//写EPROM
			epromWriteOneByte((CONFIG_EPROM_SIZE - 2), 0x34);//写EPROM
			epromWriteOneByte((CONFIG_EPROM_SIZE - 3), 0x56);//写EPROM
			epromWriteOneByte((CONFIG_EPROM_SIZE - 4), 0x78);//写EPROM
			//读EPROM
			cTemp0 = epromReadOneByte((CONFIG_EPROM_SIZE - 1));
			cTemp1 = epromReadOneByte((CONFIG_EPROM_SIZE - 2));
			cTemp2 = epromReadOneByte((CONFIG_EPROM_SIZE - 3));
			cTemp3 = epromReadOneByte((CONFIG_EPROM_SIZE - 4));
			if((cTemp0 == 0x12) && (cTemp1 == 0x34) && (cTemp2 == 0x56) && (cTemp3 == 0x78)){
				SET(R_CHECK_EPROM_PASS);
				RES(R_CHECK_EPROM_FAIL);
				NVRAM0[EM_ERROR_CODE] = ERRPR_CODE_NOERR;
			}
			else{
				RES(R_CHECK_EPROM_PASS);
				SET(R_CHECK_EPROM_FAIL);
				NVRAM0[EM_ERROR_CODE] = ERROR_CODE_EPROM;
			}
#else
			SET(R_CHECK_EPROM_PASS);
			RES(R_CHECK_EPROM_FAIL);
			NVRAM0[EM_ERROR_CODE] = ERRPR_CODE_NOERR;
#endif
		}
		if(LD(R_CHECK_EPROM_PASS)){
			T100MS(T100MS_CHECK_FLASH_DELAY, true, 3);
			if(LD(T_100MS_START * 16 + T100MS_CHECK_FLASH_DELAY)){
				T100MS(T100MS_CHECK_FLASH_DELAY, false, 3);
				NVRAM0[EM_HMI_OPERA_STEP] = WORKSTEP_CHECK_INTBUS;
				SET(R_CHECK_EPROM_DONE);
			}
			else{
				NVRAM0[EM_HMI_OPERA_STEP] = WORKSTEP_CHECK_EPROM;
			}
		}
		else{
			NVRAM0[EM_HMI_OPERA_STEP] = WORKSTEP_CHECK_EPROM;
		}
		return;
	}
	if(NVRAM0[EM_HMI_OPERA_STEP] == WORKSTEP_CHECK_INTBUS){//内部总线自检步骤
		T100MS(T100MS_CHECK_INTBUS_DELAY, true, 3);
		if(LD(T_100MS_START * 16 + T100MS_CHECK_INTBUS_DELAY)){
			T100MS(T100MS_CHECK_INTBUS_DELAY, false, 3);
			NVRAM0[EM_HMI_OPERA_STEP] = WORKSTEP_CHECK_LDR;
			SET(R_CHECK_INTBUS_DONE);
		}
		else{
			NVRAM0[EM_HMI_OPERA_STEP] = WORKSTEP_CHECK_INTBUS;
		}
		return;
	}
	if(NVRAM0[EM_HMI_OPERA_STEP] == WORKSTEP_CHECK_LDR){//激光驱动器自检步骤
		T100MS(T100MS_CHECK_LDR_DELAY, true, 3);
		if(LD(T_100MS_START * 16 + T100MS_CHECK_LDR_DELAY)){
			T100MS(T100MS_CHECK_LDR_DELAY, false, 3);
			NVRAM0[EM_HMI_OPERA_STEP] = WORKSTEP_CHECK_TEMPER;
			SET(R_CHECK_LDR_DONE);
		}
		else{
			NVRAM0[EM_HMI_OPERA_STEP] = WORKSTEP_CHECK_LDR;
		}
		return;
	}
	if(NVRAM0[EM_HMI_OPERA_STEP] == WORKSTEP_CHECK_TEMPER){//温度自检步骤
		T100MS(T100MS_CHECK_TEMPER_DELAY, true, 3);
		if(LD(T_100MS_START * 16 + T100MS_CHECK_TEMPER_DELAY)){
			T100MS(T100MS_CHECK_TEMPER_DELAY, false, 3);
			NVRAM0[EM_HMI_OPERA_STEP] = WORKSTEP_CHECK_USBHOST;
			SET(R_CHECK_TEMPER_DONE);
		}
		else{
			NVRAM0[EM_HMI_OPERA_STEP] = WORKSTEP_CHECK_TEMPER;
		}
		return;
	}
	if(NVRAM0[EM_HMI_OPERA_STEP] == WORKSTEP_CHECK_USBHOST){//USBHOST自检步骤
		T100MS(T100MS_CHECK_USBHOST_DELAY, true, 3);
		if(LD(T_100MS_START * 16 + T100MS_CHECK_USBHOST_DELAY)){
			NVRAM0[EM_HMI_OPERA_STEP] = WORKSTEP_CHECK_USBHOST;
			SET(R_CHECK_USBHOST_DONE);
		}
		else{
			NVRAM0[EM_HMI_OPERA_STEP] = WORKSTEP_CHECK_NFC;
		}
		return;
	}
	if(NVRAM0[EM_HMI_OPERA_STEP] == WORKSTEP_CHECK_NFC){//NFC自检步骤
		T100MS(T100MS_CHECK_NFC_DELAY, true, 3);
		if(LD(T_100MS_START * 16 + T100MS_CHECK_NFC_DELAY)){
			NVRAM0[EM_HMI_OPERA_STEP] = WORKSTEP_CHECK_NRF24L01;
			SET(R_CHECK_NFC_DONE);
		}
		else{
			NVRAM0[EM_HMI_OPERA_STEP] = WORKSTEP_CHECK_NFC;
		}
		return;
	}
	if(NVRAM0[EM_HMI_OPERA_STEP] == WORKSTEP_CHECK_NRF24L01){//NRF24L01自检步骤
		T100MS(T100MS_CHECK_NRF24L01_DELAY, true, 3);
		if(LD(T_100MS_START * 16 + T100MS_CHECK_NRF24L01_DELAY)){
			NVRAM0[EM_HMI_OPERA_STEP] = WORKSTEP_STANDBY;
			SET(R_CHECK_NRF24L01_DONE);
		}
		else{
			NVRAM0[EM_HMI_OPERA_STEP] = WORKSTEP_CHECK_NRF24L01;
		}
		return;
	}
	if(NVRAM0[EM_HMI_OPERA_STEP] == WORKSTEP_STANDBY){//STANDBY
		if(LD(R_SAFE_FAULT)){//
			NVRAM0[EM_HMI_OPERA_STEP] = WORKSTEP_FAULT;
		}
		else{
			if(LD(R_KEY_READY)){
				NVRAM0[SPREG_BEEM_MODE] = BEEM_MODE_0;
				NVRAM0[SPREG_BEEM_VOLUME] = NVRAM0[DM_BEEM_VOLUME];
				SET(SPCOIL_BEEM_ENABLE);//打开蜂鸣器			
				NVRAM0[EM_HMI_OPERA_STEP] = WORKSTEP_READY_LOAD_PARA;
			}
			else{
				NVRAM0[EM_HMI_OPERA_STEP] = WORKSTEP_STANDBY;
			}
		}
		return;
	}
	if(NVRAM0[EM_HMI_OPERA_STEP] == WORKSTEP_READY_LOAD_PARA){//READY
		NVRAM0[SPREG_LASER_MODE] = NVRAM0[EM_LASER_PULSE_MODE];
		NVRAM0[SPREG_LASER_SELECT] = NVRAM0[EM_LASER_SELECT];
		NVRAM0[SPREG_LASER_TMATE] = NVRAM0[EM_LASER_POSWIDTH];//激光脉冲正脉宽 10mS
		NVRAM0[SPREG_LASER_TOVERTIME] = NVRAM0[EM_LASER_POSWIDTH] + NVRAM0[EM_LASER_NEGWIDTH];//激光脉冲周期 25mS
		NVRAM0[SPREG_LASER_PMATE] = NVRAM0[EM_LASER_GROUP];//10个脉冲
		NVRAM0[SPREG_LASER_POVERTIME] = NVRAM0[EM_LASER_SPACE];//间隔33mS
		PCLAR0(EM_LASER_POWER_CH0, SPREG_DAC_0);//功率->DAC CODE
		PCLAR1(EM_LASER_POWER_CH1, SPREG_DAC_1);//功率->DAC CODE
		T100MS(T100MS_READY_BEEM_DELAY, true, 3);//启动计时器延时500mS//打开计时器
		//清空计时器
		if(LD(T_100MS_START * 16 + T100MS_READY_BEEM_DELAY)){
			T100MS(T100MS_READY_BEEM_DELAY, false, 3);
			NVRAM0[EM_HMI_OPERA_STEP] = WORKSTEP_READY_LOAD_DONE;
		}
		else{
			NVRAM0[EM_HMI_OPERA_STEP] = WORKSTEP_READY_LOAD_PARA;
		}
		return;
	}
	if(NVRAM0[EM_HMI_OPERA_STEP] == WORKSTEP_READY_LOAD_DONE){//READY状态
		RES(SPCOIL_BEEM_ENABLE);//关闭蜂鸣器
		NVRAM0[EM_HMI_OPERA_STEP] = WORKSTEP_LASER_TRIGGER;
		return;
	}
	if(NVRAM0[EM_HMI_OPERA_STEP] == WORKSTEP_LASER_TRIGGER){//等待触发激光
		if(LD(R_SAFE_FAULT)){
			NVRAM0[EM_HMI_OPERA_STEP] = WORKSTEP_FAULT;	
		}
		else{
			if(LD(R_KEY_READY)){
				if(LD(X_FOOTSWITCH_OC) && LDB(X_FOOTSWITCH_ON)){//发射激光	
					NVRAM0[SPREG_BEEM_MODE] = BEEM_MODE_1;
					NVRAM0[SPREG_BEEM_VOLUME] = NVRAM0[DM_BEEM_VOLUME];
					SET(SPCOIL_BEEM_ENABLE);//打开蜂鸣器		
					STLAR();
					NVRAM0[EM_HMI_OPERA_STEP] = WORKSTEP_LASER_EMITING;	
				}		
			}
			else{
				NVRAM0[EM_HMI_OPERA_STEP] = WORKSTEP_STANDBY;	
			}
		}
		return;
	}
	if(NVRAM0[EM_HMI_OPERA_STEP] == WORKSTEP_LASER_EMITING){//等待触发激光
		if(LD(R_SAFE_FAULT)){//发现故障
			EDLAR();
			RES(SPCOIL_BEEM_ENABLE);//打开蜂鸣器	
			RES(R_KEY_READY);//取消准备状态
			NVRAM0[EM_HMI_OPERA_STEP] = WORKSTEP_FAULT;
		}
		else{
			if(LD(X_FOOTSWITCH_OC) && LDB(X_FOOTSWITCH_ON)){//发射激光
				NVRAM0[EM_HMI_OPERA_STEP] = WORKSTEP_LASER_EMITING;		
			}
			else{
				EDLAR();
				RES(SPCOIL_BEEM_ENABLE);//关闭蜂鸣器	
				NVRAM0[EM_HMI_OPERA_STEP] = WORKSTEP_LASER_TRIGGER;
			}
		}
	}
	return;
}

#endif