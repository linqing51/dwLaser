#include "dcHmiApp.h"
/*****************************************************************************/
#define CONFIG_CHECK_DELAY_TIME						2
#define CONFIG_KEY_REPEAT_DELAY_TIME				50
/*****************************************************************************/
#define GDDC_PAGE_POWERUP							0
#define GDDC_PAGE_PASSCODE							1
#define GDDC_PAGE_NEW_PASSCODE						2
#define GDDC_PAGE_STANDBY							3
#define GDDC_PAGE_READY								4
#define GDDC_PAGE_OPTION							5//选项页面
#define GDDC_PAGE_INFO								6//信息页面
#define GDDC_PAGE_SCHEME							7//方案页面
/*****************************************************************************/
#define FSMSTEP_POWERUP								0//上电
//HMI初始操作
#define FSMSTEP_RESTORE_HMI							100//HMI 恢复储存数据
//自检状态
#define FSMSTEP_CHECK_EPROM							201//单片机自检
#define FSMSTEP_CHECK_INTBUS						202//触摸屏通信自检
#define FSMSTEP_CHECK_LDR							203//激光驱动器自检
#define FSMSTEP_CHECK_TEMPER						204//温度自检
#define FSMSTEP_CHECK_USBHOST						205//USBHOST模块自检
#define FSMSTEP_CHECK_NFC							206//NFC模块自检
#define FSMSTEP_CHECK_NRF24L01						207//无线脚踏RF自检
//密码输入状态
#define FSMSTEP_PASSCODE_INPUT						300//密码输入状态
#define FSMSTEP_PASSCODE_NEW0						301//密码更改状态第一次输入
#define FSMSTEP_PASSCODE_NEW1						302//密码更改状态第二次输入
//工作状态
#define FSMSTEP_STANDBY								400//等待状态
#define FSMSTEP_READY_LOAD_PARA						401//载入参数
#define FSMSTEP_READY_LOAD_DONE						402//载入参数完毕
#define FSMSTEP_LASER_WAIT_TRIGGER					403//激光触发
#define FSMSTEP_LASER_EMITING						404//激光发射中
#define FSMSTEP_LASER_STOP							405//激光发射结束
//选项状态
#define FSMSTEP_OPTION								500//选项菜单
//
#define FSMSTEP_INFO								600
//
#define FSMSTEP_SCHEME								700//方案菜单
//
#define FSMSTEP_FAULT								-1//故障状态
/*****************************************************************************/
#define FLASH_DATA_VERSION  0XAABB0000
#define FLASH_DATA_ADDR     0X00000000
/*****************************************************************************/
xdata uint8_t hmiCmdBuffer[CMD_MAX_SIZE];//指令缓存
xdata uint16_t hmiCmdSize;//已缓冲的指令数
void UpdateUI(void);
/*****************************************************************************/
#if CONFIG_USING_DCHMI_APP == 1
void updateSchemeDisplay(void){//更新方案显示
	SetTextValue(GDDC_PAGE_STANDBY, GDDC_PAGE_STANDBY_TEXTDISPLAY_NAME, (char*)(&NVRAM0[EM_LASER_SCHEME_NAME]));
	SetTextInt32(GDDC_PAGE_STANDBY, GDDC_PAGE_STANDBY_TEXTDISPLAY_POSWIDTH ,NVRAM0[EM_LASER_POSWIDTH], 1, 0);
	SetTextInt32(GDDC_PAGE_STANDBY, GDDC_PAGE_STANDBY_TEXTDISPLAY_NEGWIDTH ,NVRAM0[EM_LASER_NEGWIDTH], 1, 0);
	SetTextInt32(GDDC_PAGE_STANDBY, GDDC_PAGE_STANDBY_TEXTDISPLAY_GROUP ,NVRAM0[EM_LASER_GROUP], 1, 0);
	SetTextInt32(GDDC_PAGE_STANDBY, GDDC_PAGE_STANDBY_TEXTDISPLAY_SPACE ,NVRAM0[EM_LASER_SPACE], 1, 0);
}


void dcHmiLoopInit(void){//初始化模块
	NVRAM0[EM_HMI_OPERA_STEP] = 0;
}
void dcHmiLoop(void){//HMI轮训程序
	if(LD(R_DCHMI_RESET_DONE) && LD(R_DCHMI_RESTORE_DONE)){//HMI复位完成后处理串口指令
		hmiCmdSize = queue_find_cmd(hmiCmdBuffer, CMD_MAX_SIZE);//从缓冲区中获取一条指令         
        if(hmiCmdSize > 0){//接收到指令及判断是否为开机提示                                                            
            ProcessMessage((PCTRL_MSG)hmiCmdBuffer, hmiCmdSize);//指令处理  
        }                                                                             
        if(LDP(SPCOIL_PS100MS) || LD(R_DCHMI_UPDATEUI_REQ)){//每100mS刷新一次UI           
            SET(R_DCHMI_UPDATEUI_DOING);
			UpdateUI();
			RES(R_DCHMI_UPDATEUI_REQ);
			RES(R_DCHMI_UPDATEUI_DOING);
			SET(R_DCHMO_UPDATEUI_DONE);
        } 
	}
	//状态机
	if(NVRAM0[EM_HMI_OPERA_STEP] == FSMSTEP_FAULT){//故障步骤
		if(LD(R_SAFE_FAULT)){
			NVRAM0[EM_HMI_OPERA_STEP] = FSMSTEP_FAULT;
			SET(Y_LED_ALARM);//故障灯亮
			SET(SPCOIL_BEEM_ENABLE);//蜂鸣器常响
		}
		else{
			RES(Y_LED_ALARM);//故障灯亮
			RES(SPCOIL_BEEM_ENABLE);//蜂鸣器常响
			NVRAM0[EM_HMI_OPERA_STEP] = FSMSTEP_STANDBY;
		}
	}
	if(NVRAM0[EM_HMI_OPERA_STEP] == FSMSTEP_POWERUP){//上电步骤	
#if CONFIG_DEBUG == 1
		printf("sPlc->dcHmiLoop->OPERA_STEP:FSMSTEP_POWERUP\n");
#endif
#if CONFIG_USING_BACKGROUND_APP == 1
		loadScheme();//从掉电存储寄存器中恢复方案参数
#endif
		RES(R_DCHMI_RESET_REQ);
		SET(R_DCHMI_RESET_DOING);
		RES(R_DCHMI_RESET_DONE);

		RES(R_DCHMI_UPDATEUI_REQ);
		RES(R_DCHMI_UPDATEUI_DOING);
		RES(R_DCHMO_UPDATEUI_DONE);
		
		RES(R_DCHMI_RESTORE_REQ);
		RES(R_DCHMI_RESTORE_DOING);
		RES(R_DCHMI_RESTORE_DONE);	

		RES(R_CHECK_EPROM_DONE);
		RES(R_CHECK_INTBUS_DONE);			
		RES(R_CHECK_LDR_DONE);			
		RES(R_CHECK_TEMPER_DONE);				
		RES(R_CHECK_USBHOST_DONE);		
		RES(R_CHECK_NFC_DONE);			
		RES(R_CHECK_NRF24L01_DONE);	

		RES(R_CHECK_EPROM_PASS);				
		RES(R_CHECK_INTBUS_PASS);						
		RES(R_CHECK_LDR_PASS);						
		RES(R_CHECK_TEMPER_PASS);					
		RES(R_CHECK_USBHOST_PASS);					
		RES(R_CHECK_NFC_PASS);						
		RES(R_CHECK_NRF24L01_PASS);					

		RES(R_CHECK_EPROM_FAIL);						
		RES(R_CHECK_INTBUS_FAIL);						
		RES(R_CHECK_LDR_FAIL);						
		RES(R_CHECK_TEMPER_FAIL);						
		RES(R_CHECK_USBHOST_FAIL);					
		RES(R_CHECK_NFC_FAIL);						
		RES(R_CHECK_NRF24L01_FAIL);
		CLR(EM_DC_PAGE);
		CLR(EM_DC_PASSCODE_INDEX);
		CLR(EM_ERROR_CODE);
		CLR(EM_DC_NEW_PASSCODE0);
		CLR(EM_DC_NEW_PASSCODE0);
		
		NVRAM0[EM_DC_DEFAULT_PASSCODE0] = CONFIG_HMI_DEFAULT_PASSSWORD0;
		NVRAM0[EM_DC_DEFAULT_PASSCODE1] = CONFIG_HMI_DEFAULT_PASSSWORD1;
		NVRAM0[EM_DC_DEFAULT_PASSCODE2] = 0;
		NVRAM0[EM_DC_DEFAULT_PASSCODE3] = 0;
		NVRAM0[DM_DC_OLD_PASSCODE2] = 0;
		NVRAM0[DM_DC_OLD_PASSCODE3] = 0;
		
		NVRAM0[EM_DC_NEW_PASSCODE2] = 0;
		NVRAM0[EM_DC_NEW_PASSCODE3] = 0;
		//检查储存密码是否合规
		NVRAM0[TM_START + 0] = NVRAM0[DM_DC_OLD_PASSCODE0] & 0x00FF;
		NVRAM0[TM_START + 1] = (NVRAM0[DM_DC_OLD_PASSCODE0] >> 8) & 0x00FF;
		NVRAM0[TM_START + 2] = NVRAM0[DM_DC_OLD_PASSCODE1] & 0x00FF;
		NVRAM0[TM_START + 3] = (NVRAM0[DM_DC_OLD_PASSCODE1] >> 8) & 0x00FF;
		if((NVRAM0[TM_START + 0] < 0x30) || (NVRAM0[TM_START + 0] > 0x39) ||
		   (NVRAM0[TM_START + 1] < 0x30) || (NVRAM0[TM_START + 1] > 0x39) ||
		   (NVRAM0[TM_START + 2] < 0x30) || (NVRAM0[TM_START + 2] > 0x39) ||
		   (NVRAM0[TM_START + 3] < 0x30) || (NVRAM0[TM_START + 3] > 0x39)){
			NVRAM0[DM_DC_OLD_PASSCODE0] = CONFIG_HMI_DEFAULT_PASSSWORD0;
			NVRAM0[DM_DC_OLD_PASSCODE1] = CONFIG_HMI_DEFAULT_PASSSWORD1;  
		}	
		SET(R_DCHMI_RESET_DOING);
		hmiCmdSize = 0;
		queue_reset();//清空HMI指令接收缓冲区	
		NVRAM0[EM_HMI_OPERA_STEP] = FSMSTEP_RESTORE_HMI;
		return;
	}
	if(NVRAM0[EM_HMI_OPERA_STEP] == FSMSTEP_RESTORE_HMI){//等待HMI复位
		T100MS(T100MS_HMI_POWERUP_DELAY, true, CONFIG_CHECK_DELAY_TIME);
		if(LD(T_100MS_START * 16 + T100MS_HMI_POWERUP_DELAY)){
			T100MS(T100MS_HMI_POWERUP_DELAY, false, CONFIG_CHECK_DELAY_TIME);
			RES(R_DCHMI_RESET_DOING);
			SET(R_DCHMI_RESET_DONE);	
			//HMI从内置FLASH中恢复设置	
			SET(R_DCHMI_RESTORE_DOING);
			FlashRestoreControl(FLASH_DATA_VERSION, FLASH_DATA_ADDR);
			RES(R_DCHMI_RESTORE_DOING);
			SET(R_DCHMI_RESTORE_DONE);
			//设置HMI页面
			NVRAM0[EM_DC_PAGE] = GDDC_PAGE_POWERUP;//HMI页面
			SetScreen(NVRAM0[EM_DC_PAGE]);
			SetTextValue(GDDC_PAGE_PASSCODE, 15 , (uint8_t*)(&(NVRAM0[EM_DC_NEW_PASSCODE0])));
			SetTextValue(GDDC_PAGE_NEW_PASSCODE, 15 , (uint8_t*)(&(NVRAM0[EM_DC_NEW_PASSCODE0])));
			NVRAM0[EM_HMI_OPERA_STEP] = FSMSTEP_CHECK_EPROM;
		}
		else{
			NVRAM0[EM_HMI_OPERA_STEP] = FSMSTEP_RESTORE_HMI;	
		}
		return;
	}
	if(NVRAM0[EM_HMI_OPERA_STEP] == FSMSTEP_CHECK_EPROM){//EPROM自检步骤
		//测试EPROM
#if CONFIG_SPLC_USING_EPROM == 1
		NVRAM0[TM_START + 0] = rand()%0xFF;
		NVRAM0[TM_START + 1] = rand()%0xFF;
		NVRAM0[TM_START + 2] = rand()%0xFF;
		NVRAM0[TM_START + 3] = rand()%0xFF;
		epromWriteOneByte((CONFIG_EPROM_SIZE - 1), NVRAM0[TM_START + 0]);//写EPROM
		epromWriteOneByte((CONFIG_EPROM_SIZE - 2), NVRAM0[TM_START + 1]);//写EPROM
		epromWriteOneByte((CONFIG_EPROM_SIZE - 3), NVRAM0[TM_START + 2]);//写EPROM
		epromWriteOneByte((CONFIG_EPROM_SIZE - 4), NVRAM0[TM_START + 3]);//写EPROM
		//读EPROM
		NVRAM0[TM_START + 4] = epromReadOneByte((CONFIG_EPROM_SIZE - 1));
		NVRAM0[TM_START + 5] = epromReadOneByte((CONFIG_EPROM_SIZE - 2));
		NVRAM0[TM_START + 6] = epromReadOneByte((CONFIG_EPROM_SIZE - 3));
		NVRAM0[TM_START + 7] = epromReadOneByte((CONFIG_EPROM_SIZE - 4));
		if((NVRAM0[TM_START + 0] == NVRAM0[TM_START + 4]) && (NVRAM0[TM_START + 1] == NVRAM0[TM_START + 5]) &&
		   (NVRAM0[TM_START + 2] == NVRAM0[TM_START + 6]) && (NVRAM0[TM_START + 3] == NVRAM0[TM_START + 7])){
			setLedVar(true);
			delayMs(250);
			setLedVar(false);
			delayMs(250);
			setLedVar(true);
			delayMs(250);
			setLedVar(false); 
			SET(R_CHECK_EPROM_PASS);
			NVRAM0[EM_ERROR_CODE] = ERRPR_CODE_NOERR;
		}
		else{
			setLedVar(true);
			
			SET(R_CHECK_EPROM_FAIL);
			NVRAM0[EM_ERROR_CODE] = ERROR_CODE_EPROM;
		}
#else
		SET(R_CHECK_EPROM_PASS);
		RES(R_CHECK_EPROM_FAIL);
		NVRAM0[EM_ERROR_CODE] = ERRPR_CODE_NOERR;
#endif
		if(LD(R_CHECK_EPROM_PASS) && LDB(R_CHECK_EPROM_FAIL)){
			T100MS(T100MS_CHECK_FLASH_DELAY, true, CONFIG_CHECK_DELAY_TIME);
			if(LD(T_100MS_START * 16 + T100MS_CHECK_FLASH_DELAY)){
				T100MS(T100MS_CHECK_FLASH_DELAY, false, CONFIG_CHECK_DELAY_TIME);
				NVRAM0[EM_HMI_OPERA_STEP] = FSMSTEP_CHECK_INTBUS;
				SET(R_CHECK_EPROM_DONE);
			}
			else{
				NVRAM0[EM_HMI_OPERA_STEP] = FSMSTEP_CHECK_EPROM;//EPROM自检失败
			}
		}
		else{
			NVRAM0[EM_HMI_OPERA_STEP] = FSMSTEP_CHECK_EPROM;
		}
		return;
	}
	if(NVRAM0[EM_HMI_OPERA_STEP] == FSMSTEP_CHECK_INTBUS){//内部总线自检步骤
		T100MS(T100MS_CHECK_INTBUS_DELAY, true, CONFIG_CHECK_DELAY_TIME);
		if(LD(T_100MS_START * 16 + T100MS_CHECK_INTBUS_DELAY)){
			T100MS(T100MS_CHECK_INTBUS_DELAY, false, CONFIG_CHECK_DELAY_TIME);
			NVRAM0[EM_HMI_OPERA_STEP] = FSMSTEP_CHECK_LDR;
			SET(R_CHECK_INTBUS_DONE);
		}
		else{
			NVRAM0[EM_HMI_OPERA_STEP] = FSMSTEP_CHECK_INTBUS;
		}
		return;
	}
	if(NVRAM0[EM_HMI_OPERA_STEP] == FSMSTEP_CHECK_LDR){//激光驱动器自检步骤
		T100MS(T100MS_CHECK_LDR_DELAY, true, CONFIG_CHECK_DELAY_TIME);
		if(LD(T_100MS_START * 16 + T100MS_CHECK_LDR_DELAY)){
			T100MS(T100MS_CHECK_LDR_DELAY, false, CONFIG_CHECK_DELAY_TIME);
			NVRAM0[EM_HMI_OPERA_STEP] = FSMSTEP_CHECK_TEMPER;
			SET(R_CHECK_LDR_DONE);
		}
		else{
			NVRAM0[EM_HMI_OPERA_STEP] = FSMSTEP_CHECK_LDR;
		}
		return;
	}
	if(NVRAM0[EM_HMI_OPERA_STEP] == FSMSTEP_CHECK_TEMPER){//温度自检步骤
		T100MS(T100MS_CHECK_TEMPER_DELAY, true, CONFIG_CHECK_DELAY_TIME);
		if(LD(T_100MS_START * 16 + T100MS_CHECK_TEMPER_DELAY)){
			T100MS(T100MS_CHECK_TEMPER_DELAY, false, CONFIG_CHECK_DELAY_TIME);
			NVRAM0[EM_HMI_OPERA_STEP] = FSMSTEP_CHECK_USBHOST;
			SET(R_CHECK_TEMPER_DONE);
		}
		else{
			NVRAM0[EM_HMI_OPERA_STEP] = FSMSTEP_CHECK_TEMPER;
		}
		return;
	}
	if(NVRAM0[EM_HMI_OPERA_STEP] == FSMSTEP_CHECK_USBHOST){//USBHOST自检步骤
		T100MS(T100MS_CHECK_USBHOST_DELAY, true, CONFIG_CHECK_DELAY_TIME);
		if(LD(T_100MS_START * 16 + T100MS_CHECK_USBHOST_DELAY)){
			T100MS(T100MS_CHECK_USBHOST_DELAY, false, CONFIG_CHECK_DELAY_TIME);
			NVRAM0[EM_HMI_OPERA_STEP] = FSMSTEP_CHECK_USBHOST;
			SET(R_CHECK_USBHOST_DONE);
		}
		else{
			NVRAM0[EM_HMI_OPERA_STEP] = FSMSTEP_CHECK_NFC;
		}
		return;
	}
	if(NVRAM0[EM_HMI_OPERA_STEP] == FSMSTEP_CHECK_NFC){//NFC自检步骤
		T100MS(T100MS_CHECK_NFC_DELAY, true, CONFIG_CHECK_DELAY_TIME);
		if(LD(T_100MS_START * 16 + T100MS_CHECK_NFC_DELAY)){
			T100MS(T100MS_CHECK_NFC_DELAY, false, CONFIG_CHECK_DELAY_TIME);
			NVRAM0[EM_HMI_OPERA_STEP] = FSMSTEP_CHECK_NRF24L01;
			SET(R_CHECK_NFC_DONE);
		}
		else{
			NVRAM0[EM_HMI_OPERA_STEP] = FSMSTEP_CHECK_NFC;
		}
		return;
	}
	if(NVRAM0[EM_HMI_OPERA_STEP] == FSMSTEP_CHECK_NRF24L01){//NRF24L01自检步骤
		T100MS(T100MS_CHECK_NRF24L01_DELAY, true, CONFIG_CHECK_DELAY_TIME);
		if(LD(T_100MS_START * 16 + T100MS_CHECK_NRF24L01_DELAY)){
			T100MS(T100MS_CHECK_NRF24L01_DELAY, false, CONFIG_CHECK_DELAY_TIME);
			NVRAM0[EM_HMI_OPERA_STEP] = FSMSTEP_PASSCODE_INPUT;
			SET(R_CHECK_NRF24L01_DONE);
			NVRAM0[EM_DC_PAGE] = GDDC_PAGE_PASSCODE;
			SetScreen(NVRAM0[EM_DC_PAGE]);//跳转HMI页面
		}
		else{
			NVRAM0[EM_HMI_OPERA_STEP] = FSMSTEP_CHECK_NRF24L01;
		}
		return;
	}
	if(NVRAM0[EM_HMI_OPERA_STEP] == FSMSTEP_PASSCODE_INPUT){//等待输入开机密码
		return;
	}
	if(NVRAM0[EM_HMI_OPERA_STEP] == FSMSTEP_PASSCODE_NEW0){//等待输入新密码
		return;
	}
	if(NVRAM0[EM_HMI_OPERA_STEP] == FSMSTEP_STANDBY){//待机状态机
		if(LD(R_KEY_POSWIDTH_ADD_DOWN)){//正脉宽加按键
			T10MS(T10MS_POSWIDTH_ADD_KEYDOWN_DELAY, true, CONFIG_KEY_REPEAT_DELAY_TIME);
			if(LD(T_10MS_START * 16 + T10MS_POSWIDTH_ADD_KEYDOWN_DELAY)){	
				if(LDP(SPCOIL_PS10MS) && (NVRAM0[EM_LASER_POSWIDTH] < CONFIG_MAX_LASER_POSWIDTH)){
					ADDS1(EM_LASER_POSWIDTH);
					SetTextInt32(GDDC_PAGE_STANDBY, GDDC_PAGE_STANDBY_TEXTDISPLAY_POSWIDTH ,NVRAM0[EM_LASER_POSWIDTH], 1, 0);	
					SET(R_DCHMI_UPDATEUI_REQ);
				}
			}
		}
		if(LD(R_KEY_POSWIDTH_ADD_UP)){
			T10MS(T10MS_POSWIDTH_ADD_KEYDOWN_DELAY, false, CONFIG_KEY_REPEAT_DELAY_TIME);
			RES(LD(R_KEY_POSWIDTH_ADD_UP));
		}
		if(LD(R_KEY_POSWIDTH_DEC_DOWN)){//正脉宽减按键
			T10MS(T10MS_POSWIDTH_DEC_KEYDOWN_DELAY, true, CONFIG_KEY_REPEAT_DELAY_TIME);
			if(LD(T_10MS_START * 16 + T10MS_POSWIDTH_DEC_KEYDOWN_DELAY)){	
				if(LDP(SPCOIL_PS10MS) && (NVRAM0[EM_LASER_POSWIDTH] > CONFIG_MIN_LASER_POSWIDTH)){
					DECS1(EM_LASER_POSWIDTH);
					SetTextInt32(GDDC_PAGE_STANDBY, GDDC_PAGE_STANDBY_TEXTDISPLAY_POSWIDTH ,NVRAM0[EM_LASER_POSWIDTH], 1, 0);	
					SET(R_DCHMI_UPDATEUI_REQ);
				}
			}
		}
		if(LD(R_KEY_POSWIDTH_DEC_UP)){
			T10MS(T10MS_POSWIDTH_DEC_KEYDOWN_DELAY, false, CONFIG_KEY_REPEAT_DELAY_TIME);
			RES(R_KEY_POSWIDTH_DEC_UP);
		}
		if(LD(R_KEY_NEGWIDTH_ADD_DOWN)){//负脉宽加按键
			T10MS(T10MS_NEGWIDTH_ADD_KEYDOWN_DELAY, true, CONFIG_KEY_REPEAT_DELAY_TIME);
			if(LD(T_10MS_START * 16 + T10MS_NEGWIDTH_ADD_KEYDOWN_DELAY)){	
				if(LDP(SPCOIL_PS10MS) && (NVRAM0[EM_LASER_NEGWIDTH] < CONFIG_MAX_LASER_NEGWIDTH)){
					ADDS1(EM_LASER_NEGWIDTH);
					SetTextInt32(GDDC_PAGE_STANDBY, GDDC_PAGE_STANDBY_TEXTDISPLAY_NEGWIDTH ,NVRAM0[EM_LASER_NEGWIDTH], 1, 0);	
					SET(R_DCHMI_UPDATEUI_REQ);
				}
			}
		}
		if(LD(R_KEY_NEGWIDTH_ADD_UP)){
			T10MS(T10MS_NEGWIDTH_ADD_KEYDOWN_DELAY, false, CONFIG_KEY_REPEAT_DELAY_TIME);
			RES(R_KEY_NEGWIDTH_ADD_UP);
		}
		if(LD(R_KEY_NEGWIDTH_DEC_DOWN)){//负脉宽减按键
			T10MS(T10MS_NEGWIDTH_DEC_KEYDOWN_DELAY, true, CONFIG_KEY_REPEAT_DELAY_TIME);
			if(LD(T_10MS_START * 16 + T10MS_NEGWIDTH_DEC_KEYDOWN_DELAY)){	
				if(LDP(SPCOIL_PS10MS) && (NVRAM0[EM_LASER_NEGWIDTH] > CONFIG_MIN_LASER_NEGWIDTH)){
					DECS1(EM_LASER_NEGWIDTH);
					SetTextInt32(GDDC_PAGE_STANDBY, GDDC_PAGE_STANDBY_TEXTDISPLAY_NEGWIDTH ,NVRAM0[EM_LASER_NEGWIDTH], 1, 0);	
					SET(R_DCHMI_UPDATEUI_REQ);
				}
			}
		}
		if(LD(R_KEY_NEGWIDTH_DEC_UP)){
			T10MS(T10MS_NEGWIDTH_DEC_KEYDOWN_DELAY, false, CONFIG_KEY_REPEAT_DELAY_TIME);
			RES(R_KEY_NEGWIDTH_DEC_UP);
		}
		if(LD(R_KEY_GROUP_ADD_DOWN)){//脉冲数加按键
			T10MS(T10MS_GROUP_ADD_KEYDOWN_DELAY, true, CONFIG_KEY_REPEAT_DELAY_TIME);
			if(LD(T_10MS_START * 16 + T10MS_GROUP_ADD_KEYDOWN_DELAY)){	
				if(LDP(SPCOIL_PS10MS) && (NVRAM0[EM_LASER_GROUP] < CONFIG_MAX_LASER_GROUP)){
					ADDS1(EM_LASER_GROUP);
					SetTextInt32(GDDC_PAGE_STANDBY, GDDC_PAGE_STANDBY_TEXTDISPLAY_GROUP ,NVRAM0[EM_LASER_GROUP], 1, 0);	
					SET(R_DCHMI_UPDATEUI_REQ);
				}
			}
		}
		if(LD(R_KEY_GROUP_ADD_UP)){
			T10MS(T10MS_GROUP_ADD_KEYDOWN_DELAY, false, CONFIG_KEY_REPEAT_DELAY_TIME);
			RES(R_KEY_GROUP_ADD_UP);
		}
		if(LD(R_KEY_GROUP_DEC_DOWN)){//脉冲数减按键
			T10MS(T10MS_GROUP_DEC_KEYDOWN_DELAY, true, CONFIG_KEY_REPEAT_DELAY_TIME);
			if(LD(T_10MS_START * 16 + T10MS_GROUP_DEC_KEYDOWN_DELAY)){	
				if(LDP(SPCOIL_PS10MS) && (NVRAM0[EM_LASER_GROUP] > CONFIG_MIN_LASER_GROUP)){
					DECS1(EM_LASER_GROUP);
					SetTextInt32(GDDC_PAGE_STANDBY, GDDC_PAGE_STANDBY_TEXTDISPLAY_GROUP ,NVRAM0[EM_LASER_GROUP], 1, 0);	
					SET(R_DCHMI_UPDATEUI_REQ);
				}
			}
		}
		if(LD(R_KEY_GROUP_DEC_UP)){
			T10MS(T10MS_GROUP_DEC_KEYDOWN_DELAY, false, CONFIG_KEY_REPEAT_DELAY_TIME);
			RES(R_KEY_GROUP_DEC_UP);
		}
		
		if(LD(R_KEY_SPACE_ADD_DOWN)){//脉冲间隔加按键
			T10MS(T10MS_SPACE_ADD_KEYDOWN_DELAY, true, CONFIG_KEY_REPEAT_DELAY_TIME);
			if(LD(T_10MS_START * 16 + T10MS_SPACE_ADD_KEYDOWN_DELAY)){	
				if(LDP(SPCOIL_PS10MS) && (NVRAM0[EM_LASER_SPACE] < CONFIG_MAX_LASER_SPACE)){
					ADDS1(EM_LASER_SPACE);
					SetTextInt32(GDDC_PAGE_STANDBY, GDDC_PAGE_STANDBY_TEXTDISPLAY_SPACE ,NVRAM0[EM_LASER_SPACE], 1, 0);	
					SET(R_DCHMI_UPDATEUI_REQ);
				}
			}
		}
		if(LD(R_KEY_SPACE_ADD_UP)){
			T10MS(T10MS_SPACE_ADD_KEYDOWN_DELAY, false, CONFIG_KEY_REPEAT_DELAY_TIME);
			RES(R_KEY_SPACE_ADD_UP);
		}
		if(LD(R_KEY_SPACE_DEC_DOWN)){//脉冲间隔减按键
			T10MS(T10MS_SPACE_DEC_KEYDOWN_DELAY, true, CONFIG_KEY_REPEAT_DELAY_TIME);
			if(LD(T_10MS_START * 16 + T10MS_SPACE_DEC_KEYDOWN_DELAY)){	
				if(LDP(SPCOIL_PS10MS) && (NVRAM0[EM_LASER_SPACE] > CONFIG_MIN_LASER_SPACE)){
					DECS1(EM_LASER_SPACE);
					SetTextInt32(GDDC_PAGE_STANDBY, GDDC_PAGE_STANDBY_TEXTDISPLAY_SPACE ,NVRAM0[EM_LASER_SPACE], 1, 0);	
					SET(R_DCHMI_UPDATEUI_REQ);
				}
			}
		}
		if(LD(R_KEY_SPACE_DEC_UP)){
			T10MS(T10MS_SPACE_DEC_KEYDOWN_DELAY, false, CONFIG_KEY_REPEAT_DELAY_TIME);
			RES(R_KEY_SPACE_DEC_UP);
		}
		
//		if(LD(R_SAFE_FAULT)){//
//			NVRAM0[EM_HMI_OPERA_STEP] = FSMSTEP_FAULT;
//		}
//		else if(LD(R_DC_STANDBY_POSWIDTH_ADD_REQ)){//正脉宽增加
//			if(NVRAM0[EM_LASER_POSWIDTH] <  CONFIG_MAX_LASER_POSWIDTH){
//				ADDS1(EM_LASER_POSWIDTH);
//			}
//			RES(R_DC_STANDBY_POSWIDTH_ADD_REQ);
//		}
//		else if(LD(R_DC_STANDBY_POSWIDTH_DEC_REQ)){//正脉宽减小
//			if(NVRAM0[EM_LASER_POSWIDTH] > CONFIG_MIN_LASER_POSWIDTH){
//				DECS1(EM_LASER_POSWIDTH);
//			}
//			RES(R_DC_STANDBY_POSWIDTH_DEC_REQ);
//		}
//		else if(LD(R_DC_STANDBY_NEGWIDTH_ADD_REQ)){//负脉宽增加
//			if(NVRAM0[EM_LASER_NEGWIDTH] <  CONFIG_MAX_LASER_NEGWIDTH){
//				ADDS1(EM_LASER_NEGWIDTH);
//			}
//			RES(R_DC_STANDBY_NEGWIDTH_ADD_REQ);
//		}
//		else if(LD(R_DC_STANDBY_NEGWIDTH_DEC_REQ)){//负脉宽减小
//			if(NVRAM0[EM_LASER_NEGWIDTH] > CONFIG_MIN_LASER_NEGWIDTH){
//				DECS1(EM_LASER_NEGWIDTH);
//			}
//			RES(R_DC_STANDBY_NEGWIDTH_DEC_REQ);
//		}
//		else if(LD(R_DC_STANDBY_RESET_REQ)){//复位能量和计时器时间
//			CLR(EM_DC_DISPLAY_RELEASE_TIME);
//			CLR(EM_DC_DISPLAY_RELEASE_ENERGY);
//			RES(R_DC_STANDBY_RESET_REQ);
//		}
//		else if(LD(R_DC_STANDBY_SELECT_CH0_REQ)){//选择激光通道0
//			NVRAM0[EM_LASER_SELECT] = LASER_TIMER_SELECT_CH0;
//			RES(R_DC_STANDBY_SELECT_CH0_REQ);
//		}
//		else if(LD(R_DC_STANDBY_SELECT_CH1_REQ)){//选择激光通道1
//			NVRAM0[EM_LASER_SELECT] = LASER_TIMER_SELECT_CH1;
//			RES(R_DC_STANDBY_SELECT_CH0_REQ);
//		}
//		else if(LD(R_DC_STANDBY_SELECT_CH01_REQ)){//选择激光通道0+1
//			NVRAM0[EM_LASER_SELECT] = LASER_TIMER_SELECT_BOTH;
//			RES(R_DC_STANDBY_SELECT_CH01_REQ);
//		}
//		else if(LD(R_DC_STANDBY_MODE_CW_REQ)){//选择连续模式
//			NVRAM0[EM_LASER_PULSE_MODE] = LASER_TIMER_MODE_CW;
//			RES(R_DC_STANDBY_MODE_CW_REQ);
//		}
//		else if(LD(R_DC_STANDBY_MODE_SP_REQ)){//选择单脉冲模式
//			NVRAM0[EM_LASER_PULSE_MODE] = LASER_TIMER_MODE_SP;
//			RES(R_DC_STANDBY_MODE_SP_REQ);
//		}
//		else if(LD(R_DC_STANDBY_MODE_MP_REQ)){//选择多脉冲模式
//			NVRAM0[EM_LASER_PULSE_MODE] = LASER_TIMER_MODE_MP;
//			RES(R_DC_STANDBY_MODE_MP_REQ);
//		}
//		else if(LD(R_DC_STANDBY_MODE_GP_REQ)){//选择可编程脉冲模式
//			NVRAM0[EM_LASER_PULSE_MODE] = LASER_TIMER_MODE_GP;
//			RES(R_DC_STANDBY_MODE_GP_REQ);
//		}
//		else if(LD(R_DC_STANDBY_GROUP_ADD_REQ)){//可编程脉冲数增加
//			if(NVRAM0[DM_LASER_GROUP] < CONFIG_MAX_LASER_GROUP){
//				ADDS1(DM_LASER_GROUP);
//			}
//			RES(R_DC_STANDBY_GROUP_ADD_REQ);
//		}
//		else if(LD(R_DC_STANDBY_GROUP_DEC_REQ)){//可编程脉冲数减小
//			if(NVRAM0[DM_LASER_GROUP] > CONFIG_MIN_LASER_GROUP){
//				DECS1(DM_LASER_GROUP);
//			}
//			RES(R_DC_STANDBY_GROUP_DEC_REQ);
//		}
//		else if(LD(R_DC_STANDBY_SPACE_ADD_REQ)){//可编程脉冲间隔增加
//			if(NVRAM0[EM_LASER_SPACE] > CONFIG_MAX_LASER_SPACE){
//				ADDS1(EM_LASER_SPACE);
//			}
//			RES(R_DC_STANDBY_SPACE_ADD_REQ);
//		}
//		else if(LD(R_DC_STANDBY_SPACE_DEC_REQ)){//可编程脉冲间隔减小
//			if(NVRAM0[EM_LASER_SPACE] < CONFIG_MIN_LASER_SPACE){
//				DECS1(EM_LASER_SPACE);
//			}
//			RES(R_DC_STANDBY_SPACE_DEC_REQ);
//		}
//		else if(LD(R_DC_STANDBY_SCHEME_SAVE_REQ)){//当前设定储存请求
//			BCPY((DM_SCHEME_START_0 + 25 * NVRAM0[DM_SCHEME_NUM]), EM_LASER_SCHEME_NAME, 25); 
//			RES(R_DC_STANDBY_SCHEME_SAVE_REQ);
//		}
//		else if(LD(R_DC_STANDBY_LASERPOWER0_ADD_REQ)){//增大通道0激光功率
//			if(NVRAM0[EM_LASER_POWER_CH0] < CONFIG_MAX_LASERPOWER_CH0){
//				ADDS1(EM_LASER_POWER_CH0);
//			}
//			RES(R_DC_STANDBY_LASERPOWER0_ADD_REQ);
//		}
//		else if(LD(R_DC_STANDBY_LASERPOWER1_ADD_REQ)){//增大通道1激光功率
//			if(NVRAM0[EM_LASER_POWER_CH1] < CONFIG_MAX_LASERPOWER_CH1){
//				ADDS1(EM_LASER_POWER_CH1);
//			}
//			RES(R_DC_STANDBY_LASERPOWER1_ADD_REQ);
//		}
//		else if(LD(R_DC_STANDBY_LASERPOWER0_DEC_REQ)){//减小通道0激光功率
//			if(NVRAM0[EM_LASER_POWER_CH0] < CONFIG_MAX_LASERPOWER_CH0){
//				DECS1(EM_LASER_POWER_CH0);
//			}
//			RES(R_DC_STANDBY_LASERPOWER0_DEC_REQ);
//		}
//		else if(LD(R_DC_STANDBY_LASERPOWER1_DEC_REQ)){//减小通道1激光功率
//			if(NVRAM0[EM_LASER_POWER_CH1] < CONFIG_MAX_LASERPOWER_CH1){
//				DECS1(EM_LASER_POWER_CH1);
//			}
//			RES(R_DC_STANDBY_LASERPOWER1_DEC_REQ);
//		}
//		else if(LD(R_DC_STANDBY_OPTION)){//选择选项界面
//			NVRAM0[EM_HMI_OPERA_STEP] = FSMSTEP_OPTION;
//			NVRAM0[EM_DC_PAGE] = GDDC_PAGE_OPTION;
//			RES(R_DC_STANDBY_OPTION);
//		}
//		else if(LD(R_DC_STANDBY_LAST_SCHEME)){//选择上一个方案
//			if(NVRAM0[DM_SCHEME_NUM] > 0){
//				DECS1(DM_SCHEME_NUM);
//				BCPY(EM_LASER_SCHEME_NAME, (DM_SCHEME_START_0 + NVRAM0[DM_SCHEME_NUM] * 25), 25);//DM->EM
//			}
//			RES(R_DC_STANDBY_LAST_SCHEME);
//		}
//		else if(LD(R_DC_STANDBY_NEXT_SCHEME)){//选择下一个方案
//			if(NVRAM0[DM_SCHEME_NUM] < CONFIG_HMI_SCHEME_NUM){
//				ADDS1(DM_SCHEME_NUM);
//				BCPY(EM_LASER_SCHEME_NAME, (DM_SCHEME_START_0 + NVRAM0[DM_SCHEME_NUM] * 25), 25);//DM->EM
//			}
//			RES(R_DC_STANDBY_NEXT_SCHEME);
//		}
//		else if(LD(R_DC_STANDBY_READY)){//点击READY
//			
//			NVRAM0[SPREG_BEEM_MODE] = BEEM_TIMER_MODE_0;
//			NVRAM0[SPREG_BEEM_VOLUME] = NVRAM0[DM_BEEM_VOLUME];
//			SET(SPCOIL_BEEM_ENABLE);//打开蜂鸣器			
//			NVRAM0[EM_HMI_OPERA_STEP] = FSMSTEP_READY_LOAD_PARA;
//			RES(LD(R_DC_STANDBY_READY));
//		}
//		else{
//			NVRAM0[EM_HMI_OPERA_STEP] = FSMSTEP_STANDBY;
//		}
		return;
	}
	if(NVRAM0[EM_HMI_OPERA_STEP] == FSMSTEP_READY_LOAD_PARA){//将发射参数载入运行寄存器并打开蜂鸣器
		NVRAM0[SPREG_LASER_MODE] = NVRAM0[EM_LASER_PULSE_MODE];
		NVRAM0[SPREG_LASER_SELECT] = NVRAM0[EM_LASER_SELECT];
		NVRAM0[SPREG_LASER_TMATE] = NVRAM0[EM_LASER_POSWIDTH];//激光脉冲正脉宽 10mS
		NVRAM0[SPREG_LASER_TOVERTIME] = NVRAM0[EM_LASER_POSWIDTH] + NVRAM0[EM_LASER_NEGWIDTH];//激光脉冲周期 25mS
		NVRAM0[SPREG_LASER_PMATE] = NVRAM0[EM_LASER_GROUP];//10个脉冲
		NVRAM0[SPREG_LASER_POVERTIME] = NVRAM0[EM_LASER_SPACE];//间隔33mS
#if CONFIG_USING_BACKGROUND_APP == 1
		PCLAR0(EM_LASER_POWER_CH0, SPREG_DAC_0);//功率->DAC CODE
		PCLAR1(EM_LASER_POWER_CH1, SPREG_DAC_1);//功率->DAC CODE
#endif
		T100MS(T100MS_READY_BEEM_DELAY, true, 3);//启动计时器延时500mS//打开计时器
		//清空计时器
		if(LD(T_100MS_START * 16 + T100MS_READY_BEEM_DELAY)){
			T100MS(T100MS_READY_BEEM_DELAY, false, 3);
			NVRAM0[EM_HMI_OPERA_STEP] = FSMSTEP_READY_LOAD_DONE;
		}
		else{
			NVRAM0[EM_HMI_OPERA_STEP] = FSMSTEP_READY_LOAD_PARA;
		}
		return;
	}
	if(NVRAM0[EM_HMI_OPERA_STEP] == FSMSTEP_READY_LOAD_DONE){//参数载入完毕并停止蜂鸣器
		RES(SPCOIL_BEEM_ENABLE);//关闭蜂鸣器
		NVRAM0[EM_HMI_OPERA_STEP] = FSMSTEP_LASER_WAIT_TRIGGER;
		return;
	}
	if(NVRAM0[EM_HMI_OPERA_STEP] == FSMSTEP_LASER_WAIT_TRIGGER){//等待触发激光
//		if(LD(R_SAFE_FAULT)){
//			NVRAM0[EM_HMI_OPERA_STEP] = FSMSTEP_FAULT;	
//		}
//		else if(LDB(R_DC_STANDBY_READY)){//回到等待状态
//			
//			NVRAM0[EM_HMI_OPERA_STEP] = FSMSTEP_STANDBY;
//			NVRAM0[EM_DC_PAGE] = GDDC_PAGE_STANDBY;//切换待机页面
//		}
//		else if(LD(X_FOOTSWITCH_OC) && LDB(X_FOOTSWITCH_ON)){//发射激光	
//			NVRAM0[SPREG_BEEM_MODE] = BEEM_TIMER_MODE_1;
//			NVRAM0[SPREG_BEEM_VOLUME] = NVRAM0[DM_BEEM_VOLUME];
//			SET(SPCOIL_BEEM_ENABLE);//打开蜂鸣器	
//#if CONFIG_SPLC_USING_LASER_TIMER == 1			
//			STLAR();
//#endif
//			NVRAM0[EM_HMI_OPERA_STEP] = FSMSTEP_LASER_EMITING;	
//		}		
//		else{
//			NVRAM0[EM_HMI_OPERA_STEP] = FSMSTEP_STANDBY;	
//		}
		return;
	}
	if(NVRAM0[EM_HMI_OPERA_STEP] == FSMSTEP_LASER_EMITING){//发激光中
//		if(LD(R_SAFE_FAULT)){//发现故障
//#if CONFIG_SPLC_USING_LASER_TIMER == 1
//			EDLAR();
//#endif
//			RES(SPCOIL_BEEM_ENABLE);//打开蜂鸣器	
//			RES(R_DC_STANDBY_READY);//取消准备状态
//			NVRAM0[EM_HMI_OPERA_STEP] = FSMSTEP_FAULT;
//		}
//		else if(LD(X_FOOTSWITCH_OC) && LDB(X_FOOTSWITCH_ON)){//发射激光
//			NVRAM0[EM_HMI_OPERA_STEP] = FSMSTEP_LASER_EMITING;		
//		}
//		else{
//#if CONFIG_SPLC_USING_LASER_TIMER == 1
//			EDLAR();
//#endif
//			RES(SPCOIL_BEEM_ENABLE);//关闭蜂鸣器	
//			NVRAM0[EM_HMI_OPERA_STEP] = FSMSTEP_LASER_WAIT_TRIGGER;
//		}
		return;
	}
	if(NVRAM0[EM_HMI_OPERA_STEP] == FSMSTEP_OPTION){//选项界面
		return;
	}
}

//消息处理流程
//msg 待处理消息
//size 消息长度
void ProcessMessage( PCTRL_MSG msg, uint16_t size ){
	uint8_t cmd_type = msg->cmd_type;                                                     //指令类型
    uint8_t ctrl_msg = msg->ctrl_msg;                                                     //消息的类型
    uint8_t control_type = msg->control_type;                                             //控件类型
    uint16_t screen_id = PTR2U16(&msg->screen_id);                                        //画面ID
    uint16_t control_id = PTR2U16(&msg->control_id);                                      //控件ID
    uint32_t value = PTR2U32(msg->param);                                                 //数值
    switch(cmd_type){  
		case NOTIFY_TOUCH_PRESS:{//触摸屏按下
			break;
		}
		case NOTIFY_TOUCH_RELEASE:{//触摸屏松开
			NotifyTouchXY(hmiCmdBuffer[1],PTR2U16(hmiCmdBuffer + 2),PTR2U16(hmiCmdBuffer + 4)); 
			break;
		}			
		case NOTIFY_WRITE_FLASH_OK:{//写FLASH成功
			NotifyWriteFlash(1);                                                      
			break;              
		}			
		case NOTIFY_WRITE_FLASH_FAILD:{//写FLASH失败
			NotifyWriteFlash(0);                        	                              
			break;            
		}			
		case NOTIFY_READ_FLASH_OK:{//读取FLASH成功
			NotifyReadFlash(1, hmiCmdBuffer + 2, size - 6);//去除帧头帧尾
			break;                                  
		}			
		case NOTIFY_READ_FLASH_FAILD:{//读取FLASH失败
			NotifyReadFlash(0,0,0);                                                   
			break;  
		}			
		case NOTIFY_READ_RTC:{//读取RTC时间
			NotifyReadRTC(hmiCmdBuffer[2], hmiCmdBuffer[3], hmiCmdBuffer[4], hmiCmdBuffer[5], hmiCmdBuffer[6], hmiCmdBuffer[7], hmiCmdBuffer[8]);
			break;
		}
		case NOTIFY_CONTROL:{
			if(ctrl_msg==MSG_GET_CURRENT_SCREEN){//画面ID变化通知
                NotifyScreen(screen_id);//画面切换调动的函数
            }
            else{
				switch(control_type){
					case kCtrlButton:{//按钮控件
						NotifyButton(screen_id,control_id,msg->param[1]);                  
						break;  
					}
					case kCtrlText:{//文本控件
						NotifyText(screen_id,control_id,msg->param);                       
						break;
					}						
					case kCtrlProgress:{//进度条控件
						NotifyProgress(screen_id,control_id,value);                        
						break;
					}						
					case kCtrlSlider:{//滑动条控件
						NotifySlider(screen_id,control_id,value);                          
						break;
					}						
					case kCtrlMeter:{//仪表控件
						NotifyMeter(screen_id,control_id,value);                           
						break;
					}
					case kCtrlMenu:{//菜单控件
						NotifyMenu(screen_id,control_id,msg->param[0],msg->param[1]);      
						break;
					}
					case kCtrlSelector:{//选择控件
						NotifySelector(screen_id,control_id,msg->param[0]);                
						break;
					}						
					case kCtrlRTC:{//倒计时控件
						NotifyTimer(screen_id,control_id);
						break;
					}
					default:{
						break;
					}
				}
            } 
            break;  
        } 
    case NOTIFY_HandShake:
        //NOTIFYHandShake();
        break;
    default:
        break;
    }
}
 

//按钮控件通知当按钮状态改变(或调用GetControlValue)时，执行此函数
//screen_id 画面ID;control_id 控件ID;state 按钮状态：0弹起，1按下
void NotifyButton(uint16_t screen_id, uint16_t control_id, uint8_t state){ 
	//SCREEN ID = 0
	if(screen_id == 1 && control_id == GDDC_PAGE_PASSCODE_KEY_NUM1){//按键1
		if(NVRAM0[EM_DC_PASSCODE_INDEX] == 0){
			NVRAM0[EM_DC_NEW_PASSCODE0] |= 0x3100;
			NVRAM0[EM_DC_PASSCODE_INDEX] = 1;
		}
		else if(NVRAM0[EM_DC_PASSCODE_INDEX] == 1){
			NVRAM0[EM_DC_NEW_PASSCODE0] |= 0x0031;
			NVRAM0[EM_DC_PASSCODE_INDEX] = 2;	
		}
		else if(NVRAM0[EM_DC_PASSCODE_INDEX] == 2){
			NVRAM0[EM_DC_NEW_PASSCODE1] |= 0x3100;	
			NVRAM0[EM_DC_PASSCODE_INDEX] = 3;	
		}
		else if(NVRAM0[EM_DC_PASSCODE_INDEX] == 3){
			NVRAM0[EM_DC_NEW_PASSCODE1] |= 0x0031;
			NVRAM0[EM_DC_PASSCODE_INDEX] = 4;
		}
		SetTextValue(screen_id, 15, (uint8_t*)(&(NVRAM0[EM_DC_NEW_PASSCODE0])));
		return;
	}
	else if(screen_id == GDDC_PAGE_PASSCODE && control_id == GDDC_PAGE_PASSCODE_KEY_NUM2){//按键2		
		if(NVRAM0[EM_DC_PASSCODE_INDEX] == 0){
			NVRAM0[EM_DC_NEW_PASSCODE0] |= 0x3200;
			NVRAM0[EM_DC_PASSCODE_INDEX] = 1;
		}
		else if(NVRAM0[EM_DC_PASSCODE_INDEX] == 1){
			NVRAM0[EM_DC_NEW_PASSCODE0] |= 0x0032;
			NVRAM0[EM_DC_PASSCODE_INDEX] = 2;	
		}
		else if(NVRAM0[EM_DC_PASSCODE_INDEX] == 2){
			NVRAM0[EM_DC_NEW_PASSCODE1] |= 0x3200;	
			NVRAM0[EM_DC_PASSCODE_INDEX] = 3;	
		}
		else if(NVRAM0[EM_DC_PASSCODE_INDEX] == 3){
			NVRAM0[EM_DC_NEW_PASSCODE1] |= 0x0032;
			NVRAM0[EM_DC_PASSCODE_INDEX] = 4;
		}
		SetTextValue(screen_id, 15, (uint8_t*)(&(NVRAM0[EM_DC_NEW_PASSCODE0])));
	}
	if(screen_id == GDDC_PAGE_PASSCODE && control_id == GDDC_PAGE_PASSCODE_KEY_NUM3){//按键3
		if(NVRAM0[EM_DC_PASSCODE_INDEX] == 0){
			NVRAM0[EM_DC_NEW_PASSCODE0] |= 0x3300;
			NVRAM0[EM_DC_PASSCODE_INDEX] = 1;
		}
		else if(NVRAM0[EM_DC_PASSCODE_INDEX] == 1){
			NVRAM0[EM_DC_NEW_PASSCODE0] |= 0x0033;
			NVRAM0[EM_DC_PASSCODE_INDEX] = 2;	
		}
		else if(NVRAM0[EM_DC_PASSCODE_INDEX] == 2){
			NVRAM0[EM_DC_NEW_PASSCODE1] |= 0x3300;	
			NVRAM0[EM_DC_PASSCODE_INDEX] = 3;	
		}
		else if(NVRAM0[EM_DC_PASSCODE_INDEX] == 3){
			NVRAM0[EM_DC_NEW_PASSCODE1] |= 0x0033;
			NVRAM0[EM_DC_PASSCODE_INDEX] = 4;	
		}
		SetTextValue(screen_id, 15, (uint8_t*)(&(NVRAM0[EM_DC_NEW_PASSCODE0])));
		return;
	}
	if(screen_id == GDDC_PAGE_PASSCODE && control_id == GDDC_PAGE_PASSCODE_KEY_NUM4){//按键4
		if(NVRAM0[EM_DC_PASSCODE_INDEX] == 0){
			NVRAM0[EM_DC_NEW_PASSCODE0] |= 0x3400;
			NVRAM0[EM_DC_PASSCODE_INDEX] = 1;
		}
		else if(NVRAM0[EM_DC_PASSCODE_INDEX] == 1){
			NVRAM0[EM_DC_NEW_PASSCODE0] |= 0x0034;
			NVRAM0[EM_DC_PASSCODE_INDEX] = 2;	
		}
		else if(NVRAM0[EM_DC_PASSCODE_INDEX] == 2){
			NVRAM0[EM_DC_NEW_PASSCODE1] |= 0x3400;	
			NVRAM0[EM_DC_PASSCODE_INDEX] = 3;	
		}
		else if(NVRAM0[EM_DC_PASSCODE_INDEX] == 3){
			NVRAM0[EM_DC_NEW_PASSCODE1] |= 0x0034;
			NVRAM0[EM_DC_PASSCODE_INDEX] = 4;	
		}
		SetTextValue(screen_id, 15 , (uint8_t*)(&(NVRAM0[EM_DC_NEW_PASSCODE0])));
		return;
	}
	if(screen_id == GDDC_PAGE_PASSCODE && control_id == GDDC_PAGE_PASSCODE_KEY_NUM5){//按键5
		if(NVRAM0[EM_DC_PASSCODE_INDEX] == 0){
			NVRAM0[EM_DC_NEW_PASSCODE0] |= 0x3500;
			NVRAM0[EM_DC_PASSCODE_INDEX] = 1;
		}
		else if(NVRAM0[EM_DC_PASSCODE_INDEX] == 1){
			NVRAM0[EM_DC_NEW_PASSCODE0] = EM_DC_NEW_PASSCODE0 | 0x0035;
			NVRAM0[EM_DC_PASSCODE_INDEX] = 2;	
		}
		else if(NVRAM0[EM_DC_PASSCODE_INDEX] == 2){
			NVRAM0[EM_DC_NEW_PASSCODE1] |= 0x3500;	
			NVRAM0[EM_DC_PASSCODE_INDEX] = 3;	
		}
		else if(NVRAM0[EM_DC_PASSCODE_INDEX] == 3){
			NVRAM0[EM_DC_NEW_PASSCODE1] |= 0x0035;
			NVRAM0[EM_DC_PASSCODE_INDEX] = 4;	
		}
		SetTextValue(screen_id, 15 , (uint8_t*)(&(NVRAM0[EM_DC_NEW_PASSCODE0])));
		return;
	}
	if(screen_id == GDDC_PAGE_PASSCODE && control_id == GDDC_PAGE_PASSCODE_KEY_NUM6){//按键6
		if(NVRAM0[EM_DC_PASSCODE_INDEX] == 0){
			NVRAM0[EM_DC_NEW_PASSCODE0] |= 0x3600;
			NVRAM0[EM_DC_PASSCODE_INDEX] = 1;
		}
		else if(NVRAM0[EM_DC_PASSCODE_INDEX] == 1){
			NVRAM0[EM_DC_NEW_PASSCODE0] |= 0x0036;
			NVRAM0[EM_DC_PASSCODE_INDEX] = 2;	
		}
		else if(NVRAM0[EM_DC_PASSCODE_INDEX] == 2){
			NVRAM0[EM_DC_NEW_PASSCODE1] |= 0x3600;	
			NVRAM0[EM_DC_PASSCODE_INDEX] = 3;	
		}
		else if(NVRAM0[EM_DC_PASSCODE_INDEX] == 3){
			NVRAM0[EM_DC_NEW_PASSCODE1] |= 0x0036;
			NVRAM0[EM_DC_PASSCODE_INDEX] = 4;	
		}
		SetTextValue(screen_id, 15 , (uint8_t*)(&(NVRAM0[EM_DC_NEW_PASSCODE0])));
		return;
	}
	if(screen_id == GDDC_PAGE_PASSCODE && control_id == GDDC_PAGE_PASSCODE_KEY_NUM7){//按键7
		if(NVRAM0[EM_DC_PASSCODE_INDEX] == 0){
			NVRAM0[EM_DC_NEW_PASSCODE0] |= 0x3700;
			NVRAM0[EM_DC_PASSCODE_INDEX] = 1;
		}
		else if(NVRAM0[EM_DC_PASSCODE_INDEX] == 1){
			NVRAM0[EM_DC_NEW_PASSCODE0] |= 0x0037;
			NVRAM0[EM_DC_PASSCODE_INDEX] = 2;	
		}
		else if(NVRAM0[EM_DC_PASSCODE_INDEX] == 2){
			NVRAM0[EM_DC_NEW_PASSCODE1] |= 0x3700;	
			NVRAM0[EM_DC_PASSCODE_INDEX] = 3;	
		}
		else if(NVRAM0[EM_DC_PASSCODE_INDEX] == 3){
			NVRAM0[EM_DC_NEW_PASSCODE1] |= 0x0037;	
			NVRAM0[EM_DC_PASSCODE_INDEX] = 4;
		}
		SetTextValue(screen_id, 15 , (uint8_t*)(&(NVRAM0[EM_DC_NEW_PASSCODE0])));
		return;
	}
	if(screen_id == GDDC_PAGE_PASSCODE && control_id == GDDC_PAGE_PASSCODE_KEY_NUM8){//按键8
		if(NVRAM0[EM_DC_PASSCODE_INDEX] == 0){
			NVRAM0[EM_DC_NEW_PASSCODE0] |= 0x3800;
			NVRAM0[EM_DC_PASSCODE_INDEX] = 1;
		}
		else if(NVRAM0[EM_DC_PASSCODE_INDEX] == 1){
			NVRAM0[EM_DC_NEW_PASSCODE0] |= 0x0038;
			NVRAM0[EM_DC_PASSCODE_INDEX] = 2;	
		}
		else if(NVRAM0[EM_DC_PASSCODE_INDEX] == 2){
			NVRAM0[EM_DC_NEW_PASSCODE1] |= 0x3800;	
			NVRAM0[EM_DC_PASSCODE_INDEX] = 3;	
		}
		else if(NVRAM0[EM_DC_PASSCODE_INDEX] == 3){
			NVRAM0[EM_DC_NEW_PASSCODE1] |= 0x0038;	
			NVRAM0[EM_DC_PASSCODE_INDEX] = 4;
		}
		SetTextValue(screen_id, 15 , (uint8_t*)(&(NVRAM0[EM_DC_NEW_PASSCODE0])));
		return;
	}
	if(screen_id == GDDC_PAGE_PASSCODE && control_id == GDDC_PAGE_PASSCODE_KEY_NUM9){//按键9
		if(NVRAM0[EM_DC_PASSCODE_INDEX] == 0){
			NVRAM0[EM_DC_NEW_PASSCODE0] |= 0x3900;
			NVRAM0[EM_DC_PASSCODE_INDEX] = 1;
		}
		else if(NVRAM0[EM_DC_PASSCODE_INDEX] == 1){
			NVRAM0[EM_DC_NEW_PASSCODE0] |= 0x0039;
			NVRAM0[EM_DC_PASSCODE_INDEX] = 2;	
		}
		else if(NVRAM0[EM_DC_PASSCODE_INDEX] == 2){
			NVRAM0[EM_DC_NEW_PASSCODE1] |= 0x3900;	
			NVRAM0[EM_DC_PASSCODE_INDEX] = 3;	
		}
		else if(NVRAM0[EM_DC_PASSCODE_INDEX] == 3){
			NVRAM0[EM_DC_NEW_PASSCODE1] |= 0x0039;
			NVRAM0[EM_DC_PASSCODE_INDEX] = 4;
		}
		SetTextValue(screen_id, 15 , (uint8_t*)(&(NVRAM0[EM_DC_NEW_PASSCODE0])));	
		return;		
	}
	if(screen_id == GDDC_PAGE_PASSCODE && control_id == GDDC_PAGE_PASSCODE_KEY_NUM0){//按键0
		if(NVRAM0[EM_DC_PASSCODE_INDEX] == 0){
			NVRAM0[EM_DC_NEW_PASSCODE0] |= 0x3000;
			NVRAM0[EM_DC_PASSCODE_INDEX] = 1;
		}
		else if(NVRAM0[EM_DC_PASSCODE_INDEX] == 1){
			NVRAM0[EM_DC_NEW_PASSCODE0] |= 0x0030;
			NVRAM0[EM_DC_PASSCODE_INDEX] = 2;	
		}
		else if(NVRAM0[EM_DC_PASSCODE_INDEX] == 2){
			NVRAM0[EM_DC_NEW_PASSCODE1] |= 0x3000;	
			NVRAM0[EM_DC_PASSCODE_INDEX] = 3;	
		}
		else if(NVRAM0[EM_DC_PASSCODE_INDEX] == 3){
			NVRAM0[EM_DC_NEW_PASSCODE1] |= 0x0030;
			NVRAM0[EM_DC_PASSCODE_INDEX] = 4;
		}
		SetTextValue(screen_id, 15 , (uint8_t*)(&(NVRAM0[EM_DC_NEW_PASSCODE0])));
		return;
	}
	if(screen_id == GDDC_PAGE_PASSCODE && control_id == GDDC_PAGE_PASSCODE_KEY_CANCEL){//清空密码 CANCEL
		CLR(EM_DC_NEW_PASSCODE0);//清空已输入密码
		CLR(EM_DC_NEW_PASSCODE1);
		CLR(EM_DC_PASSCODE_INDEX);//清空密码显示位索引
		NVRAM0[EM_DC_PAGE] = GDDC_PAGE_PASSCODE;
		SetTextValue(screen_id, 15 , (uint8_t*)(&(NVRAM0[EM_DC_NEW_PASSCODE0])));
		return;
	}
	if(screen_id == GDDC_PAGE_PASSCODE && control_id == GDDC_PAGE_PASSCODE_KEY_BACKSPACE){//回退密码字符 BACKSPACE
		if(NVRAM0[EM_DC_PASSCODE_INDEX] == 4){
			NVRAM0[EM_DC_NEW_PASSCODE1] &= 0xFF00;
			NVRAM0[EM_DC_PASSCODE_INDEX] = 0x3;
		}
		else if(NVRAM0[EM_DC_PASSCODE_INDEX] == 3){
			NVRAM0[EM_DC_NEW_PASSCODE1] &= 0x00FF;
			NVRAM0[EM_DC_PASSCODE_INDEX] = 0x2;	
		}
		else if(NVRAM0[EM_DC_PASSCODE_INDEX] == 2){
			NVRAM0[EM_DC_NEW_PASSCODE0] &= 0xFF00;	
			NVRAM0[EM_DC_PASSCODE_INDEX] = 0x1;	
		}
		else if(NVRAM0[EM_DC_PASSCODE_INDEX] == 1){
			NVRAM0[EM_DC_NEW_PASSCODE0] &= 0x00FF;
			NVRAM0[EM_DC_PASSCODE_INDEX] = 0x0;	
		}
		SetTextValue(screen_id, 15 , (uint8_t*)(&(NVRAM0[EM_DC_NEW_PASSCODE0])));
		return;
	}
	if(screen_id == GDDC_PAGE_PASSCODE && control_id == GDDC_PAGE_PASSCODE_KEY_CHANGEPASSCODE){//进入密码修改界面 change passcode
		if((NVRAM0[EM_DC_NEW_PASSCODE0] == NVRAM0[DM_DC_OLD_PASSCODE0]) && (NVRAM0[EM_DC_NEW_PASSCODE1] == NVRAM0[DM_DC_OLD_PASSCODE1])){
			NVRAM0[EM_HMI_OPERA_STEP] = FSMSTEP_PASSCODE_NEW0;
			NVRAM0[EM_DC_PAGE] = GDDC_PAGE_NEW_PASSCODE;
			SetScreen(NVRAM0[EM_DC_PAGE]);	
		}
		else if((NVRAM0[EM_DC_NEW_PASSCODE0] == NVRAM0[EM_DC_DEFAULT_PASSCODE0]) && (NVRAM0[EM_DC_NEW_PASSCODE1] == NVRAM0[DM_DC_OLD_PASSCODE1])){
			NVRAM0[EM_HMI_OPERA_STEP] = FSMSTEP_PASSCODE_NEW0;
			NVRAM0[EM_DC_PAGE] = GDDC_PAGE_NEW_PASSCODE;
			SetScreen(NVRAM0[EM_DC_PAGE]);
		}
		CLR(EM_DC_NEW_PASSCODE0);//清空已输入密码
		CLR(EM_DC_NEW_PASSCODE1);
		CLR(EM_DC_PASSCODE_INDEX);//清空密码显示位索引
		SetTextValue(screen_id, 15 , (uint8_t*)(&(NVRAM0[EM_DC_NEW_PASSCODE0])));
		return;
	}
	if(screen_id == GDDC_PAGE_PASSCODE && control_id == GDDC_PAGE_PASSCODE_KEY_ENTER){//进入待机界面 ENTER
		if((NVRAM0[EM_DC_NEW_PASSCODE0] == NVRAM0[DM_DC_OLD_PASSCODE0]) && (NVRAM0[EM_DC_NEW_PASSCODE1] == NVRAM0[DM_DC_OLD_PASSCODE1])){
			NVRAM0[EM_DC_PAGE] = GDDC_PAGE_STANDBY;
			NVRAM0[EM_HMI_OPERA_STEP] = FSMSTEP_STANDBY;
			SetScreen(NVRAM0[EM_DC_PAGE]);				   
		}		
		else if((NVRAM0[EM_DC_NEW_PASSCODE0] == NVRAM0[EM_DC_DEFAULT_PASSCODE0]) && (NVRAM0[EM_DC_NEW_PASSCODE1] == NVRAM0[EM_DC_DEFAULT_PASSCODE1])){
			NVRAM0[EM_DC_PAGE] = GDDC_PAGE_STANDBY;
			NVRAM0[EM_HMI_OPERA_STEP] = FSMSTEP_STANDBY;
			SetScreen(NVRAM0[EM_DC_PAGE]);	
		}
		CLR(EM_DC_NEW_PASSCODE0);//清空已输入密码
		CLR(EM_DC_NEW_PASSCODE1);
		CLR(EM_DC_PASSCODE_INDEX);//清空密码显示位索引 
		SetTextValue(screen_id, 15 , (uint8_t*)(&(NVRAM0[EM_DC_NEW_PASSCODE0])));
		return;
	}
	//SCREEN ID = 2
	if(screen_id == GDDC_PAGE_NEW_PASSCODE && control_id == GDDC_PAGE_NEWPASSCODE_KEY_NUM1){//按键1
		if(NVRAM0[EM_DC_PASSCODE_INDEX] == 0){
			NVRAM0[EM_DC_NEW_PASSCODE0] |= 0x3100;
			NVRAM0[EM_DC_PASSCODE_INDEX] = 1;
		}
		else if(NVRAM0[EM_DC_PASSCODE_INDEX] == 1){
			NVRAM0[EM_DC_NEW_PASSCODE0] |= 0x0031;
			NVRAM0[EM_DC_PASSCODE_INDEX] = 2;	
		}
		else if(NVRAM0[EM_DC_PASSCODE_INDEX] == 2){
			NVRAM0[EM_DC_NEW_PASSCODE1] |= 0x3100;	
			NVRAM0[EM_DC_PASSCODE_INDEX] = 3;	
		}
		else if(NVRAM0[EM_DC_PASSCODE_INDEX] == 3){
			NVRAM0[EM_DC_NEW_PASSCODE1] |= 0x0031;
			NVRAM0[EM_DC_PASSCODE_INDEX] = 4;
		}
		SetTextValue(screen_id, 15 , (uint8_t*)(&(NVRAM0[EM_DC_NEW_PASSCODE0])));	
		return;		
	}	
	if(screen_id == GDDC_PAGE_NEW_PASSCODE && control_id == GDDC_PAGE_NEWPASSCODE_KEY_NUM2){//按键2		
		if(NVRAM0[EM_DC_PASSCODE_INDEX] == 0){
			NVRAM0[EM_DC_NEW_PASSCODE0] |= 0x3200;
			NVRAM0[EM_DC_PASSCODE_INDEX] = 1;
		}
		else if(NVRAM0[EM_DC_PASSCODE_INDEX] == 1){
			NVRAM0[EM_DC_NEW_PASSCODE0] |= 0x0032;
			NVRAM0[EM_DC_PASSCODE_INDEX] = 2;	
		}
		else if(NVRAM0[EM_DC_PASSCODE_INDEX] == 2){
			NVRAM0[EM_DC_NEW_PASSCODE1] |= 0x3200;	
			NVRAM0[EM_DC_PASSCODE_INDEX] = 3;	
		}
		else if(NVRAM0[EM_DC_PASSCODE_INDEX] == 3){
			NVRAM0[EM_DC_NEW_PASSCODE1] |= 0x0032;
			NVRAM0[EM_DC_PASSCODE_INDEX] = 4;
		}
		SetTextValue(screen_id, 15 , (uint8_t*)(&(NVRAM0[EM_DC_NEW_PASSCODE0])));
		return;
	}
	if(screen_id == GDDC_PAGE_NEW_PASSCODE && control_id == GDDC_PAGE_NEWPASSCODE_KEY_NUM3){//按键3
		if(NVRAM0[EM_DC_PASSCODE_INDEX] == 0){
			NVRAM0[EM_DC_NEW_PASSCODE0] |= 0x3300;
			NVRAM0[EM_DC_PASSCODE_INDEX] = 1;
		}
		else if(NVRAM0[EM_DC_PASSCODE_INDEX] == 1){
			NVRAM0[EM_DC_NEW_PASSCODE0] |= 0x0033;
			NVRAM0[EM_DC_PASSCODE_INDEX] = 2;	
		}
		else if(NVRAM0[EM_DC_PASSCODE_INDEX] == 2){
			NVRAM0[EM_DC_NEW_PASSCODE1] |= 0x3300;	
			NVRAM0[EM_DC_PASSCODE_INDEX] = 3;	
		}
		else if(NVRAM0[EM_DC_PASSCODE_INDEX] == 3){
			NVRAM0[EM_DC_NEW_PASSCODE1] |= 0x0033;
			NVRAM0[EM_DC_PASSCODE_INDEX] = 4;	
		}
		SetTextValue(screen_id, 15 , (uint8_t*)(&(NVRAM0[EM_DC_NEW_PASSCODE0])));
		return;
	}
	if(screen_id == GDDC_PAGE_NEW_PASSCODE && control_id == GDDC_PAGE_NEWPASSCODE_KEY_NUM4){//按键4
		if(NVRAM0[EM_DC_PASSCODE_INDEX] == 0){
			NVRAM0[EM_DC_NEW_PASSCODE0] |= 0x3400;
			NVRAM0[EM_DC_PASSCODE_INDEX] = 1;
		}
		else if(NVRAM0[EM_DC_PASSCODE_INDEX] == 1){
			NVRAM0[EM_DC_NEW_PASSCODE0] |= 0x0034;
			NVRAM0[EM_DC_PASSCODE_INDEX] = 2;	
		}
		else if(NVRAM0[EM_DC_PASSCODE_INDEX] == 2){
			NVRAM0[EM_DC_NEW_PASSCODE1] |= 0x3400;	
			NVRAM0[EM_DC_PASSCODE_INDEX] = 3;	
		}
		else if(NVRAM0[EM_DC_PASSCODE_INDEX] == 3){
			NVRAM0[EM_DC_NEW_PASSCODE1] |= 0x0034;
			NVRAM0[EM_DC_PASSCODE_INDEX] = 4;	
		}
		SetTextValue(screen_id, 15 , (uint8_t*)(&(NVRAM0[EM_DC_NEW_PASSCODE0])));
		return;
	}
	if(screen_id == GDDC_PAGE_NEW_PASSCODE && control_id == GDDC_PAGE_NEWPASSCODE_KEY_NUM5){//按键5
		if(NVRAM0[EM_DC_PASSCODE_INDEX] == 0){
			NVRAM0[EM_DC_NEW_PASSCODE0] |= 0x3500;
			NVRAM0[EM_DC_PASSCODE_INDEX] = 1;
		}
		else if(NVRAM0[EM_DC_PASSCODE_INDEX] == 1){
			NVRAM0[EM_DC_NEW_PASSCODE0] = EM_DC_NEW_PASSCODE0 | 0x0035;
			NVRAM0[EM_DC_PASSCODE_INDEX] = 2;	
		}
		else if(NVRAM0[EM_DC_PASSCODE_INDEX] == 2){
			NVRAM0[EM_DC_NEW_PASSCODE1] |= 0x3500;	
			NVRAM0[EM_DC_PASSCODE_INDEX] = 3;	
		}
		else if(NVRAM0[EM_DC_PASSCODE_INDEX] == 3){
			NVRAM0[EM_DC_NEW_PASSCODE1] |= 0x0035;
			NVRAM0[EM_DC_PASSCODE_INDEX] = 4;	
		}
		SetTextValue(screen_id, 15 , (uint8_t*)(&(NVRAM0[EM_DC_NEW_PASSCODE0])));
		return;
	}
	if(screen_id == GDDC_PAGE_NEW_PASSCODE && control_id == GDDC_PAGE_NEWPASSCODE_KEY_NUM6){//按键6
		if(NVRAM0[EM_DC_PASSCODE_INDEX] == 0){
			NVRAM0[EM_DC_NEW_PASSCODE0] |= 0x3600;
			NVRAM0[EM_DC_PASSCODE_INDEX] = 1;
		}
		else if(NVRAM0[EM_DC_PASSCODE_INDEX] == 1){
			NVRAM0[EM_DC_NEW_PASSCODE0] |= 0x0036;
			NVRAM0[EM_DC_PASSCODE_INDEX] = 2;	
		}
		else if(NVRAM0[EM_DC_PASSCODE_INDEX] == 2){
			NVRAM0[EM_DC_NEW_PASSCODE1] |= 0x3600;	
			NVRAM0[EM_DC_PASSCODE_INDEX] = 3;	
		}
		else if(NVRAM0[EM_DC_PASSCODE_INDEX] == 3){
			NVRAM0[EM_DC_NEW_PASSCODE1] |= 0x0036;
			NVRAM0[EM_DC_PASSCODE_INDEX] = 4;	
		}
		SetTextValue(screen_id, 15 , (uint8_t*)(&(NVRAM0[EM_DC_NEW_PASSCODE0])));
		return;
	}
	if(screen_id == GDDC_PAGE_NEW_PASSCODE && control_id == GDDC_PAGE_NEWPASSCODE_KEY_NUM7){//按键7
		if(NVRAM0[EM_DC_PASSCODE_INDEX] == 0){
			NVRAM0[EM_DC_NEW_PASSCODE0] |= 0x3700;
			NVRAM0[EM_DC_PASSCODE_INDEX] = 1;
		}
		else if(NVRAM0[EM_DC_PASSCODE_INDEX] == 1){
			NVRAM0[EM_DC_NEW_PASSCODE0] |= 0x0037;
			NVRAM0[EM_DC_PASSCODE_INDEX] = 2;	
		}
		else if(NVRAM0[EM_DC_PASSCODE_INDEX] == 2){
			NVRAM0[EM_DC_NEW_PASSCODE1] |= 0x3700;	
			NVRAM0[EM_DC_PASSCODE_INDEX] = 3;	
		}
		else if(NVRAM0[EM_DC_PASSCODE_INDEX] == 3){
			NVRAM0[EM_DC_NEW_PASSCODE1] |= 0x0037;	
			NVRAM0[EM_DC_PASSCODE_INDEX] = 4;
		}
		SetTextValue(screen_id, 15 , (uint8_t*)(&(NVRAM0[EM_DC_NEW_PASSCODE0])));
		return;
	}
	if(screen_id == GDDC_PAGE_NEW_PASSCODE && control_id == GDDC_PAGE_NEWPASSCODE_KEY_NUM8){//按键8
		if(NVRAM0[EM_DC_PASSCODE_INDEX] == 0){
			NVRAM0[EM_DC_NEW_PASSCODE0] |= 0x3800;
			NVRAM0[EM_DC_PASSCODE_INDEX] = 1;
		}
		else if(NVRAM0[EM_DC_PASSCODE_INDEX] == 1){
			NVRAM0[EM_DC_NEW_PASSCODE0] |= 0x0038;
			NVRAM0[EM_DC_PASSCODE_INDEX] = 2;	
		}
		else if(NVRAM0[EM_DC_PASSCODE_INDEX] == 2){
			NVRAM0[EM_DC_NEW_PASSCODE1] |= 0x3800;	
			NVRAM0[EM_DC_PASSCODE_INDEX] = 3;	
		}
		else if(NVRAM0[EM_DC_PASSCODE_INDEX] == 3){
			NVRAM0[EM_DC_NEW_PASSCODE1] |= 0x0038;	
			NVRAM0[EM_DC_PASSCODE_INDEX] = 4;
		}
		SetTextValue(screen_id, 15 , (uint8_t*)(&(NVRAM0[EM_DC_NEW_PASSCODE0])));
		return;
	}
	if(screen_id == GDDC_PAGE_NEW_PASSCODE && control_id == GDDC_PAGE_NEWPASSCODE_KEY_NUM9){//按键9
		if(NVRAM0[EM_DC_PASSCODE_INDEX] == 0){
			NVRAM0[EM_DC_NEW_PASSCODE0] |= 0x3900;
			NVRAM0[EM_DC_PASSCODE_INDEX] = 1;
		}
		else if(NVRAM0[EM_DC_PASSCODE_INDEX] == 1){
			NVRAM0[EM_DC_NEW_PASSCODE0] |= 0x0039;
			NVRAM0[EM_DC_PASSCODE_INDEX] = 2;	
		}
		else if(NVRAM0[EM_DC_PASSCODE_INDEX] == 2){
			NVRAM0[EM_DC_NEW_PASSCODE1] |= 0x3900;	
			NVRAM0[EM_DC_PASSCODE_INDEX] = 3;	
		}
		else if(NVRAM0[EM_DC_PASSCODE_INDEX] == 3){
			NVRAM0[EM_DC_NEW_PASSCODE1] |= 0x0039;
			NVRAM0[EM_DC_PASSCODE_INDEX] = 4;
		}
		SetTextValue(screen_id, 15 , (uint8_t*)(&(NVRAM0[EM_DC_NEW_PASSCODE0])));	
		return;		
	}
	if(screen_id == GDDC_PAGE_NEW_PASSCODE && control_id == GDDC_PAGE_NEWPASSCODE_KEY_NUM0){//按键0
		if(NVRAM0[EM_DC_PASSCODE_INDEX] == 0){
			NVRAM0[EM_DC_NEW_PASSCODE0] |= 0x3000;
			NVRAM0[EM_DC_PASSCODE_INDEX] = 1;
		}
		else if(NVRAM0[EM_DC_PASSCODE_INDEX] == 1){
			NVRAM0[EM_DC_NEW_PASSCODE0] |= 0x0030;
			NVRAM0[EM_DC_PASSCODE_INDEX] = 2;	
		}
		else if(NVRAM0[EM_DC_PASSCODE_INDEX] == 2){
			NVRAM0[EM_DC_NEW_PASSCODE1] |= 0x3000;	
			NVRAM0[EM_DC_PASSCODE_INDEX] = 3;	
		}
		else if(NVRAM0[EM_DC_PASSCODE_INDEX] == 3){
			NVRAM0[EM_DC_NEW_PASSCODE1] |= 0x0030;
			NVRAM0[EM_DC_PASSCODE_INDEX] = 4;
		}
		SetTextValue(screen_id, 15 , (uint8_t*)(&(NVRAM0[EM_DC_NEW_PASSCODE0])));
		return;
	}
	if(screen_id == GDDC_PAGE_NEW_PASSCODE && control_id == GDDC_PAGE_NEWPASSCODE_KEY_CANCEL){//清空已输入新密码
		CLR(EM_DC_NEW_PASSCODE0);
		CLR(EM_DC_NEW_PASSCODE1);
		CLR(EM_DC_PASSCODE_INDEX);//清空密码显示位索引 
		SetTextValue(screen_id, 15 , (uint8_t*)(&(NVRAM0[EM_DC_NEW_PASSCODE0])));
		return;		
	}
	if(screen_id == GDDC_PAGE_NEW_PASSCODE && control_id == GDDC_PAGE_NEWPASSCODE_KEY_BACKSPACE){//输入新密码退格
		if(NVRAM0[EM_DC_PASSCODE_INDEX] == 4){
			NVRAM0[EM_DC_NEW_PASSCODE1] &= 0xFF00;
			NVRAM0[EM_DC_PASSCODE_INDEX] = 0x3;
		}
		else if(NVRAM0[EM_DC_PASSCODE_INDEX] == 3){
			NVRAM0[EM_DC_NEW_PASSCODE1] &= 0x00FF;
 			NVRAM0[EM_DC_PASSCODE_INDEX] = 0x2;	
		}
		else if(NVRAM0[EM_DC_PASSCODE_INDEX] == 2){
 			NVRAM0[EM_DC_NEW_PASSCODE0] &= 0xFF00;	
 			NVRAM0[EM_DC_PASSCODE_INDEX] = 0x1;	
		}
		else if(NVRAM0[EM_DC_PASSCODE_INDEX] == 1){
 			NVRAM0[EM_DC_NEW_PASSCODE0] &= 0x00FF;
			NVRAM0[EM_DC_PASSCODE_INDEX] = 0x0;	
		}
		SetTextValue(screen_id, 15 , (uint8_t*)(&(NVRAM0[EM_DC_NEW_PASSCODE0])));
		return;
	}
	if(screen_id == GDDC_PAGE_NEW_PASSCODE && control_id == GDDC_PAGE_NEWPASSCODE_KEY_SAVE){//新密码输入完毕进入等待操作
		if((NVRAM0[EM_DC_PASSCODE_INDEX] >= 4) && (NVRAM0[EM_DC_NEW_PASSCODE0] != 0x0000) && (NVRAM0[EM_DC_NEW_PASSCODE0] != 0x0000)){
			MOV(DM_DC_OLD_PASSCODE0, EM_DC_NEW_PASSCODE0);
			MOV(DM_DC_OLD_PASSCODE1, EM_DC_NEW_PASSCODE1);
			FSAV();//立即更新NVRAM
			CLR(EM_DC_PASSCODE_INDEX);//清空密码显示位索引 
			CLR(EM_DC_NEW_PASSCODE0);
			CLR(EM_DC_NEW_PASSCODE1);
			NVRAM0[EM_HMI_OPERA_STEP] = FSMSTEP_PASSCODE_INPUT;
			NVRAM0[EM_DC_PAGE] = GDDC_PAGE_PASSCODE;
#if CONFIG_DEBUG == 1
			printf("sPlc->dcHmiLoop->New PassCode:0x%4X,0x%4X Save!\n", NVRAM0[DM_DC_OLD_PASSCODE0], NVRAM0[DM_DC_OLD_PASSCODE1]);
#endif
			SetScreen(NVRAM0[EM_DC_PAGE]);
		}
		else{
			CLR(EM_DC_PASSCODE_INDEX);//清空密码显示位索引 
			CLR(EM_DC_NEW_PASSCODE0);
			CLR(EM_DC_NEW_PASSCODE1);
			NVRAM0[EM_HMI_OPERA_STEP] = FSMSTEP_PASSCODE_NEW0;
			NVRAM0[EM_DC_PAGE] = GDDC_PAGE_NEW_PASSCODE;
#if CONFIG_DEBUG == 1				
			printf("sPlc->dcHmiLoop->New PassCode Save Fail\n");
#endif
		}
		SetTextValue(screen_id, 15 , (uint8_t*)(&(NVRAM0[EM_DC_NEW_PASSCODE0])));
		return;
	}	
	if(screen_id == GDDC_PAGE_NEW_PASSCODE && control_id == GDDC_PAGE_NEWPASSCODE_KEY_BACK){//放弃新密码修改
		CLR(EM_DC_NEW_PASSCODE0);
		CLR(EM_DC_NEW_PASSCODE1);
		CLR(EM_DC_PASSCODE_INDEX);//清空密码显示位索引 
		NVRAM0[EM_HMI_OPERA_STEP] = FSMSTEP_PASSCODE_INPUT;
		NVRAM0[EM_DC_PAGE] = GDDC_PAGE_PASSCODE;
		SetTextValue(screen_id, 15 , (uint8_t*)(&(NVRAM0[EM_DC_NEW_PASSCODE0])));
		SetScreen(NVRAM0[EM_DC_PAGE]);
		return;
	}
	//SCREEN ID = 3
	if(screen_id == GDDC_PAGE_STANDBY && control_id == GDDC_PAGE_STANDBY_KEY_POSWIDTH_ADD){
		switch(state){
			case 0x00:{//UP
				RES(R_KEY_POSWIDTH_ADD_DOWN);
				SET(R_KEY_POSWIDTH_ADD_UP);
				break;
			}
			case 0x01:{//DOWN
				SET(R_KEY_POSWIDTH_ADD_DOWN);
				RES(R_KEY_POSWIDTH_ADD_UP);
				if(NVRAM0[EM_LASER_POSWIDTH] < CONFIG_MAX_LASER_POSWIDTH){
					ADDS1(EM_LASER_POSWIDTH);//+1
					SET(R_DCHMI_UPDATEUI_REQ);
					//SetTextInt32(GDDC_PAGE_STANDBY, GDDC_PAGE_STANDBY_TEXTDISPLAY_POSWIDTH ,NVRAM0[EM_LASER_POSWIDTH], 1, 0);
				}
				break;
			}
			default:break;
		}
		return;
	}
	if(screen_id == GDDC_PAGE_STANDBY && control_id == GDDC_PAGE_STANDBY_KEY_POSWIDTH_DEC){
		switch(state){
			case 0x00:{//UP
				RES(R_KEY_POSWIDTH_DEC_DOWN);
				SET(R_KEY_POSWIDTH_DEC_UP);
				break;
			}
			case 0x01:{//DOWN
				SET(R_KEY_POSWIDTH_DEC_DOWN);
				RES(R_KEY_POSWIDTH_DEC_UP);
				if(NVRAM0[EM_LASER_POSWIDTH] > CONFIG_MIN_LASER_POSWIDTH){
					DECS1(EM_LASER_POSWIDTH);//-1
					SET(R_DCHMI_UPDATEUI_REQ);
					//SetTextInt32(GDDC_PAGE_STANDBY, GDDC_PAGE_STANDBY_TEXTDISPLAY_POSWIDTH ,NVRAM0[EM_LASER_POSWIDTH], 1, 0);
				}
			}
			default:break;
		}
		return;
	}
	if(screen_id == GDDC_PAGE_STANDBY && control_id == GDDC_PAGE_STANDBY_KEY_NEGWIDTH_ADD){
		switch(state){
			case 0x00:{//UP
				RES(R_KEY_NEGWIDTH_ADD_DOWN);
				SET(R_KEY_NEGWIDTH_ADD_UP);
				break;
			}
			case 0x01:{//DOWN
				SET(R_KEY_NEGWIDTH_ADD_DOWN);
				RES(R_KEY_NEGWIDTH_ADD_UP);
				if(NVRAM0[EM_LASER_NEGWIDTH] < CONFIG_MAX_LASER_NEGWIDTH){
					ADDS1(EM_LASER_NEGWIDTH);//+1
					SET(R_DCHMI_UPDATEUI_REQ);
					//SetTextInt32(GDDC_PAGE_STANDBY, GDDC_PAGE_STANDBY_TEXTDISPLAY_NEGWIDTH ,NVRAM0[EM_LASER_NEGWIDTH], 1, 0);
				}
				
				break;
			}
			default:break;
		}
		return;	
	}
	if(screen_id == GDDC_PAGE_STANDBY && control_id == GDDC_PAGE_STANDBY_KEY_NEGWIDTH_DEC){
		switch(state){
			case 0x00:{//UP
				RES(R_KEY_NEGWIDTH_DEC_DOWN);
				SET(R_KEY_NEGWIDTH_DEC_UP);
				break;
			}
			case 0x01:{//DOWN
				SET(R_KEY_NEGWIDTH_DEC_DOWN);
				RES(R_KEY_NEGWIDTH_DEC_UP);
				if(NVRAM0[EM_LASER_NEGWIDTH] > CONFIG_MIN_LASER_NEGWIDTH){
					DECS1(EM_LASER_NEGWIDTH);//-1
					SET(R_DCHMI_UPDATEUI_REQ);
					//SetTextInt32(GDDC_PAGE_STANDBY, GDDC_PAGE_STANDBY_TEXTDISPLAY_NEGWIDTH ,NVRAM0[EM_LASER_NEGWIDTH], 1, 0);
				}
				break;
			}
			default:break;
		}
		return;		
	}
	if(screen_id == GDDC_PAGE_STANDBY && control_id == GDDC_PAGE_STANDBY_KEY_GROUP_ADD){
		switch(state){
			case 0x00:{//UP
				RES(R_KEY_GROUP_ADD_DOWN);
				SET(R_KEY_GROUP_ADD_UP);
				break;
			}
			case 0x01:{//DOWN
				SET(R_KEY_GROUP_ADD_DOWN);
				RES(R_KEY_GROUP_ADD_UP);
				if(NVRAM0[EM_LASER_GROUP] < CONFIG_MAX_LASER_GROUP){
					ADDS1(EM_LASER_GROUP);//+1
					SET(R_DCHMI_UPDATEUI_REQ);
				}
				break;
			}
			default:break;
		}
		return;		
	}
	if(screen_id == GDDC_PAGE_STANDBY && control_id == GDDC_PAGE_STANDBY_KEY_GROUP_DEC){
		switch(state){
			case 0x00:{//UP
				RES(R_KEY_GROUP_DEC_DOWN);
				SET(R_KEY_GROUP_DEC_UP);
				break;
			}
			case 0x01:{//DOWN
				SET(R_KEY_GROUP_DEC_DOWN);
				RES(R_KEY_GROUP_DEC_UP);
				if(NVRAM0[EM_LASER_GROUP] > CONFIG_MIN_LASER_GROUP){
					DECS1(EM_LASER_GROUP);//-1
					SET(R_DCHMI_UPDATEUI_REQ);
				}
				break;
			}
			default:break;
		}
		return;		
	}
	if(screen_id == GDDC_PAGE_STANDBY && control_id == GDDC_PAGE_STANDBY_KEY_SPACE_ADD){
		switch(state){
			case 0x00:{//UP
				RES(R_KEY_SPACE_ADD_DOWN);
				SET(R_KEY_SPACE_ADD_UP);
				break;
			}
			case 0x01:{//DOWN
				SET(R_KEY_SPACE_ADD_DOWN);
				RES(R_KEY_SPACE_ADD_UP);
				if(NVRAM0[EM_LASER_SPACE] < CONFIG_MAX_LASER_SPACE){
					ADDS1(EM_LASER_SPACE);//+1
					SET(R_DCHMI_UPDATEUI_REQ);
				}
				break;
			}
			default:break;
		}
		return;		
	}
	if(screen_id == GDDC_PAGE_STANDBY && control_id == GDDC_PAGE_STANDBY_KEY_SPACE_DEC){
		switch(state){
			case 0x00:{//UP
				RES(R_KEY_SPACE_DEC_DOWN);
				SET(R_KEY_SPACE_DEC_UP);
				break;
			}
			case 0x01:{//DOWN
				SET(R_KEY_SPACE_DEC_DOWN);
				RES(R_KEY_SPACE_DEC_UP);
				if(NVRAM0[EM_LASER_SPACE] > CONFIG_MIN_LASER_SPACE){
					DECS1(EM_LASER_SPACE);//-1
					SET(R_DCHMI_UPDATEUI_REQ);
				}
				break;
			}
			default:break;
		}
		return;		
	}
	if(screen_id == GDDC_PAGE_STANDBY && control_id == GDDC_PAGE_STANDBY_KEY_SCHEME_SAVE){//当前方案保存	
		if(state == 0){
			saveScheme();
			FSAV();//立即更新NVRAM
		}			
		return;
	}
	if(screen_id == GDDC_PAGE_STANDBY && control_id == GDDC_PAGE_STANDBY_KEY_SCHEME_LAST){//选择上一个方案
		if(state == 0){
			if(NVRAM0[DM_SCHEME_NUM] > 0){
				DECS1(DM_SCHEME_NUM);//+1
				loadScheme();//DM->EM
				FSAV();//立即更新NVRAM
				updateSchemeDisplay();
			}
		}
		return;
	}
	if(screen_id == GDDC_PAGE_STANDBY && control_id == GDDC_PAGE_STANDBY_KEY_SCHEME_NEXT){//选择下一个方案
		if(state == 0){
			if(NVRAM0[DM_SCHEME_NUM] < (CONFIG_HMI_SCHEME_NUM - 1)){
				ADDS1(DM_SCHEME_NUM);//+1
				loadScheme();//DM->EM
				FSAV();//立即更新NVRAM
				updateSchemeDisplay();
			}
		}
		return;
	}
	if(screen_id == GDDC_PAGE_STANDBY && control_id == GDDC_PAGE_STANDBY_KEY_SCHEME_DEFAULT){//还原默认配置
		if(state == 0){
			defaultScheme();
			updateSchemeDisplay();
		}
		return;
	}
	
}

void NotifyScreen(uint16_t screen_id){
    //TODO: 添加用户代码

}

//触摸坐标事件响应
//press 1按下触摸屏，3松开触摸屏;x x坐标;y y坐标
void NotifyTouchXY(uint8_t press,uint16_t x,uint16_t y){
    //TODO: 添加用户代码
}


/*! 
*  \brief  更新数据
*/ 
void UpdateUI(void){
	switch(NVRAM0[EM_DC_PAGE]){
		case GDDC_PAGE_STANDBY:{
			SetTextInt32(GDDC_PAGE_STANDBY, GDDC_PAGE_STANDBY_TEXTDISPLAY_POSWIDTH ,NVRAM0[EM_LASER_POSWIDTH], 1, 0);
			SetTextInt32(GDDC_PAGE_STANDBY, GDDC_PAGE_STANDBY_TEXTDISPLAY_NEGWIDTH ,NVRAM0[EM_LASER_NEGWIDTH], 1, 0);
			SetTextInt32(GDDC_PAGE_STANDBY, GDDC_PAGE_STANDBY_TEXTDISPLAY_GROUP ,NVRAM0[EM_LASER_GROUP], 1, 0);
			SetTextInt32(GDDC_PAGE_STANDBY, GDDC_PAGE_STANDBY_TEXTDISPLAY_SPACE ,NVRAM0[EM_LASER_SPACE], 1, 0);
			break;
		}
		default:break;
	}

}




/*! 
*  \brief  文本控件通知
*  \details  当文本通过键盘更新(或调用GetControlValue)时，执行此函数
*  \details  文本控件的内容以字符串形式下发到MCU，如果文本控件内容是浮点值，
*  \details  则需要在此函数中将下发字符串重新转回浮点值。
*  \param screen_id 画面ID
*  \param control_id 控件ID
*  \param str 文本控件内容
*/
void NotifyText(uint16_t screen_id, uint16_t control_id, uint8_t *str){
                                                                           
}                                                                                

/*!                                                                              
*  \brief  进度条控件通知                                                       
*  \details  调用GetControlValue时，执行此函数                                  
*  \param screen_id 画面ID                                                      
*  \param control_id 控件ID                                                     
*  \param value 值                                                              
*/                                                                              
void NotifyProgress(uint16_t screen_id, uint16_t control_id, uint32_t value){                                                                                
     
}                                                                                

/*!                                                                              
*  \brief  滑动条控件通知                                                       
*  \details  当滑动条改变(或调用GetControlValue)时，执行此函数                  
*  \param screen_id 画面ID                                                      
*  \param control_id 控件ID                                                     
*  \param value 值                                                              
*/                                                                              
void NotifySlider(uint16_t screen_id, uint16_t control_id, uint32_t value){                                                                                                                                  

}

/*! 
*  \brief  仪表控件通知
*  \details  调用GetControlValue时，执行此函数
*  \param screen_id 画面ID
*  \param control_id 控件ID
*  \param value 值
*/
void NotifyMeter(uint16_t screen_id, uint16_t control_id, uint32_t value){
    //TODO: 添加用户代码
}

/*! 
*  \brief  菜单控件通知
*  \details  当菜单项按下或松开时，执行此函数
*  \param screen_id 画面ID
*  \param control_id 控件ID
*  \param item 菜单项索引
*  \param state 按钮状态：0松开，1按下
*/
void NotifyMenu(uint16_t screen_id, uint16_t control_id, uint8_t item, uint8_t state){

}

/*! 
*  \brief  选择控件通知
*  \details  当选择控件变化时，执行此函数
*  \param screen_id 画面ID
*  \param control_id 控件ID
*  \param item 当前选项
*/
void NotifySelector(uint16_t screen_id, uint16_t control_id, uint8_t  item){


}

/*! 
*  \brief  定时器超时通知处理
*  \param screen_id 画面ID
*  \param control_id 控件ID
*/
void NotifyTimer(uint16_t screen_id, uint16_t control_id){
}

/*! 
*  \brief  读取用户FLASH状态返回
*  \param status 0失败，1成功
*  \param _data 返回数据
*  \param length 数据长度
*/
void NotifyReadFlash(uint8_t status,uint8_t *_data,uint16_t length){
    //TODO: 添加用户代码
}

/*! 
*  \brief  写用户FLASH状态返回
*  \param status 0失败，1成功
*/
void NotifyWriteFlash(uint8_t status){
    //TODO: 添加用户代码
}


void NotifyReadRTC(uint8_t year,uint8_t month,uint8_t week,uint8_t day,uint8_t hour,uint8_t minute,uint8_t second){
     
}

/*! 
*  \brief  string 转 int
*  \param char *str  数字字符串
*/
int str2int(const char *str){
    int temp = 0;
    const char *ptr = str;                                                            //记录字符串

    if(*str == '-' || *str == '+')                                                    //判断第一个字符是否是正负
    {                                                                            
        str++;                                                                        //偏移一位
    }                                                                            
    while(*str != 0)                                                             
    {                                                                            
        if ((*str < '0') || (*str > '9'))                                             //检测是否为数字字符 
        {                                                                        
            break;                                                               
        }                                                                        
        temp = temp * 10 + (*str - '0');                                              //转换
        str++;                                                                        //偏移一位
    }                                                                            
    if (*ptr == '-')                                                                  //如果为负数就取反
    {
        temp = -temp;
    }

    return temp;   
}

#endif