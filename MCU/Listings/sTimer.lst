C51 COMPILER V9.57.0.0   STIMER                                                            05/06/2018 22:53:29 PAGE 1   


C51 COMPILER V9.57.0.0, COMPILATION OF MODULE STIMER
OBJECT MODULE PLACED IN .\Objects\sTimer.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Source\Lib\sTimer.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(.\Source\Lib;.
                    -\Source\uCOSIIV2.76;.\Source\Driver;.\Source\Modbus;.\Source\MainApp) DEBUG OBJECTEXTEND PRINT(.\Listings\sTimer.lst) OB
                    -JECT(.\Objects\sTimer.obj)

line level    source

   1          #include "sTimer.h"
   2          /*****************************************************************************/
   3          SI_SEG_DATA uint8_t inputFilterCounter;//输入滤波常熟
   4          SI_SEG_DATA uint16_t inputFilter[CONFIG_PLC_X_NUM / 16 + 2];//已滤波输入
   5          SI_SEG_DATA uint16_t inputCurrent[CONFIG_PLC_X_NUM / 16 + 2];//当前输入
   6          SI_SEG_DATA uint16_t inputLast[CONFIG_PLC_X_NUM / 16 + 2];//上次输入
   7          softPlc_t softPlc;
   8          static void plcHwTimer_Init(void);
   9          /*****************************************************************************/
  10          void SoftPlc_Init(softPlc_t *pt)
  11          {
  12   1              int16_t i;
  13   1              //初始化
  14   1              memset(inputFilter, 0x0, (CONFIG_PLC_X_NUM / 16 + 1));
  15   1              memset(inputCurrent, 0x0, (CONFIG_PLC_X_NUM / 16 + 1));
  16   1              memset(inputLast, 0x0, (CONFIG_PLC_X_NUM / 16 + 1));
  17   1              inputFilterCounter = 3;//3mS
  18   1              memset(softPlc.X, 0x0, (CONFIG_PLC_X_NUM / 16 + 1));
  19   1              memset(softPlc.Y, 0x0, (CONFIG_PLC_Y_NUM / 16 + 1));
  20   1              memset(softPlc.M, 0x0, (CONFIG_PLC_M_NUM / 16 + 1));
  21   1              memset(softPlc.N, 0x0, (CONFIG_PLC_N_NUM / 16 + 1));
  22   1              memset(softPlc.T_1ms, 0x0, (CONFIG_PLC_T_1MS_NUM / 16 + 1));
  23   1              memset(softPlc.T_10ms, 0x0, (CONFIG_PLC_T_10MS_NUM / 16 + 1));
  24   1              memset(softPlc.T_100ms, 0x0, (CONFIG_PLC_T_100MS_NUM / 16 + 1));
  25   1              memset(softPlc.T_1000ms, 0x0, (CONFIG_PLC_T_1000MS_NUM / 16 + 1));
  26   1              memset(softPlc.D, 0x0, CONFIG_PLC_D_NUM);
  27   1              memset(softPlc.R, 0x0, CONFIG_PLC_R_NUM);
  28   1              
  29   1              pt->counter_1ms = 0;
  30   1              pt->counter_10ms = 0;
  31   1              pt->counter_100ms = 0;
  32   1              
  33   1              for(i = 0; i<= CONFIG_PLC_T_1MS_NUM; i++)
  34   1              {
  35   2                      pt->T_1ms[i].value = 0;
  36   2                      pt->T_1ms[i].mate = 0;
  37   2                      pt->T_1ms[i].enable = 0;
  38   2                      pt->T_1ms[i].output = 0;
  39   2              }
  40   1      
  41   1              for(i = 0; i<= CONFIG_PLC_T_10MS_NUM; i++)
  42   1              {
  43   2                      pt->T_10ms[i].value = 0;
  44   2                      pt->T_10ms[i].mate = 0;
  45   2                      pt->T_10ms[i].enable = 0;
  46   2                      pt->T_10ms[i].output = 0;
  47   2              }
  48   1              
  49   1              for(i = 0; i<= CONFIG_PLC_T_100MS_NUM; i++)
  50   1              {
  51   2                      pt->T_100ms[i].value = 0;
  52   2                      pt->T_100ms[i].mate = 0;
  53   2                      pt->T_100ms[i].enable = 0;
C51 COMPILER V9.57.0.0   STIMER                                                            05/06/2018 22:53:29 PAGE 2   

  54   2                      pt->T_100ms[i].output = 0;
  55   2              }
  56   1              
  57   1              for(i = 0; i<= CONFIG_PLC_T_1000MS_NUM; i++)
  58   1              {
  59   2                      pt->T_1000ms[i].value = 0;
  60   2                      pt->T_1000ms[i].mate = 0;
  61   2                      pt->T_1000ms[i].enable = 0;
  62   2                      pt->T_1000ms[i].output = 0;
  63   2              }
  64   1              
  65   1              //从EEPROM中恢复D寄存器
  66   1              plcHwTimer_Init();
  67   1      }
  68          static void plcHwTimer_Init(void)
  69          {//硬件sTimer计时器初始化
  70   1              CKCON &= ~(1 << 6);//Timer 4 uses the system clock divided by 12
  71   1              RCAP4H = 0xFF & (CONFIG_SOFTPLC_HWTIME >> 8);// Init Timer4 High register
  72   1              RCAP4L = (CONFIG_SOFTPLC_HWTIME & 0xFF);// Init Timer4 Low register
  73   1              T4CON = 0x0;    
  74   1              EIE2 |= (1 << 2);//ET4: Enable Timer 4 Interrupt
  75   1              T4CON |= (1 << 2);//TR4: Timer 4 Run Control.
  76   1      }
  77          void plcHwTimer_ISR(void) interrupt INTERRUPT_TIMER4
  78          {//硬件sTimer计时器中断 1mS
  79   1              SI_SEG_DATA uint8_t i, j, temp0, temp1;
  80   1      
  81   1              T4CON &= ~(1 << 7);//TF4: Timer 4 output Flag Clear     
  82   1              for(i = 0;i < CONFIG_PLC_T_1MS_NUM;i ++)
  83   1              {//1mS计数器增加
  84   2                      if(softPlc.T_1ms[i].enable)
  85   2                      {
  86   3                              if(softPlc.T_1ms[i].value >= softPlc.T_1ms[i].mate)
  87   3                                      softPlc.T_1ms[i].output = 1;
  88   3                              else
  89   3                                      softPlc.T_1ms[i].output = 0;
  90   3                              if(softPlc.T_1ms[i].value < SHRT_MAX)
  91   3                                      softPlc.T_1ms[i].value ++;
  92   3                              else
  93   3                                      softPlc.T_1ms[1].output = 0;
  94   3                      }
  95   2              }
  96   1              
  97   1              if(softPlc.counter_1ms >= 10)
  98   1              {//10mS T
  99   2                      for(i = 0;i < CONFIG_PLC_T_10MS_NUM;i ++)
 100   2                      {//10mS计数器增加
 101   3                              if(softPlc.T_10ms[i].enable)
 102   3                              {
 103   4                                      if(softPlc.T_10ms[i].value >= softPlc.T_10ms[i].mate)
 104   4                                              softPlc.T_10ms[i].output = 1;
 105   4                                      else
 106   4                                              softPlc.T_10ms[i].output = 0;
 107   4                                      if(softPlc.T_10ms[i].value < SHRT_MAX)
 108   4                                              softPlc.T_10ms[i].value ++;
 109   4                                      else
 110   4                                              softPlc.T_10ms[1].output = 0;
 111   4                              }
 112   3                      }
 113   2                      softPlc.counter_1ms = 0;
 114   2              }
 115   1              
C51 COMPILER V9.57.0.0   STIMER                                                            05/06/2018 22:53:29 PAGE 3   

 116   1              if(softPlc.counter_10ms >= 100)
 117   1              {//100mS T
 118   2                      for(i = 0;i < CONFIG_PLC_T_100MS_NUM;i ++)
 119   2                      {//100mS计数器增加
 120   3                              if(softPlc.T_100ms[i].enable)
 121   3                              {
 122   4                                      if(softPlc.T_100ms[i].value >= softPlc.T_100ms[i].mate)
 123   4                                              softPlc.T_100ms[i].output = 1;
 124   4                                      else
 125   4                                              softPlc.T_100ms[i].output = 0;
 126   4                                      
 127   4                                      if(softPlc.T_100ms[i].value < SHRT_MAX)
 128   4                                              softPlc.T_100ms[i].value ++;
 129   4                                      else
 130   4                                              softPlc.T_100ms[1].output = 0;
 131   4                              }
 132   3                      }
 133   2                      softPlc.counter_10ms = 0;
 134   2              }
 135   1              
 136   1              if(softPlc.counter_100ms >= 1000)
 137   1              {//1000mS T
 138   2                      for(i = 0;i < CONFIG_PLC_T_1000MS_NUM;i ++)
 139   2                      {//1000mS计数器增加
 140   3                              if(softPlc.T_1000ms[i].enable)
 141   3                              {
 142   4                                      if(softPlc.T_1000ms[i].value >= softPlc.T_1000ms[i].mate)
 143   4                                              softPlc.T_1000ms[i].output = 1;
 144   4                                      else
 145   4                                              softPlc.T_1000ms[i].output = 0;
 146   4                                      
 147   4                                      if(softPlc.T_1000ms[i].value < SHRT_MAX)
 148   4                                              softPlc.T_1000ms[i].value ++;
 149   4                                      else
 150   4                                              softPlc.T_1000ms[1].output = 0;
 151   4                              }
 152   3                      }
 153   2                      softPlc.counter_100ms = 0;
 154   2              }
 155   1              
 156   1              softPlc.counter_1ms ++;
 157   1              softPlc.counter_10ms ++;
 158   1              softPlc.counter_100ms ++;
 159   1              
 160   1              //输入滤波
 161   1              inputCurrent[0] = 0x0;
 162   1              inputCurrent[0] += P7;
 163   1              inputCurrent[0] += (P6 * 256);
 164   1              if(inputFilterCounter >= CONFIG_INPUT_FILTER_TIME)
 165   1              {//达到滤波时间常数
 166   2                      for(i = 0;i < (CONFIG_PLC_X_NUM / 16 + 1);i ++)
 167   2                      {
 168   3                              for(j = 0;j < 16;j ++)
 169   3                              {
 170   4                                      temp0 = (inputCurrent[i] >> j) & 0x01;
 171   4                                      temp1 = (inputLast[i] >> j) & 0x01;
 172   4                                      if(temp0 == temp1)
 173   4                                      {
 174   5                                              inputFilter[i] &= ~((uint16_t)(1 << j));
 175   5                                              inputFilter[i] |= (uint16_t)(temp0 << j);
 176   5                                      }
 177   4                              }
C51 COMPILER V9.57.0.0   STIMER                                                            05/06/2018 22:53:29 PAGE 4   

 178   3                              inputLast[i] = inputCurrent[i];
 179   3                      }
 180   2                      inputFilterCounter = 0;
 181   2              }
 182   1              else
 183   1                      inputFilterCounter ++;
 184   1      }
 185          void getInput(softPlc_t *pt)
 186          {//扫描周期读取已滤波输入口状态
 187   1              SI_SEG_DATA uint8_t i;
 188   1              EIE2 &= ~(1 << 2);//ET4: Disable Timer 4 Interrupt//关闭PLC硬件计时器中断
 189   1              for(i = 0;i <= CONFIG_PLC_X_NUM;i ++)
 190   1              {
 191   2                      pt->X[i] = inputFilter[i];
 192   2              }
 193   1              EIE2 |= (1 << 2);//ET4: Enable Timer 4 Interrupt//打开PLC硬件计时器中断
 194   1      }
 195          
 196          
 197          void setOutput(softPlc_t *pt)
 198          {//输出端口刷新
 199   1              P6 = pt->Y[0] & 0x00FF;
 200   1              //P1^6 = (pt->Y[0] >> 8) & 0x01;
 201   1              //P1^7 = (pt->Y[0] >> 9) & 0x01;
 202   1      }
 203          uint8_t getCoil(uint16_t *coil, uint16_t addr)
 204          {//获取线圈状态
 205   1              return (uint8_t)((*(coil + (addr / 16)) >> (addr % 16)) & 0x01);
 206   1      }
 207          void setCoil(uint16_t *coil, uint16_t addr)
 208          {//置位线圈
 209   1              SI_SEG_DATA uint16_t dat, mask;
 210   1              dat = coil[(addr / 16)];
 211   1              mask = addr % 16;
 212   1              dat |= (1 << mask);
 213   1      }
 214          void resetCoil(uint16_t *coil, uint16_t addr)
 215          {//复位线圈
 216   1              SI_SEG_DATA uint16_t dat, mask;
 217   1              dat = coil[(addr / 16)];
 218   1              mask = addr % 16;
 219   1              dat &= ~(1 << mask);
 220   1      }
 221          void flipCoil(uint16_t *coil, uint16_t addr)
 222          {//翻转线圈
 223   1              SI_SEG_DATA uint16_t dat, mask;
 224   1              dat = coil[addr / 16];
 225   1              mask = addr % 16;
 226   1              if((dat >> mask) & 0x01)
 227   1                      dat &= ~(1 << mask);
 228   1              else
 229   1                      dat |= (1 << mask);
 230   1      }
 231          
 232          void startTimer(softPlcTimer_t *pt, int16_t value)
 233          {//启动计时器
 234   1              if(pt->enable == 0x0)
 235   1              {
 236   2                      pt->mate = value;//设定初值
 237   2                      pt->value = 0;//复位计时值
 238   2                      pt->enable = 1;
 239   2                      pt->output = 0;
C51 COMPILER V9.57.0.0   STIMER                                                            05/06/2018 22:53:29 PAGE 5   

 240   2              }
 241   1      }
 242          
 243          void stopTimer(softPlcTimer_t *pt)
 244          {//停止计时器
 245   1              if(pt->enable != 0x0)
 246   1              {
 247   2                      pt->enable = 0;
 248   2                      pt->output = 0;
 249   2              }
 250   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2212    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    864       6
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     13      17
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
