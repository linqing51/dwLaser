C51 COMPILER V9.57.0.0   SLAVEMODBUS                                                       04/29/2018 00:02:33 PAGE 1   


C51 COMPILER V9.57.0.0, COMPILATION OF MODULE SLAVEMODBUS
OBJECT MODULE PLACED IN .\Objects\slaveModbus.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Modbus\slaveModbus.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(.\Lib;.\uCOSI
                    -I;.\Modbus;.\App) DEBUG OBJECTEXTEND PRINT(.\Listings\slaveModbus.lst) OBJECT(.\Objects\slaveModbus.obj)

line level    source

   1          #include "slaveModbus.h"
   2          /*****************************************************************************/
   3          static data uint8_t localAddr; //单片机控制板的地址
   4          static data uint8_t receTimeOut;//接收超时
   5          static data uint8_t sendCount;//发送字节个数
   6          static data uint8_t receCount;//接收到的字节个数
   7          static idata uint8_t receBuf[64];
   8          static idata uint8_t sendBuf[64];
   9          static data uint8_t bt1ms;//定时标志位
  10          static void timeProc(void);
  11          static void checkComm0Modbus(void);
  12          /* CRC 高位字节值表 */ 
  13          uint8_t code auchCRCHi[] = 
  14          { 
  15                  0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 
  16                  0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 
  17                  0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 
  18                  0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 
  19                  0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 
  20                  0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 
  21                  0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 
  22                  0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 
  23                  0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 
  24                  0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 
  25                  0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 
  26                  0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 
  27                  0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 
  28                  0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 
  29                  0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 
  30                  0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 
  31                  0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 
  32                  0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 
  33                  0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 
  34                  0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 
  35                  0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 
  36                  0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 
  37                  0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 
  38                  0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 
  39                  0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 
  40                  0x80, 0x41, 0x00, 0xC1, 0x81, 0x40 
  41          } ; 
  42          /* CRC低位字节值表*/ 
  43          uint8_t code auchCRCLo[] = 
  44          {       
  45                  0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06, 
  46                  0x07, 0xC7, 0x05, 0xC5, 0xC4, 0x04, 0xCC, 0x0C, 0x0D, 0xCD, 
  47                  0x0F, 0xCF, 0xCE, 0x0E, 0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09,               
  48                  0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9, 0x1B, 0xDB, 0xDA, 0x1A, 
  49                  0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 0x1D, 0x1C, 0xDC, 0x14, 0xD4, 
  50                  0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3, 
  51                  0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 
  52                  0xF2, 0x32, 0x36, 0xF6, 0xF7, 0x37, 0xF5, 0x35, 0x34, 0xF4, 
  53                  0x3C, 0xFC, 0xFD, 0x3D, 0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A, 
  54                  0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38, 0x28, 0xE8, 0xE9, 0x29, 
C51 COMPILER V9.57.0.0   SLAVEMODBUS                                                       04/29/2018 00:02:33 PAGE 2   

  55                  0xEB, 0x2B, 0x2A, 0xEA, 0xEE, 0x2E, 0x2F, 0xEF, 0x2D, 0xED, 
  56                  0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26, 
  57                  0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60, 
  58                  0x61, 0xA1, 0x63, 0xA3, 0xA2, 0x62, 0x66, 0xA6, 0xA7, 0x67, 
  59                  0xA5, 0x65, 0x64, 0xA4, 0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F, 
  60                  0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB, 0x69, 0xA9, 0xA8, 0x68, 
  61                  0x78, 0xB8, 0xB9, 0x79, 0xBB, 0x7B, 0x7A, 0xBA, 0xBE, 0x7E, 
  62                  0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5, 
  63                  0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 
  64                  0x70, 0xB0, 0x50, 0x90, 0x91, 0x51, 0x93, 0x53, 0x52, 0x92, 
  65                  0x96, 0x56, 0x57, 0x97, 0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C, 
  66                  0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B, 
  67                  0x99, 0x59, 0x58, 0x98, 0x88, 0x48, 0x49, 0x89, 0x4B, 0x8B, 
  68                  0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C, 
  69                  0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 
  70                  0x43, 0x83, 0x41, 0x81, 0x80, 0x40 
  71          } ;
  72          void presetSingleRegister(void);
  73          uint16_t setCoilVal(uint16_t addr,uint16_t tempData);
  74          uint16_t getCoilVal(uint16_t addr,uint16_t *tempData);
  75          uint16_t getRegisterVal(uint16_t addr,uint16_t *tempData);
  76          uint16_t setRegisterVal(uint16_t addr,uint16_t tempData);
  77          
  78          /*****************************************************************************/
  79          void InitModbusHardware(uint32_t baudrate)
  80          {//初始化MODBUS硬件
  81   1              
  82   1              memset(receBuf, 0x00, sizeof(receBuf)); 
  83   1              memset(sendBuf, 0x00, sizeof(receBuf)); 
  84   1              InitModbusTimer();//初始化计时器
  85   1              InitModbusSerial(baudrate);//初始化串口
  86   1              
  87   1      }
  88          void modbusTimerHandle(void)
  89          {//计时器中断
  90   1              bt1ms = 1;
  91   1      }
  92          void modbusSerialRxHandle(void)
  93          {//串口接收中断
  94   1              receTimeOut = MB_CONFIG_RECE_TIMEOUT;//通讯超时值这个地方很重要 10ms
  95   1              receBuf[receCount] = SBUF0;
  96   1              receCount++;          //接收地址偏移寄存器加1   
  97   1      }
  98          void modbusSerialTxHandle(void)
  99          {//串口发射中断
 100   1      }
 101          void modbusPoll(void)
 102          {
 103   1              timeProc();
 104   1              checkComm0Modbus();     
 105   1      }
 106          void setModbusSlaveAddr(uint8_t addr)
 107          {//设置从机地址
 108   1              localAddr = addr;
 109   1      }
 110          /*****************************************************************************/
 111          
 112          static void timeProc(void)
 113          {//定时处理
 114   1              if(bt1ms)
 115   1              {
 116   2                      bt1ms = 0;
C51 COMPILER V9.57.0.0   SLAVEMODBUS                                                       04/29/2018 00:02:33 PAGE 3   

 117   2                      if(receTimeOut > 0)
 118   2                      { 
 119   3                              receTimeOut --;
 120   3                              if(receTimeOut == 0 && receCount>0)   //判断通讯接收是否超时
 121   3                              {
 122   4                                      RS485_DIRECTION_RXD;//将485置为接收状态                                                               
             -                                                                                               
 123   4                                      receCount = 0;//      //将接收地址偏移寄存器清零
 124   4                                      memset(receBuf, 0x00, sizeof(receBuf)); 
 125   4                               }
 126   3                       }
 127   2              }
 128   1      }
 129          static uint16_t crc16(uint8_t *puchMsg, uint16_t usDataLen) 
 130          {//CRC16生成器 
 131   1               data uint8_t uchCRCHi = 0xFF ; /* 高CRC字节初始化 */ 
 132   1               data uint8_t uchCRCLo = 0xFF ; /* 低CRC 字节初始化 */ 
 133   1               data uint16_t uIndex ; /* CRC循环中的索引 */ 
 134   1              while (usDataLen--) /* 传输消息缓冲区 */ 
 135   1              { 
 136   2                      uIndex = uchCRCHi ^ *puchMsg++ ; /* 计算CRC */ 
 137   2                      uchCRCHi = uchCRCLo ^ auchCRCHi[uIndex] ; 
 138   2                      uchCRCLo = auchCRCLo[uIndex] ; 
 139   2              } 
 140   1              return (uchCRCLo << 8 | uchCRCHi) ; 
 141   1      }               
 142          static void beginSend(void)
 143          {//发送数据
 144   1              RS485_DIRECTION_TXD;//处于发送
 145   1              modbusSerialSendBuffer(sendBuf, sendCount);
 146   1              RS485_DIRECTION_RXD;//发送完后将485置于接收状态
 147   1          receCount = 0;   //清接收地址偏移寄存器
 148   1      }
 149          static void readCoils(void)
 150          {//fuction:01 读单个或多个线圈状态
 151   1              uint16_t addr;
 152   1              uint16_t tempAddr;
 153   1              uint16_t byteCount;
 154   1              uint16_t bitCount;
 155   1              uint16_t crcData;
 156   1              uint16_t position;
 157   1              uint16_t i, k;
 158   1              uint16_t tempData;
 159   1              uint8_t exit = 0;
 160   1              addr = (receBuf[2]<<8) + receBuf[3]; 
 161   1              tempAddr = addr;
 162   1              bitCount = (receBuf[4]<<8) + receBuf[5]; //读取的位个数
 163   1              byteCount = bitCount / 8;    //字节个数
 164   1              if(bitCount%8 != 0)
 165   1              {
 166   2                byteCount++;
 167   2              }               
 168   1              for(k = 0; k < byteCount; k ++)//字节位置
 169   1              {
 170   2                      position = k + 3;
 171   2                      sendBuf[position] = 0;
 172   2                      for(i = 0; i < 8; i ++)
 173   2                      {
 174   3                              getCoilVal(tempAddr, &tempData);
 175   3                              sendBuf[position] |= tempData << i;
 176   3                              tempAddr++;
 177   3                              if(tempAddr >= addr + bitCount)//读完
C51 COMPILER V9.57.0.0   SLAVEMODBUS                                                       04/29/2018 00:02:33 PAGE 4   

 178   3                              { 
 179   4                                      exit = 1;
 180   4                                      break;
 181   4                              } 
 182   3                      }
 183   2                      if(exit == 1)
 184   2                      break;
 185   2              }
 186   1              sendBuf[0] = localAddr;
 187   1              sendBuf[1] = 0x01; 
 188   1              sendBuf[2] = byteCount;
 189   1              byteCount += 3;
 190   1              crcData = crc16(sendBuf,byteCount); 
 191   1              sendBuf[byteCount] = crcData & 0xff;
 192   1              byteCount++;
 193   1              sendBuf[byteCount] = crcData >> 8;
 194   1              sendCount = byteCount + 1;
 195   1              beginSend();   
 196   1      }
 197          static void readInPutCoils(void)
 198          {//fuction:02 读取线圈输入（只读寄存器）状态
 199   1              uint16_t addr;
 200   1              uint16_t tempAddr;
 201   1              uint16_t byteCount;
 202   1              uint16_t  bitCount;
 203   1              uint16_t crcData;
 204   1              uint16_t  position;
 205   1              uint16_t  i,k;
 206   1              uint16_t tempData;
 207   1              uint8_t  exit = 0;
 208   1              addr = (receBuf[2]<<8) + receBuf[3]; 
 209   1              tempAddr = addr +10000;        //只读线圈寄存器偏移地址10000
 210   1              bitCount = (receBuf[4]<<8) + receBuf[5]; //读取的位个数
 211   1              byteCount = bitCount / 8;    //字节个数
 212   1              if(bitCount%8 != 0)
 213   1              {
 214   2                      byteCount++;
 215   2              }               
 216   1              for(k=0;k<byteCount;k++)//字节位置
 217   1              {
 218   2                      position = k + 3;
 219   2                      sendBuf[position] = 0;
 220   2                      for(i=0;i<8;i++)
 221   2                      {
 222   3                              getCoilVal(tempAddr,&tempData);
 223   3                              sendBuf[position] |= tempData << i;
 224   3                              tempAddr++;
 225   3                              if(tempAddr >= addr+bitCount)//读完
 226   3                              { 
 227   4                                      exit = 1;
 228   4                                      break;
 229   4                              } 
 230   3                      }
 231   2                      if(exit == 1)
 232   2                      {
 233   3                              break;
 234   3                      }
 235   2              }
 236   1              sendBuf[0] = localAddr;
 237   1              sendBuf[1] = 0x02; 
 238   1              sendBuf[2] = byteCount;
 239   1              byteCount += 3;
C51 COMPILER V9.57.0.0   SLAVEMODBUS                                                       04/29/2018 00:02:33 PAGE 5   

 240   1              crcData = crc16(sendBuf,byteCount); 
 241   1              sendBuf[byteCount] = crcData & 0xff;
 242   1              byteCount++;
 243   1              sendBuf[byteCount] = crcData >> 8;
 244   1              sendCount = byteCount + 1;
 245   1              beginSend();   
 246   1      }
 247          static void readRegisters(void)
 248          {//function code : 03，读取多个保持寄存器值
 249   1              uint16_t addr;
 250   1              uint16_t tempAddr;
 251   1              uint16_t crcData;
 252   1              uint16_t readCount;
 253   1              uint16_t byteCount;
 254   1              uint16_t i;
 255   1              uint16_t tempData = 0; 
 256   1              addr = (receBuf[2]<<8) + receBuf[3]; 
 257   1              tempAddr = addr+40000;      //+40000,保持寄存器偏移地址
 258   1              readCount = (receBuf[4]<<8) + receBuf[5]; //要读的个数 ,整型
 259   1              byteCount = readCount * 2;                  //每个寄存器内容占高，低两个字节
 260   1              for(i=0;i<byteCount;i+=2,tempAddr++)
 261   1              {
 262   2                      getRegisterVal(tempAddr,&tempData);    
 263   2                      sendBuf[i+3] = tempData >> 8;        
 264   2                      sendBuf[i+4] = tempData & 0xff;  
 265   2              }
 266   1              sendBuf[0] = localAddr;
 267   1              sendBuf[1] = 3;  //function code : 03
 268   1              sendBuf[2] = byteCount;
 269   1              byteCount += 3;             //加上前面的地址，功能码，地址 共3+byteCount个字节
 270   1              crcData = crc16(sendBuf,byteCount);
 271   1              sendBuf[byteCount] = crcData & 0xff;   // CRC代码低位在前
 272   1              byteCount++;
 273   1              sendBuf[byteCount] = crcData >> 8 ;        //高位在后
 274   1              sendCount = byteCount + 1;                      //例如byteCount=49，则sendBuf[]中实际上有49+1个元素待发
 275   1              beginSend();
 276   1      }
 277          static void readInPutRegisters(void)
 278          {//fuction 04:读取输入寄存器
 279   1              uint16_t addr;
 280   1              uint16_t tempAddr;
 281   1              uint16_t crcData;
 282   1              uint16_t readCount;
 283   1              uint16_t byteCount;
 284   1              uint16_t i;
 285   1              uint16_t tempData = 0; 
 286   1              addr = (receBuf[2]<<8) + receBuf[3]; 
 287   1              tempAddr = addr+30000;  //+输入寄存器偏移地址：30000
 288   1              readCount = (receBuf[4]<<8) + receBuf[5]; //要读的个数 ,整型
 289   1              byteCount = readCount * 2;                  //每个寄存器内容占高，低两个字节
 290   1              for(i=0;i<byteCount;i+=2,tempAddr++)
 291   1              {
 292   2                      getRegisterVal(tempAddr,&tempData);    
 293   2                      sendBuf[i+3] = tempData >> 8;        
 294   2                      sendBuf[i+4] = tempData & 0xff;  
 295   2              }
 296   1              sendBuf[0] = localAddr;
 297   1              sendBuf[1] = 4;  //function code : 04
 298   1              sendBuf[2] = byteCount;
 299   1              byteCount += 3;             //加上前面的地址，功能码，地址 共3+byteCount个字节
 300   1              crcData = crc16(sendBuf,byteCount);
 301   1              sendBuf[byteCount] = crcData & 0xff;   // CRC代码低位在前
C51 COMPILER V9.57.0.0   SLAVEMODBUS                                                       04/29/2018 00:02:33 PAGE 6   

 302   1              byteCount++;
 303   1              sendBuf[byteCount] = crcData >> 8 ;        //高位在后
 304   1              sendCount = byteCount + 1;                      //例如byteCount=49，则sendBuf[]中实际上有49+1个元素待发
 305   1              beginSend();
 306   1      }
 307          static void forceSingleCoil(void)
 308          {//fuction:05 ,强制单个线圈
 309   1              uint16_t addr;
 310   1              uint16_t tempAddr;
 311   1              uint16_t tempData;
 312   1              uint16_t  onOff;
 313   1              uint8_t i;
 314   1              addr = (receBuf[2]<<8) + receBuf[3]; 
 315   1              tempAddr = addr;
 316   1              onOff = (receBuf[4]<<8) + receBuf[5]; 
 317   1              if(onOff == 0xff00)
 318   1              { 
 319   2                      tempData = 1;//设为ON
 320   2              } 
 321   1              else if(onOff == 0x0000)//设为OFF
 322   1              { 
 323   2                      tempData = 0;
 324   2              }
 325   1              setCoilVal(tempAddr,tempData); 
 326   1              for(i=0;i<receCount;i++)
 327   1              {
 328   2                      sendBuf[i] = receBuf[i];
 329   2              }
 330   1              sendCount = receCount;
 331   1              beginSend(); 
 332   1      }
 333          
 334          static void presetSingleRegister(void)
 335          {//fuction:06设置单个寄存器
 336   1              uint16_t addr;
 337   1              uint16_t tempAddr;
 338   1              uint16_t tempData;
 339   1              uint16_t crcData;
 340   1              addr = (receBuf[2]<<8) + receBuf[3];
 341   1              tempAddr = (addr+40000);
 342   1              tempData = (receBuf[4]<<8) + receBuf[5];
 343   1              setRegisterVal(tempAddr,tempData);  
 344   1              sendBuf[0] = localAddr;
 345   1              sendBuf[1] = 6;    //function code : 16
 346   1              sendBuf[2] = addr >> 8;  //寄存器地址高位
 347   1              sendBuf[3] = addr & 0xff;//寄存器地址低位
 348   1              sendBuf[4] =receBuf[4];
 349   1              sendBuf[5] =receBuf[5];
 350   1              crcData = crc16(sendBuf,6);//生成CRC校验码
 351   1              sendBuf[6] = crcData & 0xff;  //CRC代码低位在前
 352   1              sendBuf[7] = crcData >> 8;        //高位在后
 353   1              sendCount = 8;
 354   1              beginSend(); 
 355   1      }
 356          
 357          static void forceMultipleCoils(void)
 358          {//function code : 15，强置多线圈值
 359   1              uint16_t addr;
 360   1              uint16_t tempAddr;
 361   1              uint16_t byteCount;
 362   1              uint16_t  bitCount;
 363   1              uint16_t crcData;
C51 COMPILER V9.57.0.0   SLAVEMODBUS                                                       04/29/2018 00:02:33 PAGE 7   

 364   1              uint16_t tempData;
 365   1              uint16_t  i,k;
 366   1              uint8_t  exit = 0;
 367   1              addr = (receBuf[2] << 8) + receBuf[3];
 368   1              tempAddr = addr;
 369   1              bitCount = (receBuf[4] << 8) + receBuf[5];
 370   1              byteCount = bitCount / 8;    //字节个数
 371   1              if(bitCount%8 != 0)
 372   1              {
 373   2                      byteCount++;
 374   2              }               
 375   1              for(k = 0;k < byteCount;k ++)//字节位置
 376   1              {
 377   2                      for(i = 0;i < 8;i ++)
 378   2                      {
 379   3                              tempData = (receBuf[k + 7] >> i) & 0x01;//对应位 位置  
 380   3                              setCoilVal(tempAddr, tempData); 
 381   3                              tempAddr++;
 382   3                              if(tempAddr >= addr + bitCount)//读完
 383   3                              { 
 384   4                                      exit = 1;
 385   4                                      break;
 386   4                              } 
 387   3                      }
 388   2                      if(exit == 1)
 389   2                      break;
 390   2              }
 391   1              sendBuf[0] = localAddr;
 392   1              sendBuf[1] = 15;    //function code : 16
 393   1              sendBuf[2] = addr >> 8;  //寄存器地址高位
 394   1              sendBuf[3] = addr & 0xff;//寄存器地址低位
 395   1              sendBuf[4] = bitCount >> 8;//待设置寄存器数量高位
 396   1              sendBuf[5] = bitCount & 0xff;//待设置寄存器数量低位
 397   1              crcData = crc16(sendBuf, 6);//生成CRC校验码
 398   1              sendBuf[6] = crcData & 0xff;  //CRC代码低位在前
 399   1              sendBuf[7] = crcData >> 8;        //高位在后
 400   1              sendCount = 8;
 401   1              beginSend(); 
 402   1      }
 403          
 404          static void presetMultipleRegisters(void)
 405          {//function code : 16，设置多个寄存器值
 406   1              uint16_t addr;
 407   1              uint16_t tempAddr;
 408   1              uint16_t setCount;
 409   1              uint16_t crcData;
 410   1              uint16_t tempData;
 411   1              uint8_t i;
 412   1              addr = (receBuf[2]<<8) + receBuf[3];
 413   1              tempAddr = addr + 40000;
 414   1              setCount = (receBuf[4] << 8) + receBuf[5]; 
 415   1              for(i = 0;i < setCount;i ++,tempAddr ++)
 416   1              {
 417   2                      tempData = (receBuf[i*2+7]<<8) + receBuf[i*2+8];//待设置寄存器值
 418   2                      setRegisterVal(tempAddr,tempData);  
 419   2              }
 420   1              sendBuf[0] = localAddr;
 421   1              sendBuf[1] = 16;    //function code : 16
 422   1              sendBuf[2] = addr >> 8;  //寄存器地址高位
 423   1              sendBuf[3] = addr & 0xff;//寄存器地址低位
 424   1              sendBuf[4] = setCount >> 8;//待设置寄存器数量高位
 425   1              sendBuf[5] = setCount & 0xff;//待设置寄存器数量低位
C51 COMPILER V9.57.0.0   SLAVEMODBUS                                                       04/29/2018 00:02:33 PAGE 8   

 426   1              crcData = crc16(sendBuf,6);//生成CRC校验码
 427   1              sendBuf[6] = crcData & 0xff;  //CRC代码低位在前
 428   1              sendBuf[7] = crcData >> 8;        //高位在后
 429   1              sendCount = 8;
 430   1              beginSend(); 
 431   1      }
 432          /*************************查询uart接收的数据包内容函数 **************************/
 433          ////函数功能：丛机根据串口接收到的数据包receBuf[1]里面的内容，即function code执行相应的命令
 434          /********************************************************************************/
 435          static void checkComm0Modbus(void)                 //10ms内必须响应接收数据
 436          {
 437   1              uint16_t crcData;
 438   1              uint16_t tempData;
 439   1              uint16_t temp;
 440   1              if(receCount > 4)                
 441   1              {//如果接收到数据        
 442   2                      switch(receBuf[1])
 443   2                      {
 444   3                              case 1:                                                         
 445   3                              {//读取寄存器(一个或多个)        
 446   4                                      
 447   4                                      if(receCount >= 8)  //从询问数据包格式可知，receCount应该等于8  ，接收完成一组数据应该关闭接收中断
 448   4                                      {                
 449   5                                              if(receBuf[0] == localAddr)//核对地址
 450   5                                              {        
 451   6                                                      crcData = crc16(receBuf, 6);//核对校验码
 452   6                                                      temp=receBuf[7];
 453   6                                                      temp=(temp<<8)+receBuf[6];
 454   6                                                      if(crcData == temp)
 455   6                                                      {
 456   7                                                              readCoils();//读取线圈输出状态(一个或多个) 
 457   7                                                      }
 458   6                                                      receCount = 0;                                                                    
 459   6                                              }                                       
 460   5                                      }      
 461   4                                      break;
 462   4                              }
 463   3                              case 2:                                                         
 464   3                              {//读取寄存器(一个或多个)        
 465   4                                      if(receCount >= 8)  
 466   4                                      {//从询问数据包格式可知，receCount应该等于8     ，接收完成一组数据应该关闭接收中断       
 467   5                                              if(receBuf[0] == localAddr)  
 468   5                                              {//核对地址      
 469   6                                                      crcData = crc16(receBuf,6);                     //核对校验码
 470   6                                                      temp=receBuf[7];
 471   6                                                      temp=(temp<<8)+receBuf[6];
 472   6                                                      if(crcData == temp)
 473   6                                                      {
 474   7                                                              readInPutCoils();                       //读取线圈输入状态(一个或多个) 
 475   7                                                      }
 476   6                                                      receCount = 0;                                                                    
 477   6                                              }                               
 478   5                                      }      
 479   4                                      break;
 480   4                              }
 481   3                              
 482   3                              case 3:
 483   3                              {//读取寄存器(一个或多个)        
 484   4                                      if(receCount >= 8)  
 485   4                                      {//从询问数据包格式可知，receCount应该等于8 接收完成一组数据应该关闭接收中断
 486   5                                              if(receBuf[0]==localAddr)   
 487   5                                              {//核对地址      
C51 COMPILER V9.57.0.0   SLAVEMODBUS                                                       04/29/2018 00:02:33 PAGE 9   

 488   6                                                      crcData = crc16(receBuf,6);                     //核对校验码
 489   6                                                      temp=receBuf[7];
 490   6                                                      temp=(temp<<8)+receBuf[6];
 491   6                                                      if(crcData == temp)
 492   6                                                      {
 493   7                                                              readRegisters();//读取保持寄存器(一个或多个)                                              
 494   7                                                      }       
 495   6                                                      receCount = 0;                          
 496   6                                              }
 497   5                                      }                                       
 498   4                                      break;
 499   4                              }
 500   3                              case 4:                                                         
 501   3                              {//读取寄存器(一个或多个)        
 502   4                                      if(receCount >= 8)  
 503   4                                      {//从询问数据包格式可知，receCount应该等于8 接收完成一组数据应该关闭接收中断                                    
 504   5                                              if(receBuf[0]==localAddr)   //核对地址
 505   5                                              {        
 506   6                                                      crcData = crc16(receBuf,6);                     //核对校验码
 507   6                                                      temp=receBuf[7];
 508   6                                                      temp=(temp<<8)+receBuf[6];
 509   6                                                      if(crcData == temp)
 510   6                                                      { 
 511   7                                                              readInPutRegisters();//读取输入寄存器(一个或多个) 
 512   7                                                      }
 513   6                                                      receCount = 0;                                                                    
 514   6                                              }       
 515   5                                      }      
 516   4                                      break;
 517   4                              }
 518   3                              case 5:                                                         
 519   3                              {//读取寄存器(一个或多个)        
 520   4                                      if(receCount >= 8)  
 521   4                                      {//从询问数据包格式可知 receCount应该等于8 接收完成一组数据应该关闭接收中断             
 522   5                                              if(receBuf[0] == localAddr)   
 523   5                                              {//核对地址      
 524   6                                                      crcData = crc16(receBuf, 6);//核对校验码
 525   6                                                      temp = receBuf[7];
 526   6                                                      temp = (temp<<8) + receBuf[6];
 527   6                                                      if(crcData == temp)
 528   6                                                      { 
 529   7                                                              forceSingleCoil();//强置单个线圈 状态
 530   7                                                      }
 531   6                                                      receCount = 0;                                                                    
 532   6                                              }
 533   5                                      }      
 534   4                                      break;
 535   4                              }
 536   3                              case 6: 
 537   3                              {//写单个保持寄存器     
 538   4                                      if(receCount >= 8)
 539   4                                      {//预设单个保持寄存器    
 540   5                                              if(receBuf[0]==localAddr)
 541   5                                              {
 542   6                                                      crcData = crc16(receBuf, 6);
 543   6                                                      temp = receBuf[7];
 544   6                                                      temp = (temp<<8) + receBuf[6];
 545   6                                                      if(crcData == temp)
 546   6                                                      { 
 547   7                                                              presetSingleRegister();      //预置单个保持寄存器
 548   7                                                              //可选保存设置数据到EPROM  
 549   7                                                      } 
C51 COMPILER V9.57.0.0   SLAVEMODBUS                                                       04/29/2018 00:02:33 PAGE 10  

 550   6                                              receCount = 0;                                                                                       
             -                                                  
 551   6                                              }
 552   5                                      }
 553   4                                      break;
 554   4                              }
 555   3                              case 15:
 556   3                              {//设置多个线圈
 557   4                                      tempData = receBuf[6]; 
 558   4                                      tempData += 9; //数据个数
 559   4                                      if(receCount >= tempData)
 560   4                                      {
 561   5                                              if(receBuf[0] == localAddr )
 562   5                                              {
 563   6                                                      crcData = crc16(receBuf, tempData - 2);
 564   6                                                      if(crcData == (receBuf[tempData-1] << 8)+ receBuf[tempData - 2])//更改了？？
 565   6                                                      {
 566   7                                                              forceMultipleCoils();  
 567   7                                                              //可选保存设置数据到EPROM  
 568   7                                                      }
 569   6                                              } 
 570   5                                              receCount = 0;
 571   5                                      }
 572   4                                      break;
 573   4                              }                               
 574   3                              case 16:
 575   3                              {//设置多个寄存器
 576   4                                      tempData = (receBuf[4]<<8) + receBuf[5];//设置寄存器个数
 577   4                                      tempData = tempData * 2;//数据个数=     寄存器*2
 578   4                                      tempData += 9;       //从询问数据包格式可知，receCount应该等于9+byteCount
 579   4                                      if(receCount >= tempData)
 580   4                                      {       
 581   5                                              if(receBuf[0]==localAddr )      //核对地址
 582   5                                              {        
 583   6                                                      crcData = crc16(receBuf, tempData - 2);
 584   6                                                      temp = receBuf[tempData - 1];
 585   6                                                      temp=(temp << 8) + receBuf[tempData - 2]; 
 586   6                                                      if(crcData == temp)
 587   6                                                      {  
 588   7                                                              presetMultipleRegisters();  
 589   7                                                              //可选保存设置数据到EPROM  
 590   7                                                      }
 591   6                                              } 
 592   5                                              receCount = 0;
 593   5                                      }
 594   4                                      break;  
 595   4                              }   
 596   3                              default: break;  
 597   3                      }
 598   2              }
 599   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3054    ----
   CONSTANT SIZE    =    512    ----
   XDATA SIZE       =   ----      89
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      5       4
   IDATA SIZE       =    128    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.

C51 COMPILER V9.57.0.0   SLAVEMODBUS                                                       04/29/2018 00:02:33 PAGE 11  


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
